\section{Results}
\label{sec:results}
In this section, we will first describe our data-collection process. Next we will show the code repair, and detection accuracy techniques on a small subset of this collected dataset.   

\subsection{Data collection} 
  We use dataset from two previous sources ~\cite{meng2018secure,fischer2017stack}. Both of these dataset contain code snippets posted on Stackoverflow. 
  Fisher et al. crawled 1,161 code snippets posted on Stackoverflow related to Andrioid security ~\cite{fischer2017stack}. They considered a code snippet related to Android security if the code snippets makes API calls to
  one of the security services such as Java cryptography, Java secure Communications, public key infrastructure X.509 certificates, and Java authentication - authorization services. The popular crypto libraries used by Andriod developers such as Bouncy Castle, SpongyCastle, Apache TLS/SSL, keyczar, jasypt, and GNU Crypto were also included. 
  
  Meng et al.  extracted 503 code snippets from 22,195 Stackoverflow posts by filtering the posts based on votes, duplications, and absence of code snipeets~\cite{meng2018secure}. In total our study is baded on the dataset by combining these two. Our dataset contains 1,664 code snippets. The timeline of these code snippets are from 2008-2017.
  %\minote{add some more info and some statistics}
  The average size of the collect code snippets is 46 LoC having a very high standard deviation of 58.


%\subsection{Data processing and categorization}
%  We manually analysis 
%  As to get the ground truth of the presence of insecure pattern, we have to manully analysis them, it becomes very time consuming. Therefore to make the analysis less consuming time , we only consider randomly sampled 800 code snippets -- about half of the 1.6K code snippets available. 
%  We then assign the code snippets into one of the 8 insecure patterns.  %and record the common keywords appear in the code snippets. By doing this we have list of common keyword for each of the 8 insecure patterns. We can then categorize all 1.6K code snippets using these common keywords.
  

\subsection{Code repair success rate.} 
%AES: 85/225 Broken-Hash: 69/219 
% Constructor class
\begin{figure}[ht]
\includegraphics[width=\linewidth]{Figures/success_full_repair2.eps-eps-converted-to.pdf}
\caption{Percentage of code snippets successfully repaired.}
\label{fig:code-repair}
\end{figure}

We called a code snippet successfully repaired if we can convert it to a Jimple IR. 
In summary we are able to convert 813 code snippets out of collected 1.6K code snippets -- a repair accurarcy of 30.31\%. 
We also categorize each converted into one more or category based on the secure/insecure use of the rule presented on Table~\ref{tab:insecure-patterns}.  
Figure~\ref{fig:code-repair} 
illustrates the percentage of code snippets for each categorize, we have been able to parsed (i.e., convert to Jimple IR), 
using the code repair techniques discussed in section~\ref{subsec:code-repair}.


\subsection{Insecure pattern detection accuracy.}
After converting each successfully repaired code snippets to Jimple IR, we detect rule 7, and 8 using keyword searching as mentioned previously. However for rule 1-6, need to apply backword flow analysis. To do this we give the Jimple IR to our tool. Out tool is built on top of CryptoGurd. CryptoGurd uses Soot as its program analysis enginee. Using Soot's \texttt{JimpleAST} API~\footnote{\url{https://www.sable.mcgill.ca/soot/doc/soot/jimple/parser/JimpleAST.html}}, we can enable backword flow analysis given the slicing criteria from Table~\ref{tab:slicing}. The idea is track the special method invokations parameter from the slicing criteria. In this way we can inspect the set of program statements which are affected by this slicing criteria and figure out the presence of insecure patterns. 


Table~\ref{tab:results} shows the total number of code snippets for of the 8 rules (they sum up to more than 813 as some code snippets has two or more rules). Parsed column refers to the number of code snippets, we have been able to convert to Jimple IR after applying the code repair discussed in section~\ref{subsec:code-repair}. We also shows the TP, FN, FN along side the precision, and recall.
As it can seen we have not been able to run backword flow analysis for rule 3. The reasons are explain the in the appendix~\ref{appendix:X509TrustManager}.
%If any of these set of program statements contains i) 
% Say you have done the  1,2,4,5, 7,8 correctely. How to present the results? 
% say you haven trying to address the problem of empty method detection but have not been able to do so. 

% Precision = tp/ (tp + fp)
% Recall = tp/ (tp + fn)

\begin{table}[ht]
\begin{tabular}{|l|r|r|r|r|r|r|r|}
\toprule
Rule no & Parsed & TP & FP & FN & Precision & Recall \\ \midrule
1 & 225 & 85 & 0 & 2 & - & - \\
2 & 173 & 38 & 0 & 4 & - & - \\
\textcolor{red}{3} & \textcolor{red}{219} & \textcolor{red}{-} & \textcolor{red}{-} & \textcolor{red}{-} & \textcolor{red}{-} & \textcolor{red}{-}\\
4 & 68 & 19 &  0 & 8& - & - \\
5 & 40 & 24 & 0 & 3& - & - \\
6 & 90 & 12 & 0 & 7 & - & -\\ \midrule
7 & 68 & 24 & 4& 0 & - & - \\
8 & 20 & 11 & 3& 0 & - & -\\        
\bottomrule
\end{tabular}
\caption{Table}
\label{tab:results}
\end{table}