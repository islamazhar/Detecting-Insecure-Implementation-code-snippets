,code,score,prediction,hash
,"     import java.security.SecureRandom;
     import javax.crypto.Cipher;
     import javax.crypto.KeyGenerator;
     import javax.crypto.SecretKey;
     import javax.crypto.spec.SecretKeySpec;

     public class SimpleCrypto {

public  String encrypt(String seed, String cleartext) throws Exception {
        byte[] rawKey = getRawKey(seed.getBytes());
        byte[] result = encrypt(rawKey, cleartext.getBytes());
        return toHex(result);
}

public  String decrypt(String seed, String encrypted) throws Exception {
        byte[] rawKey = getRawKey(seed.getBytes());
        byte[] enc = toByte(encrypted);
        byte[] result = decrypt(rawKey, enc);
        return new String(result);
}

//done
private  byte[] getRawKey(byte[] seed) throws Exception {
        KeyGenerator kgen = KeyGenerator.getInstance(""AES"");
        SecureRandom sr = SecureRandom.getInstance(""SHA1PRNG"");
        sr.setSeed(seed);
    kgen.init(128, sr); // 192 and 256 bits may not be available
    SecretKey skey = kgen.generateKey();
    byte[] raw = skey.getEncoded();
    return raw;
}


private  byte[] encrypt(byte[] raw, byte[] clear) throws Exception {
    SecretKeySpec skeySpec = new SecretKeySpec(raw, ""AES"");
        Cipher cipher = Cipher.getInstance(""AES"");
    cipher.init(Cipher.ENCRYPT_MODE, skeySpec);
    byte[] encrypted = cipher.doFinal(clear);
        return encrypted;
}

private  byte[] decrypt(byte[] raw, byte[] encrypted) throws Exception {
    SecretKeySpec skeySpec = new SecretKeySpec(raw, ""AES"");
        Cipher cipher = Cipher.getInstance(""AES"");
    cipher.init(Cipher.DECRYPT_MODE, skeySpec);
    byte[] decrypted = cipher.doFinal(encrypted);
        return decrypted;
}

public  String toHex(String txt) {
        return toHex(txt.getBytes());
}
public  String fromHex(String hex) {
        return new String(toByte(hex));
}

public  byte[] toByte(String hexString) {
        int len = hexString.length()/2;
        byte[] result = new byte[len];
        for (int i = 0; i &lt; len; i++)
                result[i] = Integer.valueOf(hexString.substring(2*i, 2*i+2), 16).byteValue();
        return result;
}

public  String toHex(byte[] buf) {
        if (buf == null)
                return """";
        StringBuffer result = new StringBuffer(2*buf.length);
        for (int i = 0; i &lt; buf.length; i++) {
                appendHex(result, buf[i]);
        }
        return result.toString();
}
private final static String HEX = ""0123456789ABCDEF"";
private  void appendHex(StringBuffer sb, byte b) {
        sb.append(HEX.charAt((b&gt;&gt;4)&amp;0x0f)).append(HEX.charAt(b&amp;0x0f));
}

  }
",4,0,262b6bdf80dd616de599361c5bc2d1a3547a736969ccf6d9f2ff5b94a609c0e2
,"public static SecretKey generateKey(char[] passphraseOrPin, byte[] salt) throws NoSuchAlgorithmException, InvalidKeySpecException {
// Number of PBKDF2 hardening rounds to use. Larger values increase
// computation time. You should select a value that causes computation
// to take &gt;100ms.
final int iterations = 8000; 

// Generate a 160-bit key
final int outputKeyLength = 160;

SecretKeyFactory secretKeyFactory = SecretKeyFactory.getInstance(""PBKDF2WithHmacSHA1"");
KeySpec keySpec = new PBEKeySpec(passphraseOrPin, salt, iterations, outputKeyLength);
SecretKey secretKey = secretKeyFactory.generateSecret(keySpec);
return secretKey;
",3,0,f2b267714e6ca8deda94524fd9863588a5032f98d953ca4cbe117cb589912f60
,"CertificateFactory cf = CertificateFactory.getInstance(""X.509"");
InputStream instream = context.getResources().openRawResource(R.raw.gtux_cert);
Certificate ca;
try {
    ca = cf.generateCertificate(instream);
} finally {
    caInput.close();
}

KeyStore kStore = KeyStore.getInstance(KeyStore.getDefaultType());
kStore.load(null, null);
kStore.setCertificateEntry(""ca"", ca);

TrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm(););
tmf.init(kStore);

SSLContext context = SSLContext.getInstance(""TLS"");
context.init(null, tmf.getTrustManagers(), null);

okHttpClient.setSslSocketFactory(context.getSocketFactory());
",3,0,a75a432430ad971278f8254c41ad8d9c8ab37bd95c6a177f18c66fbf43a4d274
,"public static void showHashKey(Context context) {
            try {
                PackageInfo info = context.getPackageManager().getPackageInfo(
                        ""com.example.tryitonjewelry"", PackageManager.GET_SIGNATURES); //Your            package name here
                for (Signature signature : info.signatures) {
                    MessageDigest md = MessageDigest.getInstance(""SHA"");
                    md.update(signature.toByteArray());
                    Log.i(""KeyHash:"", Base64.encodeToString(md.digest(), Base64.DEFAULT));
                    }
            } catch (NameNotFoundException e) {
            } catch (NoSuchAlgorithmException e) {
            }
        }
",3,0,60286f7a1ce0fead11ecfa72745cd3ce5f6826891b9a1027de7d72b5f9ae9b14
,"PackageInfo pi = packageManager.getPackageInfo(getPackageName());
byte[] certificate = pi.signatures[0].toByteArray();
MessageDigest md = MessageDigest.getInstance(""MD5"");
byte[] fingerprint = md.digest(certificate);
String hexFingerprint = toHexString(fingerprint);
",3,0,a331a536c6b51761f4ae948de2a6a69cb17ae8b9201db0c57658f8faea1fdf0e
,"import java.security.SecureRandom;
class secure{
    public static void main(String[] args) throws Exception{
        SecureRandom random = SecureRandom.getInstance(""SHA1PRNG"");
        System.out.println(random.nextInt(100));
    }
}
",2,0,258d2d6d332662555ca0ba8f0aa4f762f21efecea74131c468541f9d783e0e89
,"    MessageDigest digest;
    try {
        digest = MessageDigest.getInstance(""MD5"");
        byte utf8_bytes[] = tag_xml.getBytes();
        digest.update(utf8_bytes,0,utf8_bytes.length);
        hash = new BigInteger(1, digest.digest()).toString(16);
    } 
    catch (NoSuchAlgorithmException e) {
        e.printStackTrace();
    }
",,1,ad63f305146699744e43d32f70fdd9805c1cde6a76db10ac7963737e704adb49
,"  public static byte[] decryptAES(byte[] key, byte[] text) throws Exception {   

          SecretKeySpec skeySpec = new SecretKeySpec(GetKey(key), ""AES"");

            Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS7Padding"",""BC"");  

            byte [] iv = new byte[cipher.getBlockSize()];
            for(int i=0;i&lt;iv.length;i++)iv[i] = 0;
            IvParameterSpec ivSpec = new IvParameterSpec(iv);
            cipher.init(Cipher.DECRYPT_MODE, skeySpec, ivSpec);

            byte[] decrypted = cipher.doFinal(text);   
            return decrypted;   
        }
",1,0,60c4dc2f64ed8e7669c57e57180b69ff2dab6c146fd83e72d753e8000b17800f
,"TrustManager[] trustAllCerts = new TrustManager[] {new X509TrustManager() {
    public java.security.cert.X509Certificate[] getAcceptedIssuers() {
        return null;
    }

    @Override
    public void checkClientTrusted(X509Certificate[] certs, String authType) {
    }

    @Override
    public void checkServerTrusted(X509Certificate[] certs, String authType) {
    }
}};

// Install the all-trusting trust manager
SSLContext sc = SSLContext.getInstance(""SSL"");
sc.init(null, trustAllCerts, new java.security.SecureRandom());

SSLSocketFactory sslsocketfactory = sc.getSocketFactory();
SSLSocket sslsocket = (SSLSocket) sslsocketfactory.createSocket(""google.com"", 443);
...
",4,0,230f2e9c37e7fb03f6842cdb99e31120db93ce278a156931e20dc2ebd83771d1
,"try{
   SSLContext sslContext = SSLContext.getInstance(""TLS"");
   sslContext.init(null, new TrustManager[] { new X509TrustManager() {
      @Override
      public void checkClientTrusted(java.security.cert.X509Certificate[] chain, String authType)
         throws java.security.cert.CertificateException {;}
      @Override
      public void checkServerTrusted(java.security.cert.X509Certificate[] chain, String authType)
         throws java.security.cert.CertificateException {;}

      public java.security.cert.X509Certificate[] getAcceptedIssuers() {
         return new java.security.cert.X509Certificate[] {};  }
   }}, null);
   HttpsURLConnection.setDefaultSSLSocketFactory(sslContext.getSocketFactory());
}catch (Exception e) {;}
",4,0,bda272b73e9cce44e38cb050658c390b816b8bd424aa9bb881e7463bdac94cb3
,"byte[] iv = new byte[] { 0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xA, 0xB, 0xC, 0xD, 0xE, 0xF }; 
IvParameterSpec ivSpec = new IvParameterSpec(iv);

SecretKeySpec skeySpec = new SecretKeySpec(raw, ""AES"");
Cipher cipher = Cipher.getInstance(""AES/CFB/NoPadding"");
cipher.init(Cipher.ENCRYPT_MODE, skeySpec, ivSpec);
",4,0,7ec034238e0b9954981cc39f51f0dab20d0a427e5e0e21b2288caf414fcdb804
,"// data[] is pre-filled with modulus and publicExponent
String ENCRYPTION_ALGORITHM = ""RSA"";

BigInteger modulus = (BigInteger) data[0];
BigInteger publicExponent = (BigInteger) data[1];

PublicKey publicKey = getKeyFactory().generatePublic(new RSAPublicKeySpec(modulus, publicExponent));
return publicKey;

private static KeyFactory getKeyFactory() {
    if (keyFactory == null) {
        try {
            keyFactory = KeyFactory.getInstance(ENCRYPTION_ALGORITHM);
        } catch (NoSuchAlgorithmException e) {
            // Algorithm is part of every Android installation. Since we do not get here under realistic
            // circumstances it is OK to crash here.
            throw new HellFrozeOverException();
        }
    }
    return keyFactory;
}
",,1,a54714131864dc9587ff0a2423c6df7e1e1bcd25bcf18239e45e3ddd81ae6a7c
,"public class CSRHttpClient {

    public static HttpClient getNewHttpClient()
    {
        try
        {
            KeyStore trustStore = KeyStore.getInstance(KeyStore.getDefaultType());
            trustStore.load(null, null);

            SSLSocketFactory sf = new CSRSSLSocketFactory(trustStore);
            sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);

            HttpParams params = new BasicHttpParams();
            HttpProtocolParams.setVersion(params, HttpVersion.HTTP_1_1);
            HttpProtocolParams.setContentCharset(params, HTTP.UTF_8);

            SchemeRegistry registry = new SchemeRegistry();
            registry.register(new Scheme(""http"", PlainSocketFactory.getSocketFactory(), 80));
            registry.register(new Scheme(""https"", sf, 443));

            ClientConnectionManager ccm = new ThreadSafeClientConnManager(params, registry);

            return new DefaultHttpClient(ccm, params);
        } catch (Exception ex)
        {
            return new DefaultHttpClient();
        }

    }


}
",4,0,e595dca621b6e6948a2638220ae2f3086e1472f44e0958bc7b2868db672f8652
,"private TrustManager[] trustAllCerts = new TrustManager[] {
    new X509TrustManager() {
        public java.security.cert.X509Certificate[] getAcceptedIssuers() {
            return null;
        }
        public void checkClientTrusted(
            java.security.cert.X509Certificate[] certs, String authType) {
        }
        public void checkServerTrusted(
            java.security.cert.X509Certificate[] certs, String authType) {
        }
    }
};
",4,0,12a19f56c9d4a0318ed7bb95958b6dd44694127dab59e64700103133b8218f29
,"public ServiceConnectionSE(String url) throws IOException {
    try {
        SSLContext sc = SSLContext.getInstance(""TLS"");
        sc.init(null, trustAllCerts, new java.security.SecureRandom());
        HttpsURLConnection.setDefaultSSLSocketFactory(sc.getSocketFactory());
    } catch (Exception e) {
        e.getMessage();
    }
    connection = (HttpsURLConnection) new URL(url).openConnection();
    ((HttpsURLConnection) connection).setHostnameVerifier(new AllowAllHostnameVerifier());
}    
",4,0,f5efca3a50189a5231889961f9f5c3056cb8fb84a22c70eb0247afb66ce82289
,"public ServiceConnectionSE(Proxy proxy, String url) throws IOException {
    try {
        SSLContext sc = SSLContext.getInstance(""TLS"");
        sc.init(null, trustAllCerts, new java.security.SecureRandom());
        HttpsURLConnection.setDefaultSSLSocketFactory(sc.getSocketFactory());
     } catch (Exception e) {
        e.getMessage();
     }
     connection = (HttpsURLConnection) new URL(url).openConnection();
    ((HttpsURLConnection) connection).setHostnameVerifier(new AllowAllHostnameVerifier());

    connection.setUseCaches(false);
    connection.setDoOutput(true);
    connection.setDoInput(true);
}
",4,0,35dbdf822abfd26e207410d06b157f140aa9453664e481b55aaecdc34dd9a0b1
,"public static void showHashKey(Context context) {

// Set Your Package Name                                                                                                                 
String m_PackageName = ""com.example"";

    try {
        PackageInfo info = context.getPackageManager().getPackageInfo(m_PackageName, PackageManager.GET_SIGNATURES); 
        for (Signature signature : info.signatures) {
            MessageDigest md = MessageDigest.getInstance(""SHA"");
            md.update(signature.toByteArray());
            Log.d(""HashKey"", Base64.encodeToString(md.digest(), Base64.DEFAULT));
        }
    } catch (NameNotFoundException e) {
        Log.d(""HashKey"", e.getMessage());

    } catch (NoSuchAlgorithmException e) {
        Log.d(""HashKey"", e.getMessage());

    }
}
",,1,0f6bd8dd5cb41d410baf10a9cb187fe40fd1ca3a34bef264b6d35d96d4ecc7d6
,"Provider[] providers = Security.getProviders();
for (Provider provider : providers) {
    for (Object entry : provider.keySet()) {
        String name = String.valueOf(entry);
        if (name.startsWith(""Cipher"")) {
            Log.d(""Cipher"", ""Supports: "" + name.substring(7));
        }
    }
}
",,1,573637beec2fc31bebf99c76f6baf26a82a3424eab93f085a58bda875a01ff1b
,"try
{
    PackageInfo info = getPackageManager().getPackageInfo(getPackageName(), PackageManager.GET_SIGNATURES);
    for (Signature signature : info.signatures) 
    {
        MessageDigest md = MessageDigest.getInstance(""SHA"");
        Log.e(""MY KEY HASH:"", Base64.encodeToString(md.digest(), Base64.DEFAULT));
    }
} 
catch (NameNotFoundException e)
{

} 
catch (NoSuchAlgorithmException e) 
{

}
",3,0,6f7a0d6f210d53c2b0ac0602f87266167138e9d8cc0e924843c93e6e2cb1e772
,"private static final class TrustAllSSLSocketFactory implements
    LayeredSocketFactory {

    private static final TrustAllSSLSocketFactory DEFAULT_FACTORY = new TrustAllSSLSocketFactory();

    public static TrustAllSSLSocketFactory getSocketFactory() {
        return DEFAULT_FACTORY;
    }

    private SSLContext sslcontext;
    private javax.net.ssl.SSLSocketFactory socketfactory;

    private TrustAllSSLSocketFactory() {
        super();
        TrustManager[] tm = new TrustManager[] { new X509TrustManager() {

            @Override
            public void checkClientTrusted(X509Certificate[] chain,
                String authType) throws CertificateException {
                // do nothing
            }

            @Override
            public void checkServerTrusted(X509Certificate[] chain,
                String authType) throws CertificateException {
                // do nothing
            }

            @Override
            public X509Certificate[] getAcceptedIssuers() {
                return new X509Certificate[0];
            }

        } };
        try {
            this.sslcontext = SSLContext.getInstance(SSLSocketFactory.TLS);
            this.sslcontext.init(null, tm, new SecureRandom());
            this.socketfactory = this.sslcontext.getSocketFactory();
        } catch ( NoSuchAlgorithmException e ) {
            Log.e(LOG_TAG,
                ""Failed to instantiate TrustAllSSLSocketFactory!"", e);
        } catch ( KeyManagementException e ) {
            Log.e(LOG_TAG,
                ""Failed to instantiate TrustAllSSLSocketFactory!"", e);
        }
    }

    @Override
    public Socket createSocket(Socket socket, String host, int port,
        boolean autoClose) throws IOException, UnknownHostException {
        SSLSocket sslSocket = (SSLSocket) this.socketfactory.createSocket(
            socket, host, port, autoClose);
        return sslSocket;
    }

    @Override
    public Socket connectSocket(Socket sock, String host, int port,
        InetAddress localAddress, int localPort, HttpParams params)
        throws IOException, UnknownHostException, ConnectTimeoutException {
        if ( host == null ) {
            throw new IllegalArgumentException(
                ""Target host may not be null."");
        }
        if ( params == null ) {
            throw new IllegalArgumentException(
                ""Parameters may not be null."");
        }

        SSLSocket sslsock = (SSLSocket) ( ( sock != null ) ? sock
            : createSocket() );

        if ( ( localAddress != null ) || ( localPort &gt; 0 ) ) {

            // we need to bind explicitly
            if ( localPort &lt; 0 ) {
                localPort = 0; // indicates ""any""
            }

            InetSocketAddress isa = new InetSocketAddress(localAddress,
                localPort);
            sslsock.bind(isa);
        }

        int connTimeout = HttpConnectionParams.getConnectionTimeout(params);
        int soTimeout = HttpConnectionParams.getSoTimeout(params);

        InetSocketAddress remoteAddress;
        remoteAddress = new InetSocketAddress(host, port);

        sslsock.connect(remoteAddress, connTimeout);

        sslsock.setSoTimeout(soTimeout);

        return sslsock;
    }

    @Override
    public Socket createSocket() throws IOException {
        // the cast makes sure that the factory is working as expected
        return (SSLSocket) this.socketfactory.createSocket();
    }

    @Override
    public boolean isSecure(Socket sock) throws IllegalArgumentException {
        return true;
    }

}
",4,0,3acb3311906ce025b750841a6747279d27dfe0eb2a53ced9835d86588707f3c4
,"           ClientHttpRequestFactory HttpComponentsClientHttpRequestFactory = new   

      org.springframework.http.client.HttpComponentsClientHttpRequestFactory(getNewHttpC
  lient()) ;
       restTemplate.setRequestFactory(HttpComponentsClientHttpRequestFactory);


public HttpClient getNewHttpClient() {
    try {
        KeyStore trustStore = KeyStore.getInstance(KeyStore.getDefaultType());
        trustStore.load(null, null);

        MySSLSocketFactory sf = new MySSLSocketFactory(trustStore);
        sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);

        HttpParams params = new BasicHttpParams();
        HttpProtocolParams.setVersion(params, HttpVersion.HTTP_1_1);
        HttpProtocolParams.setContentCharset(params, HTTP.UTF_8);

        SchemeRegistry registry = new SchemeRegistry();
        registry.register(new Scheme(""http"", PlainSocketFactory.getSocketFactory(), 80));
        registry.register(new Scheme(""https"", sf, 443));

        ClientConnectionManager ccm = new ThreadSafeClientConnManager(params, registry);

        return new DefaultHttpClient(ccm, params);
    } catch (Exception e) {
        return new DefaultHttpClient();
    }
}
",4,0,a114e295434617bb3c52ef497a1fa1e4cc924ca3c508638c278029c3c047725d
," import org.apache.http.conn.ssl.SSLSocketFactory;
public class MySSLSocketFactory extends SSLSocketFactory {
    SSLContext sslContext = SSLContext.getInstance(""TLS"");

    public MySSLSocketFactory(KeyStore truststore) throws NoSuchAlgorithmException, KeyManagementException, KeyStoreException, UnrecoverableKeyException {
        super(truststore);

        TrustManager tm = new X509TrustManager() {
            public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {
            }

            public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {
            }

            public X509Certificate[] getAcceptedIssuers() {
                return null;
            }
        };

        sslContext.init(null, new TrustManager[] { tm }, null);
    }

    @Override
    public Socket createSocket(Socket socket, String host, int port, boolean autoClose) throws IOException, UnknownHostException {
        return sslContext.getSocketFactory().createSocket(socket, host, port, autoClose);
    }

    @Override
    public Socket createSocket() throws IOException {
        return sslContext.getSocketFactory().createSocket();
    }
 }
",4,0,9882798060369e791ae5860adb6d7a84e11e6808f759408fc016ea519fc529a3
,"public class EasySSLSocketFactory implements SocketFactory, LayeredSocketFactory 
{  
    private SSLContext sslcontext = null;  

    private static SSLContext createEasySSLContext() throws IOException 
    {  
        try
        {  
            SSLContext context = SSLContext.getInstance(""TLS"");  
            context.init(null, new TrustManager[] { new EasyX509TrustManager(null) }, null);  
            return context;  
        }
        catch (Exception e) 
        {  
            throw new IOException(e.getMessage());  
        }  
    }  

    private SSLContext getSSLContext() throws IOException 
    {  
        if (this.sslcontext == null) 
        {  
            this.sslcontext = createEasySSLContext();  
        }  
        return this.sslcontext;  
    }  

    /** 
     * @see org.apache.http.conn.scheme.SocketFactory#connectSocket(java.net.Socket, java.lang.String, int, 
     *      java.net.InetAddress, int, org.apache.http.params.HttpParams) 
     */  
    public Socket connectSocket(Socket sock,
            String host,
            int port, 
            InetAddress localAddress,
            int localPort,
            HttpParams params) 

                    throws IOException, UnknownHostException, ConnectTimeoutException 
                    {  
        int connTimeout = HttpConnectionParams.getConnectionTimeout(params);  
        int soTimeout = HttpConnectionParams.getSoTimeout(params);  
        InetSocketAddress remoteAddress = new InetSocketAddress(host, port);  
        SSLSocket sslsock = (SSLSocket) ((sock != null) ? sock : createSocket());  

        if ((localAddress != null) || (localPort &gt; 0)) 
        {  
            // we need to bind explicitly  
            if (localPort &lt; 0) 
            {  
                localPort = 0; // indicates ""any""  
            }  
            InetSocketAddress isa = new InetSocketAddress(localAddress, localPort);  
            sslsock.bind(isa);  
        }  

        sslsock.connect(remoteAddress, connTimeout);  
        sslsock.setSoTimeout(soTimeout);  
        return sslsock;    
                    }  

    /** 
     * @see org.apache.http.conn.scheme.SocketFactory#createSocket() 
     */  
    public Socket createSocket() throws IOException {  
        return getSSLContext().getSocketFactory().createSocket();  
    }  

    /** 
     * @see org.apache.http.conn.scheme.SocketFactory#isSecure(java.net.Socket) 
     */  
    public boolean isSecure(Socket socket) throws IllegalArgumentException {  
        return true;  
    }  

    /** 
     * @see org.apache.http.conn.scheme.LayeredSocketFactory#createSocket(java.net.Socket, java.lang.String, int, 
     *      boolean) 
     */  
    public Socket createSocket(Socket socket,
            String host, 
            int port,
            boolean autoClose) throws IOException,  
            UnknownHostException 
            {  
        return getSSLContext().getSocketFactory().createSocket(socket, host, port, autoClose);  
            }  

    // -------------------------------------------------------------------  
    // javadoc in org.apache.http.conn.scheme.SocketFactory says :  
    // Both Object.equals() and Object.hashCode() must be overridden  
    // for the correct operation of some connection managers  
    // -------------------------------------------------------------------  

    public boolean equals(Object obj) {  
        return ((obj != null) &amp;&amp; obj.getClass().equals(EasySSLSocketFactory.class));  
    }  

    public int hashCode() {  
        return EasySSLSocketFactory.class.hashCode();  
    }  
}
",4,0,d5cd5c7f83c80b593eb066aa17a85374d6eabf3eb68665c252694a15ed11ecd5
,"public class EasyX509TrustManager implements X509TrustManager 
{  
    private X509TrustManager standardTrustManager = null;  

    /** 
     * Constructor for EasyX509TrustManager. 
     */  
    public EasyX509TrustManager(KeyStore keystore) throws NoSuchAlgorithmException, KeyStoreException 
    {  
        super();  
        TrustManagerFactory factory = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());  
        factory.init(keystore);  
        TrustManager[] trustmanagers = factory.getTrustManagers();  
        if (trustmanagers.length == 0) 
        {  
            throw new NoSuchAlgorithmException(""no trust manager found"");  
        }  
        this.standardTrustManager = (X509TrustManager) trustmanagers[0];  
    }  

    /** 
     * @see javax.net.ssl.X509TrustManager#checkClientTrusted(X509Certificate[],String authType) 
     */  
    public void checkClientTrusted(X509Certificate[] certificates, String authType) throws CertificateException 
    {
        standardTrustManager.checkClientTrusted(certificates, authType);  
    }  

    /** 
     * @see javax.net.ssl.X509TrustManager#checkServerTrusted(X509Certificate[],String authType) 
     */  
    public void checkServerTrusted(X509Certificate[] certificates, String authType) throws CertificateException 
    {  
        X509Certificate c = certificates[0];
        String name = c.getIssuerDN().getName();
        if(!""bla bla"".equals(name))
            throw new CertificateException(""OMG! it is not bla bla!"");
        standardTrustManager.checkServerTrusted(certificates, authType);    
    }  

    /** 
     * @see javax.net.ssl.X509TrustManager#getAcceptedIssuers() 
     */  
    public X509Certificate[] getAcceptedIssuers() 
    {  
        return this.standardTrustManager.getAcceptedIssuers();  
    }    
}  
",2,0,d82cdf1afd1fbcbb4f36196024eb190012c40c277733a383e1f90a2cd67f9ff0
,"  try {
        PackageInfo info = getPackageManager().getPackageInfo(""your.package"",
                PackageManager.GET_SIGNATURES);
        for (Signature signature : info.signatures) {
            MessageDigest md = MessageDigest.getInstance(""SHA"");
            md.update(signature.toByteArray());
            Log.d(""YOURHASH KEY:"",
                    Base64.encodeToString(md.digest(), Base64.DEFAULT));
        }
    } catch (NameNotFoundException e) {

    } catch (NoSuchAlgorithmException e) {

    }
",3,0,f3fa730ce398e6ff020dee19ad7c1bf4efbd6526d448f222b921866a2b5ebc0d
,"String Decrypt(String text) throws Exception {
    cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");

    cipher.init(Cipher.DECRYPT_MODE, keyspec, ivspec);

    // here
    byte[] results = cipher.doFinal(Base64.decode(text));

    int results1 = cipher.doFinal(Base64.decode(text), 0, Base64.decode(text).length, results, 0);
    System.out.println(""String resultssssssssssssss "" + results1);
    return new String(results, ""UTF-8"");
}

String Encrypt(String text)
    throws Exception {
    cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");

    System.out.println(""String input : "" + text);

    cipher.init(Cipher.ENCRYPT_MODE, keyspec, ivspec);

    // and here
    byte[] results = cipher.doFinal(text.getBytes());

    int results1 = cipher.doFinal(text.getBytes(), 0, text.getBytes().length, results, 0);
    return Base64.encode(results);
}
",1,0,e37851a7699c9511d4ef51e4a448964628fbc8f6413c396de65fbfd46ef01626
,"KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());

// get user password and file input stream
char[] password = ""password of the keystore in the file system"";

java.io.FileInputStream fis = null;
try {
    fis = new java.io.FileInputStream(""keyStoreName"");
    ks.load(fis, password);
} finally {
    if (fis != null) {
        fis.close();
    }
}
",,1,1aa71736a3b2f2489fa681a377e2a4c8a85b3e47a776c30e121751bd79376af2
,"        String STORAGE_SCOPE = ""https://www.googleapis.com/auth/devstorage.read_write"";
        JsonFactory JSON_FACTORY = JacksonFactory.getDefaultInstance();

        Log.d(""testing"", ""checking if I can create a credential"");
        httpTransport = AndroidHttp.newCompatibleTransport();
        KeyStore keystore = KeyStore.getInstance(""PKCS12"");
        keystore.load(resources_.openRawResource(R.raw.gcs_privatekey),
                ""password"".toCharArray());

        PrivateKey key = (PrivateKey) keystore.getKey(""privatekey"", ""password"".toCharArray());

        GoogleCredential credential = new GoogleCredential.Builder()
                .setTransport(httpTransport)
                .setJsonFactory(JSON_FACTORY)
                .setServiceAccountPrivateKey(key)
                .setServiceAccountId(SERVICE_ACCOUNT_EMAIL)
                .setServiceAccountScopes(Collections.singleton(STORAGE_SCOPE))
                // .setServiceAccountUser(SERVICE_ACCOUNT_EMAIL)
                // .setClientSecrets(CLIENT_ID, CLIENT_SECRET)
                .build();
        credential.refreshToken();

        String URI = ""https://storage.googleapis.com/"" + BUCKET_NAME;
        HttpRequestFactory requestFactory = httpTransport.createRequestFactory(credential);
        GenericUrl url = new GenericUrl(URI);
        HttpRequest request = requestFactory.buildGetRequest(url);
        HttpResponse response = request.execute();
        String content = response.parseAsString();
        Log.d(""testing"", ""response content is: "" + content);
        new Storage.Builder(httpTransport, JSON_FACTORY, credential)
                .setApplicationName(""appname"").build();
",2,0,3cb82e7edf8b17049e6b61a1234613b878310dce6cfc7479adb7c285819fd727
,"private TrustManager[] getWrappedTrustManagers(TrustManager[] trustManagers) {
        final X509TrustManager originalTrustManager = (X509TrustManager) trustManagers[0];
        return new TrustManager[]{
                new X509TrustManager() {
                    public X509Certificate[] getAcceptedIssuers() {
                        return originalTrustManager.getAcceptedIssuers();
                    }

                    public void checkClientTrusted(X509Certificate[] certs, String authType) {
                        try {
                            originalTrustManager.checkClientTrusted(certs, authType);
                        } catch (CertificateException e) {
                            e.printStackTrace();
                        }
                    }

                    public void checkServerTrusted(X509Certificate[] certs, String authType) {
                        try {
                            originalTrustManager.checkServerTrusted(certs, authType);
                        } catch (CertificateException e) {
                            e.printStackTrace();
                        }
                    }
                }
        };
    }

private SSLSocketFactory getSSLSocketFactory_Certificate(String keyStoreType, int keystoreResId)
        throws CertificateException, KeyStoreException, IOException, NoSuchAlgorithmException, KeyManagementException {

    CertificateFactory cf = CertificateFactory.getInstance(""X.509"");
    InputStream caInput = getResources().openRawResource(keystoreResId);

    Certificate ca = cf.generateCertificate(caInput);
    caInput.close();

    if (keyStoreType == null || keyStoreType.length() == 0) {
        keyStoreType = KeyStore.getDefaultType();
    }
    KeyStore keyStore = KeyStore.getInstance(keyStoreType);
    keyStore.load(null, null);
    keyStore.setCertificateEntry(""ca"", ca);

    String tmfAlgorithm = TrustManagerFactory.getDefaultAlgorithm();
    TrustManagerFactory tmf = TrustManagerFactory.getInstance(tmfAlgorithm);
    tmf.init(keyStore);

    TrustManager[] wrappedTrustManagers = getWrappedTrustManagers(tmf.getTrustManagers());

    SSLContext sslContext = SSLContext.getInstance(""TLS"");
    sslContext.init(null, wrappedTrustManagers, null);

    return sslContext.getSocketFactory();
}

private SSLSocketFactory getSSLSocketFactory_KeyStore(String keyStoreType, int keystoreResId, String keyPassword)
            throws CertificateException, KeyStoreException, IOException, NoSuchAlgorithmException, KeyManagementException {

        InputStream caInput = getResources().openRawResource(keystoreResId);

        // creating a KeyStore containing trusted CAs

        if (keyStoreType == null || keyStoreType.length() == 0) {
            keyStoreType = KeyStore.getDefaultType();
        }
        KeyStore keyStore = KeyStore.getInstance(keyStoreType);

        keyStore.load(caInput, keyPassword.toCharArray());

        // creating a TrustManager that trusts the CAs in the KeyStore

        String tmfAlgorithm = TrustManagerFactory.getDefaultAlgorithm();
        TrustManagerFactory tmf = TrustManagerFactory.getInstance(tmfAlgorithm);
        tmf.init(keyStore);

        TrustManager[] wrappedTrustManagers = getWrappedTrustManagers(tmf.getTrustManagers());

        SSLContext sslContext = SSLContext.getInstance(""TLS"");
        sslContext.init(null, wrappedTrustManagers, null);

        return sslContext.getSocketFactory();
    }
",4,0,02af6fc1a498dedd889e6fc9df582000bc33ccb496b1479780d047ad26cc11df
,"private static final String CA_FILE = ""ca.pem"";
private static final String INTERMEDIATE_FILE = ""intermediate.pem"";
private static final String CERTIFICATE_FILE = ""app_01.pfx"";
private static final char[] CERTIFICATE_KEY = ""password"".toCharArray();

[...]

CertificateFactory cf = CertificateFactory.getInstance(""X.509"");
String algorithm = TrustManagerFactory.getDefaultAlgorithm();

/* trust setup */
InputStream ca = this.context.getAssets().open(CA_FILE);
InputStream intermediate = this.context.getAssets().open(INTERMEDIATE_FILE);
KeyStore trustStore = KeyStore.getInstance(""PKCS12"");
trustStore.load(null);
Certificate caCert = cf.generateCertificate(ca);
Certificate intermediateCert = cf.generateCertificate(intermediate);
trustStore.setCertificateEntry(""CA Name"", caCert);
trustStore.setCertificateEntry(""Intermediate Name"", intermediateCert);
CustomTrustManager tm = new CustomTrustManager(trustStore);
ca.close();
intermediate.close();

/* client certificate setup */
InputStream clientCert = this.context.getAssets().open(CERTIFICATE_FILE);
KeyStore keyStore = KeyStore.getInstance(""PKCS12"");
keyStore.load(clientCert, CERTIFICATE_KEY);
KeyManagerFactory kmf = KeyManagerFactory.getInstance(algorithm);
kmf.init(keyStore, CERTIFICATE_KEY);
clientCert.close();

/* SSLContext setup */
SSLContext sslContext = SSLContext.getInstance(""TLS"");
sslContext.init(kmf.getKeyManagers(), new TrustManager[]{tm}, null);

[...]

((HttpsURLConnection) con).setSSLSocketFactory(sslContext.getSocketFactory());
",3,0,900a3ef3977ed9d6b5a93062f7739afdb16907ff06902b4453425aaa8fdf9605
,"    public class ActivateHttpClient extends DefaultHttpClient { 
    final Context context;


    /**
     * Public constructor taking two arguments for ActivateHttpClient.
     * @param context - Context referencing the calling Activity, for creation of
     * the socket factory.
     * @param params - HttpParams passed to this, specifically to set timeouts on the
     * connection.
     */
    public ActivateHttpClient(Context context, HttpParams params) {
        this.setParams(params);
    }


    /* (non-Javadoc)
     * @see org.apache.http.impl.client.DefaultHttpClient#createClientConnectionManager()
     * Create references for both http and https schemes, allowing us to attach our custom
     * SSLSocketFactory to either
     */
    @Override
    protected ClientConnectionManager createClientConnectionManager() {
        SchemeRegistry registry = new SchemeRegistry();
        registry.register(new Scheme(""http"", PlainSocketFactory
                .getSocketFactory(), 80));
        registry.register(new Scheme(""https"", newSslSocketFactory(), 443));
        return new SingleClientConnManager(getParams(), registry);
    }

    /**
     * Creation of new SSLSocketFactory, which imports a certificate from
     * a server which self-signs its own certificate.
     * @return
     */
    protected SSLSocketFactory newSslSocketFactory() {
        try {

            //Keystore must be in BKS (Bouncy Castle Keystore)
            KeyStore trusted = KeyStore.getInstance(""BKS"");

            //Reference to the Keystore
            InputStream in = context.getResources().openRawResource(
                    R.raw.cert);

            //Password to the keystore
            try {
                trusted.load(in, PASSWORD_HERE.toCharArray());
            } finally {
                in.close();
            }

            // Pass the keystore to the SSLSocketFactory. The factory is
            // responsible
            // for the verification of the server certificate.
            SSLSocketFactory sf = new SSLSocketFactory(trusted);

            // Hostname verification from certificate
            // http://hc.apache.org/httpcomponents-client-ga/tutorial/html/connmgmt.html#d4e506
            sf.setHostnameVerifier(SSLSocketFactory.STRICT_HOSTNAME_VERIFIER);
            return sf;

            // return new SSLSocketFactory(trusted);
        } catch (Exception e) {
            e.printStackTrace();
            throw new AssertionError(e);
        }
    }

}
",3,0,aaa9f0d1ec004efc4b193661d10e4e98c8367ec4a3b3942a75aedd82c73e1ba6
,"private final void processChallenge(XmlPullParser parser, Writer writer,
        String sessionKey, String sessionSecret) throws IOException,
        NoSuchAlgorithmException, XmlPullParserException {

    parser.require(XmlPullParser.START_TAG, null, ""challenge"");
    String challenge = new String(Base64.decode(parser.nextText(),
            Base64.DEFAULT));

    String params[] = challenge.split(""&amp;"");
    HashMap&lt;String, String&gt; paramMap = new HashMap&lt;String, String&gt;();
    for (int i = 0; i &lt; params.length; ++i) {
        String p[] = params[i].split(""="");
        p[0] = URLDecoder.decode(p[0]);
        p[1] = URLDecoder.decode(p[1]);
        paramMap.put(p[0], p[1]);
    }

    String api_key = ""YOUR_API_KEY"";
    String call_id = """" + System.currentTimeMillis();
    String method = paramMap.get(""method"");
    String nonce = paramMap.get(""nonce"");
    String v = ""1.0"";

    StringBuffer sigBuffer = new StringBuffer();
    sigBuffer.append(""api_key="" + api_key);
    sigBuffer.append(""call_id="" + call_id);
    sigBuffer.append(""method="" + method);
    sigBuffer.append(""nonce="" + nonce);
    sigBuffer.append(""session_key="" + sessionKey);
    sigBuffer.append(""v="" + v);
    sigBuffer.append(sessionSecret);

    MessageDigest md = MessageDigest.getInstance(""MD5"");
    md.update(sigBuffer.toString().getBytes());
    byte[] digest = md.digest();

    StringBuffer sig = new StringBuffer();
    for (int i = 0; i &lt; digest.length; ++i) {
        sig.append(Integer.toHexString(0xFF &amp; digest[i]));
    }

    StringBuffer response = new StringBuffer();
    response.append(""api_key="" + URLEncoder.encode(api_key));
    response.append(""&amp;call_id="" + URLEncoder.encode(call_id));
    response.append(""&amp;method="" + URLEncoder.encode(method));
    response.append(""&amp;nonce="" + URLEncoder.encode(nonce));
    response.append(""&amp;session_key="" + URLEncoder.encode(sessionKey));
    response.append(""&amp;v="" + URLEncoder.encode(v));
    response.append(""&amp;sig="" + URLEncoder.encode(sig.toString()));

    StringBuilder out = new StringBuilder();
    out.append(""&lt;response xmlns='urn:ietf:params:xml:ns:xmpp-sasl'&gt;"");
    out.append(Base64.encodeToString(response.toString().getBytes(),
            Base64.NO_WRAP));
    out.append(""&lt;/response&gt;"");

    writer.write(out.toString());
    writer.flush();
}
",,1,ec3cef093255a506ee2854cfff25a29e7ff8482c68e56ca2289b678557b2554a
,"import java.security.MessageDigest;
import java.security.cert.Certificate;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashSet;
import java.util.Set;
import java.util.jar.JarEntry;
import java.util.jar.JarFile;

import sun.misc.BASE64Encoder;

public class Main {
    public static void main(String[] args) throws Exception {
        for (String jarFilename : args)
            extractHash(jarFilename);
    }

    private static void extractHash(String jarFilename) throws Exception {
        BASE64Encoder base64 = new BASE64Encoder();
        MessageDigest sha1 = MessageDigest.getInstance(""SHA"");
        Set&lt;Certificate&gt; certificates = new HashSet&lt;Certificate&gt;();
        JarFile jarFile = new JarFile(jarFilename);
        for (JarEntry jarEntry : Collections.list(jarFile.entries())) {
            jarFile.getInputStream(jarEntry).skip(Long.MAX_VALUE);
            Certificate[] certs = jarEntry.getCertificates();
            if (certs == null)
                continue;
            certificates.addAll(Arrays.asList(certs));
        }
        System.out.printf(""%s:"", jarFilename);
        for (Certificate cert : certificates) {
            byte[] digest = sha1.digest(cert.getEncoded());
            System.out.printf("" %s"", base64.encode(digest));
        }
        if (certificates.isEmpty())
            System.out.printf("" NOT SIGNED!"");
        System.out.println();
        jarFile.close();
    }
}
",3,0,9502c8093627738578a5175d4251e57b436640af7cc7c6d15e9000fa2319f55d
,"@Override
public void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);

    // Add code to print out the key hash
    try {
        PackageInfo info = getPackageManager().getPackageInfo(
                ""com.facebook.samples.hellofacebook"", 
                PackageManager.GET_SIGNATURES);
        for (Signature signature : info.signatures) {
            MessageDigest md = MessageDigest.getInstance(""SHA"");
            md.update(signature.toByteArray());
            Log.d(""KeyHash:"", Base64.encodeToString(md.digest(), Base64.DEFAULT));
            }
    } catch (NameNotFoundException e) {

    } catch (NoSuchAlgorithmException e) {

    }
",3,0,952e40f1762b9e066d0afff187316afdac8d6a61598cf9832fcc08c193308fd1
,"public class MyHttpClient extends DefaultHttpClient {
final Context context;
TrustManager easyTrustManager = new X509TrustManager() {
    @Override
    public void checkClientTrusted(
            X509Certificate[] chain,
            String authType) throws CertificateException {
    }

    @Override
    public void checkServerTrusted(
            X509Certificate[] chain,
            String authType) throws CertificateException {
    }

    @Override
    public X509Certificate[] getAcceptedIssuers() {
        return null;
    }    
};
  public MyHttpClient(Context context) {
    this.context = context;
  }

  @Override protected ClientConnectionManager createClientConnectionManager() {
    SchemeRegistry registry = new SchemeRegistry();
    registry.register(
        new Scheme(""http"", PlainSocketFactory.getSocketFactory(), 80));
    registry.register(new Scheme(""https"", newSslSocketFactory(), 443));
    return new SingleClientConnManager(getParams(), registry);
  }


  private MySSLSocketFactory newSslSocketFactory() {
    try {
      KeyStore trusted = KeyStore.getInstance(""BKS"");      
      try {
         trusted.load(null, null);

      } finally {
      }

      MySSLSocketFactory sslfactory =  new MySSLSocketFactory(trusted);
        sslfactory.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
        return sslfactory;
    } catch (Exception e) {
      throw new AssertionError(e);
    }

  }
  public class MySSLSocketFactory extends SSLSocketFactory {
        SSLContext sslContext = SSLContext.getInstance(""TLS"");

        public MySSLSocketFactory(KeyStore truststore) throws NoSuchAlgorithmException, KeyManagementException, KeyStoreException, UnrecoverableKeyException {
            super(truststore);

            TrustManager tm = new X509TrustManager() {
                public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {
                }

                public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {
                }

                public X509Certificate[] getAcceptedIssuers() {
                    return null;
                }
            };

            sslContext.init(null, new TrustManager[] { tm }, null);
        }

        @Override
        public Socket createSocket(Socket socket, String host, int port, boolean autoClose) throws IOException, UnknownHostException {
            return sslContext.getSocketFactory().createSocket(socket, host, port, autoClose);
        }

        @Override
        public Socket createSocket() throws IOException {
            return sslContext.getSocketFactory().createSocket();
        }
    }
   }
",4,0,5f2e392580b4fd9b998d35cc9670240e2e0f669694b3774e058084a1f7db9bf5
,"HttpClient httpClient = null;
try {
    HttpParams httpParameters = new BasicHttpParams();
    KeyStore rootca = KeyStore.getInstance(""BKS"");
    rootca.load(getResources().openRawResource(R.raw.rootcacert),""bkskeystorepass"".toCharArray());
    KeyStore mycert = KeyStore.getInstance(""pkcs12"");
    mycert.load(getResources().openRawResource(R.raw.clientcertandkey),""pkcs12storepass"".toCharArray());
    SSLSocketFactory sockfact = new SSLSocketFactory(mycert,null,rootca);
    SchemeRegistry registry = new SchemeRegistry();
    registry.register(new Scheme(""https"",sockfact , 443));
    httpClient = new DefaultHttpClient(new ThreadSafeClientConnManager(httpParameters, registry), httpParameters);
} catch (Exception e) {
    e.printStackTrace();
}
",3,0,141533d077469a293fce96c5fd18b05587a93c8b41195f812d43f75f5bb1303b
,"public class MyHttpClient extends DefaultHttpClient {

  final Context context;

  public MyHttpClient(Context context) {
      this.context = context;
  }

  @Override
  protected ClientConnectionManager createClientConnectionManager() {
      SchemeRegistry registry = new SchemeRegistry();
      registry.register(new Scheme(""http"", PlainSocketFactory.getSocketFactory(), 80));
      // Register for port 443 our SSLSocketFactory with our keystore
      // to the ConnectionManager
      registry.register(new Scheme(""https"", newSslSocketFactory(), 443));
      return new SingleClientConnManager(getParams(), registry);
  }

  private SSLSocketFactory newSslSocketFactory() {
      try {
          // Get an instance of the Bouncy Castle KeyStore format
          KeyStore trusted = KeyStore.getInstance(""BKS"");
          // Get the raw resource, which contains the keystore with
          // your trusted certificates (root and any intermediate certs)
          InputStream in = context.getResources().openRawResource(R.raw.mykeystore);
          try {
              // Initialize the keystore with the provided trusted certificates
              // Also provide the password of the keystore
              trusted.load(in, ""mysecret"".toCharArray());
          } finally {
              in.close();
          }
          // Pass the keystore to the SSLSocketFactory. The factory is responsible
          // for the verification of the server certificate.
          SSLSocketFactory sf = new SSLSocketFactory(trusted);
          // Hostname verification from certificate
          // http://hc.apache.org/httpcomponents-client-ga/tutorial/html/connmgmt.html#d4e506
          sf.setHostnameVerifier(SSLSocketFactory.STRICT_HOSTNAME_VERIFIER);
          return sf;
      } catch (Exception e) {
          throw new AssertionError(e);
      }
  }
}
",3,0,933ab2224bcfe1364d58c106de50d1e9a99ab9fc42cfb1120273ee2d159b8f6e
,"private String executeRequest(String urlAddress)
{
    String responce = null;
    String msg = null;
    int error = 0;
    try {
        URL url = new URL(urlAddress);
        HttpsURLConnection  connection = (HttpsURLConnection)url.openConnection();
        SSLSocketFactory factory =  SecureSocketFactory.getSSLSocketFactory();
        connection.setSSLSocketFactory(factory);

        connection.setHostnameVerifier(new Verifier());

        if (method == RequestMethod.POST)
        {
            connection.setDoOutput(true);
            connection.setRequestMethod(""POST"");
        }
        else
        {
            connection.setDoInput(true);
            connection.setRequestMethod(""GET"");
        }
        msg = connection.getResponseMessage();
        error = connection.getResponseCode();
        if (""OK"".equals(msg))
        {
            InputStream content = (InputStream) connection.getContent();
            responce = convertStreamToString(content);
        }
        else
        {
            responce = ""Error "" + error;
        }
        connection.disconnect();

    } catch (Exception e) {
        responce = e.toString();
    }

    return responce;
}
",,1,2e124f0e12e3f130ce5f0c636cdcfda4e6452a5897faae1f91e28c7b4d7af02a
,"package com.example.android.secure;

import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.PBEKeySpec;
import javax.crypto.spec.SecretKeySpec;

public class EncryptionManager {

 // we should get a password from the user
 String password = ""..."";
 String PBE_ALGORITHM = ""PBEWithSHA256And256BitAES-CBC-BC"";
 // Important not to rely on default here !!!! use CBC instead of ECB
 String CIPHER_ALGORITHM = ""AES/CBC/PKCS5Padding"";
 int NUM_OF_ITERATIONS = 1000;
 int KEY_SIZE = 256;
 // generated on first run
 byte[] salt = ""abababababababababa bab"".getBytes();
 byte[] iv = ""1234567890abcdef"".getBytes();
 // This is the value to be encrypted.
 String clearText = ""..."";
 byte[] encryptedText;
 byte[] decryptedText;

 public void exampleCodeNoRealMethod() {
    try {
       PBEKeySpec pbeKeySpec = new PBEKeySpec(password.toCharArray(), salt, NUM_OF_ITERATIONS, KEY_SIZE);
       SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(PBE_ALGORITHM);
       SecretKey tempKey = keyFactory.generateSecret(pbeKeySpec);
       SecretKey secretKey = new SecretKeySpec(tempKey.getEncoded(), ""AES"");
       IvParameterSpec ivSpec = new IvParameterSpec(iv);
       Cipher encCipher = Cipher.getInstance(CIPHER_ALGORITHM);
       encCipher.init(Cipher.ENCRYPT_MODE, secretKey, ivSpec);
       Cipher decCipher = Cipher.getInstance(CIPHER_ALGORITHM);
       decCipher.init(Cipher.DECRYPT_MODE, secretKey, ivSpec);
       encryptedText = encCipher.doFinal(clearText.getBytes());
       decryptedText = decCipher.doFinal(encryptedText);
       String sameAsClearText = new String(decryptedText);
    } catch (Exception e) { 
       // TODO handle this exception
    }
 }

}
",4,0,ce38700bc51608fa3a8f6f44d252f989ba013a5136c2078a6a6b0d5f2a60a246
,"public static SecretKey generateKey(char[] passphraseOrPin, byte[] salt) throws NoSuchAlgorithmException, InvalidKeySpecException {
    // Number of PBKDF2 hardening rounds to use. Larger values increase
    // computation time. You should select a value that causes computation
    // to take &gt;100ms.
    final int iterations = 1000; 

    // Generate a 256-bit key
    final int outputKeyLength = 256;

    SecretKeyFactory secretKeyFactory = SecretKeyFactory.getInstance(""PBKDF2WithHmacSHA1"");
    KeySpec keySpec = new PBEKeySpec(passphraseOrPin, salt, iterations, outputKeyLength);
    SecretKey secretKey = secretKeyFactory.generateSecret(keySpec);
    return secretKey;
}
",3,0,61ad132ccd3dd852377799268a0a3a5fe2c5d5d97dd979c3258c10d3de287661
,"KeyFactory rsaKeyFac = KeyFactory.getInstance(""RSA"");
X509EncodedKeySpec keySpec = new X509EncodedKeySpec(key);  
RSAPublicKey rsaPubKey = (RSAPublicKey)rsaKeyFac.generatePublic(keySpec);
return new PublicKeyImpl(rsaPubKey);    
",3,0,87f620cc7beebf3b736b12954c5cbefbb9365a80fb360eaa6f8235c0c5186463
,"HostnameVerifier hostnameVerifier = new HostnameVerifier() {
    @Override
    public boolean verify(String hostname, SSLSession session) {
        HostnameVerifier hv =
            HttpsURLConnection.getDefaultHostnameVerifier();
        return hv.verify(""localhost"", session);
    }
};
",2,0,c051f784e1c9d1772d6322a4628ef530c9fc17cdefa2ed5c3bde694e4050a96c
,"public void getHashKeyForFacebook(Activity activity, String packageName){
    try{
        PackageInfo info = activity.getPackageManager().getPackageInfo(packageName,  PackageManager.GET_SIGNATURES);

        for (Signature signature : info.signatures){
                MessageDigest md = MessageDigest.getInstance(""SHA"");
                md.update(signature.toByteArray());
                Log.d(""KeyHash:"", Base64.encodeToString(md.digest(), Base64.DEFAULT));
        }
    } catch (Exception ex){

    }
}
",3,0,8aa91df350cb4d785a12621ab1b362923b5902adbb3659972813517b093bb644
,"private void getHashKey() {

    try {
        PackageInfo info = getPackageManager().getPackageInfo(
                ""your_package_name"", PackageManager.GET_SIGNATURES);
        for (Signature signature : info.signatures) {
            MessageDigest md = MessageDigest.getInstance(""SHA""); 
            md.update(signature.toByteArray());
            Log.e(""YOURHASH KEY:"",
                    Base64.encodeToString(md.digest(),Base64.DEFAULT));
            String WEATHER_HASH = Base64.encodeToString(md.digest(),
                    Base64.DEFAULT);

            return;
        }
    } catch (NameNotFoundException e) {

    } catch (NoSuchAlgorithmException e) {

    }
    return;

}
",3,0,8b972d1e247eb442a01871d1d1f75d96a05e4b4619d0d0c296b9fde1ffa80040
,"SecureRandom r = new SecureRandom(); // should be the best PRNG
byte[] iv = new byte[16];
r.nextBytes(iv);

cipher.init(Cipher.ENCRYPT_MODE, skeySpec, new IvParameterSpec(iv));
",2,0,29036d1a45e7570c1b835defda2fb2b74d19ee4f1746e4f810d008dc4b373994
,"private static SoapObject getBody(final SoapSerializationEnvelope soapEnvelope) throws Exception {
        if (soapEnvelope.bodyIn == null) {
            throw new Exception(""soapEnvelope.bodyIn=null"");
        }
        else if (soapEnvelope.bodyIn.getClass() == SoapFault.class) {
            throw new ExceptionLogic((SoapFault) soapEnvelope.bodyIn));
        }
        else {
            return (SoapObject) soapEnvelope.bodyIn;
        }

    }

private static SoapSerializationEnvelope sendRequete(final SoapObject soapReq, final String classMappingName,
            final Class&lt;?&gt; classMapping, final int timeOutSpecial) {



        final SoapSerializationEnvelope soapEnvelope = new SoapSerializationEnvelope(SoapEnvelope.VER11);
        soapEnvelope.implicitTypes = true;
        soapEnvelope.dotNet = true;

        if (classMappingName != null) {
            soapEnvelope.addMapping(NAMESPACE, classMappingName, classMapping);
        }

        soapEnvelope.setOutputSoapObject(soapReq);

        try {

            final HttpTransportSE httpTransport = new HttpTransportSE(Constante.urlWebService, timeOutSpecial);
            httpTransport.debug = BuildConfig.DEBUG;

            // Prod
            if (Constante.urlWebService.startsWith(""https://"")) {
                final List&lt;HeaderProperty&gt; headerList = new ArrayList&lt;HeaderProperty&gt;();
                headerList.add(new HeaderProperty(""Authorization"", ""Basic ""
                        + org.kobjects.base64.Base64.encode((Constante.CERTIFICAT_LOGIN + "":"" + Constante.CERTIFICAT_MDP).getBytes())));

                FakeX509TrustManager.allowAllSSL();
                httpTransport.call(NAMESPACE + ""/"" + soapReq.getName(), soapEnvelope, headerList);
            }
            // Test
            else {
                httpTransport.call(NAMESPACE + ""/"" + soapReq.getName(), soapEnvelope);
            }

            return soapEnvelope;
        }
        catch (final Exception e) {
            throw new Exception(""Erreur : "" + e.getMessage(), e);
        }

    }



    private static class FakeX509TrustManager implements X509TrustManager {
        private static TrustManager[] trustManagers;
        private final X509Certificate[] _AcceptedIssuers = new X509Certificate[] {};

        @Override
        public X509Certificate[] getAcceptedIssuers() {
            return _AcceptedIssuers;
        }

        public static void allowAllSSL() {
            HttpsURLConnection.setDefaultHostnameVerifier(new HostnameVerifier() {

                @Override
                public boolean verify(final String hostname, final SSLSession session) {
                    return true;
                }
            });
            SSLContext context = null;
            if (trustManagers == null) {
                trustManagers = new TrustManager[] { new FakeX509TrustManager() };
            }
            try {
                context = SSLContext.getInstance(""TLS"");
                context.init(null, trustManagers, new SecureRandom());
            }
            catch (final NoSuchAlgorithmException e) {
                e.printStackTrace();
            }
            catch (final KeyManagementException e) {
                e.printStackTrace();
            }
            HttpsURLConnection.setDefaultSSLSocketFactory(context.getSocketFactory());
        }

        @Override
        public void checkClientTrusted(final X509Certificate[] arg0, final String arg1) throws CertificateException {

        }

        @Override
        public void checkServerTrusted(final X509Certificate[] chain, final String authType) throws CertificateException {

        }
    }
",4,0,3553cfddab7e3bd3dde614fbe42e2f9de052f71b413588186f887dd39580dd11
,"class User {
    @DatabaseField(canBeNull = false)
    private String passwordHash;

    public void setPassword(String password) {
        this.passwordHash = hashPassword(password);
    }

    public boolean isPasswordCorrect(String givenPassword) {
        return TextUtils.equals(hasPassword(givenPassword), passwordHash);
    }

    private String hashPassword(String password) {
        return AeSimpleSHA1.SHA1(password);
    }
}

public class AeSimpleSHA1 { 

    private static String convertToHex(byte[] data) { 
        StringBuffer buf = new StringBuffer();
        for (int i = 0; i &lt; data.length; i++) { 
            int halfbyte = (data[i] &gt;&gt;&gt; 4) &amp; 0x0F;
            int two_halfs = 0;
            do { 
                if ((0 &lt;= halfbyte) &amp;&amp; (halfbyte &lt;= 9)) 
                    buf.append((char) ('0' + halfbyte));
                else 
                    buf.append((char) ('a' + (halfbyte - 10)));
                halfbyte = data[i] &amp; 0x0F;
            } while(two_halfs++ &lt; 1);
        } 
        return buf.toString();
    } 

    public static String SHA1(String text) 
    throws NoSuchAlgorithmException, UnsupportedEncodingException  { 
        MessageDigest md;
        md = MessageDigest.getInstance(""SHA-1"");
        byte[] sha1hash = new byte[40];
        md.update(text.getBytes(""iso-8859-1""), 0, text.length());
        sha1hash = md.digest();
        return convertToHex(sha1hash);
    } 
} 
",3,0,26343da2736a16561dc2bce4c1bb1163448793c555974387535423c33f7d4e26
,"public void ListSupportedAlgorithms() {
String result = """";

// get all the providers
Provider[] providers = Security.getProviders();

for (int p = 0; p &lt; providers.length; p++) {
    // get all service types for a specific provider
    Set&lt;Object&gt; ks = providers[p].keySet();
    Set&lt;String&gt; servicetypes = new TreeSet&lt;String&gt;();
    for (Iterator&lt;Object&gt; it = ks.iterator(); it.hasNext();) {
        String k = it.next().toString();
        k = k.split("" "")[0];
        if (k.startsWith(""Alg.Alias.""))
            k = k.substring(10);

        servicetypes.add(k.substring(0, k.indexOf('.')));
    }

    // get all algorithms for a specific service type
    int s = 1;
    for (Iterator&lt;String&gt; its = servicetypes.iterator(); its.hasNext();) {
        String stype = its.next();
        Set&lt;String&gt; algorithms = new TreeSet&lt;String&gt;();
        for (Iterator&lt;Object&gt; it = ks.iterator(); it.hasNext();) {
        String k = it.next().toString();
        k = k.split("" "")[0];
        if (k.startsWith(stype + "".""))
            algorithms.add(k.substring(stype.length() + 1));
        else if (k.startsWith(""Alg.Alias."" + stype +"".""))
            algorithms.add(k.substring(stype.length() + 11));
    }

    int a = 1;
    for (Iterator&lt;String&gt; ita = algorithms.iterator(); ita.hasNext();) {
        result += (""[P#"" + (p + 1) + "":"" + providers[p].getName() + ""]"" +
                   ""[S#"" + s + "":"" + stype + ""]"" +
                   ""[A#"" + a + "":"" + ita.next() + ""]\n"");
        a++;
    }

    s++;
}
}
",,1,36fcfcebcb78d9c5621f6034e51fd827594650cbaaeadbae12dea13828f67100
,"public class MySSLSocketFactory extends SSLSocketFactory {
    SSLContext sslContext = SSLContext.getInstance(""TLS"");

    public MySSLSocketFactory(KeyStore truststore) throws NoSuchAlgorithmException, KeyManagementException, KeyStoreException, UnrecoverableKeyException {
        super(truststore);

        TrustManager tm = new X509TrustManager() {
            public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {
            }

            public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {
            }

            public X509Certificate[] getAcceptedIssuers() {
                return null;
            }
        };

        sslContext.init(null, new TrustManager[] { tm }, null);
    }

    @Override
    public Socket createSocket(Socket socket, String host, int port, boolean autoClose) throws IOException, UnknownHostException {
        return sslContext.getSocketFactory().createSocket(socket, host, port, autoClose);
    }

    @Override
    public Socket createSocket() throws IOException {
        return sslContext.getSocketFactory().createSocket();
    }


public static HttpClient getNewHttpClient() {
    try {
        KeyStore trustStore = KeyStore.getInstance(KeyStore.getDefaultType());
        trustStore.load(null, null);

        SSLSocketFactory sf = new MySSLSocketFactory(trustStore);
        sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);

        HttpParams params = new BasicHttpParams();
        HttpProtocolParams.setVersion(params, HttpVersion.HTTP_1_1);
        HttpProtocolParams.setContentCharset(params, HTTP.UTF_8);

        SchemeRegistry registry = new SchemeRegistry();
        registry.register(new Scheme(""http"", PlainSocketFactory.getSocketFactory(), 80));
        registry.register(new Scheme(""https"", sf, 443));

        ClientConnectionManager ccm = new ThreadSafeClientConnManager(params, registry);

        return new DefaultHttpClient(ccm, params);
    } catch (Exception e) {
        return new DefaultHttpClient();
    }
}

}
",4,0,7e9afd4393db0bdec29f2426220f059554724bc4015e22a723ef65141c10836f
,"public class MailSender {
private String mailhost = ""smtp.gmail.com"";
private String user;
private String password;
private Session session;
private Multipart _multipart;
public BodyPart messageBodyPart;
DataSource source;
static {
    Security.addProvider(new com.PackageName.JSSEProvider());
}

public MailSender(String user, String password) {
    this.user = user;
    this.password = password;

    Properties props = new Properties();
    props.setProperty(""mail.transport.protocol"", ""smtp"");
    props.setProperty(""mail.smtp.host"", mailhost);
    props.put(""mail.smtp.auth"", ""true"");
    props.put(""mail.smtp.port"", ""465"");
    props.put(""mail.smtp.socketFactory.port"", ""465"");
    props.put(""mail.smtp.socketFactory.class"",
            ""javax.net.ssl.SSLSocketFactory"");
    props.put(""mail.smtp.socketFactory.fallback"", ""false"");
    props.setProperty(""mail.smtp.quitwait"", ""false"");
    _multipart = new MimeMultipart();
    session = Session.getInstance(props, new MailAuthenticator(user,
            password));

}

public synchronized void sendMail(final String subject, final String uuid,
        final String address, final double latitude,
        final double longitude, final String recipients,
        final String filepath, final Context context, final int i, final int j)
        throws Exception {

    Thread thread = new Thread() {
        public void run() {
            Looper.prepare();
            try {
                System.out.println(""SENDING       MAIL"");
                Message message = new MimeMessage(session);
                messageBodyPart = new MimeBodyPart();
                DatabaseAdapter db = new DatabaseAdapter(context);
                String eId = db.getYourId();
                message.setFrom(new InternetAddress(eId));
                message.setSubject(subject);
                SimpleDateFormat sdf = new SimpleDateFormat(""yyyy-MM-dd"");
                String currentDate = sdf.format(new Date());
                SimpleDateFormat sTf = new SimpleDateFormat(""hh:mm:ss"");
                String currentTime = sTf.format(new Date());
                System.out.println(i);
                messageBodyPart
                        .setText(""Someone tried to unlock your device(ID : ""+uuid+"" ) at: ""
                                + currentTime + "" on "" + currentDate + ""\n""
                                + ""Device Location : "" + address + ""\n""
                                + ""Map: "" + ""http://maps.google.com/?q=""
                                + latitude + "","" + longitude);
                if (recipients.indexOf(',') &gt; 0)
                    message.setRecipients(Message.RecipientType.TO,
                            InternetAddress.parse(recipients));
                else
                    message.setRecipient(Message.RecipientType.TO,
                            new InternetAddress(recipients));

                Transport transport = session.getTransport(""smtp"");
                System.out.println(""CONECTING....."");
                transport.connect(mailhost, user, password);
                message.saveChanges();
                message.setContent(_multipart);
                _multipart.addBodyPart(messageBodyPart);
                message.setContent(_multipart);
                if (source != null) {

                    message.setFileName(""image"");
                }
                Transport.send(message);
                System.out.println(""Mail  sent ..."");

                }

                transport.close();


            } catch (Exception e) {
                e.printStackTrace();
            }

        }
    };
    thread.start();

}

public void addAttachment(String filename) throws Exception {
    if (!filename.equals("""")) {
        System.out.println(""Ataching     file        :)"");
        messageBodyPart = new MimeBodyPart();
        source = new FileDataSource(filename);
        messageBodyPart.setDataHandler(new DataHandler(source));
        messageBodyPart.setFileName(filename);
        _multipart.addBodyPart(messageBodyPart);
        System.out.println(""FILE    ATTACHED        :)"");
    }
}


class MailAuthenticator extends Authenticator {
    String us;
    String pw;

    public MailAuthenticator(String username, String password) {
        super();
        this.us = username;
        this.pw = password;
    }

    public PasswordAuthentication getPasswordAuthentication() {
        return new PasswordAuthentication(us, pw);
    }
}
",3,0,17615c7aaab99becbdb1db79b496b38991004cd1f499947be41b388d137fbccb
,"SSLContext sslcontext = SSLContext.getInstance(""TLSv1"");
sslcontext.init(null, null, null);
//  NoSSLv3SocketFactory is @bhavit-s-sengar's http://stackoverflow.com/a/29946540/8524
SSLSocketFactory noSSLv3Factory = new NoSSLv3SocketFactory(sslcontext.getSocketFactory());

NetHttpTransport.Builder netTransportBuilder = new NetHttpTransport.Builder();
netTransportBuilder.setSslSocketFactory(noSSLv3Factory);
HTTP_TRANSPORT = netTransportBuilder.build();
",3,0,4d3d5ad0982e0fd0efd655415c0f311b29fa70e2e5e25623b017d698b7be8ec5
,"private static final String CLASS_NAME = ""SendQueryTask"";
//...
import java.io.StringWriter;

import javax.xml.transform.OutputKeys;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerConfigurationException;
import javax.xml.transform.TransformerException;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.TransformerFactoryConfigurationError;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamResult;
//...
private String transformXmlToString(Node node)
{
    Transformer transformer = null;
    try
    {
        transformer = TransformerFactory.newInstance().newTransformer();
    }
    catch (TransformerConfigurationException e)
    {
        // TODO Auto-generated catch block
        e.printStackTrace();
    }
    catch (TransformerFactoryConfigurationError e)
    {
        // TODO Auto-generated catch block
        e.printStackTrace();
    }
    if ( transformer != null )
    {
        transformer.setOutputProperty( OutputKeys.INDENT, ""yes"" );

        // initialize StreamResult with File object to save to file
        StreamResult result = new StreamResult( new StringWriter() );
        DOMSource source = new DOMSource( node );

        try
        {
            transformer.transform( source, result );
        }
        catch (TransformerException e)
        {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }

        String xmlString = result.getWriter().toString();
        Log.i( CLASS_NAME, ""flattened="" + (xmlString) );

        return xmlString;
    }       
    return null;
}
",,1,e01b76eef7415d536d069a2af3879f1f6b4705e75a2edcd4b36604ea6b7c9965
,"public class SSLCertificateHandler {

    protected static final String TAG = ""NukeSSLCerts"";

    /**
     * Enables https connections
     */
    public static void nuke() {
        try {
            TrustManager[] trustAllCerts = new TrustManager[] { new X509TrustManager() {
                public X509Certificate[] getAcceptedIssuers() {
                    X509Certificate[] myTrustedAnchors = new X509Certificate[0];
                    return myTrustedAnchors;
                }

                @Override
                public void checkClientTrusted(X509Certificate[] certs, String authType) {
                }

                @Override
                public void checkServerTrusted(X509Certificate[] certs, String authType) {
                }
            } };

            SSLContext sc = SSLContext.getInstance(""SSL"");
            sc.init(null, trustAllCerts, new SecureRandom());
            HttpsURLConnection.setDefaultSSLSocketFactory(sc.getSocketFactory());
            HttpsURLConnection.setDefaultHostnameVerifier(new HostnameVerifier() {
                @Override
                public boolean verify(String arg0, SSLSession arg1) {
                    return true;
                }
            });
        } catch (Exception e) {
        }
    }

}
",4,0,8c58a05f2ca541b870634ed9884f993b71b56be26494a5c77f55f954579597cc
,"public void startTLS() {

    try {
        sslContext = SSLContext.getInstance(""TLS"");
        sslContext.init(null, trustCerts, null);
    } catch(NoSuchAlgorithmException nsa) {
        System.out.println(""Exception : No Such Algorithm"");
    } catch(KeyManagementException kme) {
        System.out.println(""Exception : KeyManagementException:"");
    }//try-catch


    IoFilterChain chain = session.getFilterChain();
    SslFilter sslFilter = (SslFilter) chain.get(""sslFilter"");

    if (sslFilter == null) {
        sslFilter = new SslFilter(sslContext);
        sslFilter.setUseClientMode(true);
        if ((cipherSuites != null) &amp;&amp; !cipherSuites.isEmpty()) {
            sslFilter.setEnabledCipherSuites(cipherSuites.toArray( new String[cipherSuites.size()] )); 
        } 

        chain.addFirst(""sslFilter"", sslFilter);

    }else {
        try {
            sslFilter.startSsl(this.session);
        } catch(SSLException se) {
            System.out.println(""SslException:""+se);
        }
    }//if-else

}//startTLS
",,1,ea8eecf5a07713d9c47a2c6074e29b13962bb749a7c273ae3284cfae30a4b08d
,"package com.facebook.android;

import java.io.IOException;
import java.io.UnsupportedEncodingException;
import java.net.URLEncoder;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.GregorianCalendar;
import java.util.HashMap;
import java.util.Map;

import org.apache.harmony.javax.security.auth.callback.CallbackHandler;
import org.apache.harmony.javax.security.sasl.Sasl;
import org.jivesoftware.smack.SASLAuthentication;
import org.jivesoftware.smack.XMPPException;
import org.jivesoftware.smack.sasl.SASLMechanism;
import org.jivesoftware.smack.util.Base64;

import android.util.Log;


public class SASLXFacebookPlatformMechanism extends SASLMechanism {

    private static final String NAME              = ""X-FACEBOOK-PLATFORM"";

    private String              apiKey            = """";
    private String              accessToken        = """";

    /**
     * Constructor.
     */
    public SASLXFacebookPlatformMechanism(SASLAuthentication saslAuthentication) {
        super(saslAuthentication);
    }

    @Override
    protected void authenticate() throws IOException, XMPPException {
        getSASLAuthentication().send(new AuthMechanism(NAME, """"));
    }

    @Override
    public void authenticate(String apiKey, String host, String accessToken) throws IOException, XMPPException {
        if (apiKey == null || accessToken == null) {
            throw new IllegalArgumentException(""Invalid parameters"");
        }

        this.apiKey = apiKey;
        this.accessToken = accessToken;
        this.hostname = host;

        String[] mechanisms = { ""DIGEST-MD5"" };
        Map&lt;String, String&gt; props = new HashMap&lt;String, String&gt;();
        this.sc = Sasl.createSaslClient(mechanisms, null, ""xmpp"", host, props, this);
        authenticate();
    }

    @Override
    public void authenticate(String username, String host, CallbackHandler cbh) throws IOException, XMPPException {
        String[] mechanisms = { ""DIGEST-MD5"" };
        Map&lt;String, String&gt; props = new HashMap&lt;String, String&gt;();
        this.sc = Sasl.createSaslClient(mechanisms, null, ""xmpp"", host, props, cbh);
        authenticate();
    }

    @Override
    protected String getName() {
        return NAME;
    }

    @Override
    public void challengeReceived(String challenge) throws IOException {
        byte[] response = null;

        if (challenge != null) {
            String decodedChallenge = new String(Base64.decode(challenge));
            Map&lt;String, String&gt; parameters = getQueryMap(decodedChallenge);

            String version = ""1.0"";
            String nonce = parameters.get(""nonce"");
            String method = parameters.get(""method"");

            String composedResponse =
                ""method="" + URLEncoder.encode(method, ""utf-8"") +
                        ""&amp;nonce="" + URLEncoder.encode(nonce, ""utf-8"") +
                        ""&amp;access_token="" + URLEncoder.encode(accessToken, ""utf-8"") +
                        ""&amp;api_key="" + URLEncoder.encode(apiKey, ""utf-8"") +
                        ""&amp;call_id=0"" +
                        ""&amp;v="" + URLEncoder.encode(version, ""utf-8"");
            response = composedResponse.getBytes();
        }

        String authenticationText = """";

        if (response != null) {
            authenticationText = Base64.encodeBytes(response);
        }

        // Send the authentication to the server
        getSASLAuthentication().send(new Response(authenticationText));
    }

    private Map&lt;String, String&gt; getQueryMap(String query) {
        Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();
        String[] params = query.split(""\\&amp;"");

        for (String param : params) {
            String[] fields = param.split(""="", 2);
            map.put(fields[0], (fields.length &gt; 1 ? fields[1] : null));
        }

        return map;
    }
}
",3,0,e978f240d12058e5207bc9e6a281bd71c77f746211fe9d121f457f3bbc7796e8
," try {
            PackageInfo info = getPackageManager().getPackageInfo(
                    ""your package name"",
                    PackageManager.GET_SIGNATURES);
            for (Signature signature : info.signatures) {
                MessageDigest md = MessageDigest.getInstance(""SHA"");
                md.update(signature.toByteArray());
                Log.d(""KeyHash:"", Base64.encodeToString(md.digest(), Base64.DEFAULT));
            }
        } catch (PackageManager.NameNotFoundException e) {

        } catch (NoSuchAlgorithmException e) {

        }
",3,0,649bc1b3d576659c3740f36b4d57c2635badddd6efe9e9a3a877323c1ea1d98b
,"    protected HttpsURLConnection createConnection(String url, Object extra) throws IOException {
    String encodedUrl = Uri.encode(url, ALLOWED_URI_CHARS);

    // Load CAs from an InputStream
    // (could be from a resource or ByteArrayInputStream or ...)
    CertificateFactory cf = null;
    try {
        cf = CertificateFactory.getInstance(""X.509"");
    } catch (CertificateException e1) {

        // TODO Auto-generated catch block
        e1.printStackTrace();

    }
    // From https://www.washington.edu/itconnect/security/ca/load-der.crt
    InputStream caInput = new BufferedInputStream(new FileInputStream(Environment.getExternalStorageDirectory()
            + ""/cub.crt""));
    Certificate ca = null;
    try {
        try {
            ca = cf.generateCertificate(caInput);
            System.out.println(""ca="" + ((X509Certificate) ca).getSubjectDN());
        } catch (CertificateException e) {

            // TODO Auto-generated catch block
            e.printStackTrace();

        }
    } finally {
        caInput.close();
    }

    // Create a KeyStore containing our trusted CAs
    String keyStoreType = KeyStore.getDefaultType();
    KeyStore keyStore = null;
    try {
        keyStore = KeyStore.getInstance(keyStoreType);
        try {
            keyStore.load(null, null);
            keyStore.setCertificateEntry(""ca"", ca);
        } catch (NoSuchAlgorithmException e1) {

            // TODO Auto-generated catch block
            e1.printStackTrace();

        } catch (CertificateException e1) {

            // TODO Auto-generated catch block
            e1.printStackTrace();

        }

        // Create a TrustManager that trusts the CAs in our KeyStore
        String tmfAlgorithm = TrustManagerFactory.getDefaultAlgorithm();
        TrustManagerFactory tmf = null;
        try {
            tmf = TrustManagerFactory.getInstance(tmfAlgorithm);
            tmf.init(keyStore);
        } catch (NoSuchAlgorithmException e1) {

            // TODO Auto-generated catch block
            e1.printStackTrace();

        }

        // Create an SSLContext that uses our TrustManager
        SSLContext context = null;
        try {
            context = SSLContext.getInstance(""TLS"");
        } catch (NoSuchAlgorithmException e) {

            // TODO Auto-generated catch block
            e.printStackTrace();

        }
        try {
            context.init(null, tmf.getTrustManagers(), null);
        } catch (KeyManagementException e) {

            // TODO Auto-generated catch block
            e.printStackTrace();

        }
        HttpsURLConnection conn = (HttpsURLConnection) new URL(encodedUrl).openConnection();
        conn.setConnectTimeout(connectTimeout);
        conn.setSSLSocketFactory(context.getSocketFactory());
        conn.setReadTimeout(readTimeout);
        return conn;
    } catch (KeyStoreException e) {

        // TODO Auto-generated catch block
        e.printStackTrace();

    }
    return null;

}
",3,0,87f947c319fe0c86c2d3769b5a1da51c0c911d47fe6ae38f0cd7664983bc5833
,"public BoolString tryEncrypt(String inString, String password) {
    try {
        String value= encrypt(inString, password);
        return new BoolString(true,"""",value);
    }
    catch (GeneralSecurityException e){
        return new BoolString(false,e.getMessage(),"""");
    }
}

    protected void onPostExecute(BoolString result){          
        progress.dismiss();
        if (result.success){
                result.value;
        }
        else {
              result.err;
        }
    }
",,1,0d644b7f8d263ecfe70467ed86e63db0a83e1c761f9597bc0d851a34255ef7e4
,"HostnameVerifier hostnameVerifier = org.apache.http.conn.ssl.SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER;
            DefaultHttpClient client = new DefaultHttpClient();
            SchemeRegistry registry = new SchemeRegistry();
            SSLSocketFactory socketFactory = SSLSocketFactory
                    .getSocketFactory();
            socketFactory
                    .setHostnameVerifier((X509HostnameVerifier) hostnameVerifier);
            registry.register(new Scheme(""https"", socketFactory, 443));
            SingleClientConnManager mgr = new SingleClientConnManager(
                    client.getParams(), registry);
            // defaultHttpClient
            DefaultHttpClient httpClient = new DefaultHttpClient(mgr,
                    client.getParams());
            HttpsURLConnection.setDefaultHostnameVerifier(hostnameVerifier);
",4,0,71ceb8141aa64f4ca99b8f694e40683677beb27e48e3ae87c180300e9bd0a7bb
,"String filename = hash(Uri.parse(downloadLink).getLastPathSegment());

public String hash(String victim) throws NoSuchAlgorithmException
{
    MessageDigest md = MessageDigest.getInstance(""SHA1"");
    md.reset();
    byte[] buffer = victim.getBytes();
    md.update(buffer);
    byte[] digest = md.digest();

    StringBuilder hexStr = new StringBuilder();
    for (int i = 0; i &lt; digest.length; i++) {
        hexStr.append(Integer.toString( ( digest[i] &amp; 0xff ) + 0x100, 16).substring( 1 ));
    }
    return hexStr.toString();
}
",3,0,c8619a64d094700ec8aafd5dc90ac0e4c8fd70ca0d95c072c9d97a124d113651
,"// get the key
final KeyGenerator generator = KeyGenerator.getInstance(""AES"");
generator.init(128);
final SecretKey secretKey = generator.generateKey();

// perform encryption
final Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
cipher.init(Cipher.ENCRYPT_MODE, secretKey);
FileInputStream fis = new FileInputStream(System.getProperty(""user.home"") + java.io.File.separatorChar + ""plain.pdf"");
FileOutputStream fos = new FileOutputStream(System.getProperty(""user.home"") + java.io.File.separatorChar + ""test.enc"");
final CipherOutputStream output = new CipherOutputStream(fos, cipher);

int bytesRead = 0;
final byte[] plainText = new byte[4096];
while ((bytesRead = fis.read(plainText)) &gt;= 0) {
    output.write(plainText, 0, bytesRead);
}
output.flush();
output.close();
fos.close();
fis.close();
final byte[] iv = cipher.getIV();

// decrypt the file
cipher.init(Cipher.DECRYPT_MODE, secretKey, new IvParameterSpec(iv));
fis = new FileInputStream(System.getProperty(""user.home"") + java.io.File.separatorChar + ""test.enc"");
fos = new FileOutputStream(System.getProperty(""user.home"") + java.io.File.separatorChar + ""test.pdf"");
final CipherInputStream input = new CipherInputStream(fis, cipher);

final byte[] decryptedData = new byte[4096];
int decryptedRead;
while ((decryptedRead = input.read(decryptedData)) &gt;= 0) {
    fos.write(decryptedData, 0, decryptedRead);
}
fos.flush();
fos.close();
input.close();
fis.close();
",,1,01732f3b265d01df1c04fbd08457730384ee5a05b3c3a76cb243811807b98c0d
,"KeyStore ts = KeyStore.getInstance(""BKS"");
InputStream in = getResources().openRawResource(R.raw.mytruststore);
ts.load(in, TRUSTSTORE_PASSWORD.toCharArray());

SchemeRegistry schemeRegistry = new SchemeRegistry();
schemeRegistry.register(new Scheme(""http"", PlainSocketFactory
                .getSocketFactory(), 80));
SSLSocketFactory sslSocketFactory = new SSLSocketFactory(ts);
schemeRegistry.register(new Scheme(""https"", sslSocketFactory, 443));
HttpParams params = new BasicHttpParams();
ClientConnectionManager cm = 
    new ThreadSafeClientConnManager(params, schemeRegistry);

HttpClient client = new DefaultHttpClient(cm, params);
",3,0,ec938d8f2b36cd2c8d44b27f4ca1ef192cd272090058466394a91e23bd1c3fd0
,"public void generateHashkey(){
    try {
        PackageInfo info = getPackageManager().getPackageInfo(
                PACKAGE,
                PackageManager.GET_SIGNATURES);
        for (Signature signature : info.signatures) {
            MessageDigest md = MessageDigest.getInstance(""SHA"");
            md.update(signature.toByteArray());

            Log.e(""Hash key"", """"+Base64.encodeToString(md.digest(),Base64.NO_WRAP));
        }
    } catch (PackageManager.NameNotFoundException e) {
        Log.d(TAG, e.getMessage(), e);
    } catch (NoSuchAlgorithmException e) {
        Log.d(TAG, e.getMessage(), e);
    }
}
",3,0,ecada97f9a914c0b3b6cdc5e04b78ee04adf1923935a234f38020071c3d3813b
,"private void printKeyHash() {
    // Add code to print out the key hash
    try {
        PackageInfo info = getPackageManager().getPackageInfo(""YOUR PACKAGE NAME"", PackageManager.GET_SIGNATURES);
        for (Signature signature : info.signatures) {
            MessageDigest md = MessageDigest.getInstance(""SHA"");
            md.update(signature.toByteArray());
            Log.d(""KeyHash:"", Base64.encodeToString(md.digest(), Base64.DEFAULT));
        }
    } catch (NameNotFoundException e) {
        Log.e(""KeyHash:"", e.toString());
    } catch (NoSuchAlgorithmException e) {
        Log.e(""KeyHash:"", e.toString());
    }
}
",3,0,ba0c62c7083713ec9beeca72bb044449d0698527ce798baf86b5d55700a5792c
,"private InputStream getDecodedInputStream (InputStream eis) {
   Cipher cipher = Cipher.getInstance(""your cipher definition"");
   cipher.init(Cipher.DECRYPT_MODE, ""your keySpec"", new IvParameterSpec(""your IV parameter spec""));
   InputStream decryptedInputStream = new CipherInputStream(is, cipher);
   return decryptedInputStream;
}
",,1,d763d8eeb5171abb73b95c225adccc59fe7cd0d52ae034d333456995cd1b1906
,"public final class PubKeyManager implements X509TrustManager
{
  private static String PUB_KEY = ""30820122300d06092a864886f70d0101..."";

  public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException
  {
    if (chain == null) {
      throw new IllegalArgumentException(""checkServerTrusted: X509Certificate array is null"");
    }

    if (!(chain.length &gt; 0)) {
      throw new IllegalArgumentException(""checkServerTrusted: X509Certificate is empty"");
    }

    if (!(null != authType &amp;&amp; authType.equalsIgnoreCase(""RSA""))) {
      throw new CertificateException(""checkServerTrusted: AuthType is not RSA"");
    }

    // Perform customary SSL/TLS checks
    try {
      TrustManagerFactory tmf = TrustManagerFactory.getInstance(""X509"");
      tmf.init((KeyStore) null);

      for (TrustManager trustManager : tmf.getTrustManagers()) {
        ((X509TrustManager) trustManager).checkServerTrusted(chain, authType);
      }
    } catch (Exception e) {
      throw new CertificateException(e);
    }

    // Hack ahead: BigInteger and toString(). We know a DER encoded Public Key begins
    // with 0x30 (ASN.1 SEQUENCE and CONSTRUCTED), so there is no leading 0x00 to drop.
    RSAPublicKey pubkey = (RSAPublicKey) chain[0].getPublicKey();
    String encoded = new BigInteger(1 /* positive */, pubkey.getEncoded()).toString(16);

    // Pin it!
    final boolean expected = PUB_KEY.equalsIgnoreCase(encoded);
    if (!expected) {
      throw new CertificateException(""checkServerTrusted: Expected public key: ""
                + PUB_KEY + "", got public key:"" + encoded);
      }
    }
  }
}
",2,0,6eaf37b7ebfcc97604509edf9039a25e6b4fea039925a19665bcf5465263dde1
,"SecureRandom rand = SecureRandom.getInstance(""SHA1PRNG"");
Log.i(TAG, ""rand.getProvider(): "" + rand.getProvider().getName());
",2,0,265034a8b7b6134d0cebe7912402209024cbb0bd1926e4edc17e0039bbf1abc0
,"SecretKey key = SecretKeyFactory.getInstance(
              ""PBEWithMD5AndDES"").generateSecret(keySpec);
",4,0,c1c594ec3baad5a2142cdf62f09ac3033e8d4b705e7e76605ec09b143dabd6cc
,"SecretKey key = SecretKeyFactory.getInstance(
              ""PBEWithMD5AndDES"",""BC"").generateSecret(keySpec);
",4,0,1d51c77241d93b536868450759396397015dca29637eacf6935ec09ac75efb43
,"try {
   PackageInfo info = getPackageManager().getPackageInfo(""[your package name, e.g. com.yourcompany.yourapp]"", PackageManager.GET_SIGNATURES);
   for (Signature signature : info.signatures) {
        MessageDigest md = MessageDigest.getInstance(""SHA"");
        md.update(signature.toByteArray());
        Log.d(""Hash Key:"", Base64.encode(md.digest()));
   }
} catch (NameNotFoundException e) {

} catch (NoSuchAlgorithmException e) {

}
",3,0,7526c785d2e0c40ec5e96cfb635502e7e522e5abd42c651e4727fb84812bc8ab
,"String password = ""_sOme*ShaREd*SecreT"";
byte[] salta = new byte[]{-84, -119, 25, 56, -100, 100, -120, -45, 84, 67, 96, 10, 24, 111, 112, -119, 3};
SecretKeyFactory factory = null;
try {
    factory = SecretKeyFactory.getInstance(""PBKDF2WithHmacSHA1"");
} catch (NoSuchAlgorithmException e2) {
    e2.printStackTrace();
}
KeySpec spec = new PBEKeySpec(password.toCharArray(), salta, 1024, 128);
SecretKey tmp = null;
try {
    tmp = factory.generateSecret(spec);
} catch (InvalidKeySpecException e2) {
    e2.printStackTrace();
}
SecretKeySpec secret = new SecretKeySpec(tmp.getEncoded(), ""AES"");
Log.i(""The secret Key: "" , Base64.encodeToString(secret.getEncoded(), 0 ));
",3,0,e537395c605f81f8e976280abce02cea6b0eb01c9dad74ee18bf274047a5c0d9
,"    /* User types in their password: */
    String password = ""password"";

    /* Store these things on disk used to derive key later: */
    int iterationCount = 1000;
    int saltLength = 32; // bytes; should be the same size as the output (256 / 8 = 32)
    int keyLength = 256; // 256-bits for AES-256, 128-bits for AES-128, etc
    byte[] salt; // Should be of saltLength

    /* When first creating the key, obtain a salt with this: */
    SecureRandom random = new SecureRandom();
    byte[] salt = new byte[saltLength];
    randomb.nextBytes(salt);

    /* Use this to derive the key from the password: */
    KeySpec keySpec = new PBEKeySpec(password.toCharArray(), salt,
                iterationCount, keyLength);
    SecretKeyFactory keyFactory = SecretKeyFactory
                .getInstance(""PBKDF2WithHmacSHA1"");
    byte[] keyBytes = keyFactory.generateSecret(keySpec).getEncoded();
    SecretKey key = new SecretKeySpec(keyBytes, ""AES"");
",3,0,53ac6735e4fa7900d3fdd65d559c7f75c37dd80f10782f293f708e24d1115af9
,"try {

        File file = new File(keystore location);
        is = new FileInputStream(file);
        KeyStore keystore = KeyStore.getInstance(KeyStore.getDefaultType());
        String password = ""password"";
        keystore.load(is, password.toCharArray());


        Enumeration enumeration = keystore.aliases();
        while(enumeration.hasMoreElements()) {
            String alias = (String)enumeration.nextElement();
            System.out.println(""alias name: "" + alias);
            Certificate certificate = keystore.getCertificate(alias);
            System.out.println(certificate.toString());

        }

    } catch (java.security.cert.CertificateException e) {
        e.printStackTrace();
    } catch (NoSuchAlgorithmException e) {
        e.printStackTrace();
    } catch (FileNotFoundException e) {
        e.printStackTrace();
    } catch (KeyStoreException e) {
        e.printStackTrace();
    } catch (IOException e) {
        e.printStackTrace();
    }finally {
        if(null != is)
            try {
                is.close();
            } catch (IOException e) {
                // TODO Auto-generated catch block
                e.printStackTrace();
            }
    }
",,1,046da3d30ef0dd084f508d7c7f3d467b8030ccef233f22bd10d5b67a65786434
,"Key key = keyStore.getKey(alias, password.toCharArray());
String encodedKey = new Base64Encoder().encode(key.getEncoded());
System.out.println(""key ? "" + encodedKey);
",,1,353dbcb1830ad5e0e3a63902e3366f2ee5940e415fb3079131356e5fecfce49b
,"public static byte[] encrypt2(byte[] value) throws GeneralSecurityException, IOException
{
    SecretKeySpec key1 = getSecretKeySpec(true);
    System.err.println(""encrypt():\t"" + key1.toString());
    Cipher cipher = Cipher.getInstance(""AES"");
    cipher.init(Cipher.ENCRYPT_MODE, key1, cipher.getParameters());
    byte[] encrypted = cipher.doFinal(value);

    SecretKeySpec key2 = getSecretKeySpec(false);
    System.err.println(""encrypt():\t"" + key2.toString());
    cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
    cipher.init(Cipher.ENCRYPT_MODE, key2, new IvParameterSpec(getIV()));
    byte[] encrypted2 = cipher.doFinal(encrypted);

    return encrypted2;//Base64Coder.encode(encrypted2);
}

public static byte[] decrypt2(byte[] message, boolean A) throws GeneralSecurityException, IOException
{
    SecretKeySpec key1 = getSecretKeySpec(false);
    System.err.println(""decrypt():\t"" + key1.toString());
    Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
    cipher.init(Cipher.DECRYPT_MODE, key1, new IvParameterSpec(getIV()));
    byte[] decrypted = cipher.doFinal(message);

    SecretKeySpec key2 = getSecretKeySpec(true);
    System.err.println(""decrypt():\t"" + key2.toString());
    cipher = Cipher.getInstance(""AES"");
    cipher.init(Cipher.DECRYPT_MODE, key2);
    byte[] decrypted2 = cipher.doFinal(decrypted);

    return decrypted2;
}
",1,0,402489b656ee5ec5f5ff970a2f2fa77215c4c9dbb605f818614ae00c1cb6a330
," // Add code to print out the key hash
    try {
        PackageInfo info = getPackageManager().getPackageInfo(
                ""yourpackagename"", 
                PackageManager.GET_SIGNATURES);
        for (Signature signature : info.signatures) {
            MessageDigest md = MessageDigest.getInstance(""SHA"");
            md.update(signature.toByteArray());
            Log.d(""KeyHash:"", Base64.encodeToString(md.digest(), Base64.DEFAULT));
            }
    } catch (NameNotFoundException e) {

    } catch (NoSuchAlgorithmException e) {

    }
",3,0,e046c9ae187879c5fb047f557966ab6e89de1968adec5384702f9df921b48e5e
,"private void getSHAFingerPrint(){
      PackageInfo info;
      try {

          info = getPackageManager().getPackageInfo(
                  ""your.package"", PackageManager.GET_SIGNATURES);

          for (Signature signature : info.signatures) {
              MessageDigest md;
              md = MessageDigest.getInstance(""SHA"");
              md.update(signature.toByteArray());
              String something = new String(Base64.encode(md.digest(), 0));
              Log.e(""Hash key"", something);
              System.out.println(""Hash key"" + something);
          }

      } catch (NameNotFoundException e1) {
          Log.e(""name not found"", e1.toString());
      } catch (NoSuchAlgorithmException e) {
          Log.e(""no such an algorithm"", e.toString());
      } catch (Exception e) {
          Log.e(""exception"", e.toString());
      }
  }
",3,0,0f2c0cd36b72915ac57ef04afcabeeb2ae27aa9be0d9d047533a28b1210237f1
,"    public class Sample {

    static {
        Security.insertProviderAt(new org.spongycastle.jce.provider.BouncyCastleProvider(), 1);
    }

    public void printProviders() {
        for (Provider provider : Security.getProviders()) {
            System.out.println(""Provider: "" + provider.getName());
            for (Provider.Service service : provider.getServices()) {
                System.out.println(""  Algorithm: "" + service.getAlgorithm());
            }
        }
    }
}
",,1,390f534ec2a79c5d6d789215a68c9428c11031d7b968398634d1d298e35248c4
,"TrustManagerFactory tmf;
    try {
        tmf = TrustManagerFactory.getInstance(TrustManagerFactory
                .getDefaultAlgorithm());

        tmf.init((KeyStore) null);

        X509TrustManager xtm = (X509TrustManager) tmf.getTrustManagers()[0];
        for (X509Certificate cert : xtm.getAcceptedIssuers()) {
            String certStr = ""S:"" + cert.getSubjectDN().getName() + ""\nI:""
                    + cert.getIssuerDN().getName();
            Log.d(LOG_TAG, certStr);
        }
    } catch (NoSuchAlgorithmException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    } catch (KeyStoreException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    }
",,1,78f8694c70ba68ce6e06a37edfef473d8420721a7aaca7522c8df7014df9c274
,"try 
    {
        KeyStore ks = KeyStore.getInstance(""AndroidCAStore"");
        if (ks != null) 
        {
            ks.load(null, null);
            Enumeration aliases = ks.aliases();
            while (aliases.hasMoreElements()) 
            {
                String alias = (String) aliases.nextElement();
                java.security.cert.X509Certificate cert = (java.security.cert.X509Certificate) ks.getCertificate(alias);

                Log.d(LOG_TAG, cert.getIssuerDN().getName());
            }
        }
    } catch (IOException e) {
        e.printStackTrace();
    } catch (KeyStoreException e) {
        e.printStackTrace();
    } catch (NoSuchAlgorithmException e) {
        e.printStackTrace();
    } catch (java.security.cert.CertificateException e) {
        e.printStackTrace();
    }
",,1,da7b5e8952a9fdb99e65c78f24625a61ce610c9837ffeef834d48c402a3b124c
,"FileInputStream fis = new FileInputStream(new File(""D:/Shashank/Test123.txt""));
        File outfile = new File(""D:/Shashank/encTest1234.txt"");
        int read;
        if(!outfile.exists())
            outfile.createNewFile();
        File decfile = new File(""D:/Shashank/dec123.txt"");
        if(!decfile.exists())
            decfile.createNewFile();
        FileOutputStream fos = new FileOutputStream(outfile);
        FileInputStream encfis = new FileInputStream(outfile);
        FileOutputStream decfos = new FileOutputStream(decfile);
        Cipher encipher = Cipher.getInstance(""AES"");
        Cipher decipher = Cipher.getInstance(""AES"");
        KeyGenerator kgen = KeyGenerator.getInstance(""AES"");
        SecretKey skey = kgen.generateKey();
        encipher.init(Cipher.ENCRYPT_MODE, skey);
        CipherInputStream cis = new CipherInputStream(fis, encipher);
        decipher.init(Cipher.DECRYPT_MODE, skey);
        CipherOutputStream cos = new CipherOutputStream(decfos,decipher);
        while((read = cis.read())!=-1)
                {
                    fos.write((char)read);
                    fos.flush();
                }   
        fos.close();
        while((read=encfis.read())!=-1)
        {
            cos.write(read);
            cos.flush();
        }
    cos.close();
",,1,3fb734b1b321d90cebee242070fa66aa7de503f6bb6ddf469d5cb7df2a86b51a
,"    try {
        PackageInfo info = getPackageManager().getPackageInfo(
            ""your package name, e.g. com.yourcompany.yourapp]"", 
            PackageManager.GET_SIGNATURES);
        for (Signature signature : info.signatures) {
            MessageDigest md = MessageDigest.getInstance(""SHA"");
            md.update(signature.toByteArray());
            Log.d(""KeyHash:"", Base64.encodeToString(md.digest(), Base64.DEFAULT));
            }
    } catch (NameNotFoundException e) {

    } catch (NoSuchAlgorithmException e) {

    }
",3,0,9f8ba6c1237844ced5fb9ba7b253f10d623952137163cdc03f5af3480c451a18
,"private enum BuildSigner {
    unknown,
    Joe,
    Carl,
    Linda
}

private BuildSigner whoBuiltThis() {
    try {
        PackageManager packageManager = getPackageManager();
        PackageInfo info = packageManager.getPackageInfo(getPackageName(),
                PackageManager.GET_SIGNATURES);
        Signature[] signs = info.signatures;
        CertificateFactory cf = CertificateFactory.getInstance(""X.509"");
        X509Certificate cert = (X509Certificate)cf.generateCertificate(
                new ByteArrayInputStream(signs[0].toByteArray()));
        PublicKey key = cert.getPublicKey();
        int modulusHash = ((RSAPublicKey)key).getModulus().hashCode();
        switch (modulusHash) {
            case 123456789:
                return BuildSigner.Joe;
            case 424242424:
                return BuildSigner.Carl;
            case -975318462:
                return BuildSigner.Linda;
        }
    } catch (Exception e) {
    }

    return BuildSigner.unknown;
}
",,1,c1c05fa865b7daae40b168e10ee12158b749279a1e66a72c09d9bd825b8f06aa
,"@Override
public void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.main);
    int hash = 0;
    try{
        PackageManager packageManager = getPackageManager();
        PackageInfo info = packageManager.getPackageInfo(
                ""com.stackexchange.marvin"", PackageManager.GET_SIGNATURES);
        Signature[] signs = info.signatures;
        CertificateFactory cf = CertificateFactory.getInstance(""X.509"");
        X509Certificate cert = (X509Certificate) cf.generateCertificate(
                new ByteArrayInputStream(signs[0].toByteArray()));
        PublicKey key = cert.getPublicKey();
        hash = ((RSAPublicKey) key).getModulus().hashCode();
    }catch(Exception e){}

    TextView tv = ((TextView)findViewById(R.id.tv));
    tv.setText(""The Stack Exchange app's signature hash is "" + hash + ""."");
    tv.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 24);
}
",,1,57501c6a0e2f6b37982cc5c22766023dc2c692dbc1d0a9abcea56d446f87c8d3
,"import org.apache.http.conn.ssl.SSLSocketFactory;

public class MyHttpClient extends DefaultHttpClient {
  final Context context;

  public MyHttpClient(Context context) {
    this.context = context;
  }

  @Override 
  protected ClientConnectionManager createClientConnectionManager() {
    SchemeRegistry registry = new SchemeRegistry();
    registry.register(new Scheme(""http"", PlainSocketFactory.getSocketFactory(), 80));
    registry.register(new Scheme(""https"", newSslSocketFactory(), 443));
    return new SingleClientConnManager(getParams(), registry);
  }

  private SSLSocketFactory newSslSocketFactory() {
    try {
      TrustManager tm = new MyCustomTrustManager();
      SSLContext ctx = SSLContext.getInstance(""TLS"");
      ctx.init(null, new TrustManager[] {tm}, null);
      SSLSocketFactory sf = new SSLSocketFactory(ctx);
      return new SSLSocketFactory(ctx);
    } catch (Exception e) {
      throw new Error(e);
    }
  }
}
",,1,4e125d4a8ad6e5a679bbc9c5fbdd153067bd66189d38ce249a58f0495c98e524
,"    import java.io.ByteArrayInputStream;
    import java.io.ByteArrayOutputStream;
    import java.io.File;
    import java.io.FileInputStream;
    import java.io.IOException;
    import java.nio.ByteBuffer;
    import java.nio.ByteOrder;
    import java.nio.charset.Charset;
    import java.nio.file.Files;
    import java.nio.file.Path;
    import java.nio.file.Paths;
    import javax.crypto.Cipher;
    import javax.crypto.spec.IvParameterSpec;
    import javax.crypto.spec.SecretKeySpec;

    public class HelloWorld {

        public static void main(String[] args) throws Exception {
            // TODO Auto-generated method stub
            Path p = Paths
                    .get(""C:\\Users\\casilva\\workspace\\StackOverflow\\src\\tst.enc"");

            byte[] a = Files.readAllBytes(p);
            byte[] result = decodeFile(""myKey123"", a);
            System.out.println(""Result="" + new String(result, ""UTF-8""));
        }


        public static byte[] decodeFile(String key, byte[] fileData)
                throws Exception {
            Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
            byte[] bKey = key.getBytes(""UTF-16LE"");

            SecretKeySpec keySpec = new SecretKeySpec(bKey, ""AES"");

            IvParameterSpec ivSpec = new IvParameterSpec(bKey);

            cipher.init(Cipher.DECRYPT_MODE, keySpec, ivSpec);

            byte[] decrypted = cipher.doFinal(fileData);

            return decrypted;
        }

    }
",2,0,86b7066ae509d4866548cdb81ea3b6912bdf7678e43752452fa7d187f4fa0b96
,"try{                
      String keyStoreType = KeyStore.getDefaultType();
      KeyStore keyStore = KeyStore.getInstance(keyStoreType);
      keyStore.load(Dummy.class.getResourceAsStream(""IPMessengerServerKeystore""), ""dhar9654"".toCharArray());                

      String keyalg=KeyManagerFactory.getDefaultAlgorithm();
      KeyManagerFactory kmf=KeyManagerFactory.getInstance(keyalg);
      kmf.init(keyStore, ""dhar9654"".toCharArray());

      SSLContext context = SSLContext.getInstance(""TLS"");
      context.init(MainActivity.kmf.getKeyManagers(), null, null);          
      SSLServerSocket ss=(SSLServerSocket)context.getServerSocketFactory().createServerSocket(Constants.CHAT_SERVER_PORT);

  }catch(Exception e){
     e.printStackTrace();
   }     
",3,0,7f6d42e2d35c157909696edeb090811c4f4c2db4597f8775b537fa37f591a02d
," private HttpClient getNewHttpClient() {

                try {               
                        KeyStore trustStore = KeyStore.getInstance(KeyStore.getDefaultType());
                        trustStore.load(null, null);

                        SSLSocketFactory sf = new MySSLSocketFactory(trustStore);
                        sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);

                        HttpParams params = new BasicHttpParams();
                        HttpProtocolParams.setVersion(params, HttpVersion.HTTP_1_1);
                        HttpProtocolParams.setContentCharset(params, HTTP.UTF_8);

                        SchemeRegistry registry = new SchemeRegistry();
                        registry.register(new Scheme(""http"", PlainSocketFactory.getSocketFactory(), 80));
                        registry.register(new Scheme(""https"", sf, 443));

                        ClientConnectionManager ccm = new ThreadSafeClientConnManager(params, registry);

                        return new DefaultHttpClient(ccm, params);
                    } catch (Exception e) {
                        return new DefaultHttpClient();
                    }
                }
",4,0,266727da14b2d4d13dedd09507ff3c79445d74ca1a4e8803fb79c3d6fe3e7898
," public class MySSLSocketFactory extends SSLSocketFactory {
            SSLContext sslContext = SSLContext.getInstance(""TLS"");

            public MySSLSocketFactory(KeyStore truststore) throws NoSuchAlgorithmException, KeyManagementException, KeyStoreException, UnrecoverableKeyException {
                super(truststore);

                TrustManager tm = new X509TrustManager() {
                    public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {
                    }

                    public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {
                    }

                    public X509Certificate[] getAcceptedIssuers() {
                        return null;
                    }
                };

                sslContext.init(null, new TrustManager[] { tm }, null);
            }

            @Override
            public Socket createSocket(Socket socket, String host, int port, boolean autoClose) throws IOException, UnknownHostException {
                return sslContext.getSocketFactory().createSocket(socket, host, port, autoClose);
            }

            @Override
            public Socket createSocket() throws IOException {
                return sslContext.getSocketFactory().createSocket();
            }
        }
",4,0,7a0452bfe783d7f6d6dcd4e36a116cbec073e1ef34ab41df47d481dce979523f
," private void getShaKey() {

 try {
 PackageInfo info = getPackageManager().getPackageInfo(""YOUR_PACKAGE_NAME"",
 PackageManager.GET_SIGNATURES);
 for (Signature signature : info.signatures) {
 MessageDigest md = MessageDigest.getInstance(""SHA"");
 md.update(signature.toByteArray());
 Log.v(TAG, ""KeyHash:"" + Base64.encodeToString(md.digest(),
 Base64.DEFAULT));
 }
 } catch (NameNotFoundException e) {
 e.printStackTrace();
 } catch (NoSuchAlgorithmException e) {
 e.printStackTrace();
 }

 }
",2,0,75dbe649d2d7a74987afc6bdcedde1e62304bc190be9e9f27101772937848c84
,"HostnameVerifier hostnameVerifier = org.apache.http.conn.ssl.SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER;

DefaultHttpClient client = new DefaultHttpClient();

SchemeRegistry registry = new SchemeRegistry();
SSLSocketFactory socketFactory = SSLSocketFactory.getSocketFactory();
socketFactory.setHostnameVerifier((X509HostnameVerifier) hostnameVerifier);
registry.register(new Scheme(""https"", socketFactory, 8443));
SingleClientConnManager mgr = new SingleClientConnManager(client.getParams(), registry);
DefaultHttpClient httpClient = new DefaultHttpClient(mgr, client.getParams());

// Set verifier      
HttpsURLConnection.setDefaultHostnameVerifier(hostnameVerifier);

// Example send http request
final String url = ""https://ts.xoomworks.com:8443/XoomworksTimesheets/ping/"";
HttpPost httpPost = new HttpPost(url);
HttpResponse response = httpClient.execute(httpPost);

response.getStatusLine().getStatusCode();

in = new BufferedReader(new InputStreamReader(response.getEntity().getContent()));
StringBuffer sb = new StringBuffer("""");
String l = """";
String nl = System.getProperty(""line.separator"");
while ((l = in.readLine()) !=null){
    sb.append(l + nl);
}
in.close();
data = sb.toString();
return data;
",4,0,464d9846fc33eceabac75787476aceade152c8974342dd2b71e98956e200c87b
,"    import java.security.SecureRandom;

    import javax.crypto.Cipher;
    import javax.crypto.KeyGenerator;
    import javax.crypto.SecretKey;
    import javax.crypto.spec.SecretKeySpec;

    import android.util.Base64;

    public class StringCryptor 
    {
        private static final String CIPHER_ALGORITHM = ""AES"";
        private static final String RANDOM_GENERATOR_ALGORITHM = ""SHA1PRNG"";
        private static final int RANDOM_KEY_SIZE = 128;

        // Encrypts string and encode in Base64
        public static String encrypt( String password, String data ) throws Exception 
        {
            byte[] secretKey = generateKey( password.getBytes() );
            byte[] clear = data.getBytes();

            SecretKeySpec secretKeySpec = new SecretKeySpec( secretKey, CIPHER_ALGORITHM );
            Cipher cipher = Cipher.getInstance( CIPHER_ALGORITHM );
            cipher.init( Cipher.ENCRYPT_MODE, secretKeySpec );

            byte[] encrypted = cipher.doFinal( clear );
            String encryptedString = Base64.encodeToString( encrypted, Base64.DEFAULT );

            return encryptedString;
        }

        // Decrypts string encoded in Base64
        public static String decrypt( String password, String encryptedData ) throws Exception 
        {
            byte[] secretKey = generateKey( password.getBytes() );

            SecretKeySpec secretKeySpec = new SecretKeySpec( secretKey, CIPHER_ALGORITHM );
            Cipher cipher = Cipher.getInstance( CIPHER_ALGORITHM );
            cipher.init( Cipher.DECRYPT_MODE, secretKeySpec );

            byte[] encrypted = Base64.decode( encryptedData, Base64.DEFAULT );
            byte[] decrypted = cipher.doFinal( encrypted );

            return new String( decrypted );
        }

        public static byte[] generateKey( byte[] seed ) throws Exception
        {
            KeyGenerator keyGenerator = KeyGenerator.getInstance( CIPHER_ALGORITHM );
            SecureRandom secureRandom = SecureRandom.getInstance( RANDOM_GENERATOR_ALGORITHM );
            secureRandom.setSeed( seed );
            keyGenerator.init( RANDOM_KEY_SIZE, secureRandom );
            SecretKey secretKey = keyGenerator.generateKey();
            return secretKey.getEncoded();
        }
    }
",3,0,9cc64d2a75d1163bd8d9311b0549b45ea275375bfd5231919df0bf2d141c7870
,"FileInputStream fis = new FileInputStream(new File(""D:/Shashank/inputVideo.avi""));
        File outfile = new File(""D:/Shashank/encVideo.avi"");
        int read;
        if(!outfile.exists())
            outfile.createNewFile();
        File decfile = new File(""D:/Shashank/decVideo.avi"");
        if(!decfile.exists())
            decfile.createNewFile();
        FileOutputStream fos = new FileOutputStream(outfile);
        FileInputStream encfis = new FileInputStream(outfile);
        FileOutputStream decfos = new FileOutputStream(decfile);
        Cipher encipher = Cipher.getInstance(""AES"");
        Cipher decipher = Cipher.getInstance(""AES"");
        KeyGenerator kgen = KeyGenerator.getInstance(""AES"");
        //byte key[] = {0x00,0x32,0x22,0x11,0x00,0x00,0x00,0x00,0x00,0x23,0x00,0x00,0x00,0x00,0x00,0x00,0x00};
        SecretKey skey = kgen.generateKey();
        //Lgo
        encipher.init(Cipher.ENCRYPT_MODE, skey);
        CipherInputStream cis = new CipherInputStream(fis, encipher);
        decipher.init(Cipher.DECRYPT_MODE, skey);
        CipherOutputStream cos = new CipherOutputStream(decfos,decipher);
        while((read = cis.read())!=-1)
                {
                    fos.write((char)read);
                    fos.flush();
                }   
        fos.close();
        while((read=encfis.read())!=-1)
        {
            cos.write(read);
            cos.flush();
        }
    cos.close(); 
",4,0,a84dd6d8cf23fd97e630d908c842e6b3f211020985da423299e4e736d32eec7c
,"try{
        PackageInfo info = getPackageManager().getPackageInfo(
                ""com.example.creeper"", PackageManager.GET_SIGNATURES);
        for (Signature signature : info.signatures) {
            MessageDigest md = MessageDigest.getInstance(""SHA"");
            md.update(signature.toByteArray());
            Log.d(""KeyHash:"",Base64.encodeToString(md.digest(), Base64.DEFAULT));       

        }
    } catch (NameNotFoundException e) {

    } catch (NoSuchAlgorithmException e) {

}
",3,0,2bf806c778846184b1c0ceb8db003f9d1770c38813b544f52ce40e242d5a0d1b
,"String algorithm = key.getAlgorithm();
Cipher cipher = Cipher.getInstance(algorithm);
",,1,6bd2150f48364a74462fa5a85780ee6ddf1a107e8920ce3995cc30bb40743900
,"try {
PackageInfo info = getPackageManager().getPackageInfo(""com.eatapp"", PackageManager.GET_SIGNATURES);
for (Signature signature : info.signatures) {
    MessageDigest md = MessageDigest.getInstance(""SHA"");
    md.update(signature.toByteArray());
    Log.e(""MY KEY HASH:"", Base64.encodeToString(md.digest(), Base64.DEFAULT));
}
} catch (NameNotFoundException e) {

} catch (NoSuchAlgorithmException e) {

}
",3,0,39993820a340925455206bd93beda68d61f61387794e071814d9956021e7a822
,"import java.io.UnsupportedEncodingException;
import java.security.Security;
import java.security.spec.KeySpec;
import java.util.Random;

import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.PBEKeySpec;
import javax.crypto.spec.SecretKeySpec;

import org.bouncycastle.jce.provider.BouncyCastleProvider;

public class SSL {

    private final static String HEX = ""0123456789ABCDEF"";
    private final static String ENC = ""US-ASCII"";
    private final static int ITERATION = 1337;

    private static final String RANDOM_ALGORITHM = ""PBEWithSHA256And256BitAES-CBC-BC"";
    private static final String CIPHER_ALGORITHM = ""AES/CBC/PKCS5Padding"";
    private static final String SECRET_KEY_ALGORITHM = ""AES"";

    private static IvParameterSpec ips;

    public static void init(byte[] iv) {
        if(iv == null) {
            iv = new byte[16];

            Random random = new Random();
            random.nextBytes(iv);
        }

        ips = new IvParameterSpec(iv);

        Security.addProvider(new BouncyCastleProvider());
    }

    public static byte[] getCertificate() {
        return ips.getIV();
    }

    public static String encrypt(Session current, String cleartext) throws Exception {
        byte[] rawKey = getRawKey(current.getCurrentSession().toCharArray());
        byte[] result = encrypt(rawKey, cleartext.getBytes(ENC));
        return toHex(result);
    }

    public static String decrypt(Session current, String encrypted) throws Exception {
        byte[] rawKey = getRawKey(current.getCurrentSession().toCharArray());
        byte[] enc = toByte(encrypted);     
        byte[] result = decrypt(rawKey, enc);
        return new String(result, ENC);
    }

    private static byte[] getRawKey(char[] seed) throws Exception {
        KeySpec keySpec = new PBEKeySpec(seed, ips.getIV(), ITERATION);

        SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(RANDOM_ALGORITHM);
        byte[] keyBytes = keyFactory.generateSecret(keySpec).getEncoded();
        SecretKey secretKey = new SecretKeySpec(keyBytes, ""AES"");

        return secretKey.getEncoded();
    }


    private static byte[] encrypt(byte[] raw, byte[] clear) throws Exception {
        SecretKeySpec skeySpec = new SecretKeySpec(raw, SECRET_KEY_ALGORITHM);
        Cipher cipher = Cipher.getInstance(CIPHER_ALGORITHM);
        cipher.init(Cipher.ENCRYPT_MODE, skeySpec, ips);
        byte[] encrypted = cipher.doFinal(clear);
        return encrypted;
    }

    private static byte[] decrypt(byte[] raw, byte[] encrypted) throws Exception {
        SecretKeySpec skeySpec = new SecretKeySpec(raw, SECRET_KEY_ALGORITHM);
        Cipher cipher = Cipher.getInstance(CIPHER_ALGORITHM);
        cipher.init(Cipher.DECRYPT_MODE, skeySpec, ips);
        byte[] decrypted = cipher.doFinal(encrypted);
        return decrypted;
    }

    public static String toHex(String txt) throws UnsupportedEncodingException {
        return toHex(txt.getBytes(ENC));
    }
    public static String fromHex(String hex) throws UnsupportedEncodingException {
        return new String(toByte(hex), ENC);
    }

    public static byte[] toByte(String hexString) {
        int len = hexString.length()/2;
        byte[] result = new byte[len];
        for (int i = 0; i &lt; len; i++)
            result[i] = Integer.valueOf(hexString.substring(2*i, 2*i+2), 16).byteValue();
        return result;
    }

    public static String toHex(byte[] buf) {
        if (buf == null)
            return """";
        StringBuffer result = new StringBuffer(2*buf.length);
        for (int i = 0; i &lt; buf.length; i++) {
            appendHex(result, buf[i]);
        }
        return result.toString();
    }

    private static void appendHex(StringBuffer sb, byte b) {
        sb.append(HEX.charAt((b&gt;&gt;4)&amp;0x0f)).append(HEX.charAt(b&amp;0x0f));
    }
}
",4,0,6782ebd4e020e8f5eeb896c572af733f49684ab75d4d21f1e5c79d99eff2ba5c
,"         // Add code to print out the key hash
try {
    PackageInfo info = getPackageManager().getPackageInfo(
            ""com.facebook.samples.hellofacebook"", 
            PackageManager.GET_SIGNATURES);
    for (Signature signature : info.signatures) {
        MessageDigest md = MessageDigest.getInstance(""SHA"");
        md.update(signature.toByteArray());
        Log.d(""KeyHash:"", Base64.encodeToString(md.digest(), Base64.DEFAULT));
        }
} catch (NameNotFoundException e) {

} catch (NoSuchAlgorithmException e) {

}
",3,0,97a0c0ef06e30a186616f13556c5e3461a25349f8ac82a78cb65652c7bf77d0f
,"public URLConnection getTolerantClient(URL url) throws IOException {
    URLConnection conn = url.openConnection();
    if (!(conn instanceof HttpsURLConnection)) {
        /* not an https:// URL, nothing to do */
        return conn;
    }
    HttpsURLConnection httpsconn = (HttpsURLConnection)conn;
    final HostnameVerifier delegate = httpsconn.getHostnameVerifier();
    if(!(delegate instanceof MyVerifier)) {
        httpsconn.setHostnameVerifier(new MyVerifier(delegate));
    }
    return conn;
}
",,1,3f5bbe3a10a5290a18f144a375df5b9e6cedec1cab837595056ce99e165bc22f
,"public class AES {

    public static SecretKey generateAESKey(int bits) throws NoSuchAlgorithmException{
        //This method is provided as to securely generate a AES key of the given length.

        //In practice you can specify your own SecureRandom instance.
        KeyGenerator kgen = KeyGenerator.getInstance(""AES"");
        kgen.init(bits);
        return kgen.generateKey();
    }

    public static byte[] encrypt(SecretKey key, byte[] plaintext) throws Exception{
        //In practice you should specify your SecureRandom implementation.
        SecureRandom rnd = new SecureRandom();

        //Generate random IV of 128-bit (AES block size)
        byte[] IV = new byte[128 / 8]; 
        rnd.nextBytes(IV);
        IvParameterSpec IVSpec = new IvParameterSpec(IV);

        //Create the cipher object to perform AES operations.
        //Specify Advanced Encryption Standard - Cipher Feedback Mode - No Padding
        Cipher AESCipher = Cipher.getInstance(""AES/CFB/NoPadding"");

        //Initialize the Cipher with the key and initialization vector.
        AESCipher.init(Cipher.ENCRYPT_MODE, key, IVSpec);

        //Encrypts the plaintext data
        byte[] ciphertext = AESCipher.doFinal(plaintext);

       /*
        * The IV must now be transferred with the ciphertext somehow. The easiest 
        * way to accomplish this would be to prepend the IV to the ciphertext 
        * message.
        */

        //Allocate new array to hold ciphertext + IV
        byte[] output = new byte[ciphertext.length + (128 / 8)];

        //Copy the respective parts into the array.
        System.arraycopy(IV, 0, output, 0, IV.length);
        System.arraycopy(ciphertext, 0, output, IV.length, ciphertext.length);

        return output;
    }

    public static byte[] decrypt(SecretKey key, byte[] IV, byte[] ciphertext) throws Exception{
        //Create the cipher object to perform AES operations.
        //Specify Advanced Encryption Standard - Cipher Feedback Mode - No Padding
        Cipher AESCipher = Cipher.getInstance(""AES/CFB/NoPadding"");

        //Create the IvParameterSpec object from the raw IV
        IvParameterSpec IVSpec = new IvParameterSpec(IV);

        //Initialize the Cipher with the key and initialization vector.
        AESCipher.init(Cipher.DECRYPT_MODE, key, IVSpec);

        //Decrypts the ciphertext data
        byte[] plaintext = AESCipher.doFinal(ciphertext);

        return plaintext;
    }

    public static void main(String[] args) throws Exception{
        //Demo the program

        String sPlaintext = ""rainbows""; //String plaintext
        byte[] rPlaintext = sPlaintext.getBytes(Charset.forName(""UTF-8"")); //Raw byte array plaintext

        //We first need to generate a key of 128-bit
        SecretKey key = generateAESKey(128);

        //Encrypt the plaintext
        byte[] output = encrypt(key, rPlaintext);

        // ----------------- //

        //Extract the IV from the encryption output
        byte[] IV = new byte[128 / 8];
        byte[] ciphertext = new byte[output.length - (128 / 8)];

        System.arraycopy(output, 0, IV, 0, IV.length);
        System.arraycopy(output, IV.length, ciphertext, 0, ciphertext.length);

        //Decrypt the ciphertext
        byte[] dPlaintext = decrypt(key, IV, ciphertext);

        String decryptedMessage = new String(dPlaintext, Charset.forName(""UTF-8""));

        //Print stuff out
        System.out.println(""Original message: "" + sPlaintext);
        System.out.println(""Original message bytes: "" + Arrays.toString(rPlaintext));
        System.out.println(""Encryption Output bytes: "" + Arrays.toString(output));
        System.out.println(""Decrypted message bytes: "" + Arrays.toString(dPlaintext));
        System.out.println(""Decrypted message: "" + decryptedMessage);
    }
}
",2,0,d9d75c00115ee08150c922eb9052ab9641c0b0dc4672381937d269ca2eadf14d
,"/*
 * Return the string from a authenticated SSL secured webserver call
 * */
public String sendHTTPSPostMessage(String userName, String userPass, String url, String[] postVars) throws NoSuchAlgorithmException, KeyManagementException, MalformedURLException, IOException {
    StringBuffer sb = new StringBuffer();

    final String serverAuth = userName + "":"" + userPass;
    final String serverAuthBase64 = MyBase64.encode(serverAuth.getBytes());

    SSLContext sc = SSLContext.getInstance(""TLS"");
    sc.init(null, new TrustManager[] { new MyTrustManager() }, new SecureRandom());
    HttpsURLConnection.setDefaultSSLSocketFactory(sc.getSocketFactory());
    HttpsURLConnection.setDefaultHostnameVerifier(new MyHostnameVerifier());
    HttpsURLConnection con = (HttpsURLConnection) new URL(url).openConnection();

    try {
        StringBuffer urlParameters = new StringBuffer();
        String[] tmpPair = null;

        for (int i = 0; i &lt; postVars.length; i++) {
            tmpPair = postVars[i].toString().split(""="");

            if (i &gt; 0)
                urlParameters.append(""&amp;"" + tmpPair[0] + ""="" + URLEncoder.encode(tmpPair[1], ""UTF-8""));
            else
                urlParameters.append(tmpPair[0] + ""="" + URLEncoder.encode(tmpPair[1], ""UTF-8""));
        }

        con.setRequestMethod(""POST"");
        con.setRequestProperty(""Authorization"", ""Basic "" + serverAuthBase64);
        con.setRequestProperty(""Content-Type"", ""application/x-www-form-urlencoded"");
        con.setRequestProperty(""Content-Length"", """" + Integer.toString(urlParameters.toString().getBytes().length));
        con.setUseCaches(false);
        con.setDoOutput(true);
        con.setDoInput(true);

        DataOutputStream wr = new DataOutputStream (con.getOutputStream());
        wr.writeBytes (urlParameters.toString());
        wr.flush();
        wr.close();

        BufferedReader br = new BufferedReader(new InputStreamReader(con.getInputStream()), 8192 );
        String line;
        while ( ( line = br.readLine() ) != null ) {
                sb.append(line);
        }
    }
    catch(Exception e) {
        Log.e(""sendHTTPSPostMessage"", e.getLocalizedMessage());
    }
    finally {
        if(con != null) {
            con.disconnect(); 
        }
    }
    return sb.toString();
}
",4,0,348db540ebf523697692e54ad175a425f19a86b5e58530c4f44d561cac4a3e80
,"public class ClientSSLSocketFactory extends SSLCertificateSocketFactory {
    private SSLContext sslContext;

    public static SSLSocketFactory getSocketFactory(){
        try
        {
            X509TrustManager tm = new X509TrustManager() {
                public void checkClientTrusted(X509Certificate[] xcs, String string) throws CertificateException {}

                public void checkServerTrusted(X509Certificate[] xcs, String string) throws CertificateException {}

                public X509Certificate[] getAcceptedIssuers() {
                    return null;
                }
            };
            sslContext = SSLContext.getInstance(""TLS"");
            sslContext.init(null, new TrustManager[] { tm }, null);

            SSLSocketFactory ssf = ClientSSLSocketFactory.getDefault(10000, new SSLSessionCache(Application.getInstance()));

            return ssf;
        } catch (Exception ex) {
            return null;
        }
    }

    @Override
    public Socket createSocket(Socket socket, String host, int port, boolean autoClose) throws IOException, UnknownHostException {
        return sslContext.getSocketFactory().createSocket(socket, host, port, autoClose);
    }

    @Override
    public Socket createSocket() throws IOException {
        return sslContext.getSocketFactory().createSocket();
    }
}
",4,0,6dc73ef2c1781bc495496bb12e62e18dfdd5cc96ec78cce19a87c9d0581213be
,"public void trustSelfSignedSSL() {
        try {
            SSLContext ctx = SSLContext.getInstance(""TLS"");
            X509TrustManager tm = new X509TrustManager() {

                public void checkClientTrusted(X509Certificate[] xcs,
                        String string) throws CertificateException {
                }

                public void checkServerTrusted(X509Certificate[] xcs,
                        String string) throws CertificateException {
                }

                public java.security.cert.X509Certificate[] getAcceptedIssuers() {
                    return null;
                }

                @Override
                public void checkClientTrusted(
                        java.security.cert.X509Certificate[] arg0, String arg1)
                        throws java.security.cert.CertificateException {
                }

                @Override
                public void checkServerTrusted(
                        java.security.cert.X509Certificate[] arg0, String arg1)
                        throws java.security.cert.CertificateException {

                }
            };
            ctx.init(null, new TrustManager[] { tm }, null);
            SSLContext.setDefault(ctx);
        } catch (Exception ex) {
            throw new RuntimeException(""Exception occurred "",ex)
        }
    }
",4,0,6bb0b5de6d3bfcc3c99b0431bcaf0fb393cba388e1d3d0a2972478db8c717d37
,"String keyStoreType = KeyStore.getDefaultType();
KeyStore keyStore = KeyStore.getInstance(keyStoreType);
",,1,027afeb1d27e9652b44bb0bd6391e532f6821eb3293eef2b1a053f8652b65c07
," static final String ENABLED_CIPHERS[] = {
    ""TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA"",
    ""TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA"",
    ""TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA"",
    ""TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA"",
    ""TLS_DHE_RSA_WITH_AES_128_CBC_SHA"",
    ""TLS_DHE_RSA_WITH_AES_256_CBC_SHA"",
    ""TLS_DHE_DSS_WITH_AES_128_CBC_SHA"",
    ""TLS_ECDHE_RSA_WITH_RC4_128_SHA"",
    ""TLS_ECDHE_ECDSA_WITH_RC4_128_SHA"",
    ""TLS_RSA_WITH_AES_256_CBC_SHA"",
    ""TLS_RSA_WITH_AES_128_CBC_SHA"",
    ""SSL_RSA_WITH_3DES_EDE_CBC_SHA"",
    ""SSL_RSA_WITH_RC4_128_SHA"",
    ""SSL_RSA_WITH_RC4_128_MD5"",
};
// put this in a place where it can be reused
static final String ENABLED_PROTOCOLS[] = {
        ""TLSv1.2"", ""TLSv1.1"", ""TLSv1""
    };

   private void sslCon()
    {
        try {
                             // setup truststore to provide trust for the server certificate
              // load truststore certificate
            InputStream trustStoresIs = getResources().openRawResource(R.raw.client_ca);
            String trustStoreType = KeyStore.getDefaultType();
            KeyStore trustStore = KeyStore.getInstance(trustStoreType);
            trustStore.load(trustStoresIs, ""spsoft_123"".toCharArray());
            //keyStore.setCertificateEntry(""ca"", ca);

            // initialize trust manager factory with the read truststore
            String tmfAlgorithm = TrustManagerFactory.getDefaultAlgorithm();
            TrustManagerFactory tmf = TrustManagerFactory.getInstance(tmfAlgorithm);
            tmf.init(trustStore);

            // setup client certificate
            // load client certificate
            InputStream keyStoreStream = getResources().openRawResource(R.raw.client_cert_key);
            KeyStore keyStore = null;
            keyStore = KeyStore.getInstance(""BKS"");
            keyStore.load(keyStoreStream, ""your password"".toCharArray());

            KeyManagerFactory keyManagerFactory = null;
            keyManagerFactory = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());
            keyManagerFactory.init(keyStore, ""your password"".toCharArray());

            // Create an SSLContext that uses our TrustManager
            SSLContext context = SSLContext.getInstance(""SSL"");
            context.init(keyManagerFactory.getKeyManagers(), tmf.getTrustManagers(), null);

            SSLSocketFactory sslsocketfactory = (SSLSocketFactory)context.getSocketFactory();
            InetAddress serverAddr = InetAddress.getByName(""192.168.11.104"");
            sslSocket = (SSLSocket) sslsocketfactory.createSocket(serverAddr, 5212);
            //String[] ciphers = sslSocket.getEnabledCipherSuites();
            sslSocket.setEnabledCipherSuites(ENABLED_CIPHERS);
            // put this right before setEnabledCipherSuites()!
            //sslSocket.setEnabledProtocols(ENABLED_PROTOCOLS);
            //InputStream inputStream =  sslSocket.getInputStream();
            OutputStream out = sslSocket.getOutputStream();

            Toast.makeText(getApplicationContext(), ""Connected"", Toast.LENGTH_SHORT).show();
            sslSocket.close();


        } catch (KeyManagementException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        } catch (CertificateException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        } catch (FileNotFoundException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        } catch (KeyStoreException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        } catch (NoSuchAlgorithmException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        } catch (IOException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        } catch (UnrecoverableKeyException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }

    }

}
",3,0,7c0c96bf784ce1deffeb2da7cd8b94e616aa44fecc2d877cd3d8d56265fa9081
,"MessageDigest md = MessageDigest.getInstance(""MD5"");
try (InputStream is = Files.newInputStream(Paths.get(""file.txt""))) {
  DigestInputStream dis = new DigestInputStream(is, md);
  /* Read stream to EOF as normal... */
}
byte[] digest = md.digest();
",,1,b19a549c6bf28af2df4f99006da5e4caee366ad558400d02cdc5f706b6623aef
,"   @Override
   protected void onCreate(Bundle savedInstanceState) {
          super.onCreate(savedInstanceState);
          setContentView(R.layout.activity_main);

          Button encryptButton = (Button) findViewById(R.id.button1);
          Button DecryptButton = (Button) findViewById(R.id.button2);
          encryptButton.setOnClickListener(new OnClickListener() {

                 @Override
                 public void onClick(View v) {
                       // TODO Auto-generated method stub
                       try {
                              encrypt();
                       } catch (InvalidKeyException e) {
                              // TODO Auto-generated catch block
                              e.printStackTrace();
                       } catch (NoSuchAlgorithmException e) {
                              // TODO Auto-generated catch block
                              e.printStackTrace();
                       } catch (NoSuchPaddingException e) {
                              // TODO Auto-generated catch block
                              e.printStackTrace();
                       } catch (IOException e) {
                              // TODO Auto-generated catch block
                              e.printStackTrace();
                       }
                 }
          });

          DecryptButton.setOnClickListener(new OnClickListener() {

                 @Override
                 public void onClick(View v) {
                       // TODO Auto-generated method stub
                       try {
                              decrypt();
                       } catch (InvalidKeyException e) {
                              // TODO Auto-generated catch block
                              e.printStackTrace();
                       } catch (NoSuchAlgorithmException e) {
                              // TODO Auto-generated catch block
                              e.printStackTrace();
                       } catch (NoSuchPaddingException e) {
                              // TODO Auto-generated catch block
                              e.printStackTrace();
                       } catch (IOException e) {
                              // TODO Auto-generated catch block
                              e.printStackTrace();
                       }
                 }
          });

   }

   /**
    * Here is Both function for encrypt and decrypt file in Sdcard folder. we
    * can not lock folder but we can encrypt file using AES in Android, it may
    * help you.
    *
    * @throws IOException
    * @throws NoSuchAlgorithmException
    * @throws NoSuchPaddingException
    * @throws InvalidKeyException
    */

   static void encrypt() throws IOException, NoSuchAlgorithmException,
                 NoSuchPaddingException, InvalidKeyException {
          // Here you read the cleartext.
          File extStore = Environment.getExternalStorageDirectory();
          FileInputStream fis = new FileInputStream(extStore + ""/sampleFile"");
          // This stream write the encrypted text. This stream will be wrapped by
          // another stream.
          FileOutputStream fos = new FileOutputStream(extStore + ""/encrypted"");

          // Length is 16 byte
          SecretKeySpec sks = new SecretKeySpec(""MyDifficultPassw"".getBytes(),
                       ""AES"");
          // Create cipher
          Cipher cipher = Cipher.getInstance(""AES"");
          cipher.init(Cipher.ENCRYPT_MODE, sks);
          // Wrap the output stream
          CipherOutputStream cos = new CipherOutputStream(fos, cipher);
          // Write bytes
          int b;
          byte[] d = new byte[8];
          while ((b = fis.read(d)) != -1) {
                 cos.write(d, 0, b);
          }
          // Flush and close streams.
          cos.flush();
          cos.close();
          fis.close();
   }

   static void decrypt() throws IOException, NoSuchAlgorithmException,
                 NoSuchPaddingException, InvalidKeyException {

          File extStore = Environment.getExternalStorageDirectory();
          FileInputStream fis = new FileInputStream(extStore + ""/encrypted"");

          FileOutputStream fos = new FileOutputStream(extStore + ""/decrypted"");
          SecretKeySpec sks = new SecretKeySpec(""MyDifficultPassw"".getBytes(),
                       ""AES"");
          Cipher cipher = Cipher.getInstance(""AES"");
          cipher.init(Cipher.DECRYPT_MODE, sks);
          CipherInputStream cis = new CipherInputStream(fis, cipher);
          int b;
          byte[] d = new byte[8];
          while ((b = cis.read(d)) != -1) {
                 fos.write(d, 0, b);
          }
          fos.flush();
          fos.close();
          cis.close();
   }
",4,0,501787962378f0cbbffe34733902d7f6f11781f7e7681f0a0edcf9f40d58c550
,"import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.security.KeyFactory;
import java.security.Signature;
import java.security.interfaces.RSAPublicKey;
import java.security.spec.X509EncodedKeySpec;

import org.spongycastle.util.io.pem.PemObject;
import org.spongycastle.util.io.pem.PemReader;

public class VerifySignature {
    public static void main(final String[] args) throws Exception {
        try (PemReader reader = publicKeyReader(); InputStream data = data(); InputStream signatureData = signature()) {
            final PemObject publicKeyPem = reader.readPemObject();
            final byte[] publicKeyBytes = publicKeyPem.getContent();
            final KeyFactory keyFactory = KeyFactory.getInstance(""RSA"");
            final X509EncodedKeySpec publicKeySpec = new X509EncodedKeySpec(publicKeyBytes);
            final RSAPublicKey publicKey = (RSAPublicKey) keyFactory.generatePublic(publicKeySpec);

            final Signature signature = Signature.getInstance(""SHA1withRSA"");
            signature.initVerify(publicKey);

            final byte[] buffy = new byte[16 * 1024];
            int read = -1;
            while ((read = data.read(buffy)) != -1) {
                signature.update(buffy, 0, read);
            }

            final byte[] signatureBytes = new byte[publicKey.getModulus().bitLength() / 8];
            signatureData.read(signatureBytes);

            System.out.println(signature.verify(signatureBytes));
        }
    }

    private static InputStream data() throws FileNotFoundException {
        return new FileInputStream(""someHTMLDoc.html"");
    }

    private static PemReader publicKeyReader() throws FileNotFoundException {
        return new PemReader(new InputStreamReader(new FileInputStream(""publicKey.pem"")));
    }

    private static InputStream signature() throws FileNotFoundException {
        return new FileInputStream(""signature.bin"");
    }
}
",3,0,c6053504d54308abe6819ab190040ae60f09649e53bce1b3a18bb81780b661d3
,"private void getAppKeyHash() {
    try {
        PackageInfo info = getPackageManager().getPackageInfo(getPackageName(), PackageManager.GET_SIGNATURES);
        for (Signature signature : info.signatures) {
            MessageDigest md;

            md = MessageDigest.getInstance(""SHA"");
            md.update(signature.toByteArray());
            String something = new String(Base64.encode(md.digest(), 0));
            Log.d(""Hash key"", something);
        } 
    }
    catch (NameNotFoundException e1) {
        // TODO Auto-generated catch block
        Log.e(""name not found"", e1.toString());
    }

    catch (NoSuchAlgorithmException e) {
        // TODO Auto-generated catch block
        Log.e(""no such an algorithm"", e.toString());
    }
    catch (Exception e){
        Log.e(""exception"", e.toString());
    }

}
",3,0,8b631fdb5bc75f2f4273cde5eaff1d4227bd0f970099b1a2c1674638f6ee3169
,"try {

   PackageInfo info = getPackageManager().getPackageInfo(getPackageName(), PackageManager.GET_SIGNATURES);

   for (Signature signature : info.signatures) 
   {
    MessageDigest md = MessageDigest.getInstance(""SHA"");
    md.update(signature.toByteArray());
    Log.d(""KeyHash:"", Base64.encodeToString(md.digest(), Base64.DEFAULT));
   }

  } catch (NameNotFoundException e) {
   Log.e(""name not found"", e.toString());
  } catch (NoSuchAlgorithmException e) {
   Log.e(""no such an algorithm"", e.toString());
  }
",3,0,17adeb46367a0c97246d2c1ff9db4b8ac91c433f67857e6e8f17da5310985eb2
,"public final class NetworkUtils {
public static final byte CONNECTION_OFFLINE = 1;
public static final byte CONNECTION_WIFI = 2;
public static final byte CONNECTION_ROAMING = 3;
public static final byte CONNECTION_SLOW = 4;
public static final byte CONNECTION_FAST = 5;

private static String sUserId;

private NetworkUtils() {}


/**
 * Check if the device is connected to the internet (mobile network or
 * WIFI).
 */
public static boolean isOnline(Context _context) {
    boolean online = false;

    TelephonyManager tmanager = (TelephonyManager) _context.getSystemService(Context.TELEPHONY_SERVICE);
    if (tmanager != null) {
        if (tmanager.getDataState() == TelephonyManager.DATA_CONNECTED) {
            // Mobile network
            online = true;
        } else {
            // WIFI
            ConnectivityManager cmanager = (ConnectivityManager) _context
                    .getSystemService(Context.CONNECTIVITY_SERVICE);
            if (cmanager != null) {
                NetworkInfo info = cmanager.getActiveNetworkInfo();
                if (info != null)
                    online = info.isConnected();
            }
        }
    }

    return online;
}

/**
 * Get the User Agent String in the format
 * AppName + AppVersion + Model + ReleaseVersion + Locale
 */
public static String getUserAgentString(Context _c, String _appName) {
    if(_appName == null)
        _appName = """";

    String agent = _appName + "" "" + BackendUtil.getAppVersionString(_c) + "" ("" + Build.MODEL + ""; Android ""
            + Build.VERSION.RELEASE + ""; "" + Locale.getDefault() + "")"";

    if(agent.startsWith("" ""))
        agent = agent.substring(1);

    return agent;
}

/**
 * Evaluate the current network connection and return the
 * corresponding type, e.g. CONNECTION_WIFI.
 */
public static byte getCurrentNetworkType(Context _context){
    NetworkInfo netInfo = ((ConnectivityManager) _context.getSystemService(Context.CONNECTIVITY_SERVICE)).getActiveNetworkInfo();

    if(netInfo == null)
        return CONNECTION_OFFLINE;

    if(netInfo.getType() == ConnectivityManager.TYPE_WIFI)
        return CONNECTION_WIFI;

    if(netInfo.isRoaming())
        return CONNECTION_ROAMING;

    if(!(netInfo.getType() == ConnectivityManager.TYPE_MOBILE 
            &amp;&amp;  (netInfo.getSubtype() == TelephonyManager.NETWORK_TYPE_UMTS 
              || netInfo.getSubtype() == TelephonyManager.NETWORK_TYPE_HSDPA
              || netInfo.getSubtype() == TelephonyManager.NETWORK_TYPE_HSUPA
              || netInfo.getSubtype() == TelephonyManager.NETWORK_TYPE_HSPA 
              || netInfo.getSubtype() == 13 // NETWORK_TYPE_LTE
              || netInfo.getSubtype() == 15))) // NETWORK_TYPE_HSPAP  
         {

        return CONNECTION_SLOW;
    }

    return CONNECTION_FAST;
}


/**
 * Return the current IP adresse of the device or null if it could not be
 * found.
 */
public static String getIpAdress() {
    String result = null;
    try {
        for (Enumeration&lt;NetworkInterface&gt; interfaces = NetworkInterface.getNetworkInterfaces(); interfaces.hasMoreElements();) {
            NetworkInterface iface = interfaces.nextElement();
            for (Enumeration&lt;InetAddress&gt; adresses = iface.getInetAddresses(); adresses.hasMoreElements();) {
                InetAddress ip = adresses.nextElement();
                if (!ip.isLoopbackAddress())
                    result = ip.getHostAddress();
            }
        }
    } catch (SocketException _e) {
        LL.error(""Could not find device's ip adress"");
    }
    return result;
}


/**
 * Return a MD5 hash of the device id.
 */
public static synchronized String getUserId(Context _context) {
    if (sUserId == null) {
        TelephonyManager tm = (TelephonyManager) _context.getSystemService(Context.TELEPHONY_SERVICE);
        String id = tm.getDeviceId();
        try {
            MessageDigest digester = MessageDigest.getInstance(""MD5"");
            digester.update(id.getBytes());
            byte[] digest = digester.digest();

            // Convert to hex string
            BigInteger converter = new BigInteger(1, digest);
            String md5 = converter.toString(16);
            while (md5.length() &lt; 32)
                md5 = ""0"" + md5;
            sUserId = md5;
        } catch (NoSuchAlgorithmException _e) {
            LL.error(""Could not find MD5"");
        }
    }
    return sUserId;
}
",,1,2cb5afdfa3bc4918e51ab8b1509745574d0b3fe6c692b2b684ae6d051a4f1dcc
,"private static void xmlParser() {
    try {
        String filepath = ""yourfile.xml"";
        DocumentBuilderFactory docFactory = DocumentBuilderFactory.newInstance();
        DocumentBuilder docBuilder = docFactory.newDocumentBuilder();
        Document doc = docBuilder.parse(filepath);
        // Get the root element
        Node min = doc.getElementsByTagName(""poem"").item(0);
        NamedNodeMap attr = min.getAttributes();
                    // get the value of the name=
        Node nodeAttr = attr.getNamedItem(""name"");
                    //if you want to change the value of the name use 
                    nodeAttr.setTextContent(""new name value"");
                    //if you want to get the value between &gt;value&lt; use 
                    nodeAttr.getTextContent()
        TransformerFactory transformerFactory = TransformerFactory.newInstance();
        Transformer transformer = transformerFactory.newTransformer();
        DOMSource source = new DOMSource(doc);
        StreamResult result = new StreamResult(new File(filepath));
        transformer.transform(source, result);
    } catch (ParserConfigurationException e) {
            e.printStackTrace();
    }
     catch (IOException ioe) {
            ioe.printStackTrace();
        } catch (SAXException sae) {
            sae.printStackTrace();
        } catch (TransformerConfigurationException e) {

            e.printStackTrace();
        } catch (TransformerException e) {

            e.printStackTrace();
        }
}
",,1,e0408af7a284cc162871aaaf144612882d4b30058535197ac567b58667e7d97c
,"package com.arisglobal.aglite.network;

import java.io.InputStream;
import java.security.KeyStore;

import org.apache.http.conn.ClientConnectionManager;
import org.apache.http.conn.scheme.PlainSocketFactory;
import org.apache.http.conn.scheme.Scheme;
import org.apache.http.conn.scheme.SchemeRegistry;
import org.apache.http.conn.ssl.SSLSocketFactory;
import org.apache.http.impl.client.DefaultHttpClient;
import org.apache.http.impl.conn.SingleClientConnManager;

import com.arisglobal.aglite.activity.R;

import android.content.Context;

public class MyHttpClient extends DefaultHttpClient {

    final Context context;

    public MyHttpClient(Context context) {
        this.context = context;
    }

    @Override
    protected ClientConnectionManager createClientConnectionManager() {
        SchemeRegistry registry = new SchemeRegistry();

        registry.register(new Scheme(""http"", PlainSocketFactory.getSocketFactory(), 80));

        // Register for port 443 our SSLSocketFactory with our keystore to the ConnectionManager
        registry.register(new Scheme(""https"", newSslSocketFactory(), 443));
        return new SingleClientConnManager(getParams(), registry);
    }

    private SSLSocketFactory newSslSocketFactory() {
        try {
            // Get an instance of the Bouncy Castle KeyStore format
            KeyStore trusted = KeyStore.getInstance(""BKS"");

            // Get the raw resource, which contains the keystore with your trusted certificates (root and any intermediate certs)
            InputStream in = context.getResources().openRawResource(R.raw.aglite);
            try {
                // Initialize the keystore with the provided trusted certificates.
                // Also provide the password of the keystore
                trusted.load(in, ""aglite"".toCharArray());
            } finally {
                in.close();
            }

            // Pass the keystore to the SSLSocketFactory. The factory is responsible for the verification of the server certificate.
            SSLSocketFactory sf = new SSLSocketFactory(trusted);

            // Hostname verification from certificate
            // http://hc.apache.org/httpcomponents-client-ga/tutorial/html/connmgmt.html#d4e506
            sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
            return sf;
        } catch (Exception e) {
            throw new AssertionError(e);
        }
    }
}
",4,0,8aae997734a5cfa30f87d36bb8fb328067efdd21b374cf7fe92c1390fca14b9b
,"/**
 * Disables the SSL certificate checking for new instances of {@link HttpsURLConnection} This has been created to
 * aid testing on a local box, not for use on production.
 */
private static void disableSSLCertificateChecking() {
    TrustManager[] trustAllCerts = new TrustManager[] { new X509TrustManager() {
        public X509Certificate[] getAcceptedIssuers() {
            return null;
        }

        @Override
        public void checkClientTrusted(X509Certificate[] arg0, String arg1) throws CertificateException {
            // Not implemented
        }

        @Override
        public void checkServerTrusted(X509Certificate[] arg0, String arg1) throws CertificateException {
            // Not implemented
        }
    } };

    try {
        SSLContext sc = SSLContext.getInstance(""TLS"");

        sc.init(null, trustAllCerts, new java.security.SecureRandom());

        HttpsURLConnection.setDefaultSSLSocketFactory(sc.getSocketFactory());
    } catch (KeyManagementException e) {
        e.printStackTrace();
    } catch (NoSuchAlgorithmException e) {
        e.printStackTrace();
    }
}
",4,0,cdf4d925fabcbe44e6e877063170b7931c21352315200cf903757a1053bc27d2
," /**
   * Generates SHA-1 digest of the provided data.
   * 
   * @param data the data to digest
   * @return SHA-1 digest of the provided data.
   */
  public static byte[] sha1Digest(byte[] data) {
    MessageDigest mdSha1 = null;
    try {
      mdSha1 = MessageDigest.getInstance(""SHA-1"");
    } catch (NoSuchAlgorithmException e1) {
      Log.e(LOG_TAG, ""Error initializing SHA1 message digest"");
    }
    mdSha1.update(data);
    byte[] sha1hash = mdSha1.digest();
    return sha1hash;
  }
",3,0,805f9f1fa72975597d68ca85cca2f3c413e73dec510e1cc8855b83aed5e3d9a5
,"try
    {
        PackageInfo info = getPackageManager().getPackageInfo(getApplication().getPackageName(), PackageManager.GET_SIGNATURES);
        for(Signature signature : info.signatures)
        {
            MessageDigest md = MessageDigest.getInstance(""SHA"");
            md.update(signature.toByteArray());
            String myHashCode = Base64.encodeBytes(md.digest());
            Log.e(""-------------FACEBOOK HASH KEY-----------"", myHashCode);
        }
    }
    catch(NameNotFoundException e)
    {
        e.printStackTrace();
    }
    catch(NoSuchAlgorithmException e)
    {
        e.printStackTrace();
    }
    catch(Exception e)
    {
        e.printStackTrace();
    }
    catch(Error e)
    {
        e.printStackTrace();
    }
",3,0,09bb8efc508b3429267ad481d47606426d80b9fabe7f64e9cce10a764f488caa
,"import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;

public class Sha1Hex {

    public String makeSHA1Hash(String input)
            throws NoSuchAlgorithmException, UnsupportedEncodingException
        {
            MessageDigest md = MessageDigest.getInstance(""SHA1"");
            md.reset();
            byte[] buffer = input.getBytes(""UTF-8"");
            md.update(buffer);
            byte[] digest = md.digest();

            String hexStr = """";
            for (int i = 0; i &lt; digest.length; i++) {
                hexStr +=  Integer.toString( ( digest[i] &amp; 0xff ) + 0x100, 16).substring( 1 );
            }
            return hexStr;
        }
}
",,1,20396823d9ecad5a2d744bd6f1d1a0a43b34e43348620b3aadddc655c5df7c11
,"    try {
        PackageInfo info = getPackageManager().getPackageInfo(""my.package.name"", PackageManager.GET_SIGNATURES);
        for (Signature signature : info.signatures) {
            MessageDigest md;
            md = MessageDigest.getInstance(""SHA"");
            md.update(signature.toByteArray());
            String something = new String(Base64.encode(md.digest(), 0));
            //String something = new String(Base64.encodeBytes(md.digest()));
            Log.e(""hash key"", something);
        }
    } catch (NameNotFoundException e1) {
        Log.e(""name not found"", e1.toString());
    } catch (NoSuchAlgorithmException e) {
        Log.e(""no such an algorithm"", e.toString());
    } catch (Exception e) {
        Log.e(""exception"", e.toString());
    }
",3,0,64bea2568ce5b1a53175bf019f9fe10fec0673f994665054a4b1243eac10671a
,"  public class SimpleSSLSocketFactory extends org.apache.http.conn.ssl.SSLSocketFactory {
    private SSLSocketFactory sslFactory = HttpsURLConnection.getDefaultSSLSocketFactory();

    public SimpleSSLSocketFactory(KeyStore truststore) throws NoSuchAlgorithmException, KeyManagementException, KeyStoreException,
            UnrecoverableKeyException {
        super(null);

        try {
            SSLContext context = SSLContext.getInstance(""TLS"");

            // Create a trust manager that does not validate certificate chains and simply
            // accept all type of certificates
            TrustManager[] trustAllCerts = new TrustManager[] { new X509TrustManager() {
                public java.security.cert.X509Certificate[] getAcceptedIssuers() {
                    return new java.security.cert.X509Certificate[] {};
                }

                public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {
                }

                public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {
                }
            } };

            // Initialize the socket factory
            context.init(null, trustAllCerts, new SecureRandom());
            sslFactory = context.getSocketFactory();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    @Override
    public Socket createSocket(Socket socket, String host, int port, boolean autoClose) throws IOException, UnknownHostException {
        return sslFactory.createSocket(socket, host, port, autoClose);
    }

    @Override
    public Socket createSocket() throws IOException {
        return sslFactory.createSocket();
    }
}
",4,0,df1379f701ed056f2cde1bdb952b3d332cb0cb635d601e17f5bad461a9e10960
," private HttpClient sslClient(HttpClient client) {
    try {
        X509TrustManager tm = new X509TrustManager() { 
            public void checkClientTrusted(X509Certificate[] xcs, String string) throws CertificateException {
            }

            public void checkServerTrusted(X509Certificate[] xcs, String string) throws CertificateException {
            }

            public X509Certificate[] getAcceptedIssuers() {
                return null;
            }
        };
        SSLContext ctx = SSLContext.getInstance(""TLS"");
        ctx.init(null, new TrustManager[]{tm}, null);
        SSLSocketFactory ssf = new MySSLSocketFactory(ctx);
        ssf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
        ClientConnectionManager ccm = client.getConnectionManager();
        SchemeRegistry sr = ccm.getSchemeRegistry();
        sr.register(new Scheme(""https"", ssf, 443));
        return new DefaultHttpClient(ccm, client.getParams());
    } catch (Exception ex) {
        return null;
    }
}
",4,0,6bdd4e49513e59fe66d9f43a97464fc154b96ec0c18955e7c349d4801d55cc59
," public class MySSLSocketFactory extends SSLSocketFactory {
     SSLContext sslContext = SSLContext.getInstance(""TLS"");

     public MySSLSocketFactory(KeyStore truststore) throws NoSuchAlgorithmException, KeyManagementException, KeyStoreException, UnrecoverableKeyException {
         super(truststore);

         TrustManager tm = new X509TrustManager() {
             public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {
             }

             public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {
             }

             public X509Certificate[] getAcceptedIssuers() {
                 return null;
             }
         };

         sslContext.init(null, new TrustManager[] { tm }, null);
     }

     public MySSLSocketFactory(SSLContext context) throws KeyManagementException, NoSuchAlgorithmException, KeyStoreException, UnrecoverableKeyException {
        super(null);
        sslContext = context;
     }

     @Override
     public Socket createSocket(Socket socket, String host, int port, boolean autoClose) throws IOException, UnknownHostException {
         return sslContext.getSocketFactory().createSocket(socket, host, port, autoClose);
     }

     @Override
     public Socket createSocket() throws IOException {
         return sslContext.getSocketFactory().createSocket();
     }
}
",4,0,8cdf0d0e0bd12920dd78572ceb5ec53db20141b3dcbfaec0a41e55f8120c7107
,"// Load CAs from an InputStream
// (could be from a resource or ByteArrayInputStream or ...)
CertificateFactory cf = CertificateFactory.getInstance(""X.509"");
// From https://www.washington.edu/itconnect/security/ca/load-der.crt
InputStream caInput = new BufferedInputStream(new FileInputStream(""load-der.crt""));
Certificate ca;
try {
    ca = cf.generateCertificate(caInput);
    System.out.println(""ca="" + ((X509Certificate) ca).getSubjectDN());
} finally {
    caInput.close();
}

// Create a KeyStore containing our trusted CAs
String keyStoreType = KeyStore.getDefaultType();
KeyStore keyStore = KeyStore.getInstance(keyStoreType);
keyStore.load(null, null);
keyStore.setCertificateEntry(""ca"", ca);

// Create a TrustManager that trusts the CAs in our KeyStore
String tmfAlgorithm = TrustManagerFactory.getDefaultAlgorithm();
TrustManagerFactory tmf = TrustManagerFactory.getInstance(tmfAlgorithm);
tmf.init(keyStore);

// Create an SSLContext that uses our TrustManager
SSLContext context = SSLContext.getInstance(""TLS"");
context.init(null, tmf.getTrustManagers(), null);

// Tell the URLConnection to use a SocketFactory from our SSLContext
URL url = new URL(""https://certs.cac.washington.edu/CAtest/"");
HttpsURLConnection urlConnection =
    (HttpsURLConnection)url.openConnection();
urlConnection.setSSLSocketFactory(context.getSocketFactory());
InputStream in = urlConnection.getInputStream();
copyInputStreamToOutputStream(in, System.out);
",3,0,ddb580b76a2b26b5616ee014f9058de888586241a132b9e18d75d4d39492acab
,"public class AESCryptt {
    private static final String TAG = ""AESCrypt"";
    private static final String AES_MODE = ""AES/ECB/ZeroBytePadding"";
    private static final String CHARSET = ""UTF-8"";//
    public static boolean DEBUG_LOG_ENABLED = false;


    private static SecretKeySpec generateKey(final String password) throws NoSuchAlgorithmException, UnsupportedEncodingException {
        byte[] key = new byte[]{your key in byte here (byte) a, (byte) f , ..... };
        SecretKeySpec secretKeySpec = new SecretKeySpec(key, ""AES"");
        return secretKeySpec;
    }


    /**
     * Encrypt and encode message using 256-bit AES with key generated from password.
     *
     *
     * @param password used to generated key
     * @param message the thing you want to encrypt assumed String UTF-8
     * @return Base64 encoded CipherText
     * @throws GeneralSecurityException if problems occur during encryption
     */
    public static String encrypt(final String password, String message)
            throws GeneralSecurityException {
        try {
            final SecretKeySpec key = generateKey(password);
            log(""message"", message);
            byte[] cipherText = encrypt(key, ivBytes, message.getBytes(CHARSET));
            //NO_WRAP is important as was getting \n at the end
            String encoded = String.valueOf(Base64.encodeToString(cipherText, Base64.NO_PADDING ));
            log(""Base64.NO_WRAP"", encoded);
            return encoded;
        } catch (UnsupportedEncodingException e) {
            if (DEBUG_LOG_ENABLED)
                Log.e(TAG, ""UnsupportedEncodingException "", e);
            throw new GeneralSecurityException(e);
        }
    }


    /**
     * More flexible AES encrypt that doesn't encode
     * @param key AES key typically 128, 192 or 256 bit
     * @param iv Initiation Vector
     * @param message in bytes (assumed it's already been decoded)
     * @return Encrypted cipher text (not encoded)
     * @throws GeneralSecurityException if something goes wrong during encryption
     */
    public static byte[] encrypt(final SecretKeySpec key, final byte[] iv, final byte[] message)
            throws GeneralSecurityException {
        final Cipher cipher = Cipher.getInstance(AES_MODE);
        IvParameterSpec ivSpec = new IvParameterSpec(iv);
        cipher.init(Cipher.ENCRYPT_MODE, key);//, ivSpec
        byte[] cipherText = cipher.doFinal(message);
        log(""cipherText"", cipherText);
        return cipherText;
    }


    /**
     * Decrypt and decode ciphertext using 256-bit AES with key generated from password
     *
     * @param password used to generated key
     * @param base64EncodedCipherText the encrpyted message encoded with base64
     * @return message in Plain text (String UTF-8)
     * @throws GeneralSecurityException if there's an issue decrypting
     */
    public static String decrypt(final String password, String base64EncodedCipherText)
            throws GeneralSecurityException {

        try {
            final SecretKeySpec key = generateKey(password);
            log(""base64EncodedCipherText"", base64EncodedCipherText);
            byte[] decodedCipherText = Base64.decode(base64EncodedCipherText, Base64.DEFAULT);
            log(""decodedCipherText"", decodedCipherText);
            byte[] decryptedBytes = decrypt(key, ivBytes, decodedCipherText);
            log(""decryptedBytes"", decryptedBytes);
            String message = new String(decryptedBytes, CHARSET);
            log(""message"", message);
            return message;
        } catch (UnsupportedEncodingException e) {
            if (DEBUG_LOG_ENABLED)
                Log.e(TAG, ""UnsupportedEncodingException "", e);
            throw new GeneralSecurityException(e);
        }
    }


    /**
     * More flexible AES decrypt that doesn't encode
     *
     * @param key AES key typically 128, 192 or 256 bit
     * @param iv Initiation Vector
     * @param decodedCipherText in bytes (assumed it's already been decoded)
     * @return Decrypted message cipher text (not encoded)
     * @throws GeneralSecurityException if something goes wrong during encryption
     */
    public static byte[] decrypt(final SecretKeySpec key, final byte[] iv, final byte[] decodedCipherText)
            throws GeneralSecurityException {
        final Cipher cipher = Cipher.getInstance(AES_MODE );
        IvParameterSpec ivSpec = new IvParameterSpec(iv);
        cipher.init(Cipher.DECRYPT_MODE, key);//, ivSpec
        byte[] decryptedBytes = cipher.doFinal(decodedCipherText);
        log(""decryptedBytes"", decryptedBytes);
        return decryptedBytes;
    }




    private static void log(String what, byte[] bytes) {
        if (DEBUG_LOG_ENABLED)
            Log.d(TAG, what + ""["" + bytes.length + ""] ["" + bytesToHex(bytes) + ""]"");
    }

    private static void log(String what, String value) {
        if (DEBUG_LOG_ENABLED)
            Log.d(TAG, what + ""["" + value.length() + ""] ["" + value + ""]"");
    }


    /**
     * Converts byte array to hexidecimal useful for logging and fault finding
     * @param bytes
     * @return
     */
    private static String bytesToHex(byte[] bytes) {
        final char[] hexArray = {'0', '1', '2', '3', '4', '5', '6', '7', '8',
                '9', 'A', 'B', 'C', 'D', 'E', 'F'};
        char[] hexChars = new char[bytes.length * 2];
        int v;
        for (int j = 0; j &lt; bytes.length; j++) {
            v = bytes[j] &amp; 0xFF;
            hexChars[j * 2] = hexArray[v &gt;&gt;&gt; 4];
            hexChars[j * 2 + 1] = hexArray[v &amp; 0x0F];
        }
        return new String(hexChars);
    }

    private AESCryptt() {
    }
}
",4,0,bc9fab15f1c0c645b56a21088f12e88255f776a7b5763beb85f9fe5366e664d9
,"public void onLocationChanged(Location location) {
  Timestamp time = new Timestamp(location.getTime());

  textTime.setText(time.toString());
}
",,1,57d89f22646cb35acb7241bfc5bd39e7aff3d20e5e55513fd983a73b916c6224
,"public static void encryptAndClose(FileInputStream fis, FileOutputStream fos) 
        throws IOException, NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException {

    // Length is 16 byte
    SecretKeySpec sks = new SecretKeySpec(""1234567890123456"".getBytes(), ""AES"");
    // Create cipher
    Cipher cipher = Cipher.getInstance(""AES"");
    cipher.init(Cipher.ENCRYPT_MODE, sks);      

    // Wrap the output stream for encoding
    CipherOutputStream cos = new CipherOutputStream(fos, cipher);       

    //wrap output with buffer stream
    BufferedOutputStream bos = new BufferedOutputStream(cos);     

    //wrap input with buffer stream
    BufferedInputStream bis = new BufferedInputStream(fis); 

    // Write bytes
    int b;
    byte[] d = new byte[8];
    while((b = bis.read(d)) != -1) {
        bos.write(d, 0, b);
    }
    // Flush and close streams.
    bos.flush();
    bos.close();
    bis.close();
}


public static void decryptAndClose(FileInputStream fis, FileOutputStream fos) 
        throws IOException, NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException {

    SecretKeySpec sks = new SecretKeySpec(""1234567890123456"".getBytes(), ""AES"");
    Cipher cipher = Cipher.getInstance(""AES"");
    cipher.init(Cipher.DECRYPT_MODE, sks);

    CipherInputStream cis = new CipherInputStream(fis, cipher);

    //wrap input with buffer stream
    BufferedInputStream bis = new BufferedInputStream(cis); 

    //wrap output with buffer stream
    BufferedOutputStream bos = new BufferedOutputStream(fos);       

    int b;
    byte[] d = new byte[8];
    while((b = bis.read(d)) != -1) {
        bos.write(d, 0, b);
    }
    bos.flush();
    bos.close();
    bis.close();
}
",4,0,232d30e5842f18ec2606add48d732319bedf36a753b9493545ec8c5d45115734
,"public class SampleEncryptor extends SecretKeyWrapper{
private static final SecureRandom RANDOM = new SecureRandom();

private SharedPreferences pref;
private SecretKey secretKey;
private byte[] encryptedKey;

public SampleEncryptor(Context context)
        throws GeneralSecurityException, IOException {
    super(context, ""myalias"");
    this.pref = context.getSharedPreferences(""mySecretKeyStore"", Context.MODE_PRIVATE);
    String base64key = pref.getString(""key"", null);
    if(base64key==null){
        this.secretKey = KeyGenerator.getInstance(""AES"").generateKey();
        this.encryptedKey = this.wrap(this.secretKey);
        pref.edit().putString(""key"", Base64.encodeToString(encryptedKey, Base64.DEFAULT)).commit();
    }else{
        this.encryptedKey = Base64.decode(base64key, Base64.DEFAULT);
        this.secretKey = this.unwrap(this.encryptedKey);
    }
}

public byte[] encrypt(byte[] data) throws GeneralSecurityException{     
    Cipher cipher = Cipher.getInstance(""AES"");
    cipher.init(Cipher.ENCRYPT_MODE, secretKey);
    return  cipher.doFinal(data);
}

public byte[] decrypt(byte[] data) throws GeneralSecurityException{
    Cipher cipher = Cipher.getInstance(""AES"");
    cipher.init(Cipher.DECRYPT_MODE, secretKey);
    return  cipher.doFinal(data);
}

public String encryptBoolean(boolean value) throws GeneralSecurityException{
    BigInteger i = new BigInteger(128, RANDOM);
    if(value){
        i = i.setBit(0);
    }else{
        i = i.clearBit(0);
    }
    byte[] encrypted =  encrypt(i.toByteArray());

    return Base64.encodeToString(encrypted, Base64.DEFAULT);
}

public Boolean decryptBoolean(String encrypted) throws GeneralSecurityException{
    byte[] data = Base64.decode(encrypted, Base64.DEFAULT);     
    BigInteger i = new BigInteger(decrypt(data));
    return i.testBit(0);
}
",4,0,8a9b79b4ca6941aa0993ad195f24cc7eba0715e5badd4635ffa923e584c78793
," private void getShaKey() {

 try {
 PackageInfo info = getPackageManager().getPackageInfo(""your_package_name"",
 PackageManager.GET_SIGNATURES);
 for (Signature signature : info.signatures) {
 MessageDigest md = MessageDigest.getInstance(""SHA"");
 md.update(signature.toByteArray());
 Log.v(TAG, ""KeyHash:"" + Base64.encodeToString(md.digest(),
 Base64.DEFAULT));
 }
 } catch (NameNotFoundException e) {
 e.printStackTrace();
 } catch (NoSuchAlgorithmException e) {
 e.printStackTrace();
 }

 }
",3,0,7b8a855deb898ea65ca72e55d6831d2e949e47106a67b89d93b63657fdd10abb
,"import javax.crypto.Cipher;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;

import java.math.*;

public class Encryptor3 {

  public static byte[] hexStringToByteArray(String hexInputString){
    byte[] bts = new byte[hexInputString.length() / 2];

    for (int i = 0; i &lt; bts.length; i++) {
      bts[i] = (byte) Integer.parseInt(hexInputString.substring(2*i, 2*i+2), 16);
    }

    return bts;
  }

  public static String byteArrayToString(byte[] byteArray) {
    StringBuilder str = new StringBuilder();

    for (int i = 0; i &lt; byteArray.length; i++) {
      str.append((char) byteArray[i]);
    }

    return str.toString();
  }

  public static String byteArrayToHexString(byte[] arg) {
    int l = arg.length * 2;
    return String.format(""%0""+l+""x"", new BigInteger(1, arg));
  }

  public static byte[] encrypt(byte[] key1, byte[] key2, byte[] value) {
    try {
      IvParameterSpec iv = new IvParameterSpec(key2);
      SecretKeySpec skeySpec = new SecretKeySpec(key1, ""AES"");

      Cipher cipher = Cipher.getInstance(""AES/CBC/NOPADDING"");
      cipher.init(Cipher.ENCRYPT_MODE, skeySpec, iv);

      byte[] encrypted = cipher.doFinal(value);

      return encrypted;

    } catch (Exception ex) {
      ex.printStackTrace();
    }

    return null;
  }

  public static byte[] decrypt(byte[] key1, byte[] key2, byte[] encrypted) {
    try {
      IvParameterSpec iv = new IvParameterSpec(key2);
      SecretKeySpec skeySpec = new SecretKeySpec(key1, ""AES"");

      Cipher cipher = Cipher.getInstance(""AES/CBC/NOPADDING"");
      cipher.init(Cipher.DECRYPT_MODE, skeySpec, iv);

      byte[] original = cipher.doFinal(encrypted);

      return original;

    } catch (Exception ex) {
      ex.printStackTrace();
    }

    return null;
  }

  public static String toHex(String arg) {
    int l = arg.length() * 2;

    return String.format(""%0""+l+""x"", new BigInteger(1, arg.getBytes()));
  }

  public static String HexStringToString (String arg) {
    StringBuilder output = new StringBuilder();
    for (int i = 0; i &lt; arg.length(); i+=2) {
      String str = arg.substring(i, i+2);
      output.append((char)Integer.parseInt(str, 16));
    }

    return output.toString();
  }


  public static void main(String[] args) {
    // source: http://www.inconteam.com/software-development/41-encryption/55-aes-test-vectors#aes-cbc-128
    String message = ""6bc1bee22e409f96e93d7e117393172a""; // 16 byte = 128 bit key
    //String message = toHex(""Hello00000000000"");
    String key1 =    ""2b7e151628aed2a6abf7158809cf4f3c"";
    String iv =      ""000102030405060708090A0B0C0D0E0F"";
    String match =   ""7649abac8119b246cee98e9b12e9197d"";

    System.out.print(""message (hex):         ""); System.out.println(message);
    System.out.print(""key (hex):             ""); System.out.println(key1);
    System.out.print(""iv (hex):              ""); System.out.println(iv);
    System.out.print(""match (hex):           ""); System.out.println(match);
    System.out.println();

    byte[] enc_message_ba = encrypt(hexStringToByteArray(key1), hexStringToByteArray(iv), hexStringToByteArray(message));
    System.out.print(""Encrypted (hex):       ""); System.out.println(byteArrayToHexString(enc_message_ba));
    System.out.println();

    byte[] dec_message_ba = decrypt(hexStringToByteArray(key1), hexStringToByteArray(iv), enc_message_ba);
    System.out.print(""Decrypted (hex):       ""); System.out.println(byteArrayToHexString(dec_message_ba));
  }
}
",4,0,02af15e5f0573f5f44d9c295d450905749e8356a89116cf1bcec063564373382
,"public class CustomSSLSocketFactory extends SSLSocketFactory {

    private SSLContext sslContext = SSLContext.getInstance(""TLS"");

    public CustomSSLSocketFactory(KeyStore truststore) throws NoSuchAlgorithmException, KeyManagementException, KeyStoreException, UnrecoverableKeyException {

        super(truststore);

        TrustManager tm = new X509TrustManager() {

            public void checkClientTrusted(X509Certificate[] chain, String authType) throws certificateException {
        }

            public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {
            }

            public X509Certificate[] getAcceptedIssuers() {
                return null;
            }

        };

        sslContext.init(null, new TrustManager[] {tm}, null);

    }

    @Override
    public Socket createSocket(Socket socket, String host, int port, boolean autoClose) throws IOException, UnknownHostException {
        return sslContext.getSocketFactory().createSocket(socket, host, port, autoClose);
    }

    @Override
    public Socket createSocket() throws IOException {
        return sslContext.getSocketFactory().createSocket();
    }

}
",4,0,843531ef27f6ff87d783639d9452679f2df28460b95b0a057cd223bc8484d907
,"public HttpClient getHttpClient() {

    DefaultHttpClient client = null;

    try {

        KeyStore trustStore = KeyStore.getInstance(KeyStore.getDefaultType());
        trustStore.load(null, null);

        SSLSocketFactory sf = new CustomSSLSocketFactory(trustStore);
        sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);

        // Setting up parameters
        HttpParams params = new BasicHttpParams();
        HttpProtocolParams.setVersion(params, HttpVersion.HTTP_1_1);
        HttpProtocolParams.setContentCharset(params, ""utf-8"");
        params.setBooleanParameter(""http.protocol.expect-continue"", false);

        // Setting timeout
        HttpConnectionParams.setConnectionTimeout(params, TIMEOUT);
        HttpConnectionParams.setSoTimeout(params, TIMEOUT);

        // Registering schemes for both HTTP and HTTPS
        SchemeRegistry registry = new SchemeRegistry();
        registry.register(new Scheme(""http"", PlainSocketFactory.getSocketFactory(), 80));
        registry.register(new Scheme(""https"", sf, 443));

        // Creating thread safe client connection manager
        ClientConnectionManager ccm = new ThreadSafeClientConnManager(params, registry);

        // Creating HTTP client
        client = new DefaultHttpClient(ccm, params);

        // Registering user name and password for authentication
        client.getCredentialsProvider().setCredentials(
                new AuthScope(null, -1),
                new UsernamePasswordCredentials(mUsername, mPassword));

    } catch (Exception e) {
        client = new DefaultHttpClient();
    }

    return client;

}
",4,0,86c4a4d218ff0820d091670fa2f34fcca4b08f2cf9fae76769e280f28700252c
,"KeyStore trustStore  = KeyStore.getInstance( ""BKS"" /*KeyStore.getDefaultType()*/ );
FileInputStream instream = new FileInputStream(new File(""/mnt/sdcard/keystore.bks""));
try {
    trustStore.load(instream, ""222222"".toCharArray());
} catch (NoSuchAlgorithmException e) {
    e.printStackTrace();
} catch (CertificateException e) {
    e.printStackTrace();
} catch (IOException e) {
    e.printStackTrace();
} finally {
    try { instream.close(); } catch (Exception ignore) {}
}

// Create socket factory with given keystore.
SSLSocketFactory socketFactory = new SSLSocketFactory(trustStore);

SSLSocketFactory socketFactory = new SSLSocketFactory(trustStore);
Scheme sch = new Scheme(""https"", socketFactory, 443);
httpclient.getConnectionManager().getSchemeRegistry().register(sch);

HttpGet httpget = new HttpGet(""https://10.2.20.20/fido/EzPay/login.php"");

System.out.println(""executing request "" + httpget.getRequestLine());

HttpResponse response = httpclient.execute(httpget);
HttpEntity entity = response.getEntity();

System.out.println(""----------------------------------------"");
System.out.println(response.getStatusLine());
if (entity != null) {
    System.out.println(""Response content length:  "" + entity.getContentLength());
}

// Print html.
BufferedReader in = new BufferedReader(new InputStreamReader(response.getEntity().getContent()));
String line = """";
while ((line = in.readLine()) != null) {
     System.out.println(line);
}
in.close();
",4,0,d1b207f7a6e71fd030277a00ce7b28588952fa96171cf737de6ee7529009b8c6
,"String alias = ""test"";
KeyStore memoryKeyStore = KeyStore.getInstance(""BKS"");
memoryKeyStore.load(null);
X509Certificate[] chain = KeyChain.getCertificateChain(getApplicationContext(),alias);
PrivateKey key = KeyChain.getPrivateKey(getApplicationContext(),alias);
memoryKeyStore.setKeyEntry(alias, key.getEncoded(), chain);
",,1,471172c7740008c60bc8765964ccc2cd3388d8451ebfa693d24ba494bc2b05dd
,"import java.util.List;
import java.util.Arrays;
import java.util.ArrayList;

import java.io.IOException;

import java.security.KeyStore;
import java.security.SecureRandom;
import java.security.KeyManagementException;
import java.security.NoSuchAlgorithmException;

import java.net.Socket;
import java.net.InetAddress;

import javax.net.SocketFactory;
import javax.net.ssl.KeyManager;
import javax.net.ssl.TrustManager;

import javax.net.ssl.SSLSocket;
import javax.net.ssl.SSLContext;
import javax.net.ssl.SSLSocketFactory;

class SSLSocketFactoryEx extends SSLSocketFactory
{
    public SSLSocketFactoryEx() throws NoSuchAlgorithmException, KeyManagementException
    {
        initSSLSocketFactoryEx(null,null,null);
    }

    public SSLSocketFactoryEx(KeyManager[] km, TrustManager[] tm, SecureRandom random) throws NoSuchAlgorithmException, KeyManagementException
    {
        initSSLSocketFactoryEx(km, tm, random);
    }

    public SSLSocketFactoryEx(SSLContext ctx) throws NoSuchAlgorithmException, KeyManagementException
    {
        initSSLSocketFactoryEx(ctx);
    }

    public String[] getDefaultCipherSuites()
    {
        return m_ciphers;
    }

    public String[] getSupportedCipherSuites()
    {
        return m_ciphers;
    }

    public String[] getDefaultProtocols()
    {
        return m_protocols;
    }

    public String[] getSupportedProtocols()
    {
        return m_protocols;
    }

    public Socket createSocket(Socket s, String host, int port, boolean autoClose) throws IOException
    {
        SSLSocketFactory factory = m_ctx.getSocketFactory();
        SSLSocket ss = (SSLSocket)factory.createSocket(s, host, port, autoClose);

        ss.setEnabledProtocols(m_protocols);
        ss.setEnabledCipherSuites(m_ciphers);

        return ss;
    }

    public Socket createSocket(InetAddress address, int port, InetAddress localAddress, int localPort) throws IOException
    {
        SSLSocketFactory factory = m_ctx.getSocketFactory();
        SSLSocket ss = (SSLSocket)factory.createSocket(address, port, localAddress, localPort);

        ss.setEnabledProtocols(m_protocols);
        ss.setEnabledCipherSuites(m_ciphers);

        return ss;
    }

    public Socket createSocket(String host, int port, InetAddress localHost, int localPort) throws IOException
    {
        SSLSocketFactory factory = m_ctx.getSocketFactory();
        SSLSocket ss = (SSLSocket)factory.createSocket(host, port, localHost, localPort);

        ss.setEnabledProtocols(m_protocols);
        ss.setEnabledCipherSuites(m_ciphers);

        return ss;
    }

    public Socket createSocket(InetAddress host, int port) throws IOException
    {
        SSLSocketFactory factory = m_ctx.getSocketFactory();
        SSLSocket ss = (SSLSocket)factory.createSocket(host, port);

        ss.setEnabledProtocols(m_protocols);
        ss.setEnabledCipherSuites(m_ciphers);

        return ss;
    }

    public Socket createSocket(String host, int port) throws IOException
    {
        SSLSocketFactory factory = m_ctx.getSocketFactory();
        SSLSocket ss = (SSLSocket)factory.createSocket(host, port);

        ss.setEnabledProtocols(m_protocols);
        ss.setEnabledCipherSuites(m_ciphers);

        return ss;
    }

    private void initSSLSocketFactoryEx(KeyManager[] km, TrustManager[] tm, SecureRandom random)
    throws NoSuchAlgorithmException, KeyManagementException
    {
        m_ctx = SSLContext.getInstance(""TLS"");
        m_ctx.init(km, tm, random);

        m_protocols = GetProtocolList();
        m_ciphers = GetCipherList();
    }

    private void initSSLSocketFactoryEx(SSLContext ctx)
    throws NoSuchAlgorithmException, KeyManagementException
    {
        m_ctx = ctx;

        m_protocols = GetProtocolList();
        m_ciphers = GetCipherList();
    }

    protected String[] GetProtocolList()
    {
        String[] preferredProtocols = { ""TLSv1"", ""TLSv1.1"", ""TLSv1.2"", ""TLSv1.3"" };
        String[] availableProtocols = null;

        SSLSocket socket = null;

        try
        {
            SSLSocketFactory factory = m_ctx.getSocketFactory();
            socket = (SSLSocket)factory.createSocket();

            availableProtocols = socket.getSupportedProtocols();
            Arrays.sort(availableProtocols);
        }
        catch(Exception e)
        {
            return new String[]{ ""TLSv1"" };
        }
        finally
        {
            if(socket != null)
                socket.close();
        }

        List&lt;String&gt; aa = new ArrayList&lt;String&gt;();
        for(int i = 0; i &lt; preferredProtocols.length; i++)
        {
            int idx = Arrays.binarySearch(availableProtocols, preferredProtocols[i]);
            if(idx &gt;= 0)
                aa.add(preferredProtocols[i]);
        }

        return aa.toArray(new String[0]);
    }

    protected String[] GetCipherList()
    {
        String[] preferredCiphers = {

            // *_CHACHA20_POLY1305 are 3x to 4x faster than existing cipher suites.
            //   http://googleonlinesecurity.blogspot.com/2014/04/speeding-up-and-strengthening-https.html
            // Use them if available. Normative names can be found at (TLS spec depends on IPSec spec):
            //   http://tools.ietf.org/html/draft-nir-ipsecme-chacha20-poly1305-01
            //   http://tools.ietf.org/html/draft-mavrogiannopoulos-chacha-tls-02
            ""TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305"",
            ""TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305"",
            ""TLS_ECDHE_ECDSA_WITH_CHACHA20_SHA"",
            ""TLS_ECDHE_RSA_WITH_CHACHA20_SHA"",

            ""TLS_DHE_RSA_WITH_CHACHA20_POLY1305"",
            ""TLS_RSA_WITH_CHACHA20_POLY1305"",
            ""TLS_DHE_RSA_WITH_CHACHA20_SHA"",
            ""TLS_RSA_WITH_CHACHA20_SHA"",

            // Done with bleeding edge, back to TLS v1.2 and below
            ""TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384"",
            ""TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384"",
            ""TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256"",
            ""TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256"",

            ""TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384"",
            ""TLS_DHE_DSS_WITH_AES_256_GCM_SHA384"",
            ""TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256"",
            ""TLS_DHE_DSS_WITH_AES_128_GCM_SHA256"",

            // TLS v1.0 (with some SSLv3 interop)
            ""TLS_DHE_RSA_WITH_AES_256_CBC_SHA384"",
            ""TLS_DHE_DSS_WITH_AES_256_CBC_SHA256"",
            ""TLS_DHE_RSA_WITH_AES_128_CBC_SHA"",
            ""TLS_DHE_DSS_WITH_AES_128_CBC_SHA"",

            ""TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA"",
            ""TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA"",
            ""SSL_DH_RSA_WITH_3DES_EDE_CBC_SHA"",
            ""SSL_DH_DSS_WITH_3DES_EDE_CBC_SHA"",

            // RSA key transport sucks, but they are needed as a fallback.
            // For example, microsoft.com fails under all versions of TLS
            // if they are not included. If only TLS 1.0 is available at
            // the client, then google.com will fail too. TLS v1.3 is
            // trying to deprecate them, so it will be interesteng to see
            // what happens.
            ""TLS_RSA_WITH_AES_256_CBC_SHA256"",
            ""TLS_RSA_WITH_AES_256_CBC_SHA"",
            ""TLS_RSA_WITH_AES_128_CBC_SHA256"",
            ""TLS_RSA_WITH_AES_128_CBC_SHA""
        };

        String[] availableCiphers = null;

        try
        {
            SSLSocketFactory factory = m_ctx.getSocketFactory();
            availableCiphers = factory.getSupportedCipherSuites();
            Arrays.sort(availableCiphers);
        }
        catch(Exception e)
        {
            return new String[] {
                ""TLS_DHE_DSS_WITH_AES_128_CBC_SHA"",
                ""TLS_DHE_DSS_WITH_AES_256_CBC_SHA"",
                ""TLS_DHE_RSA_WITH_AES_128_CBC_SHA"",
                ""TLS_DHE_RSA_WITH_AES_256_CBC_SHA"",
                ""TLS_RSA_WITH_AES_256_CBC_SHA256"",
                ""TLS_RSA_WITH_AES_256_CBC_SHA"",
                ""TLS_RSA_WITH_AES_128_CBC_SHA256"",
                ""TLS_RSA_WITH_AES_128_CBC_SHA"",
                ""TLS_EMPTY_RENEGOTIATION_INFO_SCSV""
            };
        }

        List&lt;String&gt; aa = new ArrayList&lt;String&gt;();
        for(int i = 0; i &lt; preferredCiphers.length; i++)
        {
            int idx = Arrays.binarySearch(availableCiphers, preferredCiphers[i]);
            if(idx &gt;= 0)
                aa.add(preferredCiphers[i]);
        }

        aa.add(""TLS_EMPTY_RENEGOTIATION_INFO_SCSV"");

        return aa.toArray(new String[0]);
    }

    private SSLContext m_ctx;

    private String[] m_ciphers;
    private String[] m_protocols;
}
",3,0,b6f7661c913266b699b86d67bee2a136219c3c64eadf46430d06004cb37ae126
,"public class MainActivity extends AppCompatActivity {

    private Context mContext = this;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        try {
            CertificateFactory cf = CertificateFactory.getInstance(""X.509"");
            // cert file stored in \app\src\main\res\raw
            InputStream caInput = getResources().openRawResource(R.raw.your_cert);

            Certificate ca = cf.generateCertificate(caInput);
            caInput.close();

            KeyStore keyStore = KeyStore.getInstance(""BKS"");
            keyStore.load(null, null);
            keyStore.setCertificateEntry(""ca"", ca);

            String tmfAlgorithm = TrustManagerFactory.getDefaultAlgorithm();
            TrustManagerFactory tmf = TrustManagerFactory.getInstance(tmfAlgorithm);
            tmf.init(keyStore);

            TrustManager[] wrappedTrustManagers = getWrappedTrustManagers(tmf.getTrustManagers());

            SSLContext sslContext = SSLContext.getInstance(""TLS"");
            sslContext.init(null, wrappedTrustManagers, null);

            AsyncSSLSocketMiddleware sslMiddleWare = Ion.getDefault(mContext).getHttpClient().getSSLSocketMiddleware();
            sslMiddleWare.setTrustManagers(wrappedTrustManagers);
            sslMiddleWare.setHostnameVerifier(getHostnameVerifier());
            sslMiddleWare.setSSLContext(sslContext);

            // Post application/x-www-form-urlencoded and read a String
            Ion.with(mContext)
                    .load(""https://yourserver/token"")
                    .setBodyParameter(""grant_type"", ""password"")
                    .setBodyParameter(""username"", ""bnk"")
                    .setBodyParameter(""password"", ""bnk123456789"")
                    .asString()
                    .setCallback(new FutureCallback&lt;String&gt;() {
                        @Override
                        public void onCompleted(Exception e, String result) {
                            if (result != null) {
                                Log.i(""ionSample"", result);
                            } else if (e != null) {
                                e.printStackTrace();
                            }
                        }
                    });
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    private HostnameVerifier getHostnameVerifier() {
        return new HostnameVerifier() {
            @Override
            public boolean verify(String hostname, SSLSession session) {
                return true;
                // or the following:
                // HostnameVerifier hv = HttpsURLConnection.getDefaultHostnameVerifier();
                // return hv.verify(""www.yourserver.com"", session);
            }
        };
    }

    private TrustManager[] getWrappedTrustManagers(TrustManager[] trustManagers) {
        final X509TrustManager originalTrustManager = (X509TrustManager) trustManagers[0];
        return new TrustManager[]{
                new X509TrustManager() {
                    public X509Certificate[] getAcceptedIssuers() {
                        return originalTrustManager.getAcceptedIssuers();
                    }

                    public void checkClientTrusted(X509Certificate[] certs, String authType) {
                        try {
                            originalTrustManager.checkClientTrusted(certs, authType);
                        } catch (CertificateException ignored) {
                        }
                    }

                    public void checkServerTrusted(X509Certificate[] certs, String authType) {
                        try {
                            originalTrustManager.checkServerTrusted(certs, authType);
                        } catch (CertificateException ignored) {
                        }
                    }
                }
        };
    }
",4,0,c486024f97aa8ba1510575b83f4b4c550e40c2b5cb7be9c90f6e7ca6f9e88205
,"public void saveToFile(String fileName, BigInteger mod, BigInteger exp)
        throws IOException {
    ObjectOutputStream oout = new ObjectOutputStream(
            new BufferedOutputStream(new FileOutputStream(fileName)));
    try {
        oout.writeObject(mod);
        oout.writeObject(exp);
    } catch (Exception e) {
        throw new IOException(""Unexpected error"", e);
    } finally {
        oout.close();
    }
}

PublicKey ReadPublicKeyFromFile(String keyFileName) throws IOException {
    InputStream in = RSACrypt.class.getClassLoader().getResourceAsStream(keyFileName);
    ObjectInputStream oin = new ObjectInputStream(new BufferedInputStream(
            in));
    try {
        BigInteger m = (BigInteger) oin.readObject();
        BigInteger e = (BigInteger) oin.readObject();
        RSAPublicKeySpec keySpec = new RSAPublicKeySpec(m, e);
        KeyFactory fact = KeyFactory.getInstance(""RSA"");
        PublicKey pubKey = fact.generatePublic(keySpec);
        return pubKey;
    } catch (Exception e) {
        throw new RuntimeException(""Spurious serialisation error"", e);
    } finally {
        oin.close();
    }
}
",,1,e8a4ce3c2e5579c512d62b69174cffac30960ec8843d18b08b4f0d2502fda206
,"private HttpClient getHttpClient()
{
    HttpParams params = new BasicHttpParams();

    //Set main protocol parameters
    HttpProtocolParams.setVersion(params, HttpVersion.HTTP_1_1);
    HttpProtocolParams.setContentCharset(params, HTTP.DEFAULT_CONTENT_CHARSET);
    HttpProtocolParams.setUseExpectContinue(params, true);

    // Turn off stale checking.  Our connections break all the time anyway, and it's not worth it to pay the penalty of checking every time.
    HttpConnectionParams.setStaleCheckingEnabled(params, false);
    // FIX v2.2.1+ - Set timeout to 30 seconds, seems like 5 seconds was not enough for good communication
    HttpConnectionParams.setConnectionTimeout(params, 30 * 1000);
    HttpConnectionParams.setSoTimeout(params, 30 * 1000);
    HttpConnectionParams.setSocketBufferSize(params, 8192);

    // Don't handle redirects -- return them to the caller.  Our code often wants to re-POST after a redirect, which we must do ourselves.
    HttpClientParams.setRedirecting(params, false);

    // Register our own ""trust-all"" SSL scheme
    SchemeRegistry schReg = new SchemeRegistry();
    try
    {
        KeyStore trustStore = KeyStore.getInstance(KeyStore.getDefaultType());
        trustStore.load(null, null);

        TrustAllSSLSocketFactory sslSocketFactory = new TrustAllSSLSocketFactory(trustStore);
        sslSocketFactory.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);

        Scheme sslTrustAllScheme = new Scheme(""https"", sslSocketFactory, 443);
        schReg.register(sslTrustAllScheme);
    }
    catch (Exception ex)
    {
        LogData.e(LOG_TAG, ex, LogData.Priority.None);
    }

    ClientConnectionManager conMgr = new ThreadSafeClientConnManager(params,schReg);
    return new DefaultHttpClient(conMgr, params);
}
",4,0,4e959c492a78cac984e52055d1b102db2d5ec890b285e0eba01ce5c3d2df055d
,"    public void checkServerTrusted(X509Certificate[] certificates,String authType) throws CertificateException {
    if ((certificates != null) &amp;&amp; LOG.isDebugEnabled()) {
        LOG.debug(""Server certificate chain:"");
        for (int i = 0; i &lt; certificates.length; i++) {
            LOG.debug(""X509Certificate["" + i + ""]="" + certificates[i]);
        }
    }
    if ((certificates != null) &amp;&amp; (certificates.length == 1)) {
        certificates[0].checkValidity();
    } else {
        List&lt;X509Certificate&gt; certs = new ArrayList&lt;X509Certificate&gt;();
        certs.addAll(Arrays.asList(certificates));
        X509Certificate certChain = certs.get(0);
        certs.remove(certChain);
        LinkedList&lt;X509Certificate&gt; chainList= new LinkedList&lt;X509Certificate&gt;();
        chainList.add(certChain);
        Principal certIssuer = certChain.getIssuerDN();
        Principal certSubject = certChain.getSubjectDN();
        while(!certs.isEmpty()){
            List&lt;X509Certificate&gt; tempcerts = new ArrayList&lt;X509Certificate&gt;();
            tempcerts.addAll(certs);
            for (X509Certificate cert : tempcerts){
                if(cert.getIssuerDN().equals(certSubject)){
                    chainList.addFirst(cert);
                    certSubject = cert.getSubjectDN();
                    certs.remove(cert);
                    continue;
                }

                if(cert.getSubjectDN().equals(certIssuer)){
                    chainList.addLast(cert);
                    certIssuer = cert.getIssuerDN();
                    certs.remove(cert);
                    continue;
                }
            }
        }
    standardTrustManager.checkServerTrusted(chainList.toArray(new X509Certificate[]{}),authType);

    }
}
",4,0,dbbf05c4533e77233dd49a1dae673b1b1fe7087e5d7748b8b16ba5dabbc3b908
,"byte[] key = ""MARTIN_123456789"".getBytes(""UTF-8"");
byte[] iv = ""1234567890123456"".getBytes(""UTF-8"");
byte[] decryptedData = decrypt(key, iv, b);

private byte[] decrypt(byte[] raw, byte[] iv, byte[] encrypted) throws Exception {
  SecretKeySpec skeySpec = new SecretKeySpec(raw, ""AES"");
  Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
  IvParameterSpec ivspec = new IvParameterSpec(iv);         
  cipher.init(Cipher.DECRYPT_MODE, skeySpec, ivspec);
  byte[] decrypted = cipher.doFinal(encrypted);

  return decrypted;
}
",4,0,e9317b68beee60aef6eb013b216483c51533a2b95a33c4b17a72cfe58119332a
,"OkHttpClient client = new OkHttpClient();
client.setHostnameVerifier(new HostnameVerifier() {
            @Override
            public boolean verify(String hostname, SSLSession session) {
                if (!urlHostName.equalsIgnoreCase(session.getPeerHost())) {
                    System.out.println(""Warning: URL host '"" + urlHostName
                            + ""' is different to SSLSession host '""
                            + session.getPeerHost() + ""'."");
                }
                return true;
            }
        });
",4,0,9450102170503dc9fef087fb70b04cd7284ce01a229c387fc0c90d3feef3b32a
,"MessageDigest md = MessageDigest.getInstance(""MD5"");
InputStream is = new FileInputStream(""file.txt"");
try {
    is = new DigestInputStream(is, md);
    // read stream to EOF as normal...
}
finally {
  is.close();
}
byte[] digest = md.digest();
",,1,9b43d42d19a99e50073ac4035bfe87408ab0181a0dea67ed6ec689e13fcfaf18
,"@Override
protected Void doInBackground(Void... params){
    // Create a trust manager that does not validate certificate chains
    TrustManager[] trustAllCerts = new TrustManager[] { new X509TrustManager() {
        public java.security.cert.X509Certificate[] getAcceptedIssuers() {
            return null;
        }

        public void checkClientTrusted(java.security.cert.X509Certificate[] certs, String authType) {
        }

        public void checkServerTrusted(java.security.cert.X509Certificate[] certs, String authType) {
        }
    } };

    // Install the all-trusting trust manager
    try {
        SSLContext sc = SSLContext.getInstance(""SSL"");
        sc.init(null, trustAllCerts, new java.security.SecureRandom());
        HttpsURLConnection.setDefaultSSLSocketFactory(sc.getSocketFactory());
    } catch (Exception e) {
        throw new RuntimeException(e);
    }

    // Your code ...
    URL url = null;
    HttpsURLConnection conn = null;
    try {
      url = new URL(""https://example.com"");
    } catch (MalformedURLException e) {
      e.printStackTrace();
    }

    // ...
}
",4,0,38dd91a167c2ea310c681f2454bf8b013e8beedc011256183defc65d9256fc0e
,"public static String hashKeyForDisk(String key) {
    String cacheKey;
    try {
        final MessageDigest mDigest = MessageDigest.getInstance(""MD5"");
        if (key == null) {
            Log.e(""TEST"",""key = null"");
            throw new IllegalArgumentException("" key == null"");
        }

        if (mDigest == null) {
            Log.e(""TEST"",""mDigest = null"");

            return String.valueOf(key.hashCode());
        }
        byte[] bytes = key.getBytes();
        mDigest.update(bytes);
        cacheKey = bytesToHexString(mDigest.digest());
    } catch (NoSuchAlgorithmException e) {
        cacheKey = String.valueOf(key.hashCode());
    }
    return cacheKey;
}
",,1,f746a39c66c43dad115cca47c72696a0dfe348dc6e3c6979174d991210008403
,"public static final byte[] md5(String s) { 
    try { 

        MessageDigest md = MessageDigest.getInstance(""MD5"");
        byte[] messageDigest = md.digest(s.getBytes(""UTF-8""));

        String md5 = EncodingUtils.getString(messageDigest, ""UTF-8"");

        Log.i(""Function MD5"", md5);
        Log.i(""Function MD5 Length"",""Length: ""+ md5.length());

        return messageDigest;

    } catch (NoSuchAlgorithmException e) {
        e.printStackTrace();
    } catch (UnsupportedEncodingException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    } 
    return null;
}   
",3,0,d1309435164982d4c76c0017c8f0991cc331f8c30830ca0831f24a77435ba0e2
,"try {
        Cipher cipher = Cipher.getInstance(""DESEDE/ECB/PKCS5Padding"");
        SecretKeySpec myKey = new SecretKeySpec(hash,""DESede"");

        cipher.init(Cipher.ENCRYPT_MODE, myKey);

        try {
            byte[] encryptedPlainText = cipher.doFinal(plaintextByte);

            encrypted = Base64.encodeToString(encryptedPlainText, 0); 
            Log.i(""ENCRYPT"", ""Pwd encrypted: ""+encrypted);
            return encrypted;

        } catch (IllegalBlockSizeException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        } catch (BadPaddingException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }

    } catch (NoSuchAlgorithmException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    } catch (NoSuchPaddingException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    } catch (InvalidKeyException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    }       
",4,0,fd89eda8324c1b93167c2f5767cd9084d93d5f044c0b0087e2aa50a597bf9db6
,"/**
     * Get the InputStream contents for a specific URL request, with parameters.
     * Uses POST. PLEASE NOTE: You should NOT use this method in the main
     * thread.
     * 
     * @param url
     *            is the URL to query
     * @param parameters
     *            is a Vector with instances of String containing the parameters
     */
    public static InputStream readHTTPContents(String url, String requestMethod, byte[] bodyData, String bodyEncoding, Map&lt;String, String&gt; parameters)
            throws AppException {
        HttpURLConnection connection = null;
        InputStream is = null;
        try {
            URL urlObj = new URL(url);
            if (urlObj.getProtocol().toLowerCase().equals(""https"")) {
                trustAllHosts();
                HttpsURLConnection https = (HttpsURLConnection) urlObj
                        .openConnection();
                https.setHostnameVerifier(new HostnameVerifier() {
                    public boolean verify(String hostname, SSLSession session) {
                        return true;
                    }
                });
                connection = https;
            } else {
                connection = (HttpURLConnection) urlObj.openConnection();
            }
            // Allow input
            connection.setDoInput(true);
            // If there's data, prepare to send.
            if (bodyData != null) {
                connection.setDoOutput(true);
            }
            // Write additional parameters if any
            if (parameters != null) {
                Iterator&lt;String&gt; i = parameters.keySet().iterator();
                while (i.hasNext()) {
                    String key = i.next();
                    connection.addRequestProperty(key, parameters.get(key));
                }
            }
            // Sets request method
            connection.setRequestMethod(requestMethod);
            // Establish connection
            connection.connect();
            // Send data if any

            if (bodyData != null) {
                OutputStream os = connection.getOutputStream();
                os.write(bodyData);
            }
            if (connection.getResponseCode() != HttpURLConnection.HTTP_OK) {
                throw new AppException(""Error HTTP code "" + connection.getResponseCode());
            }
            is = connection.getInputStream();
            int numBytes = is.available();
            if (numBytes &lt;= 0) {
                closeInputStream(is);
                connection.disconnect();
                throw new AppException(MessageConstants.MSG_ERROR_CONNECTION_UNKNOWN);
            }

            ByteArrayOutputStream content = new ByteArrayOutputStream();

            // Read response into a buffered stream
            int readBytes = 0;
            while ((readBytes = is.read(sBuffer)) != -1) {
                content.write(sBuffer, 0, readBytes);
            }
            ByteArrayInputStream byteStream = new ByteArrayInputStream(content.toByteArray());
            content.flush();
            return byteStream;
        } catch (Exception e) {
//          Logger.logDebug(e.getMessage());
            throw new AppException(e.getMessage());
        } finally {
            closeInputStream(is);
            closeHttpConnection(connection);
        }
    }
",4,0,591ec949416da11ff98babb5c6528921579f70451deb2733d6ff58658773a0e6
,"Signature Signer = Signature.getInstance(""SHA1withRSA"");
Signer.initSign(MyKey, new SecureRandom()); //Where do you get the key?
byte []Message = MyMessage(); //Initialize somehow
Signer.update(Message, 0, Message.length);
byte [] Signature = Sign.sign();
",3,0,75ce8dc5b68c443271667a6718b115f5771301da42202edf6f90bb4b93c52095
,"public HttpClient getNewHttpClient() {
        try {
            KeyStore trustStore = KeyStore.getInstance(KeyStore
                    .getDefaultType());
            trustStore.load(null, null);

            SSLSocketFactory sf = new MySSLSocketFactory(trustStore);
            sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);

            HttpParams params = new BasicHttpParams();
            HttpProtocolParams.setVersion(params, HttpVersion.HTTP_1_1);
            HttpProtocolParams.setContentCharset(params, HTTP.UTF_8);

            SchemeRegistry registry = new SchemeRegistry();
            registry.register(new Scheme(""http"", PlainSocketFactory
                    .getSocketFactory(), 80));
            registry.register(new Scheme(""https"", sf, 443));



            ClientConnectionManager ccm = new ThreadSafeClientConnManager(
                    params, registry);

            return new DefaultHttpClient(ccm, params);
        } catch (Exception e) {
            return new DefaultHttpClient();
        }
    }
",4,0,1248054bc1c885b051d94ec75899f3139ea85d717e3f4872ad467dfaa821eab6
,"try {
        KeyStore ks = KeyStore.getInstance(""JKS"");
",,1,a788361f3f894f8210a13f691a4fcfefcf2ace527ca76cfc7f4f1de24872c6f3
,"KeyStore ks;
try {
     ks = KeyStore.getInstance(""JKS"");
",,1,098034b33bb390b8a760c47b65d2283b3a55764558335ca7345037a66f0150b5
,"/***
  Copyright (c) 2014 CommonsWare, LLC

  Licensed under the Apache License, Version 2.0 (the ""License""); you may
  not use this file except in compliance with the License. You may obtain
  a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an ""AS IS"" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
 */

package com.commonsware.cwac.security;

import android.content.Context;
import android.content.pm.PackageManager;
import android.content.pm.PackageManager.NameNotFoundException;
import android.content.pm.Signature;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;

public class SignatureUtils {
  public static String getOwnSignatureHash(Context ctxt)
                                                        throws NameNotFoundException,
                                                        NoSuchAlgorithmException {
    return(getSignatureHash(ctxt, ctxt.getPackageName()));
  }

  public static String getSignatureHash(Context ctxt, String packageName)
                                                                         throws NameNotFoundException,
                                                                         NoSuchAlgorithmException {
    MessageDigest md=MessageDigest.getInstance(""SHA-256"");
    Signature sig=
        ctxt.getPackageManager()
            .getPackageInfo(packageName, PackageManager.GET_SIGNATURES).signatures[0];

    return(toHexStringWithColons(md.digest(sig.toByteArray())));
  }

  // based on https://stackoverflow.com/a/2197650/115145

  public static String toHexStringWithColons(byte[] bytes) {
    char[] hexArray=
        { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B',
            'C', 'D', 'E', 'F' };
    char[] hexChars=new char[(bytes.length * 3) - 1];
    int v;

    for (int j=0; j &lt; bytes.length; j++) {
      v=bytes[j] &amp; 0xFF;
      hexChars[j * 3]=hexArray[v / 16];
      hexChars[j * 3 + 1]=hexArray[v % 16];

      if (j &lt; bytes.length - 1) {
        hexChars[j * 3 + 2]=':';
      }
    }

    return new String(hexChars);
  }
}
",2,0,f2e7f02c5200d9b11e31b6448835d50d276a75083f0e43eabefc04cf8351d813
,"KeyStore trustStore = KeyStore.getInstance(""BKS"");
KeyStore certStore = KeyStore.getInstance(""BKS"");
InputStream in = context.getResources().openRawResource(R.raw.signature_certstore);
try {
    certStore.load(in, ""some_password"".toCharArray());
} finally {
    in.close();
}

in = context.getResources().openRawResource(R.raw.signature_truststore);
try {
    trustStore.load(in, ""some_password"".toCharArray());
} finally {
    in.close();
}
",,1,5d2cf03eb1caaba5e5765d7cf734d9b0b3127b0fa5266967377b123ce443b72f
,"private static char[] hextable = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'};


public static String byteArrayToHex(byte[] array) {
    String s = """";
    for (int i = 0; i &lt; array.length; ++i) {
        int di = (array[i] + 256) &amp; 0xFF; // Make it unsigned
        s = s + hextable[(di &gt;&gt; 4) &amp; 0xF] + hextable[di &amp; 0xF];
    }
    return s;
}

public static String digest(String s, String algorithm) {
    MessageDigest m = null;
    try {
        m = MessageDigest.getInstance(algorithm);
    } catch (NoSuchAlgorithmException e) {
        e.printStackTrace();
        return s;
    }

    try {
        m.update(s.getBytes(""UTF-8""));
    } catch (UnsupportedEncodingException e) {
        e.printStackTrace();
        m.update(s.getBytes());
    }
    return byteArrayToHex(m.digest());
}

public static String md5(String s) {
    return digest(s, ""MD5"");
}
",,1,e8ff8c1589921b229bdd66527b2ecc0db48ec3b3cdd6d12df92b71062fbe581e
,"        CipherParameters p = new KeyParameter(key.getBytes(""UTF-8""));

        WhirlpoolDigest w = new WhirlpoolDigest();
        HMac hm = new HMac(w);
        hm.init(p);
        hm.update(inbytes, 0, inbytes.length);
        byte[] result = new byte[hm.getMacSize()];
        hm.doFinal(result, 0);
",,1,ab86a82ebbb1efe3658bf4ab9a9208faef22cf73d530f9d93efc5bd76651d5c2
,"try {
    PackageInfo info = getPackageManager().getPackageInfo(
            ""com.example.packagename"", 
            PackageManager.GET_SIGNATURES);
    for (Signature signature : info.signatures) {
        MessageDigest md = MessageDigest.getInstance(""SHA"");
        md.update(signature.toByteArray());
        Log.d(""KeyHash:"", Base64.encodeToString(md.digest(), Base64.DEFAULT));
        }
} catch (NameNotFoundException e) {

} catch (NoSuchAlgorithmException e) {

}
",3,0,fb67bb9f1dcafa0b525185a954c40fa905590ad97fc0b37bfe9f8f50baae3885
,"public static SecretKey generateKey() throws NoSuchAlgorithmException, InvalidKeySpecException {
    return secret = new SecretKeySpec(password.getBytes(), ""AES"");
}

public static byte[] encryptMsg(String message, SecretKey secret) throws NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, InvalidParameterSpecException, IllegalBlockSizeException, BadPaddingException, UnsupportedEncodingException {
/* Encrypt the message. */
    Cipher cipher = null;
    cipher = Cipher.getInstance(""AES/ECB/PKCS5Padding"");
    cipher.init(Cipher.ENCRYPT_MODE, secret);
    byte[] cipherText = cipher.doFinal(message.getBytes(""UTF-8""));
    return cipherText;
}

public static String decryptMsg(byte[] cipherText, SecretKey secret) throws NoSuchPaddingException, NoSuchAlgorithmException, InvalidParameterSpecException, InvalidAlgorithmParameterException, InvalidKeyException, BadPaddingException, IllegalBlockSizeException, UnsupportedEncodingException {

    /* Decrypt the message, given derived encContentValues and initialization vector. */
    Cipher cipher = null;
    cipher = Cipher.getInstance(""AES/ECB/PKCS5Padding"");
   cipher.init(Cipher.DECRYPT_MODE, secret);
    String decryptString = new String(cipher.doFinal(cipherText), ""UTF-8"");
    return decryptString;
}
",4,0,4b8b9850058ca140713dfd43d3daf8e365f1f925130e6de3a199b5fd9272ed79
,"KeyStore keyStore = KeyStore.getInstance( ""PKCS12"" );
String pkcs12 = UserSession.getCertificate( context );
InputStream sslInputStream = new ByteArrayInputStream( MyBase64Decoder.decode( pkcs12.getBytes() ) );
keyStore.load( sslInputStream, ""password"".toCharArray() );
",,1,cc2da408acfa33b438c3f410ed7ed6cbce4e7bb22c93f7ef636ffa664e131795
,"/**
     * Generates the hash key used for Facebook console to register app. It can also be used for other sdks) Method copied from: https://developers.facebook.com/docs/android/getting-started/
     */
    public static String printHashKey(Context ctx) {
        // Add code to print out the key hash
        try {
            PackageInfo info = ctx.getPackageManager().getPackageInfo(ctx.getPackageName(), PackageManager.GET_SIGNATURES);
            for (Signature signature : info.signatures) {
                MessageDigest md = MessageDigest.getInstance(""SHA"");
                md.update(signature.toByteArray());
                return Base64.encodeToString(md.digest(), Base64.DEFAULT);
            }
        } catch (NameNotFoundException e) {
            return ""SHA-1 generation: the key count not be generated: NameNotFoundException thrown"";
        } catch (NoSuchAlgorithmException e) {
            return ""SHA-1 generation: the key count not be generated: NoSuchAlgorithmException thrown"";
        }

        return ""SHA-1 generation: epic failed"";
    }
",3,0,3a2b50c85308491395a52bc81dbc7cd24ac977c9055432daf5012231a6513f62
,"/**
 * Android Central Keystore repo usually located on /data/misc/keychain 
 * including the system trusted anchors located on /system/etc/security
 */
KeyStore keyStore = KetStore.getInstance(""AndroidCAStore"");
keyStore.load(null, null); //Load default system keystore
Enumeration&lt;String&gt; keyAliases = keyStore.aliases();

while(keyAliases.hasMoreElements()){
    String alias = aliases.nextElement();
    X509Certificate cert = (X509Certificate) keyStore.getCertificate(alias);

    //&lt;User cert in whatever way you want&gt;
}
",,1,d67c2ff6d6882fc8cee10d968e72d542dd9d1243540f6cebb909a61a6958c17f
," public class ChooseTeamActivity extends ListActivity {

    private static final String apiKey = ""4545ggg454hfnf7557kfdkgg454""; 
    private static final String apiUser = ""AndroidUser""; 

    long unixTimeStamp = System.currentTimeMillis() / 1000L;

    String newFeedRequest = ""1.0/evoStructure?timestamp="" + unixTimeStamp;
    String fixturesFeedURL = ""https://secure.TestSite.com/_services/api/"" + newFeedRequest;
    String strHash = null;
    public void hash() throws NoSuchAlgorithmException, UnsupportedEncodingException{

        MessageDigest md = MessageDigest.getInstance(""SHA-256"");
        md.update(fixturesFeedURL.getBytes(""UTF-8""));
        byte[] digest = md.digest();
        strHash = new String(digest);

    }   



    @Override
    protected void onCreate(Bundle savedInstanceState) {
        // TODO Auto-generated method stub
        super.onCreate(savedInstanceState);

    setContentView(R.layout.chooseact);

     hash();
     Log.v(""myApp"", fixturesFeedURL);
     Log.v(""myApp"", strhash);



    }

}
",2,0,ec73576b49a67e2aa98df0af432fd85c09cef4710bfce59161c09c69f931cbee
,"public class ChooseTeamActivity extends ListActivity {

    private static final String apiKey = ""4545ggg454hfnf7557kfdkgg454""; 
    private static final String apiUser = ""AndroidUser""; 

    long unixTimeStamp = System.currentTimeMillis() / 1000L;

    String newFeedRequest = ""1.0/evoStructure?timestamp="" + unixTimeStamp;
    String fixturesFeedURL = ""https://secure.TestSite.com/_services/api/"" + newFeedRequest;

    public String hash() throws NoSuchAlgorithmException, UnsupportedEncodingException{

        MessageDigest md = MessageDigest.getInstance(""SHA-256"");
        md.update(fixturesFeedURL.getBytes(""UTF-8""));
        byte[] digest = md.digest();
        return new String(digest);

    }   



    @Override
    protected void onCreate(Bundle savedInstanceState) {
        // TODO Auto-generated method stub
        super.onCreate(savedInstanceState);

    setContentView(R.layout.chooseact);

     String strhash = hash();
     Log.v(""myApp"", fixturesFeedURL);
     Log.v(""myApp"", strhash);



    }

}
",2,0,39b97e97d3055072060ba9da851666e0e5cdc15da070a73308a5f415e109cf94
,"static String decrypt(String strInput) throws IOException,
    NoSuchAlgorithmException, NoSuchPaddingException,
    InvalidKeyException, IllegalBlockSizeException, BadPaddingException {

    FileInputStream fis = new FileInputStream(strInput);

    int endFile = strInput.length() - 4;
    String strOut = strInput.substring(0, endFile) + ""xx.txt""; 

    FileOutputStream fos = new FileOutputStream(strOut);

    SecretKeySpec sks = new SecretKeySpec(""MyDifficultPassw"".getBytes(), ""AES"");
    Cipher cipher = Cipher.getInstance(""AES"");
    cipher.init(Cipher.DECRYPT_MODE, sks);

    int b;
    byte[] d = new byte[8];
    while ((b = fis.read(d)) != -1) {
        fos.write(cipher.update(d));
    }
    fos.write(cipher.doFinal());

    fos.flush();
    fos.close();
    fis.close();
    return strOut;
}
",4,0,5f85829ea7a1fcece739b4fe6eed592470e9da4602d753682f9352d15d650406
,"OkHttpClient okHttpClient = new OkHttpClient();
try {
    SSLContext sslContext = SSLContext.getInstance(""TLS"");
    sslContext.init(null, null, null);
    okHttpClient.setSslSocketFactory(sslContext.getSocketFactory());
} catch (GeneralSecurityException ignored) {
}

// open a URL connection to the Servlet
fileInputStream = mImagePath.getContentStream();
URL url = new URL(Api.url(Api.Methods.UPLOAD_IMAGE));

conn = okHttpClient.open(url); // FIX!!!
conn.setDoInput(true);
conn.setDoOutput(true);
conn.setUseCaches(false);
conn.setRequestMethod(""POST"");
",3,0,13f8cd59c8f30f6a38b9582b536eb3ba4b98c8958379aeeb8fd89171c98c7bab
,"try {
    PackageInfo info = getPackageManager().getPackageInfo(
            ""com.yours.package"", 
            PackageManager.GET_SIGNATURES);
    for (Signature signature : info.signatures) {
        MessageDigest md = MessageDigest.getInstance(""SHA"");
        md.update(signature.toByteArray());
        Log.d(""KeyHash:"", Base64.encodeToString(md.digest(), Base64.DEFAULT));
        }
} catch (NameNotFoundException e) {

} catch (NoSuchAlgorithmException e) {

}
",3,0,d0f21e20ae128b787cdd37635f57bfb067cb441b7acd045ab501180a1bd136a5
,"PackageInfo info;
try {
    info = getPackageManager().getPackageInfo(""YOUR_APP_PACKAGE"", PackageManager.GET_SIGNATURES);
    for (Signature signature : info.signatures) {
        MessageDigest md;
        md = MessageDigest.getInstance(""SHA"");
        md.update(signature.toByteArray());
        String keyhash = new String(Base64.encode(md.digest(), 0));
        //string something is what you should paste as key hash
        Log.e(""hash key"", keyhash);
    }
} catch (NameNotFoundException e1) {
    Log.e(""name not found"", e1.toString());
} catch (NoSuchAlgorithmException e) {
    Log.e(""no such an algorithm"", e.toString());
} catch (Exception e) {
    Log.e(""exception"", e.toString());
} 
",3,0,e5d3c7c43a4b6aeeb87519c8a988225eb4cef258c267448ffc832d455b376043
,"HttpClient httpClient = MainActivity.createHttpClient();


public static HttpClient createHttpClient(){
    try {
        KeyStore trustStore = KeyStore.getInstance(KeyStore.getDefaultType());
        trustStore.load(null, null);

        SSLSocketFactory sf = new MySSLSocketFactory(trustStore);
        sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);

        HttpParams params = new BasicHttpParams();
        HttpConnectionParams.setConnectionTimeout(params, 15000);
        HttpConnectionParams.setSoTimeout(params, 5000);

        SchemeRegistry registry = new SchemeRegistry();
        registry.register(new Scheme(""http"", PlainSocketFactory.getSocketFactory(), 80));
        registry.register(new Scheme(""https"", sf, 443));

        ClientConnectionManager ccm = new ThreadSafeClientConnManager(params, registry);

        return new DefaultHttpClient(ccm, params);
    } catch (Exception e) {
        return new DefaultHttpClient();
    }
}
",4,0,beb9a4a1dfe750b75b73aecc9e726fab1cba5fe7e111c31f19627d884222dc8a
,"public class TwitterUpdater {
     Context context;
     public TwitterUpdate(Context ctx){
        context = ctx;
        Timer timer = new Timer;
        timer.scheduleAtFixedRate(new TwitterTask(), 0, 300000);
     }

}

public class TwitterTask extends TimerTask{
    @Override
    public void run() {
        // TODO Auto-generated method stub
        this.loadMessages();
    }

}
public void loadMessages(){
        StringBuilder builder = new StringBuilder();
        HostnameVerifier hostnameVerifier = org.apache.http.conn.ssl.SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER;

           DefaultHttpClient client = new DefaultHttpClient();

           SchemeRegistry registry = new SchemeRegistry();
           SSLSocketFactory socketFactory = SSLSocketFactory.getSocketFactory();
           socketFactory.setHostnameVerifier((X509HostnameVerifier) hostnameVerifier);
           registry.register(new Scheme(""https"", socketFactory, 443));
           SingleClientConnManager mgr = new SingleClientConnManager(client.getParams(), registry);
           DefaultHttpClient httpClient = new DefaultHttpClient(mgr, client.getParams());

           // Set verifier      
           HttpsURLConnection.setDefaultHostnameVerifier(hostnameVerifier);


        HttpGet httpGet = new HttpGet(""https://api.twitter.com/1/statuses/user_timeline.json?include_entities=true&amp;include_rts=true&amp;screen_name=&lt;Your twitter account name&gt;"");
        try {
          HttpResponse response = httpClient.execute(httpGet);
          StatusLine statusLine = response.getStatusLine();
          int statusCode = statusLine.getStatusCode();
          if (statusCode == 200) {

            HttpEntity entity = response.getEntity();
            InputStream content = entity.getContent();
            BufferedReader reader = new BufferedReader(new InputStreamReader(content));
            String line;
            while ((line = reader.readLine()) != null) {
              builder.append(line);
            }
            JSONArray obj = new JSONArray(builder.toString());
            if (obj.getClass() == JSONArray.class){
                JSONArray  results = obj;
                for(int i = 0; i &lt; results.length(); i++){
                    JSONObject result = results.getJSONObject(i);

                    JSONObject user = result.getJSONObject(""user"");
                    if(((String) user.get(""screen_name"")).compareToIgnoreCase(""TNCVB"")== 0){
                        String name = user.getString(""screen_name"");
                        String text =result.getString(""text"");
                        String timestamp = result.getString(""created_at"");
                        //Put them in an object and add to array or something
                    }
                }
            }

                Intent nintent = new Intent(context, MyActivity.class);
                PendingIntent pintent = PendingIntent.getActivity(context, 0, nintent, 0);

                NotificationCompat.Builder mBuilder =
                        new NotificationCompat.Builder(context)
                        .setSmallIcon(R.drawable.ic_launcher)
                        .setContentTitle(""Update"")
                        .setContentIntent(pintent)
                        .setContentText(""New messages are available."");
                NotificationManager notificationManager = (NotificationManager) context.getSystemService(Context.NOTIFICATION_SERVICE);
                notificationManager.notify(007, mBuilder.build());
          } else {
            Log.e(""JSON Error:"", ""Failed to download file"");
          }
        } catch (ClientProtocolException e) {
          e.printStackTrace();
        } catch (IOException e) {
          e.printStackTrace();
        }catch(Exception e){

        }

    }
}
",4,0,4e84c8301677e316da535674ec25463544cc7148eb1a36d51ae736b3e2494c35
,"// use local trust store (CA)
TrustManagerFactory tmf;
KeyStore trustedStore = null;
InputStream in = context.getResources().openRawResource(R.raw.mycatruststore); // BKS in res/raw
trustedStore = KeyStore.getInstance(""BKS"");
trustedStore.load(in, ""insertBksPasswordHere"".toCharArray());
tmf = TrustManagerFactory.getInstance(""X509"");
tmf.init(trustedStore);

// load client certificate
KeyStore clientKeyStore = loadClientKeyStore(getApplicationContext());
KeyManagerFactory kmf = KeyManagerFactory.getInstance(""X509"");
kmf.init(clientKeyStore, ""insertPasswordHere"".toCharArray());

SSLContext context = SSLContext.getInstance(""TLS"");

// provide client cert - if server requires client cert this will pass
context.init(kmf.getKeyManagers(), tmf.getTrustManagers(), null);
HostnameVerifier hostnameVerifier = org.apache.http.conn.ssl.SSLSocketFactory.STRICT_HOSTNAME_VERIFIER;

// connect to url
URL u = new URL(""https://10.0.2.2:8888/"");
HttpsURLConnection urlConnection = (HttpsURLConnection) u.openConnection();
urlConnection.setSSLSocketFactory(context.getSocketFactory());
urlConnection.setHostnameVerifier(hostnameVerifier);
urlConnection.connect();
System.out.println(""Response Code: "" + urlConnection.getResponseCode());
",3,0,79c359e878a5a712999733b12f4c43f15832db4f5baa29d252ebedef817b4520
,"private KeyStore loadClientKeyStore(Context context) {
    InputStream in = context.getResources().openRawResource(R.yourKeyStoreFile);
    KeyStore trusted = null;
    trusted = KeyStore.getInstance(""BKS"");
    trusted.load(in, ""yourClientPassword"".toCharArray());
    in.close();
    return trusted;
}
",,1,5dd632b09efc36e73b6bba65856bc5a29a8d1b3fa0e77e81882216e92891eb0a
,"import java.util.Properties;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.transform.OutputKeys;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerConfigurationException;
import javax.xml.transform.TransformerException;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamResult;

import org.w3c.dom.Document;


public class XMLhelper
{
    private static String serializeDocument(Document doc)
    {
        String xml = null;
        try
        {
            TransformerFactory factory = TransformerFactory.newInstance();
            Transformer transformer = factory.newTransformer();
            Properties outFormat = new Properties();
            outFormat.setProperty( OutputKeys.INDENT, ""yes"" );
            outFormat.setProperty( OutputKeys.METHOD, ""xml"" );
            outFormat.setProperty( OutputKeys.OMIT_XML_DECLARATION, ""no"" );
            outFormat.setProperty( OutputKeys.VERSION, ""1.0"" );
            outFormat.setProperty( OutputKeys.ENCODING, ""UTF-8"" );
            transformer.setOutputProperties( outFormat );

            DOMSource domSource = new DOMSource( doc.getDocumentElement() );
            OutputStream output = new StringOutputStream();
            StreamResult result = new StreamResult( output );
            transformer.transform( domSource, result );

            xml = output.toString();
            android.util.Log.i( ""XMLHELPER"", xml );
        }
        catch (TransformerConfigurationException e)
        {
            android.util.Log.d( ""XMLHELPER"", ""Exception: "" + e );
            e.printStackTrace();
        }
        catch (TransformerException e)
        {
            android.util.Log.d( ""XMLHELPER"", ""Exception: "" + e );
            e.printStackTrace();
        }

        return xml;
    }
}
",,1,fea2994aad9fabebf472ef66738b7ae9dc1d246d6d2ad32fde346cb6f4785743
,"try {
PackageInfo info = getPackageManager().getPackageInfo(
      ""com.facebook.samples.loginhowto"", PackageManager.GET_SIGNATURES);
for (Signature signature : info.signatures){
       MessageDigest md = MessageDigest.getInstance(""SHA"");
       md.update(signature.toByteArray());
       Log.d(""KeyHash:"", Base64.encodeToString(md.digest(), Base64.DEFAULT));
}
} catch (NameNotFoundException e) {
} catch (NoSuchAlgorithmException e) {
}
",3,0,80910eef04cc4af9db8bad2a02d00611430f42be1eff794ec827119f7fa28d87
,"public class PreferredCipherSuiteSSLSocketFactory extends SSLSocketFactory {


private static final String PREFERRED_CIPHER_SUITE = ""TLS_RSA_WITH_AES_128_CBC_SHA"";

private final SSLSocketFactory delegate;

public PreferredCipherSuiteSSLSocketFactory(SSLSocketFactory delegate) {

    this.delegate = delegate;
}

@Override
public String[] getDefaultCipherSuites() {

    return setupPreferredDefaultCipherSuites(this.delegate);
}

@Override
public String[] getSupportedCipherSuites() {

    return setupPreferredSupportedCipherSuites(this.delegate);
}

@Override
public Socket createSocket(String arg0, int arg1) throws IOException,
        UnknownHostException {

    Socket socket = this.delegate.createSocket(arg0, arg1);
    String[] cipherSuites = setupPreferredDefaultCipherSuites(delegate);
    ((SSLSocket)socket).setEnabledCipherSuites(cipherSuites);

    return socket;
}

@Override
public Socket createSocket(InetAddress arg0, int arg1) throws IOException {

    Socket socket = this.delegate.createSocket(arg0, arg1);
    String[] cipherSuites = setupPreferredDefaultCipherSuites(delegate);
    ((SSLSocket)socket).setEnabledCipherSuites(cipherSuites);

    return socket;
}

@Override
public Socket createSocket(Socket arg0, String arg1, int arg2, boolean arg3)
        throws IOException {

    Socket socket = this.delegate.createSocket(arg0, arg1, arg2, arg3);
    String[] cipherSuites = setupPreferredDefaultCipherSuites(delegate);
    ((SSLSocket)socket).setEnabledCipherSuites(cipherSuites);

    return socket;
}

@Override
public Socket createSocket(String arg0, int arg1, InetAddress arg2, int arg3)
        throws IOException, UnknownHostException {

    Socket socket = this.delegate.createSocket(arg0, arg1, arg2, arg3);
    String[] cipherSuites = setupPreferredDefaultCipherSuites(delegate);
    ((SSLSocket)socket).setEnabledCipherSuites(cipherSuites);

    return socket;
}

@Override
public Socket createSocket(InetAddress arg0, int arg1, InetAddress arg2,
        int arg3) throws IOException {

    Socket socket = this.delegate.createSocket(arg0, arg1, arg2, arg3);
    String[] cipherSuites = setupPreferredDefaultCipherSuites(delegate);
    ((SSLSocket)socket).setEnabledCipherSuites(cipherSuites);

    return socket;
}

private static String[] setupPreferredDefaultCipherSuites(SSLSocketFactory sslSocketFactory) {

    String[] defaultCipherSuites = sslSocketFactory.getDefaultCipherSuites();

    ArrayList&lt;String&gt; suitesList = new ArrayList&lt;String&gt;(Arrays.asList(defaultCipherSuites));
    suitesList.remove(PREFERRED_CIPHER_SUITE);
    suitesList.add(0, PREFERRED_CIPHER_SUITE);

    return suitesList.toArray(new String[suitesList.size()]);
}

private static String[] setupPreferredSupportedCipherSuites(SSLSocketFactory sslSocketFactory) {

    String[] supportedCipherSuites = sslSocketFactory.getSupportedCipherSuites();

    ArrayList&lt;String&gt; suitesList = new ArrayList&lt;String&gt;(Arrays.asList(supportedCipherSuites));
    suitesList.remove(PREFERRED_CIPHER_SUITE);
    suitesList.add(0, PREFERRED_CIPHER_SUITE);

    return suitesList.toArray(new String[suitesList.size()]);
}
}
",1,0,21c94d914e867f8c52c85bd066a754b30dcf0de368141b85d18bd77ca2ce71e6
,"            HttpsURLConnection connection = (HttpsURLConnection) (new URL(url))
                .openConnection();
        SSLContext context = SSLContext.getInstance(""TLS"");
        TrustManager tm[] = {new SSLPinningTrustManager()};
        context.init(null, tm, null);
        SSLSocketFactory preferredCipherSuiteSSLSocketFactory = new PreferredCipherSuiteSSLSocketFactory(context.getSocketFactory());
        connection.setSSLSocketFactory(preferredCipherSuiteSSLSocketFactory);
                    connection.connect();
",,1,a391b42a059d2fc37481e22a7da8829414f633d60b5dccc445085923eac3d0d5
,"// open the certificate
keyStore = KeyStore.getInstance(""PKCS12"");
fis = new FileInputStream(certificateFile);
keyStore.load(fis, clientCertPassword.toCharArray());


// create the SSL context
KeyManagerFactory kmf = KeyManagerFactory.getInstance(""X509"");
kmf.init(keyStore, clientCertPassword.toCharArray());
KeyManager[] keyManagers = kmf.getKeyManagers();

TrustManagerFactory tmf = TrustManagerFactory.getInstance(""X509"");
tmf.init(trustStore);
TrustManager[] trustManagers = tmf.getTrustManagers();

SSLContext sslContext = SSLContext.getInstance(""TLS"");
sslContext.init(keyManagers, trustManagers, null);


// perform the HTTP request
String result = null;
HttpURLConnection urlConnection = null;

try {
    URL requestedUrl = new URL(url);
    urlConnection = (HttpURLConnection) requestedUrl.openConnection();
    if(urlConnection instanceof HttpsURLConnection) {
        ((HttpsURLConnection)urlConnection)
             .setSSLSocketFactory(sslContext.getSocketFactory());
    }
    urlConnection.setRequestMethod(""GET"");
    urlConnection.setConnectTimeout(1500);
    urlConnection.setReadTimeout(1500);
    lastResponseCode = urlConnection.getResponseCode();
    result = IOUtil.readFully(urlConnection.getInputStream());
    lastContentType = urlConnection.getContentType();
} catch(Exception ex) {
    result = ex.toString();
} finally {
    if(urlConnection != null) {
        urlConnection.disconnect();
    }
}
",3,0,257870ea9bef1f352bf622d372ae212483f506dba9eb21569df7b1b18c004446
,"byte[] keyBytes = Base64.decode(publicK.getBytes(""utf-8""));
X509EncodedKeySpec spec = new X509EncodedKeySpec(keyBytes);
KeyFactory keyFactory = KeyFactory.getInstance(""RSA"");
PublicKey key = keyFactory.generatePublic(spec);
",2,0,2fe41b3ebf83ffe62e6fbd403511eaa9471b6bc18cb1a9b96d3bf0835be7344e
,"byte[] keyBytes = Base64.decode(privateK.getBytes(""utf-8""));
PKCS8EncodedKeySpec keySpec = new PKCS8EncodedKeySpec(clear);
KeyFactory fact = KeyFactory.getInstance(""RSA"");
PrivateKey priv = fact.generatePrivate(keySpec);
",3,0,a3c94ab180ca9aeb27252956fe917092375779251b92d2c1eb8f0a9fa6843ceb
,"try {
        PackageInfo info = getPackageManager().getPackageInfo(
                ""com.facebook.samples.hellofacebook"", 
                PackageManager.GET_SIGNATURES);
        for (Signature signature : info.signatures) {
            MessageDigest md = MessageDigest.getInstance(""SHA"");
            md.update(signature.toByteArray());
            Log.d(""KeyHash:"", Base64.encodeToString(md.digest(), Base64.DEFAULT));
            }
    } catch (NameNotFoundException e) {

    } catch (NoSuchAlgorithmException e) {

    }
",2,0,5f82118bd24a9547efffca9a5c48aecda0aabdec241c1f0a4d1255f70d9d29cd
,"    public static SignedRequestResponse parse_signed_request(String input, String secret, int max_age) {
        String[] split = input.split(""[.]"", 2);
        SignedRequestResponse response = new SignedRequestResponse();
        response.setStatus(Status.Failure);

        String encoded_sig = split[0];
        String encoded_envelope = split[1];
        JSONParser parser = new JSONParser();
        Map envelope;
        try {
            envelope = (Map) parser.parse(new String(base64_url_decode(encoded_envelope)));
        } catch (Exception ex) {
            response.addError(""ParsingError"");
            return response;
        }

        response.setEnvelope(envelope);

        String algorithm = (String) envelope.get(""algorithm"");

        if (!algorithm.equals(""HMAC-SHA256"")) {
            response.addError(""UnsupportedAlgorithm"");
            return response;    // instant fail
        }

        byte[] key = secret.getBytes();
        SecretKey hmacKey = new SecretKeySpec(key, ""HMACSHA256"");
        Mac mac = null;
        try {
            mac = Mac.getInstance(""HMACSHA256"");
            mac.init(hmacKey);
        } catch (Exception e) {
            response.addError(""DecryptionError"");
            return response; // instant fail
        }

        byte[] digest = mac.doFinal(encoded_envelope.getBytes());
        try {

            if (!Arrays.equals(base64_url_decode(encoded_sig), digest)) {
                response.addError(""InvalidSignature"");
                return response; // instant fail
            }
        } catch (Exception ex) {
            response.addError(""InvalidSignature"");
            return response; // instant fail
        }

        if (((Long) envelope.get(""issued_at"")) &lt; System.currentTimeMillis() / 1000 - max_age) {
            response.addError(""Expired"");
            response.setStatus(Status.PartialSuccess);
            return response;    // partial fail
        }

        response.setStatus(Status.Success);
        return response;
    }
}
",2,0,9e384ace273a1e93457aae45f6fba4de32bd2518a2abf76631b3aaff6e5c6555
,"private static String convertToHex(byte[] data) {
    StringBuilder buf = new StringBuilder();
    for (byte b : data) {
        int halfbyte = (b &gt;&gt;&gt; 4) &amp; 0x0F;
        int two_halfs = 0;
        do {
            buf.append((0 &lt;= halfbyte) &amp;&amp; (halfbyte &lt;= 9) ? (char) ('0' + halfbyte) : (char) ('a' + (halfbyte - 10)));
            halfbyte = b &amp; 0x0F;
        } while (two_halfs++ &lt; 1);
    }
    return buf.toString();
}

public static String SHA1(String text) throws NoSuchAlgorithmException, UnsupportedEncodingException {
    MessageDigest md = MessageDigest.getInstance(""SHA-1"");
    md.update(text.getBytes(""iso-8859-1""), 0, text.length());
    byte[] sha1hash = md.digest();
    return convertToHex(sha1hash);
}
",2,0,684a5544ccb85eb4cbef6a381a7c7db400373bb168b1e6333e78879e56a81fa3
,"public static String encrypt(String inputString, byte[] keyBytes) {
        Calendar cal = Calendar.getInstance();
        int mDay = cal.get(Calendar.DAY_OF_MONTH);
        // System.out.println(""Day of month :::"" + mDay);
        String encryptedString = """";
        Key publicKey = null;
        try {
            Random generator = new Random(mDay);
            int num = (generator.nextInt()) % 100;
            String salt = ""MNSadm563784"" + num;
            //inputString += salt;
            X509EncodedKeySpec publicKeySpec = new X509EncodedKeySpec(keyBytes);
            KeyFactory keyFactory = KeyFactory.getInstance(""RSA"");
            publicKey = keyFactory.generatePublic(publicKeySpec);
        } catch (Exception e) {
            System.out.println(""Exception rsaEncrypt:::::::::::::::::  ""
                    + e.getMessage());
            e.printStackTrace();
        }
        // Encode the original data with RSA public key
        byte[] encodedBytes = null;
        try {
            Cipher c = Cipher.getInstance(""RSA"");
            c.init(Cipher.ENCRYPT_MODE, publicKey);
            encodedBytes = c.doFinal(inputString.getBytes());
            encryptedString = Base64.encodeToString(encodedBytes,
                    Base64.NO_CLOSE);
            System.out.print(""-----??""+encryptedString+""??-------"");
        } catch (Exception e) {
            System.out.println(""Exception rsaEncrypt:::::::::::::::::  ""
                    + e.getMessage());
            e.printStackTrace();
        }

        return encryptedString;
    }
",4,0,8b1708d6c958b20af82d93ca28f8586f18251f8e9ae251497c7a7803a6a1d6e1
,"public static String decrypt(String inputString, byte[] keyBytes) {
        String resultStr = null;
//      Calendar cal = Calendar.getInstance();
//      int mDay = cal.get(Calendar.DAY_OF_MONTH);
//      Random generator = new Random(mDay);
//      int num = (generator.nextInt()) % 100;
//      String salt = ""MNSadm563784"" + num;
        PrivateKey privateKey = null;
        try {
            KeyFactory keyFactory = KeyFactory.getInstance(""RSA"");
            EncodedKeySpec privateKeySpec = new PKCS8EncodedKeySpec(
                    keyBytes);
            privateKey = keyFactory.generatePrivate(privateKeySpec);
        } catch (Exception e) {
            System.out.println(""Exception privateKey:::::::::::::::::  ""
                    + e.getMessage());
            e.printStackTrace();
        }
        byte[] decodedBytes = null;
        try {
            Cipher c = Cipher.getInstance(""RSA/ECB/NoPadding"");
            // Cipher c = Cipher.getInstance(""RSA"");
            c.init(Cipher.DECRYPT_MODE, privateKey);
            decodedBytes = c.doFinal(Base64.decodeBase64(inputString));
            // decodedBytes = c.doFinal(Base64InputStream());

        } catch (Exception e) {
            System.out.println(""Exception privateKey1:::::::::::::::::  ""
                    + e.getMessage());
            e.printStackTrace();
        }
        if (decodedBytes != null) {
            resultStr = new String(decodedBytes);
            System.out.println(""resultStr:::"" + resultStr + "":::::"");
//          resultStr = resultStr.replace(salt, """");
        }
        return resultStr;

    }
",4,0,fa0cfd21765d4058a04e6621e7292c68b0503051befb613ffe1ef08028036c68
,"    PEMWriter writer = new PEMWriter(new FileWriter(""test.pem""));
    KeyPairGenerator kpg = KeyPairGenerator.getInstance(""RSA"");
    kpg.initialize(3072);
    KeyPair keyPair = kpg.generateKeyPair();
    writer.writeObject(keyPair.getPublic());
    writer.close();
",2,0,10c9735db29099a07d2b03d04ea7b7a32657df502a5571ecfb84f212ac59e086
,"</p>

<pre><code>/**
 * &lt;p&gt;Title: RSA Security&lt;/p&gt;
 * Description: This class generates a RSA private and public key, reinstantiates
 * the keys from the corresponding key files.It also generates compatible .Net Public Key,
 * which we will read later in C# program using .Net Securtiy Framework
 * The reinstantiated keys are used to sign and verify the given data.&lt;/p&gt;
 *
 * @author Shaheryar
 * @version 1.0
 */

import java.security.*;
import java.security.spec.*;
import java.io.*;
import java.security.interfaces.*;
import java.security.cert.*;
import javax.xml.transform.stream.*;
import javax.xml.transform.dom.*;
import javax.xml.transform.*;
import org.w3c.dom.*;
import javax.xml.parsers.*;
import sun.misc.BASE64Decoder;
import sun.misc.BASE64Encoder;

public class SecurityManager {

  private KeyPairGenerator keyGen; //Key pair generator for RSA
  private PrivateKey privateKey; // Private Key Class
  private PublicKey publicKey; // Public Key Class
  private KeyPair keypair; // KeyPair Class
  private Signature sign; // Signature, used to sign the data
  private String PRIVATE_KEY_FILE; // Private key file.
  private String PUBLIC_KEY_FILE; // Public key file.
  private String DOT_NET_PUBLIC_KEY_FILE; // File to store .Net Compatible Key Data

  /**
   * Default Constructor. Instantiates the key paths and signature algorithm.
 * @throws IOException 
 * @throws InvalidKeySpecException 
 * @throws NoSuchAlgorithmException 
   */
  public SecurityManager() throws NoSuchAlgorithmException, InvalidKeySpecException, IOException {

  }


  public static void main(String args[]) throws NoSuchAlgorithmException, InvalidKeySpecException, IOException{
      GenerateDotNetKey(""MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAp6340BNzismmb/n98sTcYfNEmmzNGumdWnK1e7NNWntM6mjZMnQaVZ9HiJKmMgtn69dAU4gaMVUWACDsuup1GBxN8dLgDbtR26M0u1jf1G8AQehcKfqxqSYzxKquXXotffdYsJPpjseZbi96Y7j47kz9CjNP3y1BzjJNTWQUx9fc9e2Bpsi0GtqJ8porPBuIGTjcCnlKM14tIv6YlHtECW1L1wcOBkoj/5liI1nhlYDth/DNXg1OY11JqIIP1fO2vQPtKEpdtcTBTjmB9M45O1N8K/shTcMntFjwVTpL0hRd+eaN1bUjpMvrhFik0VcF/ZNN6Hn0Coqe+ey18dLosQIDAQAB"");
  }
  public static void GenerateDotNetKey(String base64PubKey)
          throws IOException, NoSuchAlgorithmException,
          InvalidKeySpecException {
      /*
       * String base64PubKey - 
       * Is a Key retrieved from Google Checkout Merchant Account
       */
      BASE64Decoder decoder = new BASE64Decoder();

      byte[] publicKeyBytes = decoder.decodeBuffer(base64PubKey);

      EncodedKeySpec publicKeySpec = new X509EncodedKeySpec(publicKeyBytes);
      RSAPublicKey publicKey = (RSAPublicKey) KeyFactory.getInstance(""RSA"").generatePublic(publicKeySpec);

      byte[] modulusBytes = publicKey.getModulus().toByteArray();
      byte[] exponentBytes = publicKey.getPublicExponent().toByteArray();

      modulusBytes = stripLeadingZeros1(modulusBytes);

      BASE64Encoder encoder = new BASE64Encoder();
      String modulusB64 = encoder.encode(modulusBytes);
      String exponentB64 = encoder.encode(exponentBytes);
int i=0;
     // return new DotNetRSA(modulusB64, exponentB64);
  }

    private static byte[] stripLeadingZeros1(byte[] a) {
      int lastZero = -1;
      for (int i = 0; i &lt; a.length; i++) {
        if (a[i] == 0) {
          lastZero = i;
        }
        else {
          break;
        }
      }
      lastZero++;
      byte[] result = new byte[a.length - lastZero];
      System.arraycopy(a, lastZero, result, 0, result.length);
      return result;
    }


  }
",,1,f619df0197f42479885a69736cc9b5496d1bd5cb9385689ba4d23546c3d1c8d0
,"public String calcHmac(String src) throws Exception {

    String key = ""d6fc3a4a06ed55d24fecde188aaa9161"";
    Mac mac = Mac.getInstance(""HmacSHA1"");
    SecretKeySpec sk = new SecretKeySpec(key.getBytes(),mac.getAlgorithm());  
    mac.init(sk);
    byte[] result = mac.doFinal(src.getBytes());


    return Base64.encodeToString(result ,Base64.URL_SAFE);
}
",3,0,5d2dadab3ca055bb8a4bb979499bfd35059057dc7b849375570bfc5e46d2bda7
,"     try {
    PackageInfo info = getPackageManager().getPackageInfo(
            ""your.application.package.name"",
            PackageManager.GET_SIGNATURES);
    for (Signature signature : info.signatures) {
        MessageDigest md = MessageDigest.getInstance(""SHA"");
        md.update(signature.toByteArray());
        Log.d(""KeyHash:"", Base64.encodeToString(md.digest(), Base64.DEFAULT));
    }
} catch (PackageManager.NameNotFoundException e) {

} catch (NoSuchAlgorithmException e) {
 }
",3,0,2a8062099ac13a5bf20d5cd6b564f7a7ddca7f08d70dbd74591d733a90aa2148
,"static void encrypt() throws IOException, NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException {
    // Here you read the cleartext.
    FileInputStream fis = new FileInputStream(""data/cleartext"");
    // This stream write the encrypted text. This stream will be wrapped by another stream.
    FileOutputStream fos = new FileOutputStream(""data/encrypted"");

    // Length is 16 byte
    SecretKeySpec sks = new SecretKeySpec(""MyDifficultPassw"".getBytes(), ""AES"");
    // Create cipher
    Cipher cipher = Cipher.getInstance(""AES"");
    cipher.init(Cipher.ENCRYPT_MODE, sks);
    // Wrap the output stream
    CipherOutputStream cos = new CipherOutputStream(fos, cipher);
    // Write bytes
    int b;
    byte[] d = new byte[8];
    while((b = fis.read(d)) != -1) {
        cos.write(d, 0, b);
    }
    // Flush and close streams.
    cos.flush();
    cos.close();
    fis.close();
}
",4,0,7cfa4821dd83d0f0ec8a396738a3e2a7247513667752c85fcd87c35e90afba75
,"static void decrypt() throws IOException, NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException {
    FileInputStream fis = new FileInputStream(""data/encrypted"");

    FileOutputStream fos = new FileOutputStream(""data/decrypted"");
    SecretKeySpec sks = new SecretKeySpec(""MyDifficultPassw"".getBytes(), ""AES"");
    Cipher cipher = Cipher.getInstance(""AES"");
    cipher.init(Cipher.DECRYPT_MODE, sks);
    CipherInputStream cis = new CipherInputStream(fis, cipher);
    int b;
    byte[] d = new byte[8];
    while((b = cis.read(d)) != -1) {
        fos.write(d, 0, b);
    }
    fos.flush();
    fos.close();
    cis.close();
}
",2,0,8d9b98893953b38e827d6e7fe2188946237e5f1efbebf973c0f9c6a2f8d2f74f
,"FileInputStream fis;
FileOutputStream fos;
CipherOutputStream cos;
// File you are reading from
fis = new FileInputStream(""/tmp/a.txt"");
// File output
fos = new FileOutputStream(""/tmp/b.txt"");

// Here the file is encrypted. The cipher1 has to be created.
// Key Length should be 128, 192 or 256 bit =&gt; i.e. 16 byte
SecretKeySpec skeySpec = new SecretKeySpec(""MyDifficultPassw"".getBytes(), ""AES""); 
Cipher cipher1 = Cipher.getInstance(""AES"");  
cipher1.init(Cipher.ENCRYPT_MODE, skeySpec);
cos = new CipherOutputStream(fos, cipher1);
// Here you read from the file in fis and write to cos.
byte[] b = new byte[8];
int i = fis.read(b);
while (i != -1) {
    cos.write(b, 0, i);
    i = fis.read(b);
}
cos.flush();
",,1,4ba516679714debcd1ce331ce01d34dafcdd107ec6bdac19ff8436040b5c524d
,"final PackageManager packageManager = context.getPackageManager();
final List&lt;PackageInfo&gt; packageList = packageManager.getInstalledPackages(PackageManager.GET_SIGNATURES);
CertificateFactory certFactory = null;
try {
    certFactory = CertificateFactory.getInstance(""X509"");
}
catch (CertificateException e) {
    // e.printStackTrace();
}

for (PackageInfo p : packageList) {
    String strName = p.applicationInfo.loadLabel(packageManager).toString();
    String strVendor = p.packageName;

    sb.append(""&lt;br&gt;"" + strName + "" / "" + strVendor + ""&lt;br&gt;"");

    Signature[] arrSignatures = p.signatures;
    for (Signature sig : arrSignatures) {
        /*
        * Get the X.509 certificate.
        */
        byte[] rawCert = sig.toByteArray();
        InputStream certStream = new ByteArrayInputStream(rawCert);

        X509Certificate x509Cert = null;
        try {
            x509Cert = (X509Certificate) certFactory.generateCertificate(certStream);
        }
        catch (CertificateException e) {
            // e.printStackTrace();
        }

        sb.append(""Certificate subject: "" + x509Cert.getSubjectDN() + ""&lt;br&gt;"");
        sb.append(""Certificate issuer: "" + x509Cert.getIssuerDN() + ""&lt;br&gt;"");
        sb.append(""Certificate serial number: "" + x509Cert.getSerialNumber() + ""&lt;br&gt;"");
        sb.append(""&lt;br&gt;"");
    }
}
",,1,2795c664753c454c836bbed51b3334f05bb79738f16b7b6b1d00598024da6669
,"public String WriteSignature(String packageName)
{     
   PackageManager pm = this.getPackageManager();
   String sig = """"; 
   PackageInfo pi = null;
   try {
       pi = pm.getPackageInfo(packageName, PackageManager.GET_SIGNATURES);
   } catch (NameNotFoundException e1) {
       e1.printStackTrace();
   }

   try {
       for (Signature signature : pi.signatures) {
           MessageDigest md = MessageDigest.getInstance(""SHA"");
           md.update(signature.toByteArray());
           sig = Base64.encodeToString(md.digest(), Base64.DEFAULT);
           Log.d(ACTIVITY_TAG, sig);
       }
   } catch (NoSuchAlgorithmException e) {
       e.printStackTrace();
   }

   return sig;
}
",3,0,0281d174b2663e28d2e663295803c243f3993cc0958326b1c947b30df841d60e
,"import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.DESKeySpec;
import android.util.Base64;

public class SimpleCrypto {

    private String charsetName = ""UTF8"";
    private String algorithm = ""DES"";
    private int base64Mode = Base64.DEFAULT;

    public String getCharsetName() {
        return charsetName;
    }

    public void setCharsetName(String charsetName) {
        this.charsetName = charsetName;
    }

    public String getAlgorithm() {
        return algorithm;
    }

    public void setAlgorithm(String algorithm) {
        this.algorithm = algorithm;
    }

    public int getBase64Mode() {
        return base64Mode;
    }

    public void setBase64Mode(int base64Mode) {
        this.base64Mode = base64Mode;
    }

    public String encrypt(String key, String data) {
        if (key == null || data == null)
            return null;
        try {
            DESKeySpec desKeySpec = new DESKeySpec(key.getBytes(charsetName));
            SecretKeyFactory secretKeyFactory = SecretKeyFactory.getInstance(algorithm);
            SecretKey secretKey = secretKeyFactory.generateSecret(desKeySpec);
            byte[] dataBytes = data.getBytes(charsetName);
            Cipher cipher = Cipher.getInstance(algorithm);
            cipher.init(Cipher.ENCRYPT_MODE, secretKey);
            return Base64.encodeToString(cipher.doFinal(dataBytes), base64Mode);
        } catch (Exception e) {
            return null;
        }
    }

    public String decrypt(String key, String data) {
        if (key == null || data == null)
            return null;
        try {
            byte[] dataBytes = Base64.decode(data, base64Mode);
            DESKeySpec desKeySpec = new DESKeySpec(key.getBytes(charsetName));
            SecretKeyFactory secretKeyFactory = SecretKeyFactory.getInstance(algorithm);
            SecretKey secretKey = secretKeyFactory.generateSecret(desKeySpec);
            Cipher cipher = Cipher.getInstance(algorithm);
            cipher.init(Cipher.DECRYPT_MODE, secretKey);
            byte[] dataBytesDecrypted = (cipher.doFinal(dataBytes));
            return new String(dataBytesDecrypted);
        } catch (Exception e) {
            return null;
        }
    }
}
",4,0,18c9e5d6655101de0abaafd0b465d80a791b3bc45ee4a79356783071db884c84
," // encryption
              DESKeySpec keySpec = new DESKeySpec(
                      ""123456789123456789"".getBytes(""UTF8""));
              SecretKeyFactory keyFactory = SecretKeyFactory
                      .getInstance(""DES"");
              SecretKey key = keyFactory.generateSecret(keySpec);

          // BASE64Decoder base64decoder = new BASE64Decoder();
          // Base64.

          // ENCODE plainTextPassword String
          byte[] cleartext = pass.getBytes(""UTF8"");

          Cipher cipher = Cipher.getInstance(""DES""); // cipher is not
                                                      // thread safe
          cipher.init(Cipher.ENCRYPT_MODE, key);

          cleartext = Base64.encode(cipher.doFinal(cleartext), 0);
          String enstr = new String(cleartext);
          Log.e(""Encrypted password"", enstr);
",4,0,1089d6866d8e937d3b698fad6cb641612b2fdc3f2e93f663f4d167736a873730
,"public class MessageUtil {
      private final static String AUTH = ""authentication"";

      private static final String UPDATE_CLIENT_AUTH = ""Update-Client-Auth"";

      public static final String PARAM_REGISTRATION_ID = ""registration_id"";

      public static final String PARAM_DELAY_WHILE_IDLE = ""delay_while_idle"";

      public static final String PARAM_COLLAPSE_KEY = ""collapse_key"";

      private static final String UTF8 = ""UTF-8"";

      public static int sendMessage(String auth_token, String registrationId,
          String message) throws IOException {

        StringBuilder postDataBuilder = new StringBuilder();
        postDataBuilder.append(PARAM_REGISTRATION_ID).append(""="")
            .append(registrationId);
        postDataBuilder.append(""&amp;"").append(PARAM_COLLAPSE_KEY).append(""="")
            .append(""0"");
        postDataBuilder.append(""&amp;"").append(""data.payload"").append(""="")
            .append(URLEncoder.encode(message, UTF8));

        byte[] postData = postDataBuilder.toString().getBytes(UTF8);

        // Hit the dm URL.

        URL url = new URL(""https://android.clients.google.com/c2dm/send"");
        HttpsURLConnection
            .setDefaultHostnameVerifier(new CustomizedHostnameVerifier());
        HttpsURLConnection conn = (HttpsURLConnection) url.openConnection();
        conn.setDoOutput(true);
        conn.setUseCaches(false);
        conn.setRequestMethod(""POST"");
        conn.setRequestProperty(""Content-Type"",
            ""application/x-www-form-urlencoded;charset=UTF-8"");
        conn.setRequestProperty(""Content-Length"",
            Integer.toString(postData.length));
        conn.setRequestProperty(""Authorization"", ""GoogleLogin auth=""
            + auth_token);

        OutputStream out = conn.getOutputStream();
        out.write(postData);
        out.close();

        int responseCode = conn.getResponseCode();
        return responseCode;
      }

      private static class CustomizedHostnameVerifier implements HostnameVerifier {
        public boolean verify(String hostname, SSLSession session) {
          return true;
        }
      }
 } 
",4,0,9b51714b2320d707f668313a3ac6b0f0a45f77bc762d37e597c048a13c7af38b
,"    private void generateHashKey() {
    // Add code to print out the key hash
    try {
        PackageInfo info = getPackageManager().getPackageInfo(
                ""your.package.name"", PackageManager.GET_SIGNATURES);
        for (Signature signature : info.signatures) {
            MessageDigest md = MessageDigest.getInstance(""SHA"");
            md.update(signature.toByteArray());
            System.out.println(""KeyHash:"" + Base64.encodeToString(md.digest(),Base64.DEFAULT));
        }
    } catch (NameNotFoundException e) {

    } catch (NoSuchAlgorithmException e) {

    }
}
",3,0,7cdf5e22df11dc17b288b6b4447638abd447e01e75a0e0dd7f63ccbfd8ed1dc7
,"import javax.crypto.spec.IvParameterSpec
import javax.crypto.spec.SecretKeySpec
import javax.crypto.Cipher

ext {
    KEY = ""mysecretkey"".padRight(16).getBytes(""UTF-8"")
    SERVERKEY = ""serverkey""
    IV = ""1234"".padRight(16).getBytes(""UTF-8"")
    PROVIDER = ""SunJCE""
}

task encIt &lt;&lt; {
    SecretKeySpec key = new SecretKeySpec(KEY, ""AES"")
    Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"", PROVIDER)
    cipher.init(Cipher.ENCRYPT_MODE, key, new IvParameterSpec(IV))
    def encBytes = cipher.doFinal(SERVERKEY.bytes)
    def out = file('obf.enc')
    out.delete()
    out &lt;&lt; encBytes
}

task decIt &lt;&lt; {
    def cipherText = file('obf.enc').bytes
    Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"", PROVIDER)
    SecretKeySpec key = new SecretKeySpec(KEY, ""AES"")
    cipher.init(Cipher.DECRYPT_MODE, key, new IvParameterSpec(IV))
    println new String(cipher.doFinal(cipherText), ""UTF-8"")
}
",,1,1bc2a22eec0ae553bbd7749155a90fbf08cb73a707b6895014eb25610663e2b7
,"public static String hashKeyForDisk(String key) {
    String cacheKey;
    try {
        final MessageDigest mDigest = MessageDigest.getInstance(""MD5"");
        mDigest.update(key.getBytes());
        cacheKey = bytesToHexString(mDigest.digest());
    } catch (NoSuchAlgorithmException e) {
        cacheKey = String.valueOf(key.hashCode());
    }
    return cacheKey;
}

private static String bytesToHexString(byte[] bytes) {
    StringBuilder sb = new StringBuilder();
    for (int i = 0; i &lt; bytes.length; i++) {
        String hex = Integer.toHexString(0xFF &amp; bytes[i]);
        if (hex.length() == 1) {
            sb.append('0');
        }
        sb.append(hex);
    }
    return sb.toString();
}
",,1,f9255cbfbd6b69e69d14932455cf545888ff7357648010c9a720353e57e1b952
,"private void genKey() {
        // TODO Auto-generated method stub
        Context context = this;
        final Dialog myDialog = new Dialog(context);

        myDialog.setContentView(R.layout.dialog);

        myDialog.setTitle(""enter key"");

        key_edt = (EditText) myDialog.findViewById(R.id.dg_key_tv);
        Button ok_btn = (Button) myDialog.findViewById(R.id.dg_ok_btn);
        Button cancel_btn = (Button) myDialog.findViewById(R.id.dg_cancel_btn);

        Log.d(TAG1, key_str);

        ok_btn.setOnClickListener(new OnClickListener() {

            @Override
            public void onClick(View v) {
                // TODO Auto-generated method stub

                key_str = key_edt.getText().toString();

                // only try to create the Key Spec now we have our key string
                // first check to make sure it's not blank
                if(key_str != null &amp;&amp; !key_str.isEmpty()){
                    try {
                        SecureRandom sr = SecureRandom.getInstance(""SHA1PRNG"");
                        sr.setSeed(key_str.getBytes());

                        KeyGenerator kg = KeyGenerator.getInstance(""AES"");
                        kg.init(128, sr);
                        this.sks = new SecretKeySpec((kg.generateKey()).getEncoded(), ""AES"");
                        Log.i(""encrypt"", sks.toString());

                    } catch (Exception e) {
                        Log.e(TAG, ""AES secret key spec error"");
                    }
                }
                else{   // string is empty
                    // make some toast to alert user
                }
            }
        });

        cancel_btn.setOnClickListener(new OnClickListener() {

            @Override
            public void onClick(View v) {
                // TODO Auto-generated method stub
                myDialog.dismiss();
            }
        });
        myDialog.show();

    }
",3,0,bb4774fa16e52c546d6ef3ad066e83aee9a1fedd9f2d174a0e4528ab0aafe11a
,"private void encrypt() {
    if (this.sks == null){
        // make toast and tell user to generate the key
    } else {
        try {
            Cipher c = Cipher.getInstance(""AES"");
            // use the class key spec to encrypt
            c.init(Cipher.ENCRYPT_MODE, this.sks);
            encodedBytes = c.doFinal(getData_str.getBytes());
            String encoded = Base64
                    .encodeToString(encodedBytes, Base64.DEFAULT);
            System.out.println("" "" + encoded);
        } catch (Exception e) {
            Log.e(TAG, ""AES encryption error"");
        }
    }
}
",4,0,6df81532c8d2d47462b4191af7826cc341c1fd96fa29c89c3f6fe997d31f8199
,"try {
   PackageInfo info = getPackageManager().getPackageInfo(""**YOURPACKAGENAME**"", PackageManager.GET_SIGNATURES);
   for (Signature signature : info.signatures) {
        MessageDigest md = MessageDigest.getInstance(""SHA"");
        md.update(signature.toByteArray());
        Log.i(""PXR"", Base64.encodeBytes(md.digest()));
   }
}
catch (NameNotFoundException e) {}
catch (NoSuchAlgorithmException e) {}
",3,0,8f6857fb2b1972048ede819786d89004cdb2369f33b322bca8bd63d99da69cb5
,"public void PrintInstalledCertificates( ){

    try 
    {
        KeyStore ks = KeyStore.getInstance(""AndroidCAStore"");
        if (ks != null) 
        {
            ks.load(null, null);
            Enumeration&lt;String&gt; aliases = ks.aliases();
            while (aliases.hasMoreElements()) 
            {
                String alias = (String) aliases.nextElement();
                java.security.cert.X509Certificate cert = (java.security.cert.X509Certificate) ks.getCertificate(alias);

                //To print System Certs only
                if(cert.getIssuerDN().getName().contains(system))
                {
                    System.out.println(cert.getIssuerDN().getName());
                }

                //To print User Certs only 
                if(cert.getIssuerDN().getName().contains(user))
                {
                    System.out.println(cert.getIssuerDN().getName());
                }

                //To print all certs
                System.out.println(cert.getIssuerDN().getName());                           
            }
        }
    } catch (IOException e) {
        e.printStackTrace();
    } catch (KeyStoreException e) {
        e.printStackTrace();
    } catch (NoSuchAlgorithmException e) {
        e.printStackTrace();
    } catch (java.security.cert.CertificateException e) {
        e.printStackTrace();
    }               
}
",,1,6632c4c92b735fa47535416f8a65d2e0dd91cee52b8efa15f4fea6addf813b4a
,"public boolean checkCACertificateInstalled(javax.security.cert.X509Certificate x509){

    boolean isCACertificateInstalled = false;

    try 
    {
        String name = x509.getIssuerDN().getName(); 
        KeyStore ks = KeyStore.getInstance(""AndroidCAStore"");
        if (ks != null) 
        {
            ks.load(null, null);
            Enumeration&lt;String&gt; aliases = ks.aliases();
            while (aliases.hasMoreElements()) 
            {
                String alias = (String) aliases.nextElement();
                java.security.cert.X509Certificate cert = (java.security.cert.X509Certificate) ks.getCertificate(alias);

                if (cert.getIssuerDN().getName().contains(name)) 
                {
                    isCACertificateInstalled = true;
                    break;
                }
            }
        }
    } catch (IOException e) {
        e.printStackTrace();
    } catch (KeyStoreException e) {
        e.printStackTrace();
    } catch (NoSuchAlgorithmException e) {
        e.printStackTrace();
    } catch (java.security.cert.CertificateException e) {
        e.printStackTrace();
    }

    return isCACertificateInstalled;
}
",,1,90ad2dc1a2c36dfc21012f872557cf9492f4b2dd14ec74b0b8fa61ac9be8a920
,"import java.io.IOException;
import java.net.Socket;
import java.net.UnknownHostException;
import java.security.KeyManagementException;
import java.security.KeyStore;
import java.security.KeyStoreException;
import java.security.NoSuchAlgorithmException;
import java.security.UnrecoverableKeyException;
import java.security.cert.CertificateException;
import java.security.cert.X509Certificate;

import javax.net.ssl.SSLContext;
import javax.net.ssl.TrustManager;
import javax.net.ssl.X509TrustManager;

import org.apache.http.HttpVersion;
import org.apache.http.conn.ClientConnectionManager;
import org.apache.http.conn.scheme.PlainSocketFactory;
import org.apache.http.conn.scheme.Scheme;
import org.apache.http.conn.scheme.SchemeRegistry;
import org.apache.http.conn.ssl.SSLSocketFactory;
import org.apache.http.impl.client.DefaultHttpClient;
import org.apache.http.impl.conn.tsccm.ThreadSafeClientConnManager;
import org.apache.http.params.BasicHttpParams;
import org.apache.http.params.HttpParams;
import org.apache.http.params.HttpProtocolParams;
import org.apache.http.protocol.HTTP;

public class MySSLSocketFactory extends SSLSocketFactory {
    SSLContext sslContext = SSLContext.getInstance(""TLS"");

    public MySSLSocketFactory(KeyStore truststore) throws NoSuchAlgorithmException, KeyManagementException, KeyStoreException, UnrecoverableKeyException {
        super(truststore);

        TrustManager tm = new X509TrustManager() {
            public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {
            }

            public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {
            }

            public X509Certificate[] getAcceptedIssuers() {
                return null;
            }
        };

        sslContext.init(null, new TrustManager[] { tm }, null);
    }

    @Override
    public Socket createSocket(Socket socket, String host, int port, boolean autoClose) throws IOException, UnknownHostException {
        return sslContext.getSocketFactory().createSocket(socket, host, port, autoClose);
    }

    @Override
    public Socket createSocket() throws IOException {
        return sslContext.getSocketFactory().createSocket();
    }


public static DefaultHttpClient getNewHttpClient() {
    try {
        KeyStore trustStore = KeyStore.getInstance(KeyStore.getDefaultType());
        trustStore.load(null, null);

        SSLSocketFactory sf = new MySSLSocketFactory(trustStore);
        sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);

        HttpParams params = new BasicHttpParams();
        HttpProtocolParams.setVersion(params, HttpVersion.HTTP_1_1);
        HttpProtocolParams.setContentCharset(params, HTTP.UTF_8);

        SchemeRegistry registry = new SchemeRegistry();
        registry.register(new Scheme(""http"", PlainSocketFactory.getSocketFactory(), 80));
        registry.register(new Scheme(""https"", sf, 443));

        ClientConnectionManager ccm = new ThreadSafeClientConnManager(params, registry);

        return new DefaultHttpClient(ccm, params);
    } catch (Exception e) {
        return new DefaultHttpClient();
    }
}
}
",4,0,9718623ecdc792769adee2249275e1721682ea5db653e28dd2029bfc4f47ebf4
,"    try {

           PackageInfo info = getPackageManager().getPackageInfo(""Your.packet.name"",PackageManager.GET_SIGNATURES);

           for (Signature signature : info.signatures) {
              MessageDigest md = MessageDigest.getInstance(""SHA"");
              md.update(signature.toByteArray());
              Log.d(""KeyHash:"", Base64.encodeToString(md.digest(), Base64.DEFAULT));
           }

    } catch (NameNotFoundException e) {

    } catch (NoSuchAlgorithmException e) {

    }
",3,0,0b805903c7b04b05d10883e6fde7267a909660da41f5ae3103c2cf7e857b78ac
,"public class ChooseTeamActivity extends ListActivity {

    private static final String apiKey = ""4545ggg454hfnf7557kfdkgg454""; 
    private static final String apiUser = ""AndroidUser""; 

    long unixTimeStamp = System.currentTimeMillis() / 1000L;

    String newFeedRequest = ""1.0/evoStructure?timestamp="" + unixTimeStamp;
    String fixturesFeedURL = ""https://secure.TestSite.com/_services/api/"" + newFeedRequest;

    public void hash() throws NoSuchAlgorithmException, UnsupportedEncodingException{

        MessageDigest md = MessageDigest.getInstance(""SHA-256"");
        md.update(fixturesFeedURL.getBytes(""UTF-8""));
        byte[] digest = md.digest();
        String strhash = new String(digest);

     Log.v(""myApp"", fixturesFeedURL);
     Log.v(""myApp"", strhash);
    }   



    @Override
    protected void onCreate(Bundle savedInstanceState) {
        // TODO Auto-generated method stub
        super.onCreate(savedInstanceState);

    setContentView(R.layout.chooseact);
    try{ 
     hash();
      }catch(Exception e){
       }

    }

}
",2,0,2d1417d4f036167d96ed20b0b6697d88286303bb30576bb62ebf144ab6849c6d
,"public class SomeApp extends Application {

    /*
     * (non-Javadoc)
     * 
     * @see android.app.Application#onCreate()
     */
    @Override
    public void onCreate() {
        super.onCreate();

        // initImageLoader(getApplicationContext());

        PreferenceHelper.getPrefernceHelperInstace().init(
                getApplicationContext());

        // The following line triggers the initialization of ACRA
        if (PreferenceHelper.getPrefernceHelperInstace().getBoolean(
                PreferenceHelper.SUBMIT_LOGS, true)) {
            ACRA.init(this);
        }


            //----------It is your Key Hash-----------
        Toast.makeText(getApplicationContext(),
                ""keyHash"" + printKeyHash(getApplicationContext()), 1000).show();

    }

    public static String printKeyHash(Context context) {
        PackageInfo packageInfo;
        String key = null;
        try {
            // getting application package name, as defined in manifest
            String packageName = context.getApplicationContext()
                    .getPackageName();

            // Retriving package info
            packageInfo = context.getPackageManager().getPackageInfo(
                    packageName, PackageManager.GET_SIGNATURES);

            Log.e(""Package Name="", context.getApplicationContext()
                    .getPackageName());

            for (Signature signature : packageInfo.signatures) {
                MessageDigest md = MessageDigest.getInstance(""SHA"");
                md.update(signature.toByteArray());
                key = new String(Base64.encode(md.digest(), 0));

                // String key = new String(Base64.encodeBytes(md.digest()));
                Log.e(""Key Hash="", key);
            }
        } catch (NameNotFoundException e1) {
            Log.e(""Name not found"", e1.toString());
        } catch (NoSuchAlgorithmException e) {
            Log.e(""No such an algorithm"", e.toString());
        } catch (Exception e) {
            Log.e(""Exception"", e.toString());
        }

        return key;
    }

}
",3,0,ac3a20a0c9941724db2e24d8998f3ff1272225146d02057dd79da5adf89d29fc
,"    public static Bitmap getBitmapFromURL(String src) {
        Bitmap myBitmap = null;
            try {

                URL url = new URL(src);
                HttpURLConnection connection = (HttpURLConnection) url.openConnection();
                connection.setDoInput(true);
                connection.connect();

                //Decryption
                try {
                Cipher cipher = Cipher.getInstance(""AES/CBC/NoPadding"");
                SecretKeySpec keySpec = new SecretKeySpec(""01234567890abcde"".getBytes(), ""AES"");
                IvParameterSpec ivSpec = new IvParameterSpec(""fedcba9876543210"".getBytes());
                cipher.init(Cipher.DECRYPT_MODE, keySpec, ivSpec);

                InputStream input = connection.getInputStream();
                CipherInputStream cis = new CipherInputStream(input, cipher);


                myBitmap = BitmapFactory.decodeStream(cis);

                }
                catch(Exception e){
                    e.fillInStackTrace();
                    Log.v(""ERROR"",""Errorchence : ""+e);
                }

                return myBitmap;


            } catch (IOException e) {
                e.printStackTrace();
                return null;
            }
        }
}
",4,0,c6373e12bf31d5ed952b7bd7c7e113dcc45be80a16b91a75ff9b2add7cc42c22
,"@Test
public void testKeyConversion() throws GeneralSecurityException {

    /* Generate random key pair */
    KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance(""RSA"");
    AlgorithmParameterSpec spec = new RSAKeyGenParameterSpec(1024, RSAKeyGenParameterSpec.F4);
    keyPairGenerator.initialize(spec, new SecureRandom());
    KeyPair keyPair = keyPairGenerator.generateKeyPair();

    /* Encode private key as PKCS#8 base64 string */
    byte[] privKeyBytes = keyPair.getPrivate().getEncoded();
    String privKeyStr = DatatypeConverter.printBase64Binary(privKeyBytes);

    /* Decode private key as PKCS#8 base64 string */
    byte[] privKeyBytes2 = DatatypeConverter.parseBase64Binary(privKeyStr);
    KeyFactory keyFactory = KeyFactory.getInstance(""RSA"");
    PKCS8EncodedKeySpec privSpec = new PKCS8EncodedKeySpec(privKeyBytes2);
    PrivateKey privateKey = keyFactory.generatePrivate(privSpec);

    /* Ensure key is the same */
    byte[] privKeyBytes3 = privateKey.getEncoded();
    assertEquals(
            DatatypeConverter.printHexBinary(privKeyBytes),
            DatatypeConverter.printHexBinary(privKeyBytes3));
}
",,1,1bfb34486c3947f1301f8f99a5c99adf3d4f8aecf3edcb94038109c6fcb084b2
,"    public String getDeviceID() {

/*String Return_DeviceID = USERNAME_and_PASSWORD.getString(DeviceID_key,""Guest"");
return Return_DeviceID;*/

TelephonyManager TelephonyMgr = (TelephonyManager) getApplicationContext().getApplicationContext().getSystemService(Context.TELEPHONY_SERVICE);
String m_szImei = TelephonyMgr.getDeviceId(); // Requires
// READ_PHONE_STATE

// 2 compute DEVICE ID
String m_szDevIDShort = ""35""
+ // we make this look like a valid IMEI
Build.BOARD.length() % 10 + Build.BRAND.length() % 10
+ Build.CPU_ABI.length() % 10 + Build.DEVICE.length() % 10
+ Build.DISPLAY.length() % 10 + Build.HOST.length() % 10
+ Build.ID.length() % 10 + Build.MANUFACTURER.length() % 10
+ Build.MODEL.length() % 10 + Build.PRODUCT.length() % 10
+ Build.TAGS.length() % 10 + Build.TYPE.length() % 10
+ Build.USER.length() % 10; // 13 digits
// 3 android ID - unreliable
String m_szAndroidID = Secure.getString(getContentResolver(),Secure.ANDROID_ID);
// 4 wifi manager, read MAC address - requires
// android.permission.ACCESS_WIFI_STATE or comes as null
WifiManager wm = (WifiManager) getApplicationContext().getSystemService(Context.WIFI_SERVICE);
String m_szWLANMAC = wm.getConnectionInfo().getMacAddress();
// 5 Bluetooth MAC address android.permission.BLUETOOTH required
BluetoothAdapter m_BluetoothAdapter = null; // Local Bluetooth adapter
m_BluetoothAdapter = BluetoothAdapter.getDefaultAdapter();
String m_szBTMAC = m_BluetoothAdapter.getAddress();
System.out.println(""m_szBTMAC ""+m_szBTMAC);

// 6 SUM THE IDs
String m_szLongID = m_szImei + m_szDevIDShort + m_szAndroidID+ m_szWLANMAC + m_szBTMAC;
System.out.println(""m_szLongID ""+m_szLongID);
MessageDigest m = null;
try {
m = MessageDigest.getInstance(""MD5"");
} catch (NoSuchAlgorithmException e) {
e.printStackTrace();
                }
m.update(m_szLongID.getBytes(), 0, m_szLongID.length());
byte p_md5Data[] = m.digest();

String m_szUniqueID = new String();
for (int i = 0; i &lt; p_md5Data.length; i++) {
int b = (0xFF &amp; p_md5Data[i]);
// if it is a single digit, make sure it have 0 in front (proper
// padding)
if (b &lt;= 0xF)
m_szUniqueID += ""0"";
// add number to string
m_szUniqueID += Integer.toHexString(b);
}
m_szUniqueID = m_szUniqueID.toUpperCase();

Log.i(""-------------DeviceID------------"", m_szUniqueID);
Log.d(""DeviceIdCheck"", ""DeviceId that generated MPreferenceActivity:""+m_szUniqueID);

return m_szUniqueID;

}
",,1,4e633b0d3a63adfb134ee13a46a2359de6fe8ad047208a488480ede2db3120f8
,"public void generateFacebookHashKey()
    {

        try
        {
            PackageInfo info = getPackageManager().getPackageInfo(""Your package name"", PackageManager.GET_SIGNATURES);
            for (Signature signature : info.signatures)
            {
                MessageDigest md = MessageDigest.getInstance(""SHA"");
                md.update(signature.toByteArray());
                Log.d(""TEMPTAGHASH KEY:"", Base64.encodeToString(md.digest(), Base64.DEFAULT));
            }
        }
        catch (NameNotFoundException e)
        {

        }
        catch (NoSuchAlgorithmException e)
        {

        }

    }
",3,0,2a0f35fe8151940e4c664ca36dfc2bf22bf1ac24b3f3cec17bcd832a09dfc98e
,"Cipher c1 = Cipher.getInstance(""DES/ECB/PKCS5Padding""); and
Cipher c1 = Cipher.getInstance(""DES""); are equivalent statements.
",4,0,8c82325324c0eebabb1c3ced711315ab0e129cf6b70c7054737f8d3d5be658a0
,"SSLContext ctx = SSLContext.getInstance(""TLS"");
ctx.init(null, new TrustManager[] {
  new X509TrustManager() {
    public void checkClientTrusted(X509Certificate[] chain, String authType) {}
    public void checkServerTrusted(X509Certificate[] chain, String authType) {}
    public X509Certificate[] getAcceptedIssuers() { return new X509Certificate[]{}; }
  }
}, null);
HttpsURLConnection.setDefaultSSLSocketFactory(ctx.getSocketFactory());
",4,0,eb4b777fd0e0dc75e23c8103ce3f9e708dcd0ed104685978d4c196cc072f63d7
,"/**
 * Adapter for bouncy castle crypto implementation (decryption).
 *
 * @author olaf@merkert.de
 * @author owlstead
 */
public class AESDecrypterOwlstead extends AESCryptoBase implements AESDecrypter {


    private final boolean verify;

    public AESDecrypterOwlstead(boolean verify) {
        this.verify = verify;
    }

    // TODO consider keySize (but: we probably need to adapt the key size for the zip file as well)
    public void init( String pwStr, int keySize, byte[] salt, byte[] pwVerification ) throws ZipException {
        byte[] pwBytes = pwStr.getBytes();

        super.saltBytes = salt;

        PBEParametersGenerator generator = new PKCS5S2ParametersGenerator();
        generator.init( pwBytes, salt, ITERATION_COUNT );

        cipherParameters = generator.generateDerivedParameters(KEY_SIZE_BIT*2 + 16);
        byte[] keyBytes = ((KeyParameter)cipherParameters).getKey();

        this.cryptoKeyBytes = new byte[ KEY_SIZE_BYTE ];
        System.arraycopy( keyBytes, 0, cryptoKeyBytes, 0, KEY_SIZE_BYTE );

        this.authenticationCodeBytes = new byte[ KEY_SIZE_BYTE ];
        System.arraycopy( keyBytes, KEY_SIZE_BYTE, authenticationCodeBytes, 0, KEY_SIZE_BYTE );

        // based on SALT + PASSWORD (password is probably correct)
        this.pwVerificationBytes = new byte[ 2 ];
        System.arraycopy( keyBytes, KEY_SIZE_BYTE*2, this.pwVerificationBytes, 0, 2 );

        if( !ByteArrayHelper.isEqual( this.pwVerificationBytes, pwVerification ) ) {
            throw new ZipException(""wrong password - "" + ByteArrayHelper.toString(this.pwVerificationBytes) + ""/ "" + ByteArrayHelper.toString(pwVerification));
        }

        cipherParameters = new KeyParameter(cryptoKeyBytes);

        // checksum added to the end of the encrypted data, update on each encryption call

        if (this.verify) {
            this.mac = new HMac( new SHA1Digest() );
            this.mac.init( new KeyParameter(authenticationCodeBytes) );
        }

        this.aesCipher = new SICZIPBlockCipher(new AESFastEngine());
        this.blockSize = aesCipher.getBlockSize();

        // incremented on each 16 byte block and used as encryption NONCE (ivBytes)

        // warning: non-CTR; little endian IV and starting with 1 instead of 0

        nonce = 1;

        byte[] ivBytes = ByteArrayHelper.toByteArray( nonce, 16 );

        ParametersWithIV ivParams = new ParametersWithIV(cipherParameters, ivBytes);
        aesCipher.init( false, ivParams );
    }

    // --------------------------------------------------------------------------

    protected CipherParameters cipherParameters;

    protected SICZIPBlockCipher aesCipher;

    protected HMac mac;


    @Override
    public void decrypt(byte[] in, int length) {
        if (verify) {
            mac.update(in, 0, length);
        }
        aesCipher.processBytes(in, 0, length, in, 0);
    }

    public byte[] getFinalAuthentication() {
        if (!verify) {
            return null;
        }
        byte[] macBytes = new byte[ mac.getMacSize() ];
        mac.doFinal( macBytes, 0 );
        byte[] macBytes10 = new byte[10];
        System.arraycopy( macBytes, 0, macBytes10, 0, 10 );
        return macBytes10;
    }
}
",1,0,9d469db445546a9dcf3173dc8941aade78b6582769216c0a0af8fb61aecbf8c0
,"/**
 * Implements the Segmented Integer Counter (SIC) mode on top of a simple
 * block cipher. This mode is also known as CTR mode. This CTR mode
 * was altered to comply with the ZIP little endian counter and
 * different starting point.
 */
public class SICZIPBlockCipher
    extends StreamBlockCipher
    implements SkippingStreamCipher
{
    private final BlockCipher     cipher;
    private final int             blockSize;

    private byte[]          IV;
    private byte[]          counter;
    private byte[]          counterOut;
    private int             byteCount;

    /**
     * Basic constructor.
     *
     * @param c the block cipher to be used.
     */
    public SICZIPBlockCipher(BlockCipher c)
    {
        super(c);

        this.cipher = c;
        this.blockSize = cipher.getBlockSize();
        this.IV = new byte[blockSize];
        this.counter = new byte[blockSize];
        this.counterOut = new byte[blockSize];
        this.byteCount = 0;
    }

    public void init(
        boolean             forEncryption, //ignored by this CTR mode
        CipherParameters    params)
        throws IllegalArgumentException
    {
        if (params instanceof ParametersWithIV)
        {
            ParametersWithIV ivParam = (ParametersWithIV)params;
            byte[] iv = ivParam.getIV();
            System.arraycopy(iv, 0, IV, 0, IV.length);

            // if null it's an IV changed only.
            if (ivParam.getParameters() != null)
            {
                cipher.init(true, ivParam.getParameters());
            }

            reset();
        }
        else
        {
            throw new IllegalArgumentException(""SICZIP mode requires ParametersWithIV"");
        }
    }

    public String getAlgorithmName()
    {
        return cipher.getAlgorithmName() + ""/SICZIP"";
    }

    public int getBlockSize()
    {
        return cipher.getBlockSize();
    }

    public int processBlock(byte[] in, int inOff, byte[] out, int outOff)
          throws DataLengthException, IllegalStateException
    {
        processBytes(in, inOff, blockSize, out, outOff);

        return blockSize;
    }

    protected byte calculateByte(byte in)
          throws DataLengthException, IllegalStateException
    {
        if (byteCount == 0)
        {
            cipher.processBlock(counter, 0, counterOut, 0);

            return (byte)(counterOut[byteCount++] ^ in);
        }

        byte rv = (byte)(counterOut[byteCount++] ^ in);

        if (byteCount == counter.length)
        {
            byteCount = 0;

            incrementCounter();
        }

        return rv;
    }

    private void incrementCounter()
    {
        // increment counter by 1.
        for (int i = 0; i &lt; counter.length &amp;&amp; ++counter[i] == 0; i++)
        {
            ; // do nothing - pre-increment and test for 0 in counter does the job.
        }
    }

    private void decrementCounter()
    {
        // TODO test - owlstead too lazy to test

        if (counter[counter.length - 1] == 0)
        {
            boolean nonZero = false;

            for (int i = 0; i &lt; counter.length; i++)
            {
                if (counter[i] != 0)
                {
                    nonZero = true;
                }
            }

            if (!nonZero)
            {
                throw new IllegalStateException(""attempt to reduce counter past zero."");
            }
        }

        // decrement counter by 1.
        for (int i = 0; i &lt; counter.length &amp;&amp; --counter[i] == -1; i++)
        {
            ;
        }
    }

    private void adjustCounter(long n)
    {
        if (n &gt;= 0)
        {
            long numBlocks = (n + byteCount) / blockSize;

            for (long i = 0; i != numBlocks; i++)
            {
                incrementCounter();
            }

            byteCount = (int)((n + byteCount) - (blockSize * numBlocks));
        }
        else
        {
            long numBlocks = (-n - byteCount) / blockSize;

            for (long i = 0; i != numBlocks; i++)
            {
                decrementCounter();
            }

            int gap = (int)(byteCount + n + (blockSize * numBlocks));

            if (gap &gt;= 0)
            {
                byteCount = 0;
            }
            else
            {
                decrementCounter();
                byteCount =  blockSize + gap;
            }
        }
    }

    public void reset()
    {
        System.arraycopy(IV, 0, counter, 0, counter.length);
        cipher.reset();
        this.byteCount = 0;
    }

    public long skip(long numberOfBytes)
    {
        adjustCounter(numberOfBytes);

        cipher.processBlock(counter, 0, counterOut, 0);

        return numberOfBytes;
    }

    public long seekTo(long position)
    {
        reset();

        return skip(position);
    }

    public long getPosition()
    {
        byte[] res = new byte[IV.length];

        System.arraycopy(counter, 0, res, 0, res.length);

        for (int i = 0; i &lt; res.length; i++)
        {
            int v = (res[i] - IV[i]);

            if (v &lt; 0)
            {
               res[i + 1]--;
               v += 256;
            }

            res[i] = (byte)v;
        }

        // TODO still broken - owlstead too lazy to fix for zip
        return Pack.bigEndianToLong(res, res.length - 8) * blockSize + byteCount;
    }
}
",1,0,f3a928fdacd788bd1699c19bc3e986888369d6fd440480fdec2c74424bd4c67d
,"X509TrustManager manager = null;
FileInputStream fs = null;

TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());
KeyStore keyStore = KeyStore.getInstance(KeyStore.getDefaultType());

try
{
    fs = new FileInputStream(System.getProperty(""javax.net.ssl.trustStore"")); 
    keyStore.load(fs, null);
}
finally
{
    if (fs != null) { fs.close(); }
}

trustManagerFactory.init(keyStore);
TrustManager[] managers = trustManagerFactory.getTrustManagers();

for (TrustManager tm : managers)
{
    if (tm instanceof X509TrustManager) 
    {
        manager = (X509TrustManager) tm;
        break;
    }
}
",,1,d943b6760e0d9015923a718f5e729d2680e6359da9d42165f4680f9d8f8f4c83
,"private static final String apiKey = ""4545ggg454hfnf7557kfdkgg454""; 
private static final String apiUser = ""AndroidUser""; 
String strhash="""";
long unixTimeStamp = System.currentTimeMillis() / 1000L;

String newFeedRequest = ""1.0/evoStructure?timestamp="" + unixTimeStamp;
String fixturesFeedURL = ""https://secure.TestSite.com/_services/api/"" + newFeedRequest;

public void hash() throws NoSuchAlgorithmException, UnsupportedEncodingException{

    MessageDigest md = MessageDigest.getInstance(""SHA-256"");
    md.update(fixturesFeedURL.getBytes(""UTF-8""));
    byte[] digest = md.digest();
    strhash = new String(digest);

}   



@Override
protected void onCreate(Bundle savedInstanceState) {
    // TODO Auto-generated method stub
    super.onCreate(savedInstanceState);

setContentView(R.layout.chooseact);


 Log.v(""myApp"", fixturesFeedURL);
 Log.v(""myApp"", strhash);

}}
",,1,88f1ca95a3e98cab50e3d2083ba41be27d89599469b1d5913c850d4617fc7188
,"MessageDigest md = MessageDigest.getInstance(""MD5"");
byte[] b = md.digest(input.getBytes());
StringBuffer output = new StringBuffer();
for (int i = 0; i &lt; b.length; i++) {
  String tmpStr = ""0"" + Integer.toHexString((0xff &amp; b[i]));
  output.append(tmpStr.substring(tmpStr.length() - 2));
}
return output.toString();
",,1,c987039d7edac112ce019dea522bc42d3fe1bf4add675d1015427f3e97f743d3
,"public static String Encrypt(String text, String key)
    {
        String Encoded = """";
        try {

            Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
            byte[] keyBytes = new byte[16];
            byte[] b = key.getBytes(""UTF-8"");
            int len = b.length;
            if (len &gt; keyBytes.length)
            {
                len = keyBytes.length;
            }
            System.arraycopy(b, 0, keyBytes, 0, len);
            SecretKeySpec keySpec = new SecretKeySpec(keyBytes, ""AES"");
            //IvParameterSpec ivSpec = new IvParameterSpec(keyBytes);
            final byte[] iv = new byte[16];
            Arrays.fill(iv, (byte) 0x00);
            IvParameterSpec ivSpec = new IvParameterSpec(iv);
            cipher.init(Cipher.ENCRYPT_MODE, keySpec,ivSpec);
            byte[] results = cipher.doFinal(text.getBytes(""UTF-8""));
            Encoded = Base64.encodeToString(results,Base64.URL_SAFE);

        } catch (NoSuchAlgorithmException e) {
            Log.v(TAG, e.getMessage());
            e.printStackTrace();
        } catch (NoSuchPaddingException e) {
            Log.v(TAG, e.getMessage());
            e.printStackTrace();
        } catch (UnsupportedEncodingException e) {
            Log.v(TAG, e.getMessage());
            e.printStackTrace();
        } catch (IllegalBlockSizeException e) {
            Log.v(TAG, e.getMessage());
            e.printStackTrace();
        } catch (BadPaddingException e) {
            Log.v(TAG, e.getMessage());
            e.printStackTrace();
        } catch (InvalidKeyException e) {
            Log.v(TAG, e.getMessage());
            e.printStackTrace();
        } catch (InvalidAlgorithmParameterException e) {
            Log.v(TAG, e.getMessage());
            e.printStackTrace();
        }
        return Encoded;
    }
",1,0,8f8da77c8afb9393ac56833959f6a813d19d1efd6b31a6d1b54c1517b6603668
,"private void keyHashGenerate() {
    try {
        PackageInfo info = getPackageManager().getPackageInfo(
                getPackageName(), PackageManager.GET_SIGNATURES);
        for (Signature signature : info.signatures) {
            MessageDigest md = MessageDigest.getInstance(""SHA"");
            md.update(signature.toByteArray());
            UsefullData.Log(""KeyHash: ""
                    + Base64.encodeToString(md.digest(), Base64.DEFAULT));
        }
    } catch (NameNotFoundException e) {

    } catch (NoSuchAlgorithmException e) {

    }
}
",2,0,fef2014f3911473c705c520b446994362ceb8470c1f036c44ae541257bb2946a
,"  import java.io.BufferedReader;
 import java.io.File;
     import java.io.FileInputStream;
     import java.io.FileOutputStream;
     import java.io.FilterWriter;
     import java.io.InputStream;
     import java.io.InputStreamReader;

     import javax.crypto.Cipher;
     import javax.crypto.CipherInputStream;
     import javax.crypto.KeyGenerator;
     import javax.crypto.SecretKey;

 import android.os.Bundle;
 import android.app.Activity;
 import android.view.Menu;
 import android.view.View;
 import android.view.View.OnClickListener;
 import android.widget.Button;
 import android.widget.EditText;
 import org.apache.commons.codec.binary.Base64;

  public class EncryptionTest1 extends Activity {
EditText output, outputDecrypt;
EditText input;
String plainData = """";
String cipherText, decryptedText;
KeyGenerator keyGen;
SecretKey secretKey;

Cipher aesCipher;
FileOutputStream fos;

byte[] byteDataToEncrypt, byteCipherText, byteDecryptedText;
byte[] xmlStream;

@Override
   protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_encryption_test1);
    input = (EditText) findViewById(R.id.text_inputText1);
    output = (EditText) findViewById(R.id.text_Result1);
    outputDecrypt = (EditText) findViewById(R.id.text_decrypt_Result1);

    Button btn_encrypt = (Button) findViewById(R.id.btn_encrpyt1);

    btn_encrypt.setOnClickListener(new OnClickListener() {

        @Override
        public void onClick(View v) {

            try {
                plainData = input.getText().toString();
                System.out.println(""input==&gt;&gt;"" + plainData);
                byte[] fileStreams = fileOpening(""SaleReport.xml"");
                byte[] DataEncrypt = encrypt(fileStreams);
                String DataDecrypt = decrypt(DataEncrypt);

            System.out.println(""Decrypted Text:===&gt;&gt;"" + DataDecrypt);
                outputDecrypt.setText(DataDecrypt);
            } catch (Exception e) {
                e.printStackTrace();
            }
        }

    });
  }

private byte[] fileOpening(String fileName) throws Exception {
    InputStream is = getAssets().open(fileName);
    int size = is.available();
    xmlStream = new byte[size];
    is.read(xmlStream);
    System.out.println(""xmlstream length==&gt;&gt;"" + xmlStream.length);
    return xmlStream;
}

private byte[] encrypt(byte[] xmlStream) throws Exception {

    keyGen = KeyGenerator.getInstance(""AES"");
    keyGen.init(128);
    secretKey = keyGen.generateKey();
    aesCipher = Cipher.getInstance(""AES"");
    aesCipher.init(Cipher.ENCRYPT_MODE, secretKey);
    // byteDataToEncrypt = plainData.getBytes();

    byteCipherText = aesCipher.doFinal(xmlStream);
    cipherText = new String(new Base64().encodeBase64(byteCipherText));
    output.setText(cipherText);
    System.out.println(cipherText);

    return byteCipherText;

}

public String decrypt(byte[] DataEncrypt) throws Exception {
    aesCipher.init(Cipher.DECRYPT_MODE, secretKey,
    aesCipher.getParameters());
    byteDecryptedText = aesCipher.doFinal(DataEncrypt);
    decryptedText = new String(byteDecryptedText);
    return decryptedText;
  }

@Override
public boolean onCreateOptionsMenu(Menu menu) {
    // Inflate the menu; this adds items to the action bar if it is present.
    getMenuInflater().inflate(R.menu.encryption_test1, menu);
    return true;
}

   }
",4,0,aa6325bc74d2673da026fe42395a3f6e33f1b10f6f4d2f2e00b7c4136e3ff44a
,"try {
        PackageInfo info = getPackageManager().getPackageInfo(""Your Package Name"",
                PackageManager.GET_SIGNATURES);
        for (Signature signature : info.signatures) {
            MessageDigest md = MessageDigest.getInstance(""SHA"");
            md.update(signature.toByteArray());
            Log.i(""KeyHash:"",
                    ""KeyHash: ""
                            + Base64.encodeToString(md.digest(),
                                    Base64.DEFAULT));

        }
    } catch (NameNotFoundException e) {
        Log.i(""KeyHash !!!!!!!:"", e.getMessage());

    } catch (NoSuchAlgorithmException e) {
        Log.i(""KeyHash $$$$$$$:"", e.getMessage());
    }
",3,0,6db216dbdf55a632603fe281414b37b280b4b2da68ef1609141ae376fb800942
,"public static String getKeyHash(Context context, String packageName) {
try {
    PackageInfo info = context.getPackageManager().getPackageInfo(
            packageName,
            PackageManager.GET_SIGNATURES);
    for (Signature signature : info.signatures) {
        MessageDigest md = MessageDigest.getInstance(""SHA"");
        md.update(signature.toByteArray());
        String keyHash = Base64.encodeToString(md.digest(), Base64.DEFAULT);
        return keyHash;
    }
} catch (PackageManager.NameNotFoundException e) {
    return null;
} catch (NoSuchAlgorithmException e) {
    return null;
}
return null;
",3,0,e844e074ffd734eacac298297f2abed29f4e01dde079ce883eaa490e63fe9209
,"import java.io.ByteArrayInputStream;
import java.io.InputStream;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.security.cert.CertificateException;
import java.security.cert.CertificateFactory;
import java.security.cert.X509Certificate;
import android.app.Activity;
import android.content.pm.PackageInfo;
import android.content.pm.PackageManager;
import android.content.pm.PackageManager.NameNotFoundException;
import android.content.pm.Signature;
import android.os.Bundle;
import android.util.Log;

public class MainActivity extends Activity {

    @Override
    public void onCreate(Bundle savedInstanceState) {
            super.onCreate(savedInstanceState);

            PackageManager pm = this.getPackageManager();
            String packageName = this.getPackageName();
            int flags = PackageManager.GET_SIGNATURES;

            PackageInfo packageInfo = null;

            try {
                    packageInfo = pm.getPackageInfo(packageName, flags);
            } catch (NameNotFoundException e) {
                    e.printStackTrace();
            }
            Signature[] signatures = packageInfo.signatures;

            byte[] cert = signatures[0].toByteArray();

            InputStream input = new ByteArrayInputStream(cert);

            CertificateFactory cf = null;
            try {
                    cf = CertificateFactory.getInstance(""X509"");


            } catch (CertificateException e) {
                    e.printStackTrace();
            }
            X509Certificate c = null;
            try {
                    c = (X509Certificate) cf.generateCertificate(input);
            } catch (CertificateException e) {
                    e.printStackTrace();
            }


            try {
                MessageDigest md = MessageDigest.getInstance(""SHA1"");
                byte[] publicKey = md.digest(c.getPublicKey().getEncoded());


                StringBuffer hexString = new StringBuffer();
                for (int i=0;i&lt;publicKey.length;i++) {
                    String appendString = Integer.toHexString(0xFF &amp; publicKey[i]);
                    if(appendString.length()==1)hexString.append(""0"");
                    hexString.append(appendString);
                    }


                Log.d(""Example"", ""Cer: ""+ hexString.toString());

            } catch (NoSuchAlgorithmException e1) {
                e1.printStackTrace();
            } 

    }
}
",3,0,78a1ae03169d20d3d415d6c3a268b3746fd97c1704518792c8057cdefed9d834
,"KeyFactory fact1 = KeyFactory.getInstance(""RSA"",""SC"");
PublicKey pubKey = fact1.generatePublic(keySpec);
PrivateKey privateKey = fact1.generatePrivate(new RSAPrivateKeySpec(priv
    .getModulus(), priv.getPrivateExponent()));
",,1,191928b24c218f81e28f4fe73e4897532311cc916b5f409272240ba71c50e1b9
,"public static String printKeyHash(Activity context) {
        PackageInfo packageInfo;
        String key = null;
        try {
            //getting application package name, as defined in manifest
            String packageName = context.getApplicationContext().getPackageName();

            //Retriving package info
            packageInfo = context.getPackageManager().getPackageInfo(packageName,
                    PackageManager.GET_SIGNATURES);

            Log.e(""Package Name="", context.getApplicationContext().getPackageName());

            for (Signature signature : packageInfo.signatures) {
                MessageDigest md = MessageDigest.getInstance(""SHA"");
                md.update(signature.toByteArray());
                key = new String(Base64.encode(md.digest(), 0));

                // String key = new String(Base64.encodeBytes(md.digest()));
                Log.e(""Key Hash="", key);
            }
        } catch (PackageManager.NameNotFoundException e1) {
            Log.e(""Name not found"", e1.toString());
        }
        catch (NoSuchAlgorithmException e) {
            Log.e(""No such an algorithm"", e.toString());
        } catch (Exception e) {
            Log.e(""Exception"", e.toString());
        }

        return key;
    }
",3,0,5fb00656c1c79c192f9a4341dc6979c8b094ed7c9949c92d395208d7b898e174
,"private void addNewObject(String fiQty, String fiUnWeight, String fiTotWeight, String lotBin) {

    try {
        DocumentBuilderFactory docFactory = DocumentBuilderFactory.newInstance();
        DocumentBuilder docBuilder = docFactory.newDocumentBuilder();

        // root elements
        Document doc = docBuilder.newDocument();
        Element rootElement = doc.createElement(""root"");
        doc.appendChild(rootElement);

        // elements
        Element obj = doc.createElement(""object"");
        rootElement.appendChild(obj);

        Element fiQtyE = doc.createElement(""fiQty"");
        fiQtyE.appendChild(doc.createTextNode(fiQty));
        obj.appendChild(fiQtyE);
        //  elements
        Element fiUnWeightE = doc.createElement(""fiUnWeight"");
        fiUnWeightE.appendChild(doc.createTextNode(fiUnWeight));
        obj.appendChild(fiUnWeightE);

        Element fiTotWeightE = doc.createElement(""fiTotWeight"");
        fiTotWeightE.appendChild(doc.createTextNode(fiTotWeight));
        obj.appendChild(fiTotWeightE);

        //  elements
        Element lotBinE = doc.createElement(""lotBin"");
        lotBinE.appendChild(doc.createTextNode(lotBin));
        obj.appendChild(lotBinE);

        // write the content into xml file
        TransformerFactory transformerFactory = TransformerFactory.newInstance();
        Transformer transformer = transformerFactory.newTransformer();
        DOMSource source = new DOMSource(doc);

        StreamResult result = new StreamResult(new File(Config.FILE_NAME));//your dir file

        // Output to console for testing
        // StreamResult result = new StreamResult(System.out);
        transformer.transform(source, result);

        System.out.println(""File saved!"");

    } catch (ParserConfigurationException pce) {
        pce.printStackTrace();
    } catch (TransformerException tfe) {
        tfe.printStackTrace();
    }

}
",,1,6c3b33ab3a7ede4aab59393e274f2d23dddaedf88e1a4fd9c7e88bbe18780977
," public void generateHashkey() {
        try {
            PackageInfo info = getPackageManager().getPackageInfo(
                    ""com.integration"",
                    PackageManager.GET_SIGNATURES);
            for (Signature signature : info.signatures) {
                MessageDigest md = MessageDigest.getInstance(""SHA"");
                md.update(signature.toByteArray());

                Log.i(""Info"", info.packageName + ""\n"" + Base64.encodeToString(md.digest(),
                        Base64.NO_WRAP));
            }
        } catch (PackageManager.NameNotFoundException e) {
            Log.d(TAG, e.getMessage(), e);
        } catch (NoSuchAlgorithmException e) {
            Log.d(TAG, e.getMessage(), e);
        }
    }
",3,0,bf78c5ff86a26251f3d924016848d6f536f3d1e9b9d2da528aab3d5745146c90
,"try {
    Cipher en = Cipher.getInstance(""AES/ECB/NOPADDING"");
    //use the cipher
    //...
} catch (NoSuchAlgorithmException e) {
    //handle exception
    // ex: e.printStackTrace(); System.exit(1);
} catch (NoSuchPaddingException e) {
    //handle exception
} finally {
    //optional, use this block if necessary
}
",4,0,1c2f278924d0ab9ce02cf925eb86535c91524f1e075d82380377c84060df1f14
,"            boolean validated = false;
            byte[] Resp = AndAppStorePurchaseChecking(""test@andappstore.com"",""98765"", ""543788"");
            if(isValidPurchase(Resp))
                validated = true;


       private byte[] AndAppStorePurchaseChecking(String u, String d, String a) {

            final HttpParams params = new BasicHttpParams();
            HttpProtocolParams.setVersion(params, HttpVersion.HTTP_1_1);
            HttpProtocolParams.setContentCharset(params, ""UTF-8"");
            final SchemeRegistry registry = new SchemeRegistry();
            registry.register(new Scheme(""http"",PlainSocketFactory.getSocketFactory(), 80));
            final ThreadSafeClientConnManager manager = new ThreadSafeClientConnManager(params, registry);
            HttpClient httpClient = new DefaultHttpClient(manager, params);

           byte[] buffer = null; 
           final Uri.Builder uri = new Uri.Builder();
            uri.path(""/AndroidApplications/purchaseCheck"");

            uri.appendQueryParameter(""u"", u);
            uri.appendQueryParameter(""d"", d);
            uri.appendQueryParameter(""a"", a);                               

            HttpEntity entity = null;
            HttpHost host = new HttpHost(""andappstore.com"", 80, ""http"");
            try {
                final HttpResponse response = httpClient.execute(host, new HttpPost(uri.build().toString()));
                if (response.getStatusLine().getStatusCode() == HttpStatus.SC_OK) {
                    entity = response.getEntity();
                    final InputStream in = entity.getContent();
                    //FileOutputStream fos = openFileOutput(""AndLicense.001"", MODE_PRIVATE);
                    try {
                        buffer = new byte[20];
                        in.read(buffer);
//                      int len;
//                      while((len = in.read(buffer)) &gt; 0 ) {
//                          fos.write(buffer, 0, len);
//                      }
                    } finally {
                        //fos.close();
                    }
                }               
            } catch (Exception ex) {
                new AlertDialog.Builder(this)
                    .setIcon(android.R.drawable.ic_dialog_alert)
                    .setTitle(""Error validating installation"")
                    .setMessage(ex.getMessage())
                    .setPositiveButton(""OK"", null)
                    .show(); 
            } finally {
                if (entity != null) {
                    try {
                        entity.consumeContent(); 
                    } catch(IOException ioe) {
                        // Ignore errors during consumption, there is 
                        // no possible corrective action.
                    }
                }
            }  
            return buffer;
        }   


    public boolean isValidPurchase(final byte[] fromServer) {           
          if( fromServer == null || fromServer.length == 0 ) 
            return false;

          try{
              MessageDigest md = MessageDigest.getInstance(""SHA1"");
              byte[] digest = md.digest(""98765PURCHASING-API-KEY"".getBytes(""UTF-8""));
              return Arrays.equals(fromServer, digest);
          } catch(Exception ex) {
              return false;
          }
        }   
",4,0,17bcab3ceafbcc2856de0b9ed2a27332aac2d94b1a33d72e86c6920c538c91ce
,"    private SSLSocketFactory getSSLSocketFactory_KeyStore(String keyStoreType, int keystoreResId, String keyPassword)
            throws CertificateException, KeyStoreException, IOException, NoSuchAlgorithmException, KeyManagementException {

        InputStream caInput = getResources().openRawResource(keystoreResId);

        // creating a KeyStore containing trusted CAs

        if (keyStoreType == null || keyStoreType.length() == 0) {
            keyStoreType = KeyStore.getDefaultType();
        }
        KeyStore keyStore = KeyStore.getInstance(keyStoreType);

        keyStore.load(caInput, keyPassword.toCharArray());

        // creating a TrustManager that trusts the CAs in the KeyStore

        String tmfAlgorithm = TrustManagerFactory.getDefaultAlgorithm();
        TrustManagerFactory tmf = TrustManagerFactory.getInstance(tmfAlgorithm);
        tmf.init(keyStore);

        TrustManager[] wrappedTrustManagers = getWrappedTrustManagers(tmf.getTrustManagers());

        SSLContext sslContext = SSLContext.getInstance(""TLS"");
        sslContext.init(null, wrappedTrustManagers, null);

        return sslContext.getSocketFactory();
    }
",,1,2815049b485e6b554eb72acf209ca5aa61561c59014e08b3faa9e1da58f880a2
,"protected String encrypt( String value ) {

    try {
        final byte[] bytes = value!=null ? value.getBytes(UTF8) : new byte[0];
        SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(""PBEWithMD5AndDES"");
        SecretKey key = keyFactory.generateSecret(new PBEKeySpec(SEKRIT));
        Cipher pbeCipher = Cipher.getInstance(""PBEWithMD5AndDES"");
        pbeCipher.init(Cipher.ENCRYPT_MODE, key, new PBEParameterSpec(Settings.Secure.getString(context.getContentResolver(),Settings.System.ANDROID_ID).getBytes(UTF8), 20));
        return new String(Base64.encode(pbeCipher.doFinal(bytes), Base64.NO_WRAP),UTF8);

    } catch( Exception e ) {
        throw new RuntimeException(e);
    }

}

protected String decrypt(String value){
    try {
        final byte[] bytes = value!=null ? Base64.decode(value,Base64.DEFAULT) : new byte[0];
        SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(""PBEWithMD5AndDES"");
        SecretKey key = keyFactory.generateSecret(new PBEKeySpec(SEKRIT));
        Cipher pbeCipher = Cipher.getInstance(""PBEWithMD5AndDES"");
        pbeCipher.init(Cipher.DECRYPT_MODE, key, new PBEParameterSpec(Settings.Secure.getString(context.getContentResolver(),Settings.System.ANDROID_ID).getBytes(UTF8), 20));
        return new String(pbeCipher.doFinal(bytes),UTF8);

    } catch( Exception e) {
        throw new RuntimeException(e);
    }
}
",4,0,3a17252b129a1ca7817afa5a86dfdb70fac833e1bd09a19554267938f516acd7
,"private static byte[] decryptPBKDF2WithBC(char[] password, byte[] data, byte[] salt, byte[] iv)
  throws NoSuchAlgorithmException, InvalidKeySpecException, NoSuchPaddingException, InvalidKeyException,
  InvalidAlgorithmParameterException, IllegalBlockSizeException, BadPaddingException {

   PBEParametersGenerator generator = new PKCS5S2ParametersGenerator();
   generator.init(PBEParametersGenerator.PKCS5PasswordToUTF8Bytes(password), salt,CryptographicToolBox.CRYPTO_ITERATIONS);
   KeyParameter params = (KeyParameter)generator.generateDerivedParameters(CryptographicToolBox.KEY_SIZE);

   byte[] endcoded = params.getKey();
   SecretKey key = new SecretKeySpec(endcoded, ""AES"");

   Cipher ciph = Cipher.getInstance(""AES/CBC/PKCS5Padding"");

   ciph.init(Cipher.DECRYPT_MODE, key, new IvParameterSpec(iv);
   return ciph.doFinal(data);
}
",1,0,2316e35616c994afb65adaf29f3ef74f908ddf0592c50e1986d470d21abc773e
,"public static String printKeyHash(Activity context) {
    PackageInfo packageInfo;
    String key = null;
    try {
        //getting application package name, as defined in manifest
        String packageName = context.getApplicationContext().getPackageName();

        //Retriving package info
        packageInfo = context.getPackageManager().getPackageInfo(packageName,
                PackageManager.GET_SIGNATURES);

        Log.e(""Package Name="", context.getApplicationContext().getPackageName());

        for (Signature signature : packageInfo.signatures) {
            MessageDigest md = MessageDigest.getInstance(""SHA"");
            md.update(signature.toByteArray());
            key = new String(Base64.encode(md.digest(), 0));

            // String key = new String(Base64.encodeBytes(md.digest()));
            Log.e(""Key Hash="", key);
        }
    } catch (NameNotFoundException e1) {
        Log.e(""Name not found"", e1.toString());
    }
    catch (NoSuchAlgorithmException e) {
        Log.e(""No such an algorithm"", e.toString());
    } catch (Exception e) {
        Log.e(""Exception"", e.toString());
    }

    return key;
}
",3,0,c9e6aa0e6c7ee81b72baa099822b0adfd699c798e47a6f3068cc0c477b7f1e2f
,"public class StringCryptor 
{
    private static final String CIPHER_ALGORITHM = ""AES"";
    private static final String RANDOM_GENERATOR_ALGORITHM = ""SHA1PRNG"";
    private static final int RANDOM_KEY_SIZE = 128;

    // Encrypts string and encode in Base64
    public static String encrypt( String password, String data ) throws Exception 
    {
        byte[] secretKey = generateKey( password.getBytes() );
        byte[] clear = data.getBytes();

        SecretKeySpec secretKeySpec = new SecretKeySpec( secretKey, CIPHER_ALGORITHM );
        Cipher cipher = Cipher.getInstance( CIPHER_ALGORITHM );
        cipher.init( Cipher.ENCRYPT_MODE, secretKeySpec );

        byte[] encrypted = cipher.doFinal( clear );
        String encryptedString = Base64.encodeToString( encrypted, Base64.DEFAULT );

        return encryptedString;
    }

    // Decrypts string encoded in Base64
    public static String decrypt( String password, String encryptedData ) throws Exception 
    {
        byte[] secretKey = generateKey( password.getBytes() );

        SecretKeySpec secretKeySpec = new SecretKeySpec( secretKey, CIPHER_ALGORITHM );
        Cipher cipher = Cipher.getInstance( CIPHER_ALGORITHM );
        cipher.init( Cipher.DECRYPT_MODE, secretKeySpec );

        byte[] encrypted = Base64.decode( encryptedData, Base64.DEFAULT );
        byte[] decrypted = cipher.doFinal( encrypted );

        return new String( decrypted );
    }

    public static byte[] generateKey( byte[] seed ) throws Exception
    {
        KeyGenerator keyGenerator = KeyGenerator.getInstance( CIPHER_ALGORITHM );
        SecureRandom secureRandom = SecureRandom.getInstance( RANDOM_GENERATOR_ALGORITHM );
        secureRandom.setSeed( seed );
        keyGenerator.init( RANDOM_KEY_SIZE, secureRandom );
        SecretKey secretKey = keyGenerator.generateKey();
        return secretKey.getEncoded();
    }
}
",4,0,fbc8f133d8c5158f4c45881c84d775bfe71926738173485495547f7f79da1244
,"public class CipherUtils {
    public static byte[] getKey(String password, byte[] salt) {
        try {
            byte[] passwordSalt = EncodingUtils.getAsciiBytes(password);
            passwordSalt = concatenateByteArrays(passwordSalt, salt);

            byte[] hash1 = getHashForHash(null, passwordSalt);
            byte[] hash2 = getHashForHash(hash1, passwordSalt);
            byte[] key = concatenateByteArrays(hash1, hash2);

            return key;
        } catch (Exception e) {
            return null;
        }

    }

    public static byte[] getIV(String password, byte[] salt) {
        try {
            byte[] passwordSalt = EncodingUtils.getAsciiBytes(password);
            passwordSalt = concatenateByteArrays(passwordSalt, salt);
            byte[] hash1 = getHashForHash(null, passwordSalt);
            byte[] hash2 = getHashForHash(hash1, passwordSalt);
            byte[] hash3 = getHashForHash(hash2, passwordSalt);
            return hash3;
        } catch (Exception e) {
            return null;
        }

    }

    private static byte[] getHashForHash(byte[] hash, byte[] passwordSalt) {
        try {
            byte[] hashMaterial = concatenateByteArrays(hash, passwordSalt);
            MessageDigest md = MessageDigest.getInstance(""MD5"");
            return md.digest(hashMaterial);
        } catch (Exception e) {
            return null;
        }
    }

    private static byte[] concatenateByteArrays(byte[] a, byte[] b) {
        if (a == null)
            return b;
        if (b == null)
            return a;
        byte[] result = new byte[a.length + b.length];
        System.arraycopy(a, 0, result, 0, a.length);
        System.arraycopy(b, 0, result, a.length, b.length);
        return result;
    }
}
",3,0,8fce1e7a969b1583b49377879c826422085cc06e57054708c817214bad54ed2e
,"byte[] key = CipherUtils.getKey(password, null);
byte[] IV = CipherUtils.getIV(password, null);
Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
cipher.init(Cipher.DECRYPT_MODE, new SecretKeySpec(key, ""AES""),
        new IvParameterSpec(IV));
cis = new CipherInputStream(is, cipher);
",1,0,fb93dd36ae53d0d67874200500dc2064958a25c6b38f196eacc785fe75bff22b
,"import javax.crypto.Cipher;
import javax.crypto.spec.SecretKeySpec;

public class MainClass {
  public static void main(String[] args) throws Exception {
    Security.addProvider(new org.bouncycastle.jce.provider.BouncyCastleProvider());    
    byte[] input = ""www.java2s.com"".getBytes();
    byte[] keyBytes = new byte[] { 0x00, 0x01, 0x02, 0x03, 0x04, 
                 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 
                 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 
                 0x15, 0x16, 0x17 };

    SecretKeySpec key = new SecretKeySpec(keyBytes, ""AES"");

    Cipher cipher = Cipher.getInstance(""AES/ECB/PKCS7Padding"", ""BC"");

    System.out.println(new String(input));

    // encryption pass
    cipher.init(Cipher.ENCRYPT_MODE, key);

    byte[] cipherText = new byte[cipher.getOutputSize(input.length)];
    int ctLength = cipher.update(input, 0, input.length, cipherText, 0);
    ctLength += cipher.doFinal(cipherText, ctLength);
    System.out.println(new String(cipherText));
    System.out.println(ctLength);

    // decryption pass
    cipher.init(Cipher.DECRYPT_MODE, key);
    byte[] plainText = new byte[cipher.getOutputSize(ctLength)];
    int ptLength = cipher.update(cipherText, 0, ctLength, plainText, 0);
    ptLength += cipher.doFinal(plainText, ptLength);
    System.out.println(new String(plainText));
    System.out.println(ptLength);
  }
}
",4,0,2db4274b308af8cfeadd4d9b877c2bfab1a87ab51c4e89d2d9721e11c560297b
,"private byte[] encrypt(byte[] raw, byte[] clear) throws Exception {
    SecretKeySpec skeySpec = new SecretKeySpec(raw, ""AES"");
    Cipher cipher = Cipher.getInstance(""AES"");
    cipher.init(Cipher.ENCRYPT_MODE, skeySpec);

    int offset = 0;
    byte[] encrypted;

    while(offset &lt; clear.length()) {
        final byte[] answer = cipher.update(clear, offset, 1024);
        encrypted = Arrays.copyOf( encrypted, encrypted.length + 1024);
        System.arrayCopy(answer, 0, encrypted, offset, 1024);
        offset += 1024;
    }
    encrypted += cipher.doFinal(clear, offset, clear.length() - offset);
    return encrypted;
}
",4,0,f22c82c560d697d955c4aa9f7f4ea059da6dc52981f42fafe77d46d1cb6cbbf6
,"   public  byte[] decrypt(byte[] cipherText, byte[] key, byte [] initialVector) throws NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, InvalidAlgorithmParameterException, IllegalBlockSizeException, BadPaddingException
{
    Cipher cipher = Cipher.getInstance(cipherTransformation);
    SecretKeySpec secretKeySpecy = new SecretKeySpec(key, aesEncryptionAlgorithm);
    IvParameterSpec ivParameterSpec = new IvParameterSpec(initialVector);
    cipher.init(Cipher.DECRYPT_MODE, secretKeySpecy, ivParameterSpec);
    cipherText = cipher.doFinal(cipherText);
    return cipherText;
}

public byte[] encrypt(byte[] plainText, byte[] key, byte [] initialVector) throws NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, InvalidAlgorithmParameterException, IllegalBlockSizeException, BadPaddingException
{
    Cipher cipher = Cipher.getInstance(cipherTransformation);
    SecretKeySpec secretKeySpec = new SecretKeySpec(key, aesEncryptionAlgorithm);
    IvParameterSpec ivParameterSpec = new IvParameterSpec(initialVector);
    cipher.init(Cipher.ENCRYPT_MODE, secretKeySpec, ivParameterSpec);
    plainText = cipher.doFinal(plainText);
    return plainText;
}
",,1,425c13cf6049879c184f94d7765f22f4e8877880f7b8a2a09336becf2fa1b6d0
,"    try
    {
        MessageDigest digester = MessageDigest.getInstance(""MD5"");
        digester.update(""test"".getBytes(""UTF-8""));
        byte[] digest = digester.digest();
    }
    catch (Throwable e1)
    {
        e1.printStackTrace();
        // Class available but not functional
    }
",3,0,aa84a578f54060e806b32b5b5c7908827db08bacc681c1ffb7e3806fdc69d622
,"String aid = Settings.Secure.getString(getContext().getContentResolver(), ""android_id"");

Object obj = null;
try {
    ((MessageDigest) (obj = MessageDigest.getInstance(""MD5""))).update(
                                   aid.getBytes(), 0, aid.length());

    obj = String.format(""%032X"", new Object[] { new BigInteger(1,
                                   ((MessageDigest) obj).digest()) });
} catch (NoSuchAlgorithmException localNoSuchAlgorithmException) {
    obj = aid.substring(0, 32);
}
adRequest.addTestDevice(obj.toString());
",,1,a6d22e29b6e912584692afe0980e64a55eb3dc7868b0e8fb2e8ea80ac4df3eaa
,"    PackageInfo packageInfo = null;
    try {
        packageInfo = getContext().getPackageManager().getPackageInfo(getContext().getPackageName(), PackageManager.GET_SIGNATURES);
    } catch (PackageManager.NameNotFoundException e) {
        e.printStackTrace();
    }
    Signature[] signatures = packageInfo.signatures;
    byte[] cert = signatures[0].toByteArray();
    InputStream input = new ByteArrayInputStream(cert);

    CertificateFactory cf = null;
    try {
        cf = CertificateFactory.getInstance(""X509"");
    } catch (CertificateException e) {
        e.printStackTrace();
    }
    X509Certificate c = null;
    try {
        c = (X509Certificate) cf.generateCertificate(input);
    } catch (CertificateException e) {
        e.printStackTrace();
    }
    try {
        MessageDigest md = MessageDigest.getInstance(""SHA1"");
        byte[] publicKey = md.digest(c.getPublicKey().getEncoded());

        StringBuffer hexString = new StringBuffer();
        for (int i=0;i&lt;publicKey.length;i++) {
            String appendString = Integer.toHexString(0xFF &amp; publicKey[i]);
            if(appendString.length()==1)hexString.append(""0"");
            hexString.append(appendString);
        }
        Log.d(""SHA1"", ""Cer: "" + hexString.toString());

    } catch (NoSuchAlgorithmException e1) {
        e1.printStackTrace();
    }
",3,0,ef574bce018a841e18d676421002cbc5a68daea98f7e4fb539376b01e8f23cf6
,"public class WriteXMLFile {

    public static void main(String argv[]) {

      try {

        DocumentBuilderFactory docFactory = DocumentBuilderFactory.newInstance();
        DocumentBuilder docBuilder = docFactory.newDocumentBuilder();

        // root elements
        Document doc = docBuilder.newDocument();
        Element rootElement = doc.createElement(""company"");
        doc.appendChild(rootElement);

        // staff elements
        Element staff = doc.createElement(""Staff"");
        rootElement.appendChild(staff);

        // set attribute to staff element
        Attr attr = doc.createAttribute(""id"");
        attr.setValue(""1"");
        staff.setAttributeNode(attr);

        // shorten way
        // staff.setAttribute(""id"", ""1"");

        // firstname elements
        Element firstname = doc.createElement(""firstname"");
        firstname.appendChild(doc.createTextNode(""yong""));
        staff.appendChild(firstname);

        // lastname elements
        Element lastname = doc.createElement(""lastname"");
        lastname.appendChild(doc.createTextNode(""mook kim""));
        staff.appendChild(lastname);

        // nickname elements
        Element nickname = doc.createElement(""nickname"");
        nickname.appendChild(doc.createTextNode(""mkyong""));
        staff.appendChild(nickname);

        // salary elements
        Element salary = doc.createElement(""salary"");
        salary.appendChild(doc.createTextNode(""100000""));
        staff.appendChild(salary);

        // write the content into xml file
        TransformerFactory transformerFactory = TransformerFactory.newInstance();
        Transformer transformer = transformerFactory.newTransformer();
        DOMSource source = new DOMSource(doc);
        StreamResult result = new StreamResult(new File(""C:\\file.xml""));

        // Output to console for testing
        // StreamResult result = new StreamResult(System.out);

        transformer.transform(source, result);

        System.out.println(""File saved!"");

      } catch (ParserConfigurationException pce) {
        pce.printStackTrace();
      } catch (TransformerException tfe) {
        tfe.printStackTrace();
      }
    }
}
",,1,9016c571e0017289de888521a48567a7c19fcad522c814ad5f14da2b26315748
,"private static void trustAllHosts()
{
    // Create a trust manager that does not validate certificate chains
    TrustManager[] trustAllCerts = new TrustManager[] { new X509TrustManager()
    {
        public java.security.cert.X509Certificate[] getAcceptedIssuers()
        {
            return new java.security.cert.X509Certificate[] {};
        }

        public void checkClientTrusted(X509Certificate[] chain,
                String authType) throws CertificateException
        {}

        public void checkServerTrusted(X509Certificate[] chain,
                String authType) throws CertificateException
        {}
    }

    // Install the all-trusting trust manager
    try
    {
        SSLContext sc = SSLContext.getInstance(""TLS"");
        sc.init(null, trustAllCerts, new java.security.SecureRandom());
        HttpsURLConnection
        .setDefaultSSLSocketFactory(sc.getSocketFactory());
    }
    catch (Exception e)
    {
        e.printStackTrace();
    }
}
",4,0,bde47facf38d551bae1b9b49e9c7e74f586cb346722701e27455bdbdc70339d1
,"private static class MyTrustManager implements X509TrustManager
{

    @Override
    public void checkClientTrusted(X509Certificate[] chain, String authType)
         throws CertificateException
    {
    }

    @Override
    public void checkServerTrusted(X509Certificate[] chain, String authType)
        throws CertificateException
    {
    }

    @Override
    public X509Certificate[] getAcceptedIssuers()
    {
        return null;
    }

}

...

HttpsURLConnection conn = (HttpsURLConnection) url.openConnection();
try
{
    // Create an SSLContext that uses our TrustManager
    SSLContext context = SSLContext.getInstance(""TLS"");
    TrustManager[] tmlist = {new MyTrustManager()};
    context.init(null, tmlist, null);
    conn.setSSLSocketFactory(context.getSocketFactory());
}
catch (NoSuchAlgorithmException e)
{
    throw new IOException(e);
} catch (KeyManagementException e)
{
    throw new IOException(e);
}
conn.setRequestMethod(""GET"");
int rcode = conn.getResponseCode();
",4,0,cad45220e2a4bb0aadbf493f79131bc231adcf6c2334d297cd8f4430c5e62c48
,"public static String encriptSHA1(String password){
        String hash = """";

        try {
            MessageDigest md;
            byte[] buffer, digest;

            buffer = password.getBytes();
            md = MessageDigest.getInstance(""SHA1"");

            md.update(buffer);
            digest = md.digest();

            for(byte aux : digest) {
                int b = aux &amp; 0xff;
                if (Integer.toHexString(b).length() == 1) hash += ""0"";
                hash += Integer.toHexString(b);
            }
        } catch (NoSuchAlgorithmException e) {
        }

        return hash;
    }
",3,0,55d98491da58aafb57bf04a5fa09a1233a93147b524e22db1da68c9a0942cb1d
,"
public class GMailSender extends javax.mail.Authenticator {
 private String mailhost = ""smtp.gmail.com"";
 private String user;
 private String password;
 private Session session;

 static {
  Security.addProvider(new JSSEProvider());
 }

 public GMailSender(String user, String password) {
  this.user = user;
  this.password = password;

  Properties props = new Properties();
  props.setProperty(""mail.transport.protocol"", ""smtp"");
  props.setProperty(""mail.host"", mailhost);
  props.put(""mail.smtp.auth"", ""true"");
  props.put(""mail.smtp.port"", ""465"");
  props.put(""mail.smtp.socketFactory.port"", ""465"");
  props.put(""mail.smtp.socketFactory.class"", ""javax.net.ssl.SSLSocketFactory"");
  props.put(""mail.smtp.socketFactory.fallback"", ""false"");
  props.setProperty(""mail.smtp.quitwait"", ""false"");

  session = Session.getDefaultInstance(props, this);
 }

 protected PasswordAuthentication getPasswordAuthentication() {
  return new PasswordAuthentication(user, password);
 }

 public synchronized void sendMail(String subject, String body, String sender, String recipients) throws Exception {
  MimeMessage message = new MimeMessage(session);
  DataHandler handler = new DataHandler(new ByteArrayDataSource(body.getBytes(), ""text/plain""));
  message.setSender(new InternetAddress(sender));
  message.setSubject(subject);
  message.setDataHandler(handler);
  if (recipients.indexOf(',') > 0)
   message.setRecipients(Message.RecipientType.TO, InternetAddress.parse(recipients));
  else
   message.setRecipient(Message.RecipientType.TO, new InternetAddress(recipients));
  Transport.send(message);
 }

 public class ByteArrayDataSource implements DataSource {
  private byte[] data;
  private String type;

  public ByteArrayDataSource(byte[] data, String type) {
   super();
   this.data = data;
   this.type = type;
  }

  public ByteArrayDataSource(byte[] data) {
   super();
   this.data = data;
  }

  public void setType(String type) {
   this.type = type;
  }

  public String getContentType() {
   if (type == null)
    return ""application/octet-stream"";
   else
    return type;
  }

  public InputStream getInputStream() throws IOException {
   return new ByteArrayInputStream(data);
  }

  public String getName() {
   return ""ByteArrayDataSource"";
  }

  public OutputStream getOutputStream() throws IOException {
   throw new IOException(""Not Supported"");
  }
 }
}
",3,0,3b98bbc795548916e3fc46b8b5d2482aeaf34b955246fc6baaa50af0fe5f1237
,"
@SuppressWarnings(""serial"")
public final class JSSEProvider extends Provider {
 public JSSEProvider() {
  super(""HarmonyJSSE"", 1.0, ""Harmony JSSE Provider"");
  AccessController.doPrivileged(new java.security.PrivilegedAction() {
   public Void run() {
    put(""SSLContext.TLS"", ""org.apache.harmony.xnet.provider.jsse.SSLContextImpl"");
    put(""Alg.Alias.SSLContext.TLSv1"", ""TLS"");
    put(""KeyManagerFactory.X509"", ""org.apache.harmony.xnet.provider.jsse.KeyManagerFactoryImpl"");
    put(""TrustManagerFactory.X509"", ""org.apache.harmony.xnet.provider.jsse.TrustManagerFactoryImpl"");
    return null;
   }
  });
 }
}
</pre>",3,0,48f1fbf10e5e02bb585028ef4f15751534ed537f80d83032b83c6e3511702407
,"KeyStore keyStore = KeyStore.getInstance(KeyStore.getDefaultType());
keyStore.load(getAssets().open(""test.keystore""), ""ssltest"".toCharArray());

ServerSocketFactory socketFactory = SSLServerSocketFactory.getDefault();
mServerSocket = (SSLServerSocket) socketFactory.createServerSocket(8080);
",,1,d1c7d49c693b374fd613eb6c61a1b5e5ff03be28ac669e6b48b04fd6d4393749
,"final String appPackage = ""com.example""  // TODO: Add here the package name!!

try {
    final PackageManager pm = getPackageManager();
    final ApplicationInfo ai = pm.getApplicationInfo(appPackage, PackageManager.GET_META_DATA);

    if ( ai != null ) {
        final PackageInfo pi = pm.getPackageInfo(this.packageName, PackageManager.GET_PERMISSIONS);

        if ( pi != null ) {
            final Signature[] signatures = pi.signatures;

            if ( (pi.signatures != null) &amp;&amp; (pi.signatures.length &gt; 0) ) {
                for ( final Signature signature : signatures ) {
                    if ( signature != null ) {
                        final InputStream certInputStream = new ByteArrayInputStream(signature.toByteArray());
                        final CertificateFactory certFactory;
                        final X509Certificate x509Cert;

                        try {
                            certFactory = CertificateFactory.getInstance(""X509"");

                            if ( certFactory != null ) {
                                x509Cert = (X509Certificate) certFactory.generateCertificate(certInputStream);

                                if ( x509Cert != null ) {
                                    SimpleDateFormat dateFormat = new SimpleDateFormat(""yyyy-MM-dd HH:mm:ss"");

                                    Log.d(TAG, ""Certificate Owner: "" + x509Cert.getSubjectDN().toString());
                                    Log.d(TAG, ""Certificate Issuer: "" + x509Cert.getIssuerDN().toString());
                                    Log.d(TAG, ""Certificate Serial Number: "" + x509Cert.getSerialNumber().toString());
                                    Log.d(TAG, ""Certificate Algorithm: "" + x509Cert.getSigAlgName());
                                    Log.d(TAG, ""Certificate Version: "" + x509Cert.getVersion());
                                    Log.d(TAG, ""Certificate OID: "" + x509Cert.getSigAlgOID());
                                    Log.d(TAG, ""Certificate Valid From: "" + dateFormat.format( x509Cert.getNotBefore() ));
                                    Log.d(TAG, ""Certificate Valid To: "" + dateFormat.format( x509Cert.getNotAfter() ));

                                    try {
                                        final MessageDigest md = MessageDigest.getInstance(""SHA-256"");
                                        md.update( x509Cert.getEncoded() );

                                        Log.d(TAG, ""Certificate SHA-256: "" + getHex(md.digest()));
                                    }
                                    catch ( NoSuchAlgorithmException e ) {
                                        //Debug:
                                        Log.e(TAG, ""MessageDigest ERROR: "" + e.getMessage() + ""\n"");
                                        //e.printStackTrace();
                                    }
                                }
                            }
                        }
                        catch ( final CertificateException e ) {
                            //Debug:
                            Log.e(TAG, ""CertificateFactory ERROR: "" + e.getMessage() + ""\n"");
                            //e.printStackTrace();
                        }
                    }
                }
            }
        }
    }
}
catch ( final PackageManager.NameNotFoundException e ) {
    //Debug:
    Log.e(TAG, ""ApplicationInfo ERROR: "" + e.getMessage() + ""\n"");
    //e.printStackTrace();
}
",,1,2ac20c23f4666ff7524195bb9b8047aa508149c47514c47470de3bff4ecf0803
,"private static byte[] encrypt(byte[] raw, byte[] clear) throws Exception {
SecretKeySpec skeySpec = new SecretKeySpec(raw, ""AES"");
Cipher cipher = Cipher.getInstance(""AES"");
cipher.init(Cipher.ENCRYPT_MODE, skeySpec);
byte[] encrypted = cipher.doFinal(clear);
return encrypted;
}

private static byte[] decrypt(byte[] raw, byte[] encrypted) throws   
 Exception   {
SecretKeySpec skeySpec = new SecretKeySpec(raw, ""AES"");
Cipher cipher = Cipher.getInstance(""AES"");
cipher.init(Cipher.DECRYPT_MODE, skeySpec);
byte[] decrypted = cipher.doFinal(encrypted);
return decrypted;
}
",4,0,90da9665793f3eaac775f19a9f809683eba36a9e5759b45ee3821819e9cb8153
,"    Provider[] providers = Security.getProviders();
    for (Provider p : providers) {
        Log.d(TAG, ""provider: "" + p.getName());
        Set&lt;Provider.Service&gt; services = p.getServices();
        for (Provider.Service s : services) {
            Log.d(TAG, ""--&gt; algorithm: "" + s.getAlgorithm());
        }
    }
",,1,e16b414c0ee002d4f1e206116be6cac620a418086bcbff90d48f27e45bdbf797
,"//Generate a key
KeyGenerator KeyGen = KeyGenerator.getInstance(""AES"");
KeyGen.init(128);
SecretKey Key = KeyGen.generateKey();

//Generate init vector
SecureRandom rng = SecureRandom.getInstance(""SHA1PRNG"");
byte [] IV = new byte[16];
rng.nextBytes(IV);

//Initialize the encryptor
Cipher ci = Cipher.getInstance(""AES/CBC/NoPadding""); //The spec might be different!
ci.init(Cipher.ENCRYPT_MODE, Key, new IvParameterSpec(IV));
",4,0,a9a4203c4d534a2f6180cfdd3aefe74d8a95c0e30553a76e7a6abd0d44a4088a
,"/*
Copyright (C) 2012 Sveinung Kval Bakken, sveinung.bakken@gmail.com

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
""Software""), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

 */

import java.io.UnsupportedEncodingException;
import java.security.GeneralSecurityException;
import java.security.InvalidAlgorithmParameterException;
import java.security.InvalidKeyException;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;

import javax.crypto.Cipher;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;

import android.content.Context;
import android.content.SharedPreferences;
import android.util.Base64;


public class SecurePreferences {

    public static class SecurePreferencesException extends RuntimeException {

        public SecurePreferencesException(Throwable e) {
            super(e);
        }

    }

    private static final String TRANSFORMATION = ""AES/CBC/PKCS5Padding"";
    private static final String KEY_TRANSFORMATION = ""AES/ECB/PKCS5Padding"";
    private static final String SECRET_KEY_HASH_TRANSFORMATION = ""SHA-256"";
    private static final String CHARSET = ""UTF-8"";

    private final boolean encryptKeys;
    private final Cipher writer;
    private final Cipher reader;
    private final Cipher keyWriter;
    private final SharedPreferences preferences;

    /**
     * This will initialize an instance of the SecurePreferences class
     * @param context your current context.
     * @param preferenceName name of preferences file (preferenceName.xml)
     * @param secureKey the key used for encryption, finding a good key scheme is hard. 
     * Hardcoding your key in the application is bad, but better than plaintext preferences. Having the user enter the key upon application launch is a safe(r) alternative, but annoying to the user.
     * @param encryptKeys settings this to false will only encrypt the values, 
     * true will encrypt both values and keys. Keys can contain a lot of information about 
     * the plaintext value of the value which can be used to decipher the value.
     * @throws SecurePreferencesException
     */
    public SecurePreferences(Context context, String preferenceName, String secureKey, boolean encryptKeys) throws SecurePreferencesException {
        try {
            this.writer = Cipher.getInstance(TRANSFORMATION);
            this.reader = Cipher.getInstance(TRANSFORMATION);
            this.keyWriter = Cipher.getInstance(KEY_TRANSFORMATION);

            initCiphers(secureKey);

            this.preferences = context.getSharedPreferences(preferenceName, Context.MODE_PRIVATE);

            this.encryptKeys = encryptKeys;
        }
        catch (GeneralSecurityException e) {
            throw new SecurePreferencesException(e);
        }
        catch (UnsupportedEncodingException e) {
            throw new SecurePreferencesException(e);
        }
    }

    protected void initCiphers(String secureKey) throws UnsupportedEncodingException, NoSuchAlgorithmException, InvalidKeyException,
            InvalidAlgorithmParameterException {
        IvParameterSpec ivSpec = getIv();
        SecretKeySpec secretKey = getSecretKey(secureKey);

        writer.init(Cipher.ENCRYPT_MODE, secretKey, ivSpec);
        reader.init(Cipher.DECRYPT_MODE, secretKey, ivSpec);
        keyWriter.init(Cipher.ENCRYPT_MODE, secretKey);
    }

    protected IvParameterSpec getIv() {
        byte[] iv = new byte[writer.getBlockSize()];
        System.arraycopy(""fldsjfodasjifudslfjdsaofshaufihadsf"".getBytes(), 0, iv, 0, writer.getBlockSize());
        return new IvParameterSpec(iv);
    }

    protected SecretKeySpec getSecretKey(String key) throws UnsupportedEncodingException, NoSuchAlgorithmException {
        byte[] keyBytes = createKeyBytes(key);
        return new SecretKeySpec(keyBytes, TRANSFORMATION);
    }

    protected byte[] createKeyBytes(String key) throws UnsupportedEncodingException, NoSuchAlgorithmException {
        MessageDigest md = MessageDigest.getInstance(SECRET_KEY_HASH_TRANSFORMATION);
        md.reset();
        byte[] keyBytes = md.digest(key.getBytes(CHARSET));
        return keyBytes;
    }

    public void put(String key, String value) {
        if (value == null) {
            preferences.edit().remove(toKey(key)).commit();
        }
        else {
            putValue(toKey(key), value);
        }
    }

    public boolean containsKey(String key) {
        return preferences.contains(toKey(key));
    }

    public void removeValue(String key) {
        preferences.edit().remove(toKey(key)).commit();
    }

    public String getString(String key) throws SecurePreferencesException {
        if (preferences.contains(toKey(key))) {
            String securedEncodedValue = preferences.getString(toKey(key), """");
            return decrypt(securedEncodedValue);
        }
        return null;
    }

    public void clear() {
        preferences.edit().clear().commit();
    }

    private String toKey(String key) {
        if (encryptKeys)
            return encrypt(key, keyWriter);
        else return key;
    }

    private void putValue(String key, String value) throws SecurePreferencesException {
        String secureValueEncoded = encrypt(value, writer);

        preferences.edit().putString(key, secureValueEncoded).commit();
    }

    protected String encrypt(String value, Cipher writer) throws SecurePreferencesException {
        byte[] secureValue;
        try {
            secureValue = convert(writer, value.getBytes(CHARSET));
        }
        catch (UnsupportedEncodingException e) {
            throw new SecurePreferencesException(e);
        }
        String secureValueEncoded = Base64.encodeToString(secureValue, Base64.NO_WRAP);
        return secureValueEncoded;
    }

    protected String decrypt(String securedEncodedValue) {
        byte[] securedValue = Base64.decode(securedEncodedValue, Base64.NO_WRAP);
        byte[] value = convert(reader, securedValue);
        try {
            return new String(value, CHARSET);
        }
        catch (UnsupportedEncodingException e) {
            throw new SecurePreferencesException(e);
        }
    }

    private static byte[] convert(Cipher cipher, byte[] bs) throws SecurePreferencesException {
        try {
            return cipher.doFinal(bs);
        }
        catch (Exception e) {
            throw new SecurePreferencesException(e);
        }
    }
}
",4,0,a2bec02aa3996a19549efe8a4772756df76732e02c963b5862156248823b429a
,"try {
            PackageInfo info = getPackageManager().getPackageInfo(""YOUR_PACKAGE_NAME"", PackageManager.GET_SIGNATURES);
            for (Signature signature : info.signatures) {
                MessageDigest md = MessageDigest.getInstance(""SHA"");
                md.update(signature.toByteArray());
                Log.d(""KeyHash:"", Base64.encodeToString(md.digest(), Base64.DEFAULT));
                }
        } catch (NameNotFoundException e) {

        } catch (NoSuchAlgorithmException e) {

        }
",3,0,38f9550e974781d86a8a5d6fbe15e8c4a5221c9f870e36f5b6aefd2cc39056a1
,"enter code here
public static void GenerateKeyPair()
{       
    try{
        KeyPairGenerator kpg = KeyPairGenerator.getInstance(""RSA"");
        kpg.initialize(2048);
        KeyPair kp = kpg.genKeyPair();

        KeyFactory fact = KeyFactory.getInstance(""RSA"");
        RSAPublicKeySpec pub = fact.getKeySpec(kp.getPublic(),
          RSAPublicKeySpec.class);
        RSAPrivateKeySpec priv = fact.getKeySpec(kp.getPrivate(),
          RSAPrivateKeySpec.class);

        saveToFile(""public.key"", pub.getModulus(),
                  pub.getPublicExponent());
        saveToFile(""private.key"", priv.getModulus(),
                  priv.getPrivateExponent());
    }catch(Exception e){
        System.out.println(e.getMessage());
    }
}

public static void saveToFile(String fileName,
  BigInteger mod, BigInteger exp) throws Exception {
  ObjectOutputStream oout = new ObjectOutputStream(
    new BufferedOutputStream(new FileOutputStream(fileName)));
  try {
    oout.writeObject(mod);
    oout.writeObject(exp);
  } catch (Exception e) {
    throw new Exception(""error"", e);
  } finally {
    oout.close();
  }
}
",3,0,3463a1156760f62477d3c747117de52f633fdfcfbf12487c16b2e68334cad730
,"private void showHashKey()
{
    // Add code to print out the key hash
    try {
        PackageInfo info = getPackageManager().getPackageInfo(
                ""com.kisan.kisan"",
                PackageManager.GET_SIGNATURES);
        for (Signature signature : info.signatures) {
            MessageDigest md = MessageDigest.getInstance(""SHA"");
            md.update(signature.toByteArray());
            Log.d(""KeyHash:"", Base64.encodeToString(md.digest(), Base64.DEFAULT));
        }
    } catch (PackageManager.NameNotFoundException e) {

    } catch (NoSuchAlgorithmException e) {

    }

}
",3,0,bdbb41842b0018cf088564acfab7fe2ee288ae86c4cd7bf76ebeb2eedc4e2c04
,"//get keystore 
//jks for type ""JKS"",
//.p12 or .pfx for type ""PKCS12""
//specification name is PKCS#12, but the # is not used in the Java keystore type name
KeyStore keystore = KeyStore.getInstance(""pkcs12"");
//load keystore - is FileImputStream to location of your pfx/jks file          
keystore.load(is, password);
//get private key           
PrivateKey privateKey = (PrivateKey)keystore.getKey(alias, password);
",,1,74552bfb4b8b4352112c16f9bc41298fb79d22336edf2da5de921142c1939e91
,"    InputStream is = new FileInputStream(...); //Input stream

    SecretKeySpec skey = new SecretKeySpec(Hex.decodeHex(key.toCharArray()), ""AES"");
    Cipher cipher = Cipher.getInstance(""AES/ECB/PKCS5Padding"");
    cipher.init(Cipher.ENCRYPT_MODE, skey); 
    FileOutputStream fileOuputStream = new FileOutputStream(SD_CARD_PATH+ ""/"" + ""abcd.db""); 
    CipherOutputStream cos = new CipherOutputStream(fileOuputStream, cipher);

    //Now read from input and write to output using your favorite utilities library
    //Guava and Apache Commons IO are good examples.
    FooUtils.copy(is, cos);
    //Remember to close streams if the previous call didn't (preferably in a finally block)
",4,0,a9e618ad6b46182c209557e5ad20d4372fa4dce8bf0299dd2476f292b97f9f43
,"SSLContext ctx;
        try {
            ctx = SSLContext.getInstance(""TLS"");
            ctx.init(null, new TrustManager[] {
                      new X509TrustManager() {
                        public void checkClientTrusted(X509Certificate[] chain, String authType) {}
                        public void checkServerTrusted(X509Certificate[] chain, String authType) {}
                        public X509Certificate[] getAcceptedIssuers() { return new X509Certificate[]{}; }
                      }
                    }, null);
            HttpsURLConnection.setDefaultSSLSocketFactory(ctx.getSocketFactory());
        } catch (NoSuchAlgorithmException e) {
            e.printStackTrace();
        } catch (KeyManagementException e) {
            e.printStackTrace();
        }
",4,0,4960212ab56fe390650c737e86b30119d21dfb8d287509698515335d97b2d6d2
,"HttpParams params = new BasicHttpParams();
HttpConnectionParams.setConnectionTimeout(params, 5000);
HttpConnectionParams.setSoTimeout(params, 30000);
HostnameVerifier hostnameVerifier = org.apache.http.conn.ssl.SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER;

DefaultHttpClient httpClient = new DefaultHttpClient();

SchemeRegistry registry = new SchemeRegistry();
SSLSocketFactory socketFactory = SSLSocketFactory.getSocketFactory();
socketFactory.setHostnameVerifier((X509HostnameVerifier) hostnameVerifier);
registry.register(new Scheme(""https"", socketFactory, 443));
SingleClientConnManager mgr = new SingleClientConnManager(httpClient.getParams(), registry);
DefaultHttpClient client = new DefaultHttpClient(mgr, httpClient.getParams());

// Set verifier      
HttpsURLConnection.setDefaultHostnameVerifier(hostnameVerifier);
",4,0,9e4236f76ceb99653726a6b9538b40a2538a219425b7bdeac4f4c948c33c2481
,"public void setPassCode(String   value) throws Exception { 

    try {

        SecretKeySpec sks = null; 
        sks = getEncryptKey();

        byte[] userLatENC=null;

        Cipher c = Cipher.getInstance(""AES"");
        c.init(Cipher.ENCRYPT_MODE,sks ); 
        userLatENC = c.doFinal(value.getBytes());

        passCode = Base64.encodeToString(userLatENC, Base64.DEFAULT);

    } catch (Exception e) {
        throw e;
    }
}
",4,0,7d01625f3ac8cb5de0c47e7fed5bfc2e502ebf4a8f44eb64a2d197923d8d3f71
,"    try {

        String encVal = ""pass_code"";

        if (encVal.isEmpty()) {
            return encVal;
        }


        sks = getDecryptKey();

        byte[] latDEC=null;


        Cipher c = Cipher.getInstance(""AES"");
        c.init(Cipher.DECRYPT_MODE, sks);

        latDEC = c.doFinal(Base64.decode(encVal, Base64.DEFAULT));




        return new String(latDEC);

    } catch (Exception e) {
        throw e;
    }
}
",4,0,63b2758ebdd15c89c1fdb5d04c8cb59cb64cc4c8d62ab5d756a678d5c1d01ad9
,"    SecretKeySpec sks = null; 
    SecretKey key =null;
    byte[]  keyToSave;


    try {
        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());



        SecureRandom sr = SecureRandom.getInstance(""SHA1PRNG"");
        sr.setSeed(""any data used as random seed"".getBytes());
        KeyGenerator kg = KeyGenerator.getInstance(""AES"");


        kg.init(128, sr);
        key= kg.generateKey();
        keyToSave =key.getEncoded();
        sks = new SecretKeySpec(keyToSave, ""AES"");

        ks.load(null,null);
        ks.setKeyEntry(""aliasKey"",key,null, null);


        FileOutputStream ksout = context.openFileOutput(""keystore_android"", Context.MODE_PRIVATE);
        ks.store(ksout, null);
        ksout.close();

        return sks;

    } catch (Exception e) {
        throw e;
    }
}
",4,0,19a8b67941435c63565e0fe8b993766c9fb183ccb1950777bd1e3afe0231b975
,"    SecretKeySpec sks = null;

    try {

        KeyStore keyStore = KeyStore.getInstance(KeyStore.getDefaultType());
        FileInputStream fis = null;

        fis = context.openFileInput(""keystore_android"");



        keyStore.load(fis,null);
        sks=new SecretKeySpec((keyStore.getKey(""aliasKey"", null)).getEncoded(), ""AES"");

        return sks;
    } catch (Exception e) {
        throw e;
    } 
}
",,1,bdeff5185a775ecb7180a471edfe0a3fa8acde8e9024dcbcc50b939165d9169c
,"public class ServerThread extends Thread
{
    //is the thread running
    private boolean running = true;

    //ports for the server sockets
    private final int dataPort;
    private final int filePort;

    private final String certificateDir;
    private final char[] password;

    private Vector&lt;ClientHandlerThread&gt; connectedClients = new Vector&lt;ClientHandlerThread&gt;(20, 5);
    private Properties userProperties = new Properties();

    public ServerThread(int dataPort,
                        int filePort,
                        String certificateDir,
                        char[] password,
                        Properties userProperties)
    {
        this.dataPort = dataPort;
        this.filePort = filePort;
        this.certificateDir = certificateDir;
        this.password = password;
        this.userProperties = userProperties;
    }

    public void run()
    {
        /*
         * We need a server socket that can accept traffic. I use one for file traffic and one
         * for data traffic although one socket could be used.
         */
        SSLServerSocket sslDataTraffic = null;
        SSLServerSocket sslFileTraffic = null;
        SSLServerSocketFactory sslFac = null;

        /*
         * Everything in the following block is related to creating a SSL security manager. 
         * If you don't need validated communications you don't have to use SSL. Just normal
         * sockets.
         */
        try
        {
            KeyStore keyStore = KeyStore.getInstance(KeyStore.getDefaultType());
            keyStore.load(new FileInputStream(certificateDir), password);

            TrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());
            tmf.init(keyStore);

            KeyManagerFactory kmf = KeyManagerFactory.getInstance((KeyManagerFactory.getDefaultAlgorithm()));
            kmf.init(keyStore, password);

            System.setProperty(""https.protocols"", ""SSL"");
            SSLContext ctx = SSLContext.getInstance(""SSL"");
            ctx.init(kmf.getKeyManagers(), tmf.getTrustManagers(), null);
            sslFac = ctx.getServerSocketFactory();
        }
        catch(Exception e)
        {
            System.out.println(""FAILED."");
            e.printStackTrace();
            System.exit(-1);
        }

        try
        {
            //create data server socket 
            System.out.print(""Creating data socket......... "");
            sslDataTraffic = (SSLServerSocket) sslFac.createServerSocket(dataPort);
            System.out.println(""DONE. Est. on:"" + dataPort);

            //create file server socket
            System.out.print(""Creating file socket......... "");
            sslFileTraffic = (SSLServerSocket) sslFac.createServerSocket(filePort);
            System.out.println(""DONE. Est. on:"" + filePort);
        }
        catch (IOException e)
        {
            System.out.println(""FAILED."");
            System.out.println(e.toString() + "" ::: "" + e.getCause());
            System.exit(-1);
        }

        /*
         * This block is used to print the ip the server is running on. Easy to incorporate this here
         * so the information doesn't have to be gathered form another source.
         */
        try
        {
            System.out.print(""Finishing.................... "");
            Socket s = new Socket(""google.com"", 80);
            System.out.println(""DONE."");
            System.out.println(""Server online at: "" + s.getLocalAddress().getHostAddress());
            System.out.println(""====================*===================="");
            s.close();
        }
        catch (IOException e)
        {
            e.printStackTrace();
        }

        /*
         * This is the block that accepts connections from clients.
         */
        try
        {
            while (running)
            {
                //wait here until a connection is bound to new sockets through the server sockets
                SSLSocket sslDataTrafficSocketInstance = (SSLSocket) sslDataTraffic.accept();
                SSLSocket sslFileTrafficSocketInstance = (SSLSocket) sslFileTraffic.accept();
                //sockets to communicate with the client are created. Lets put them in a thread so 
                //we can continue to accept new clients while we work with the newly and previously
                //connected clients

                //create a new thread
                ClientHandlerThread c = new ClientHandlerThread(
                        sslDataTrafficSocketInstance, 
                        sslFileTrafficSocketInstance, 
                        userProperties);
                //start thread
                c.start();
                //add newly connected client to the list of connected clients
                connectedClients.add(c);
            }
        }
        catch (IOException e)
        {
            System.out.println(""Fatal server error, terminating server and client handler threads"");

            stopServer();
        }
    }
}
",,1,61afcb5ae5f7fbfd4663ebd2a068374aed37849f2dfbf19c0c9d63c3ac178ff8
,"    private void connect()
    {
        try
        {
            SSLSocketFactory sslFac;
            SSLSocket dataSocket = null;
            SSLSocket fileSocket = null;

            /*
             * This block is nearly identical to the security block for the server side.  
             */
            try
            {
                KeyStore keyStore = KeyStore.getInstance(KeyStore.getDefaultType());
                keyStore.load(new FileInputStream(certificateDir), password.toCharArray());

                TrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());
                tmf.init(keyStore);

                KeyManagerFactory kmf = KeyManagerFactory.getInstance((KeyManagerFactory.getDefaultAlgorithm()));
                kmf.init(keyStore, password.toCharArray());

                System.setProperty(""https.protocols"", ""SSL"");
                SSLContext ctx = SSLContext.getInstance(""SSL"");
                ctx.init(kmf.getKeyManagers(), tmf.getTrustManagers(), null);
                sslFac = ctx.getSocketFactory();

                String ip = ""&lt;THE SERVER'S IP ADDRESS&gt;"";
                dataSocket = (SSLSocket) sslFac.createSocket(ip, dataPort);
                fileSocket = (SSLSocket) sslFac.createSocket(ip, filePort);
            }
            catch(Exception e)
            {
                System.out.println(""FAILED."");
                e.printStackTrace();
                System.exit(-1);
            }

            reader = new BufferedReader(new InputStreamReader(dataSocket.getInputStream()));
            writer = new PrintWriter(dataSocket.getOutputStream());
            OutputStream fileOut = fileSocket.getOutputStream();

            writer.println(""CLIENT_HANDSHAKE_INIT"");
            writer.flush();
            }
     }
",3,0,b514b770e459574607931431b80cdde243d97827afa0db1697a85d1a9af65efd
,"public boolean deleteFile(File target)
{
    if (System.getSecurityManager() != null)
    {
        try
        {
            Actions actions = (Actions) m_actions.get();
            actions.set(Actions.DELETE_FILE_ACTION, target);
            return ((Boolean) AccessController.doPrivileged(actions, m_acc))
                .booleanValue();
        }
        catch (PrivilegedActionException ex)
        {
            throw (RuntimeException) ex.getException();
        }
    }
    else
    {
        // Solution: Rename before deleting
        // http://stackoverflow.com/questions/11539657/open-failed-ebusy-device-or-resource-busy

        File to = new File(target.getAbsolutePath() + System.currentTimeMillis());
        boolean renameStatus = target.renameTo(to);
        boolean deleteStatus = to.delete();
        boolean returnStatus = ( renameStatus &amp;&amp; deleteStatus );

        // Debug SecureAction
        //boolean returnStatus = target.delete();
        Log.e ( ""SecureAction"" , ""Deleting "" + target + "" delete(): "" + returnStatus );
        return returnStatus;
    }
}
",,1,5610abfc93851502de4673571152821d7b7148f2dc9ea6577a4ca796fdaf4efe
,"    try {
        PackageInfo info = getPackageManager().getPackageInfo(""my.package.name"", PackageManager.GET_SIGNATURES);
        for (Signature signature : info.signatures) {
            MessageDigest md;
            md = MessageDigest.getInstance(""SHA-1"");
            md.update(signature.toByteArray());
            Log.e(""hash key"", Base64.encodeToString(md.digest(), Base64.DEFAULT));
        }
    } catch (NameNotFoundException e1) {
        Log.e(""name not found"", e1.toString());
    } catch (NoSuchAlgorithmException e) {
        Log.e(""no such an algorithm"", e.toString());
    } catch (Exception e) {
        Log.e(""exception"", e.toString());
    }
",3,0,5347752cb151f87d25f749064e2966bbe62533e05763252e0617277ca679585f
,"public static String decrypt(byte[] keyValue, String ivValue, String encryptedData) throws Exception {
    Key key = new SecretKeySpec(keyValue, ""AES"");
    byte[] iv = Base64.decode(ivValue.getBytes(""UTF-8""), Base64.DEFAULT);
    byte[] decodedValue = Base64.decode(encryptedData.getBytes(""UTF-8""), Base64.DEFAULT);

    Cipher c = Cipher.getInstance(""AES/CBC/PKCS7Padding""); // or PKCS5Padding
    c.init(Cipher.DECRYPT_MODE, key, new IvParameterSpec(iv));
    byte[] decValue = c.doFinal(decodedValue);

    int firstQuoteIndex = 0;
    while(decValue[firstQuoteIndex] != (byte)'""') firstQuoteIndex++;
    return new String(Arrays.copyOfRange(decValue, firstQuoteIndex + 1, decValue.length-2));
}
",1,0,67aea8d0efe19df79e11861f2d75f13448684ba468a866c325e53b8534edc163
,"public static String decrypt(byte[] keyValue, String ivValue, String encryptedData, String macValue) throws Exception {
    Key key = new SecretKeySpec(keyValue, ""AES"");
    byte[] iv = Base64.decode(ivValue.getBytes(""UTF-8""), Base64.DEFAULT);
    byte[] decodedValue = Base64.decode(encryptedData.getBytes(""UTF-8""), Base64.DEFAULT);

    SecretKeySpec macKey = new SecretKeySpec(keyValue, ""HmacSHA256"");
    Mac hmacSha256 = Mac.getInstance(""HmacSHA256"");
    hmacSha256.init(macKey);
    hmacSha256.update(ivValue.getBytes(""UTF-8""));
    byte[] calcMac = hmacSha256.doFinal(encryptedData.getBytes(""UTF-8""));
    byte[] mac = Hex.decodeHex(macValue.toCharArray());
    if (!Arrays.equals(calcMac, mac)) // TODO: use time-constant compare
        return null; // or throw exception

    Cipher c = Cipher.getInstance(""AES/CBC/PKCS7Padding""); // or PKCS5Padding
    c.init(Cipher.DECRYPT_MODE, key, new IvParameterSpec(iv));
    byte[] decValue = c.doFinal(decodedValue);

    int firstQuoteIndex = 0;
    while(decValue[firstQuoteIndex] != (byte)'""') firstQuoteIndex++;
    return new String(Arrays.copyOfRange(decValue, firstQuoteIndex + 1, decValue.length-2));
}
",1,0,194cd272389d9ef94c1653ea20fd86c0a632437aec4489f8d413eacf6da8d532
,"private static class CookiePersistingClient extends ApacheClient {

    private static final int HTTPS_PORT = 443;
    private static final int SOCKET_TIMEOUT = 300000;
    private static final int CONNECTION_TIMEOUT = 300000;

    public CookiePersistingClient() {
        super(createDefaultClient());
    }

    private static HttpClient createDefaultClient() {
        // Registering https clients.
        SSLSocketFactory sf = null;
        try {
            KeyStore trustStore = KeyStore.getInstance(KeyStore
                    .getDefaultType());
            trustStore.load(null, null);

            sf = new MySSLSocketFactory(trustStore);
            sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
        } catch (KeyManagementException e) {
            e.printStackTrace();
        } catch (UnrecoverableKeyException e) {
            e.printStackTrace();
        } catch (KeyStoreException e) {
            e.printStackTrace();
        } catch (NoSuchAlgorithmException e) {
            e.printStackTrace();
        } catch (CertificateException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        }
        HttpParams params = new BasicHttpParams();
        HttpConnectionParams.setConnectionTimeout(params,
                CONNECTION_TIMEOUT);
        HttpConnectionParams.setSoTimeout(params, SOCKET_TIMEOUT);
        SchemeRegistry registry = new SchemeRegistry();
        registry.register(new Scheme(""https"", sf, HTTPS_PORT));
        // More customization (https / timeouts etc) can go here...

        ClientConnectionManager cm = new ThreadSafeClientConnManager(
                params, registry);
        DefaultHttpClient client = new DefaultHttpClient(cm, params);

        // Set the default cookie store
        client.setCookieStore(COOKIE_STORE);

        return client;
    }

    @Override
    protected HttpResponse execute(final HttpClient client,
            final HttpUriRequest request) throws IOException {
        // Set the http context's cookie storage
        BasicHttpContext mHttpContext = new BasicHttpContext();
        mHttpContext.setAttribute(ClientContext.COOKIE_STORE, COOKIE_STORE);
        return client.execute(request, mHttpContext);
    }

    @Override
    public Response execute(final Request request) throws IOException {
        Response response = super.execute(request);
        if (response.getStatus() == 401) {

            // Retrofit Callback to handle AccessToken
            Callback&lt;AccessTockenResponse&gt; accessTokenCallback = new Callback&lt;AccessTockenResponse&gt;() {

                @SuppressWarnings(""deprecation"")
                @Override
                public void success(
                        AccessTockenResponse loginEntityResponse,
                        Response response) {
                    try {
                        String accessToken =  loginEntityResponse
                                .getAccessToken();
                        TypedOutput body = request.getBody();
                        ByteArrayOutputStream byte1 = new ByteArrayOutputStream();
                        body.writeTo(byte1);
                        String s = byte1.toString();
                        FormUrlEncodedTypedOutput output = new FormUrlEncodedTypedOutput();
                        String[] pairs = s.split(""&amp;"");
                        for (String pair : pairs) {
                            int idx = pair.indexOf(""="");
                            if (URLDecoder.decode(pair.substring(0, idx))
                                    .equals(""access_token"")) {
                                output.addField(""access_token"",
                                        accessToken);
                            } else {
                                output.addField(URLDecoder.decode(
                                        pair.substring(0, idx), ""UTF-8""),
                                        URLDecoder.decode(
                                                pair.substring(idx + 1),
                                                ""UTF-8""));
                            }
                        }
                        execute(new Request(request.getMethod(),
                                request.getUrl(), request.getHeaders(),
                                output));
                    } catch (IOException e) {
                        e.printStackTrace();
                    }

                }

                @Override
                public void failure(RetrofitError error) {
                    // Handle Error while refreshing access_token
                }
            };
            // Call Your retrofit method to refresh ACCESS_TOKEN
            refreshAccessToken(GRANT_REFRESH,CLIENT_ID, CLIENT_SECRET_KEY,accessToken, accessTokenCallback);
        }

        return response;
    }
}
",4,0,624068537fde9802fb347cc7cc12d350c8cbce9431e64c7e937b3f342d5e2899
,"public void setHttpsClient(String password) {

        try {
            KeyStore mycert = KeyStore.getInstance(""pkcs12"");

            byte[] pkcs12;

            //Load the PKCS file from database or file.
            pkcs12 = DataManager.getAuthP12Data();
            ByteArrayInputStream pkcs12BAIS = new ByteArrayInputStream(pkcs12);
            mycert.load(pkcs12BAIS, password.toCharArray());

            SSLSocketFactory sockfact = new SSLSocketFactory(mycert, null, null);

             sockfact.setHostnameVerifier(new StrictHostnameVerifier());

            // Done temporarily to accept all hosts
            //sockfact.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);

            SchemeRegistry registry = new SchemeRegistry();
            registry.register(new Scheme(""https"", sockfact, 443));

            BasicHttpParams httpParameters = new BasicHttpParams();
            HttpProtocolParams.setUseExpectContinue(httpParameters, false);
            HttpProtocolParams.setVersion(httpParameters, HttpVersion.HTTP_1_1);

            HttpConnectionParams.setConnectionTimeout(httpParameters, _TIMEOUT);
            HttpConnectionParams.setSoTimeout(httpParameters, _TIMEOUT);

            ThreadSafeClientConnManager cm = new ThreadSafeClientConnManager(
                    httpParameters, registry);
            cm.closeExpiredConnections();
            cm.closeIdleConnections(3000, TimeUnit.MILLISECONDS);

            _httpClient = new MyHttpClient(cm, httpParameters);
        } catch (Exception e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }

    }
",3,0,03706ddb760cfe758cf648bf2ab70e9a602ec3b69562fbdbd354d7226ccf84ec
,"private static SecretKey key = generateAESkey();
private static String cipherString = ""AES/CBC/PKCS5Padding"";

public static void main(String[] args) throws Exception {
    ByteArrayOutputStream log = new ByteArrayOutputStream();
    appendToLog(""Test1"", log);
    appendToLog(""Test2 is longer"", log);
    appendToLog(""Test3 is multiple of block size!"", log);
    appendToLog(""Test4 is shorter."", log);

    byte[] encLog = log.toByteArray();

    List&lt;String&gt; logs = decryptLog(new ByteArrayInputStream(encLog));

    for(String logLine : logs) {
        System.out.println(logLine);
    }
}

private static SecretKey generateAESkey() {
    try {
        return KeyGenerator.getInstance(""AES"").generateKey();
    } catch (NoSuchAlgorithmException e) {
        e.printStackTrace();
    }
    return null;
}

private static byte[] generateIV() {
    SecureRandom random = new SecureRandom();
    byte[] iv = new byte[16];
    random.nextBytes(iv);
    return iv;
}

public static void appendToLog(String s, OutputStream os) throws Exception {
    Cipher cipher = Cipher.getInstance(cipherString);
    byte[] iv = generateIV();
    cipher.init(Cipher.ENCRYPT_MODE, key, new IvParameterSpec(iv));
    byte[] data = cipher.doFinal(s.getBytes(""UTF-8""));
    os.write(data.length);
    os.write(iv);
    os.write(data);
}

public static List&lt;String&gt; decryptLog(InputStream is) throws Exception{
    ArrayList&lt;String&gt; logs = new ArrayList&lt;String&gt;();
    while(is.available() &gt; 0) {
        int len = is.read();
        byte[] encLogLine = new byte[len];
        byte[] iv = new byte[16];
        is.read(iv);
        is.read(encLogLine);

        Cipher cipher = Cipher.getInstance(cipherString);
        cipher.init(Cipher.DECRYPT_MODE, key, new IvParameterSpec(iv));
        byte[] data = cipher.doFinal(encLogLine);
        logs.add(new String(data, ""UTF-8""));
    }
    return logs;
}
",4,0,dd6430fad9797a8e46061ac5a5e5f54b9de0b3d877a8764fa6511a212a9c4a00
,"  public static byte[] encrypt(String plainText, String encryptionKey) throws Exception   
  {
    Cipher cipher = Cipher.getInstance(""AES/CBC/NoPadding"", ""SunJCE"");
    SecretKeySpec key = new SecretKeySpec(encryptionKey.getBytes(""UTF-8""), ""AES"");
    cipher.init(Cipher.ENCRYPT_MODE, key,new IvParameterSpec(new byte[cipher.getBlockSize()]));
    return cipher.doFinal(plainText.getBytes(""UTF-8""));
  }

  public static String decrypt(byte[] cipherText, String encryptionKey) throws Exception
  {
    Cipher cipher = Cipher.getInstance(""AES/CBC/NoPadding"", ""SunJCE"");
    SecretKeySpec key = new SecretKeySpec(encryptionKey.getBytes(""UTF-8""), ""AES"");
    cipher.init(Cipher.DECRYPT_MODE, key,new IvParameterSpec(new byte[cipher.getBlockSize()]));
    return new String(cipher.doFinal(cipherText),""UTF-8"");
  }
",1,0,1d99e20e353a8258e926d7bba1ff2092d842d03294ec8075edd7cdb94a366ee2
,"Cipher cipher = Cipher.getInstance(CIPHER_ALGORITHM);

cipher.init(Cipher.DECRYPT_MODE, key);
cipher.update(cipherBytes);

// byte[] plaintext = cipher.doFinal(cipherBytes);
//                                   ^-- You shouldn't pass cipherBytes twice.
//                                   v-- instead use the parameter-less method:
byte[] plaintext    = cipher.doFinal();
",,1,285073745a94385084bb0118bb7b47def2a04bb2b918e951679845e87d59d01c
," * This method returns the appropriate HttpClient.
 * @param isTLS Whether Transport Layer Security is required.
 * @param trustStoreInputStream The InputStream generated from the BKS keystore.
 * @param trustStorePsw The password related to the keystore.
 * @return The DefaultHttpClient object used to invoke execute(request) method.
private DefaultHttpClient getHttpClient(boolean isTLS, InputStream trustStoreInputStream, String trustStorePsw) 
    throws KeyStoreException, NoSuchAlgorithmException, CertificateException, IOException, KeyManagementException, UnrecoverableKeyException {
    DefaultHttpClient client = null;        
    SchemeRegistry schemeRegistry = new SchemeRegistry();
    Scheme http = new Scheme(""http"", PlainSocketFactory.getSocketFactory(), 8080);
    schemeRegistry.register(http);
    if(isTLS) {
        KeyStore trustKeyStore = null;
        char[] trustStorePswCharArray = null;
        if(trustStorePsw!=null) {
            trustStorePswCharArray = trustStorePsw.toCharArray();
        } 
        trustKeyStore = KeyStore.getInstance(""BKS"");
        trustKeyStore.load(trustStoreInputStream, trustStorePswCharArray);
        SSLSocketFactory sslSocketFactory = null;
        sslSocketFactory = new SSLSocketFactory(trustKeyStore);
        Scheme https = new Scheme(""https"", sslSocketFactory, 8443);
        schemeRegistry.register(https);
    }                
    HttpParams httpParams = new BasicHttpParams();
    HttpConnectionParams.setConnectionTimeout(httpParams, CONNECTION_TIMEOUT);
    HttpConnectionParams.setSoTimeout(httpParams, SOCKET_TIMEOUT);        
    ClientConnectionManager clientConnectionManager = new ThreadSafeClientConnManager(httpParams, schemeRegistry);        
    client = new DefaultHttpClient(clientConnectionManager, httpParams);        
    return client;
}
",3,0,841fc8db35b2216a72e2461466790918565121f647dc9d9b4c1ad8fd1e42be5c
," * This method set the certificate for the HttpsURLConnection
 * @param url The url to contact.
 * @param certificateInputStream The InputStream generated from the .crt certificate.
 * @param certAlias The alias for the certificate. 
 * @return The returned HttpsURLConnection
private HttpsURLConnection getHttpsURLConnection(URL url, InputStream certificateInputStream, String certAlias) 
    throws CertificateException, IOException, KeyStoreException, NoSuchAlgorithmException, KeyManagementException {
    HttpsURLConnection connection = null;
    CertificateFactory certFactory = null;
    Certificate cert = null;
    KeyStore keyStore = null;
    TrustManagerFactory tmFactory = null;
    SSLContext sslContext = null;
    // Load certificates from an InputStream
    certFactory = CertificateFactory.getInstance(""X.509"");
    cert = certFactory.generateCertificate(certificateInputStream);
    certificateInputStream.close();
    // Create a KeyStore containing the trusted certificates
    keyStore = KeyStore.getInstance(KeyStore.getDefaultType());
    keyStore.load(null, null);
    keyStore.setCertificateEntry(certAlias, cert);
    // Create a TrustManager that trusts the certificates in our KeyStore
    tmFactory = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());
    tmFactory.init(keyStore);
    // Create an SSLContext that uses our TrustManager
    sslContext = SSLContext.getInstance(""TLS"");
    sslContext.init(null, tmFactory.getTrustManagers(), null);
    connection = (HttpsURLConnection)url.openConnection();
    connection.setSSLSocketFactory(sslContext.getSocketFactory());
    return connection;
}
",3,0,9bddd8dacb4d5d5d39d0c4c4236d76c11781eec75862d52e2cb81512513fd576
," @Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_main2);
    Toolbar toolbar = (Toolbar) findViewById(R.id.toolbar);
    setSupportActionBar(toolbar);


    try {
        PackageInfo info = getPackageManager().getPackageInfo(
                ""com.example.chirag.maptesting"",
                PackageManager.GET_SIGNATURES);
        for (Signature signature : info.signatures) {
            MessageDigest md = MessageDigest.getInstance(""SHA"");
            md.update(signature.toByteArray());
            Log.d(""KeyHash:"", Base64.encodeToString(md.digest(), Base64.DEFAULT));
            Toast.makeText(Main2Activity.this, ""Hash Key :""+Base64.encodeToString(md.digest(), Base64.DEFAULT), Toast.LENGTH_SHORT).show();
        }
    } catch (PackageManager.NameNotFoundException e) {

    } catch (NoSuchAlgorithmException e) {

    }
}
",3,0,d6ffe9640cb833e37c8c4c73f028ec22c2d3e19b15990753a5f1b4a38d922487
,"String keyStorePath = ""absolute path to your JKS keystore file"";
String keyStorePass = ""keystore password"";

System.setProperty(""javax.net.ssl.keyStore"", keyStorePath);
System.setProperty(""javax.net.ssl.keyStorePassword"", keyStorePass);

SSLServerSocketFactory sslserversocketfactory = (SSLServerSocketFactory) SSLServerSocketFactory.getDefault();
SSLServerSocket serverSocket = (SSLServerSocket) sslserversocketfactory.createServerSocket(port_number);

while (true) {
    new ClientThread((SSLSocket) serverSocket.accept()).start();
}
",,1,c15fd334da3e8a9529471c228c40fadfa01d293d33689a66a73377c1be45fda9
,"private String doFetch(URL url, String postdata, String sk, String token) throws Exception {
        HttpURLConnection conn = null;

        Proxy proxy = null;
        String host = null;
        int port = -1;

        if(Build.VERSION.SDK_INT &lt;11) {
            Context ctx = IRCCloudApplication.getInstance().getApplicationContext();
            if(ctx != null) {
                host = android.net.Proxy.getHost(ctx);
                port = android.net.Proxy.getPort(ctx);
            }
        } else {
            host = System.getProperty(""http.proxyHost"", null);
            try {
                port = Integer.parseInt(System.getProperty(""http.proxyPort"", ""8080""));
            } catch (NumberFormatException e) {
                port = -1;
            }
        }

        if(host != null &amp;&amp; host.length() &gt; 0 &amp;&amp; !host.equalsIgnoreCase(""localhost"") &amp;&amp; !host.equalsIgnoreCase(""127.0.0.1"") &amp;&amp; port &gt; 0) {
            InetSocketAddress proxyAddr = new InetSocketAddress(host, port);
            proxy = new Proxy(Proxy.Type.HTTP, proxyAddr);
        }

        if(host != null &amp;&amp; host.length() &gt; 0 &amp;&amp; !host.equalsIgnoreCase(""localhost"") &amp;&amp; !host.equalsIgnoreCase(""127.0.0.1"") &amp;&amp; port &gt; 0) {
            Crashlytics.log(Log.DEBUG, TAG, ""Requesting: "" + url + "" via proxy: "" + host);
        } else {
            Crashlytics.log(Log.DEBUG, TAG, ""Requesting: "" + url);
        }

        if (url.getProtocol().toLowerCase().equals(""https"")) {
            HttpsURLConnection https = (HttpsURLConnection)((proxy != null)?url.openConnection(proxy):url.openConnection(Proxy.NO_PROXY));
            if(url.getHost().equals(IRCCLOUD_HOST))
                https.setSSLSocketFactory(IRCCloudSocketFactory);
            conn = https;
        } else {
            conn = (HttpURLConnection)((proxy != null)?url.openConnection(proxy):url.openConnection(Proxy.NO_PROXY));
        }

        conn.setConnectTimeout(5000);
        conn.setReadTimeout(5000);
        conn.setUseCaches(false);
        conn.setRequestProperty(""User-Agent"", useragent);
        conn.setRequestProperty(""Accept"", ""application/json"");
        if(sk != null)
            conn.setRequestProperty(""Cookie"", ""session=""+sk);
        if(token != null)
            conn.setRequestProperty(""x-auth-formtoken"", token);
        if(postdata != null) {
            conn.setRequestMethod(""POST"");
            conn.setDoOutput(true);
            conn.setRequestProperty(""Content-type"", ""application/x-www-form-urlencoded"");
            OutputStream ostr = null;
            try {
                ostr = conn.getOutputStream();
                ostr.write(postdata.getBytes());
            } catch (Exception e) {
                e.printStackTrace();
            } finally {
                if (ostr != null)
                    ostr.close();
            }
        }
        BufferedReader reader = null;
        String response = """";

        try {
            ConnectivityManager cm = (ConnectivityManager)IRCCloudApplication.getInstance().getSystemService(Context.CONNECTIVITY_SERVICE);
            NetworkInfo ni = cm.getActiveNetworkInfo();
            if(ni != null &amp;&amp; ni.getType() == ConnectivityManager.TYPE_WIFI) {
                Crashlytics.log(Log.DEBUG, TAG, ""Loading via WiFi"");
            } else {
                Crashlytics.log(Log.DEBUG, TAG, ""Loading via mobile"");
            }
        } catch (Exception e) {
        }

        try {
            if(conn.getInputStream() != null) {
                reader = new BufferedReader(new InputStreamReader(conn.getInputStream()), 512);
            }
        } catch (IOException e) {
            if(conn.getErrorStream() != null) {
                reader = new BufferedReader(new InputStreamReader(conn.getErrorStream()), 512);
            }
        }

        if(reader != null) {
            response = toString(reader);
            reader.close();
        }
        conn.disconnect();
        return response;
    }
",,1,cd7658e8441da8d1afb229e06d5d237bd3c25d17f1726f7787fbc8fa18787e38
,"CertificateFactory cf = CertificateFactory.getInstance(""X.509"");
    // From https://www.washington.edu/itconnect/security/ca/load-der.crt
    InputStream is = context.getResources().getAssets().openAsset(""somefolder/somecertificate.crt""); // path should be your files path
    InputStream caInput = new BufferedInputStream(is);
    Certificate ca;
    try {
        ca = cf.generateCertificate(caInput);
        // System.out.println(""ca="" + ((X509Certificate) ca).getSubjectDN());
    } finally {
        caInput.close();
    }
",,1,6813dbaa1410b3049c96bd2ab93264366ea1d60309da65962135fb9ac1c80120
,"private void AdjustSocket(Socket socket)
{
    String[] protocols = ((SSLSocket) socket).getSSLParameters().getProtocols();
    ArrayList&lt;String&gt; protocolList = new ArrayList&lt;String&gt;(Arrays.asList(protocols));

    for (int ii = protocolList.size() - 1; ii &gt;= 0; --ii )
        {
        if ((protocolList.get(ii).contains(""TLSv1.1"")) || (protocolList.get(ii).contains(""TLSv1.2"")))
            protocolList.remove(ii);
        }

    protocols = protocolList.toArray(new String[protocolList.size()]);
    ((SSLSocket)socket).setEnabledProtocols(protocols);
}
",4,0,63ab7824737ae0c13295bfb74bad286c6ac267ba99aed7650f768ea0e4646c26
,"public static String dirMD5(String dir)
{
    String md5    = """";
    File   folder = new File(dir);
    File[] files  = folder.listFiles();

    for (int i=0; i&lt;files.length; i++)
    {
        md5 = md5 + getMd5OfFile(files[i].toString());
    }
    md5 = GetMD5HashOfString(md5);
    return md5;
}


public static String getMd5OfFile(String filePath)
{
    String returnVal = """";
    try 
    {
        InputStream   input   = new FileInputStream(filePath); 
        byte[]        buffer  = new byte[1024];
        MessageDigest md5Hash = MessageDigest.getInstance(""MD5"");
        int           numRead = 0;
        while (numRead != -1)
        {
            numRead = input.read(buffer);
            if (numRead &gt; 0)
            {
                md5Hash.update(buffer, 0, numRead);
            }
        }
        input.close();

        byte [] md5Bytes = md5Hash.digest();
        for (int i=0; i &lt; md5Bytes.length; i++)
        {
            returnVal += Integer.toString( ( md5Bytes[i] &amp; 0xff ) + 0x100, 16).substring( 1 );
        }
    } 
    catch(Throwable t) {t.printStackTrace();}
    return returnVal.toUpperCase();
}

public static String    GetMD5HashOfString  (String str)
    {
        MessageDigest md5 ;        
        StringBuffer  hexString = new StringBuffer();
        try
        {                            
            md5 = MessageDigest.getInstance(""md5"");         
            md5.reset();
            md5.update(str.getBytes());                       
            byte messageDigest[] = md5.digest();
            for (int i = 0; i &lt; messageDigest.length; i++)
            {
                hexString.append(Integer.toHexString((0xF0 &amp; messageDigest[i])&gt;&gt;4));
                hexString.append(Integer.toHexString (0x0F &amp; messageDigest[i]));
            }
        } 
        catch (Throwable t) {History.Error(t);}      
        return hexString.toString();
    }
",,1,fc8cca17d51b72ac7a154de00d177b52c7dbcb3de19f0f1faa49382036bc9ece
,"public void PrintInstalledCertificates( ){

               try 
                {
                    KeyStore ks = KeyStore.getInstance(""AndroidCAStore"");
                    if (ks != null) 
                    {
                        ks.load(null, null);
                        Enumeration&lt;String&gt; aliases = ks.aliases();
                        while (aliases.hasMoreElements()) 
                        {
                            String alias = (String) aliases.nextElement();
                            java.security.cert.X509Certificate cert = (java.security.cert.X509Certificate) ks.getCertificate(alias);
                                        //To print System Certs only
                                        if(cert.getIssuerDN().getName().contains(system)){
                                         System.out.println(cert.getIssuerDN().getName());
                                        }

                                        //To print User Certs only 
                                        if(cert.getIssuerDN().getName().contains(user)){
                                         System.out.println(cert.getIssuerDN().getName());
                                        }

                                        //To print all certs
                            System.out.println(cert.getIssuerDN().getName());                           
                        }
                    }
                } catch (IOException e) {
                    e.printStackTrace();
                } catch (KeyStoreException e) {
                    e.printStackTrace();
                } catch (NoSuchAlgorithmException e) {
                    e.printStackTrace();
                } catch (java.security.cert.CertificateException e) {
                    e.printStackTrace();
                }               

     }
",,1,71aeae7b9057fd11e79a3b09cb589721f7fa631a77b10fdaec94155b9271614b
,"public class RestModule {
     private RestAdapter mRestAdapter;
     private RaasService mRaasService;
     private String mAccessToken;

     public RestModule(final Context context, final String endPoint)
     {
          init(context, endPoint);
     }
     public RestModule(final Context context, final String endPoint, final String accessToken) {
          mAccessToken = accessToken;
          init(context, endPoint);
     }
     public void init(final Context context, final String endPoint) {
          final MyPreferences preference = MyPreferences.getInstance();
          final RestAdapter.Builder builder = new RestAdapter.Builder().setLogLevel(RestAdapter.LogLevel.FULL)
                  .setRequestInterceptor(new RequestInterceptor() {
                      @Override
                      public void intercept(RequestFacade requestFacade) {
                          if (mAccessToken == null) {
                              mAccessToken = preference.getCurrentAccountAccessToken();
                          }
                          requestFacade.addHeader(""secretToken"", mAccessToken);
                          requestFacade.addHeader(""Content-Type"", ""application/json;charset=UTF-8"");
                      }
                  })
                  .setEndpoint(endPoint);
          builder.setClient(new OkClient(getPinnedOkHttpClient(context)));
          mRestAdapter = builder.build();

     }

     private static OkHttpClient getPinnedOkHttpClient(Context context) {
          try {
              final SSLContext sslContext = getSslContext(context);
              sslContext.init(null, trustAllCerts, new java.security.SecureRandom());
              // Create an ssl socket factory with our all-trusting manager
              final SSLSocketFactory sslSocketFactory = sslContext.getSocketFactory();
              OkHttpClient okHttpClient = new OkHttpClient();
              okHttpClient.setSslSocketFactory(sslSocketFactory);
              okHttpClient.setHostnameVerifier(new HostnameVerifier() {
                  @Override
                  public boolean verify(String hostname, SSLSession session) {
                      return true;
                  }
              });
              okHttpClient.setConnectTimeout(30, TimeUnit.SECONDS);
              okHttpClient.setReadTimeout(30, TimeUnit.SECONDS);
              return okHttpClient;
          } catch (Exception e) {
              throw new RuntimeException(e);
          }
     }

     private SSLContext getSslContext(Context context) throws Exception {
         KeyStore trustStore = loadTrustStore(context);
         String algotithmName = TrustManagerFactory.getDefaultAlgorithm();
         TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(algotithmName);
         trustManagerFactory.init(trustStore);
         SSLContext sslContext = SSLContext.getInstance(""TLS"");
         sslContext.init(null, trustManagerFactory.getTrustManagers(), null);
         return sslContext;
     }

     private KeyStore loadTrustStore(Context context) throws Exception {
         KeyStore trustStore = KeyStore.getInstance(""BKS"");
         InputStream trustStoreStream = context.getResources().getAssets().open(""trust.bks"");
         trustStore.load(trustStoreStream, ""password"".toCharArray());
         return trustStore;
     }

     public RaasService getService() {
          if (mRaasService == null) {
              mRaasService = mRestAdapter.create(RaasService.class);
          }
          return mRaasService;
     }
}
",4,0,e94247f16b5c3de6ee7553c688a6c2401fc9157ae7f8e18907ed2851f506cf0f
,"public class HttpsTrustManager implements X509TrustManager {
    private static TrustManager[] trustManagers;
    private static final X509Certificate[] _AcceptedIssuers = new X509Certificate[]{};

@Override
public void checkClientTrusted(
        X509Certificate[] x509Certificates, String s)
        throws java.security.cert.CertificateException {
}

@Override
public void checkServerTrusted(
        X509Certificate[] x509Certificates, String s)
        throws java.security.cert.CertificateException {
}

public boolean isClientTrusted(X509Certificate[] chain) {
    return true;
}

public boolean isServerTrusted(X509Certificate[] chain) {
    return true;
}

@Override
public X509Certificate[] getAcceptedIssuers() {
    return _AcceptedIssuers;
}

public static void allowAllSSL() {
    HttpsURLConnection.setDefaultHostnameVerifier(new HostnameVerifier() {

        @Override
        public boolean verify(String arg0, SSLSession arg1) {
            return true;
        }

    });

    SSLContext context = null;
    if (trustManagers == null) {
        trustManagers = new TrustManager[]{new HttpsTrustManager()};
    }

    try {
        context = SSLContext.getInstance(""TLS"");
        context.init(null, trustManagers, new SecureRandom());
    } catch (NoSuchAlgorithmException | KeyManagementException e) {
        e.printStackTrace();
    }

    HttpsURLConnection.setDefaultSSLSocketFactory(context != null ? context.getSocketFactory() : null);
}
",4,0,0c00dc4ec41be887ae0f5871b10b233653a5eebd862f8919dba80ca0836487c1
,"public class TokenEncryptor {

    private final static String TOKEN_KEY = ""fqJfdzGDvfwbedsKSUGty3VZ9taXxMVw"";

    public static String encrypt(String plain) {
        try {
            byte[] iv = new byte[16];
            new SecureRandom().nextBytes(iv);
            Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
            cipher.init(Cipher.ENCRYPT_MODE, new SecretKeySpec(TOKEN_KEY.getBytes(""utf-8""), ""AES""), new IvParameterSpec(iv));
            byte[] cipherText = cipher.doFinal(plain.getBytes(""utf-8""));
            byte[] ivAndCipherText = getCombinedArray(iv, cipherText);
            return Base64.encodeToString(ivAndCipherText, Base64.NO_WRAP);
        } catch (Exception e) {
            Ln.e(e);
            return null;
        }
    }

    public static String decrypt(String encoded) {
        try {
            byte[] ivAndCipherText = Base64.decode(encoded, Base64.NO_WRAP);
            byte[] iv = Arrays.copyOfRange(ivAndCipherText, 0, 16);
            byte[] cipherText = Arrays.copyOfRange(ivAndCipherText, 16, ivAndCipherText.length);

            Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
            cipher.init(Cipher.DECRYPT_MODE, new SecretKeySpec(TOKEN_KEY.getBytes(""utf-8""), ""AES""), new IvParameterSpec(iv));
            return new String(cipher.doFinal(cipherText), ""utf-8"");
        } catch (Exception e) {
            Ln.e(e);
            return null;
        }
    }

    private static byte[] getCombinedArray(byte[] one, byte[] two) {
        byte[] combined = new byte[one.length + two.length];
        for (int i = 0; i &lt; combined.length; ++i) {
            combined[i] = i &lt; one.length ? one[i] : two[i - one.length];
        }
        return combined;
    }

}
",4,0,b805dc64f954eabdf99ba65fb1c04cb4122cce05089632a729598f2963f167b6
,"/**
 * An {@link javax.net.ssl.SSLSocket} that doesn't allow {@code SSLv3} only connections
 * &lt;p&gt;fixes https://github.com/koush/ion/issues/386&lt;/p&gt;
 */
private static class NoSSLv3SSLSocket extends DelegateSSLSocket {

private NoSSLv3SSLSocket(SSLSocket delegate) {
    super(delegate);

    String canonicalName = delegate.getClass().getCanonicalName();
    if (!canonicalName.equals(""org.apache.harmony.xnet.provider.jsse.OpenSSLSocketImpl"")){
        // try replicate the code from HttpConnection.setupSecureSocket()
        try {
            Method msetUseSessionTickets = delegate.getClass().getMethod(""setUseSessionTickets"", boolean.class);
            if (null != msetUseSessionTickets) {
                msetUseSessionTickets.invoke(delegate, true);
            }
        } catch (NoSuchMethodException ignored) {
        } catch (InvocationTargetException ignored) {
        } catch (IllegalAccessException ignored) {
        }
    }
}

@Override
public void setEnabledProtocols(String[] protocols) {
    if (protocols != null &amp;&amp; protocols.length == 1 &amp;&amp; ""SSLv3"".equals(protocols[0])) {
        // no way jose
        // see issue https://code.google.com/p/android/issues/detail?id=78187
        List&lt;String&gt; enabledProtocols = new ArrayList&lt;String&gt;(Arrays.asList(delegate.getEnabledProtocols()));
        if (enabledProtocols.size() &gt; 1) {
            enabledProtocols.remove(""SSLv3"");
        } else {
            LogManager.getLogger().w(""SSL stuck with protocol available for "" + String.valueOf(enabledProtocols));
        }
        protocols = enabledProtocols.toArray(new String[enabledProtocols.size()]);
    }
    super.setEnabledProtocols(protocols);
}
}


/**
 * {@link javax.net.ssl.SSLSocketFactory} that doesn't allow {@code SSLv3} only connections
 */
private static class NoSSLv3Factory extends SSLSocketFactory {
private final SSLSocketFactory delegate;

private NoSSLv3Factory() {
    this.delegate = HttpsURLConnection.getDefaultSSLSocketFactory();
}

@Override
public String[] getDefaultCipherSuites() {
    return delegate.getDefaultCipherSuites();
}

@Override
public String[] getSupportedCipherSuites() {
    return delegate.getSupportedCipherSuites();
}

private static Socket makeSocketSafe(Socket socket) {
    if (socket instanceof SSLSocket) {
        socket = new NoSSLv3SSLSocket((SSLSocket) socket);
    }
    return socket;
}

@Override
public Socket createSocket(Socket s, String host, int port, boolean autoClose) throws IOException {
    return makeSocketSafe(delegate.createSocket(s, host, port, autoClose));
}

@Override
public Socket createSocket(String host, int port) throws IOException {
    return makeSocketSafe(delegate.createSocket(host, port));
}

@Override
public Socket createSocket(String host, int port, InetAddress localHost, int localPort) throws IOException {
    return makeSocketSafe(delegate.createSocket(host, port, localHost, localPort));
}

@Override
public Socket createSocket(InetAddress host, int port) throws IOException {
    return makeSocketSafe(delegate.createSocket(host, port));
}

@Override
public Socket createSocket(InetAddress address, int port, InetAddress localAddress, int localPort) throws IOException {
    return makeSocketSafe(delegate.createSocket(address, port, localAddress, localPort));
}
}

static {
HttpsURLConnection.setDefaultSSLSocketFactory(new NoSSLv3Factory());
}
",3,0,2346f940377dfe438e09ae70449f15893f3372146705df38218c7e0afa2cc804
,"fileinputstrm=new FileInputStream(path);
BufferedInputStream input=new BufferedInputStream(fileinputstrm);
Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
SecretKeyFactory keyFac = SecretKeyFactory.getInstance(""PBEWithMD5AndDES"");
PBEKeySpec pbeKeySpec = new PBEKeySpec(""pass"".toCharArray());          

PBEParameterSpec pbeParamSpec = new PBEParameterSpec(salt, 20);
SecretKey pbeKey = keyFac.generateSecret(pbeKeySpec);
Cipher pbeCipher = Cipher.getInstance(""PBEWithMD5AndDES"");
pbeCipher.init(Cipher.ENCRYPT_MODE, pbeKey, pbeParamSpec);

FileOutputStream output = new FileOutputStream(path + "".icrpt"");
CipherOutputStream cos = new CipherOutputStream(output, pbeCipher);

ByteArrayOutputStream bytes = new ByteArrayOutputStream();
output.write(bytes.toByteArray());
cos.close();
",4,0,99e8c79ccb383460631f02975bde1705018220468324021fc1db1dac3f7e7685
,"byte[] salt = { (byte) 0xc7, (byte) 0x73, (byte) 0x21, (byte) 0x8c,
        (byte) 0x7e, (byte) 0xc8, (byte) 0xee, (byte) 0x99 };
fileinputstrm = new FileInputStream(path);

PBEKeySpec pbeKeySpec = new PBEKeySpec(""pass"".toCharArray());

PBEParameterSpec pbeParamSpec = new PBEParameterSpec(salt, 20);
SecretKeyFactory keyFac = SecretKeyFactory.getInstance(""PBEWithMD5AndDES"");
SecretKey pbeKey = keyFac.generateSecret(pbeKeySpec);

Cipher pbeCipher = Cipher.getInstance(""PBEWithMD5AndDES"");
pbeCipher.init(Cipher.DECRYPT_MODE, pbeKey, pbeParamSpec);

FileInputStream fis=new FileInputStream(path);
CipherInputStream cis=new CipherInputStream(fis, pbeCipher);
BufferedInputStream bfi=new BufferedInputStream(cis);
bfi.read();
cis.close();
FileOutputStream output1 = new FileOutputStream(path+"".jpeg"");
ByteArrayOutputStream baos=new ByteArrayOutputStream();
BufferedOutputStream bfo=new BufferedOutputStream(output1);
output1.write(baos.toByteArray());
",4,0,dc5ccb3f6f34d12e7b3751029898999890cae381ac87f30e08f416bc552b621b
,"/*
 * Copyright 2006 Sun Microsystems, Inc.  All Rights Reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 *   - Redistributions of source code must retain the above copyright
 *     notice, this list of conditions and the following disclaimer.
 *
 *   - Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 *
 *   - Neither the name of Sun Microsystems nor the names of its
 *     contributors may be used to endorse or promote products derived
 *     from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ""AS
 * IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
/**
 * http://blogs.sun.com/andreas/resource/InstallCert.java
 * Use:
 * java InstallCert hostname
 * Example:
 *% java InstallCert ecc.fedora.redhat.com
 */

import javax.net.ssl.*;
import java.io.*;
import java.security.KeyStore;
import java.security.MessageDigest;
import java.security.cert.CertificateException;
import java.security.cert.X509Certificate;

/**
 * Class used to add the server's certificate to the KeyStore
 * with your trusted certificates.
 */
public class InstallCert {

    public static void main(String[] args) throws Exception {
    String host;
    int port;
    char[] passphrase;
    if ((args.length == 1) || (args.length == 2)) {
        String[] c = args[0].split("":"");
        host = c[0];
        port = (c.length == 1) ? 443 : Integer.parseInt(c[1]);
        String p = (args.length == 1) ? ""changeit"" : args[1];
        passphrase = p.toCharArray();
    } else {
        System.out.println(""Usage: java InstallCert &lt;host&gt;[:port] [passphrase]"");
        return;
    }

    File file = new File(""jssecacerts"");
    if (file.isFile() == false) {
        char SEP = File.separatorChar;
        File dir = new File(System.getProperty(""java.home"") + SEP
                + ""lib"" + SEP + ""security"");
        file = new File(dir, ""jssecacerts"");
        if (file.isFile() == false) {
            file = new File(dir, ""cacerts"");
        }
    }
    System.out.println(""Loading KeyStore "" + file + ""..."");
    InputStream in = new FileInputStream(file);
    KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());
    ks.load(in, passphrase);
    in.close();

    SSLContext context = SSLContext.getInstance(""TLS"");
    TrustManagerFactory tmf =
            TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());
    tmf.init(ks);
    X509TrustManager defaultTrustManager = (X509TrustManager) tmf.getTrustManagers()[0];
    SavingTrustManager tm = new SavingTrustManager(defaultTrustManager);
    context.init(null, new TrustManager[]{tm}, null);
    SSLSocketFactory factory = context.getSocketFactory();

    System.out.println(""Opening connection to "" + host + "":"" + port + ""..."");
    SSLSocket socket = (SSLSocket) factory.createSocket(host, port);
    socket.setSoTimeout(10000);
    try {
        System.out.println(""Starting SSL handshake..."");
        socket.startHandshake();
        socket.close();
        System.out.println();
        System.out.println(""No errors, certificate is already trusted"");
    } catch (SSLException e) {
        System.out.println();
        e.printStackTrace(System.out);
    }

    X509Certificate[] chain = tm.chain;
    if (chain == null) {
        System.out.println(""Could not obtain server certificate chain"");
        return;
    }

    BufferedReader reader =
            new BufferedReader(new InputStreamReader(System.in));

    System.out.println();
    System.out.println(""Server sent "" + chain.length + "" certificate(s):"");
    System.out.println();
    MessageDigest sha1 = MessageDigest.getInstance(""SHA1"");
    MessageDigest md5 = MessageDigest.getInstance(""MD5"");
    for (int i = 0; i &lt; chain.length; i++) {
        X509Certificate cert = chain[i];
        System.out.println
                ("" "" + (i + 1) + "" Subject "" + cert.getSubjectDN());
        System.out.println(""   Issuer  "" + cert.getIssuerDN());
        sha1.update(cert.getEncoded());
        System.out.println(""   sha1    "" + toHexString(sha1.digest()));
        md5.update(cert.getEncoded());
        System.out.println(""   md5     "" + toHexString(md5.digest()));
        System.out.println();
    }

    System.out.println(""Enter certificate to add to trusted keystore or 'q' to quit: [1]"");
    String line = reader.readLine().trim();
    int k;
    try {
        k = (line.length() == 0) ? 0 : Integer.parseInt(line) - 1;
    } catch (NumberFormatException e) {
        System.out.println(""KeyStore not changed"");
        return;
    }

    X509Certificate cert = chain[k];
    String alias = host + ""-"" + (k + 1);
    ks.setCertificateEntry(alias, cert);

    OutputStream out = new FileOutputStream(""jssecacerts"");
    ks.store(out, passphrase);
    out.close();

    System.out.println();
    System.out.println(cert);
    System.out.println();
        System.out.println
                (""Added certificate to keystore 'jssecacerts' using alias '""
                        + alias + ""'"");
    }

    private static final char[] HEXDIGITS = ""0123456789abcdef"".toCharArray();

    private static String toHexString(byte[] bytes) {
        StringBuilder sb = new StringBuilder(bytes.length * 3);
        for (int b : bytes) {
            b &amp;= 0xff;
            sb.append(HEXDIGITS[b &gt;&gt; 4]);
            sb.append(HEXDIGITS[b &amp; 15]);
            sb.append(' ');
        }
        return sb.toString();
    }

private static class SavingTrustManager implements X509TrustManager {

        private final X509TrustManager tm;
        private X509Certificate[] chain;

        SavingTrustManager(X509TrustManager tm) {
            this.tm = tm;
        }

        public X509Certificate[] getAcceptedIssuers() {
            throw new UnsupportedOperationException();
        }

        public void checkClientTrusted(X509Certificate[] chain, String authType)
                throws CertificateException {
            throw new UnsupportedOperationException();
        }

        public void checkServerTrusted(X509Certificate[] chain, String authType)
                throws CertificateException {
            this.chain = chain;
            tm.checkServerTrusted(chain, authType);
        }
    }
}
",4,0,5cdddceb1a9d89dc60cc30551bc99570ae2a26bfc67614771d8ec96a76b937b7
,"import java.io.File;
import java.io.FileInputStream;
import java.io.InputStream;
import java.security.KeyStore;
import java.security.cert.CertificateException;
import java.security.cert.X509Certificate;

import javax.net.ssl.SSLContext;
import javax.net.ssl.SSLSocketFactory;
import javax.net.ssl.TrustManager;
import javax.net.ssl.TrustManagerFactory;
import javax.net.ssl.X509TrustManager;

public class CertManager {

private static final char[] passphrase = ""changeit"".toCharArray();
private String rootPath;
private SSLSocketFactory factory;
private SavingTrustManager trustManager;
private KeyStore keyStore;


/**
 * Creates a CertManager.
 * @param rootPath Path to directory where the file 'jssecacerts' is located.
 */
public CertManager(String rootPath){
    this.rootPath = rootPath;       
}

/**
 * Gets a SSLSocketFactory with the trusted certs.
 * @return
 * @throws Exception
 */
public SSLSocketFactory getSSLSocketFactory() throws Exception {
    //Load trusted certs
    File file = new File(rootPath+""jssecacerts"");

    System.out.println(""Loading KeyStore "" + file + ""..."");
    InputStream in = new FileInputStream(file);
    keyStore = KeyStore.getInstance(KeyStore.getDefaultType());
    keyStore.load(in, passphrase);
    in.close();

    //Use these certs 
    SSLContext context = SSLContext.getInstance(""TLS"");
    TrustManagerFactory tmf =
        TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());
    tmf.init(keyStore);
    X509TrustManager defaultTrustManager = (X509TrustManager)tmf.getTrustManagers()[0];
    trustManager = new SavingTrustManager(defaultTrustManager);
    context.init(null, new TrustManager[] {trustManager}, null);
    factory = context.getSocketFactory();
    return factory;
}

private static class SavingTrustManager implements X509TrustManager {

    private final X509TrustManager tm;
    private X509Certificate[] chain;

    SavingTrustManager(X509TrustManager tm) {
        this.tm = tm;
    }

    public X509Certificate[] getAcceptedIssuers() {         
        return tm.getAcceptedIssuers();
    }

    public void checkClientTrusted(X509Certificate[] chain, String authType)
    throws CertificateException {
        this.chain = chain;
        tm.checkClientTrusted(chain, authType);
    }

    public void checkServerTrusted(X509Certificate[] chain, String authType)
    throws CertificateException {
        this.chain = chain;
        tm.checkServerTrusted(chain, authType);
    }
}
}
",3,0,63d93032105b241dccf5d1b16b6a59144604242d55c14a8ef78353c7c22b99d5
,"public static byte[] encrypt(String passphrase, byte[] data) throws Exception {

    // Hash the ASCII-encoded passphrase with md5

    byte[] keyData = passphrase.getBytes(Charset.forName(""US-ASCII""));
    MessageDigest md = MessageDigest.getInstance(""MD5"");
    byte [] md5HashOfKey = md.digest(keyData);

    // Need to use bouncycastle (spongycastle on Android) to get RC2

    Security.addProvider(new BouncyCastleProvider());

    Cipher rc2 = Cipher.getInstance(""RC2/CBC/PKCS5PADDING"");

    // Create an RC2 40-bit key from the 1st 5 bytes of the hash.

    SecretKeySpec rc2KeySpec = new SecretKeySpec(md5HashOfKey, 0, 5, ""RC2"");
    rc2.init(Cipher.ENCRYPT_MODE, rc2KeySpec);

    byte [] cipher = rc2.doFinal(data);

    return cipher;
}
",4,0,9fbedd5a87785229d3cccad01d0f5bed50b74121ebff6fb7fe3dd4af62fb2688
,"public static byte[] encryptAES(SecretKey key, byte[] clear) {
    try {

        SecretKeySpec skeySpec = new SecretKeySpec(key.getEncoded(), ""AES"");
        Cipher cipher = Cipher.getInstance(""AES"");
        cipher.init(Cipher.ENCRYPT_MODE, skeySpec);
        byte[] encrypted = cipher.doFinal(clear);
        return encrypted;
    } catch (Exception e) {
        e.printStackTrace();
    }

    return null;
}
",4,0,210dd1d4d308d97e6333c2e881f1441dc758436ba4015658a553d1e21be8e325
,"public static byte[] decryptAES(SecretKey key, byte[] encrypted) {
    try {

        SecretKeySpec skeySpec = new SecretKeySpec(key.getEncoded(), ""AES"");
        Cipher cipher = Cipher.getInstance(""AES"");
        cipher.init(Cipher.DECRYPT_MODE, skeySpec);
        byte[] decrypted = cipher.doFinal(encrypted);
        return decrypted;
    } catch (Exception e) {
        e.printStackTrace();
    }

    return null;
}
",4,0,6b085926576150d6dae67b2228f813769585f5fb60d2fa62c5063fe1c2960b4f
,"public SecretKey newAESKey() {

    try {
        String s_key = new BigInteger(130, random).toString(32);

        KeyGenerator kgen = KeyGenerator.getInstance(""AES"");
        SecureRandom sr = SecureRandom.getInstance(""SHA1PRNG"");

        sr.setSeed(s_key.getBytes());
        kgen.init(128, sr); // 192 and 256 bits may not be available

        SecretKey skey = kgen.generateKey();
        return skey;
    } catch (Exception e) {
        e.printStackTrace();
    }

    return null;
}
",4,0,13f71623ef6067e27b9014eafd36b37aa5faaaa7f40cab812b6c84b88ea024fe
,"try {
    PackageInfo info = getPackageManager().getPackageInfo(
          YOUR_PACKAGE_NAME, PackageManager.GET_SIGNATURES);
    for (Signature signature : info.signatures) 
        {
           MessageDigest md = MessageDigest.getInstance(""SHA"");
           md.update(signature.toByteArray());
           Log.d(""KeyHash:"", Base64.encodeToString(md.digest(), Base64.DEFAULT));
        }
    }
} catch (NameNotFoundException e) {
} catch (NoSuchAlgorithmException e) {
}
",3,0,51eac58d7d52260d2229a0159bd8ea97182168665f4a12a74df3c2a3b3655099
,"public static javax.net.ssl.TrustManager getTrustManager()
{
    javax.net.ssl.TrustManager tm = new javax.net.ssl.X509TrustManager() {

        public java.security.cert.X509Certificate[] getAcceptedIssuers() {
        return null;
        }

        @Override
        public void checkClientTrusted(
                java.security.cert.X509Certificate[] chain, String authType)
                throws java.security.cert.CertificateException {

        }

        @Override
        public void checkServerTrusted(
                java.security.cert.X509Certificate[] chain, String authType)
                throws java.security.cert.CertificateException {        
        }
        };
        return tm;
}



public static DefaultHttpClient getThreadSafeClient() throws KeyStoreException, NoSuchAlgorithmException, CertificateException, IOException, KeyManagementException, UnrecoverableKeyException {
    DefaultHttpClient client = new DefaultHttpClient();
    ClientConnectionManager mgr = client.getConnectionManager();
    HttpParams cleintParams = client.getParams();

    cleintParams.setBooleanParameter(""http.protocol.expect-continue"", true);
    cleintParams.setBooleanParameter(""http.protocol.warn-extra-input"", true);
    // params.setIntParameter(""http.socket.receivebuffer"", 999999);

    //----&gt;&gt; SSL
    KeyStore trustStore = KeyStore.getInstance(KeyStore.getDefaultType());
    trustStore.load(null, null);

    SSLSocketFactory sf = new MySSLSocketFactory(trustStore);
    sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);

    HttpParams params = new BasicHttpParams();
    HttpProtocolParams.setVersion(params, HttpVersion.HTTP_1_1);
   // HttpProtocolParams.setContentCharset(params, HTTP.UTF_8);

    SchemeRegistry registry = new SchemeRegistry();
    registry.register(new Scheme(""http"", PlainSocketFactory.getSocketFactory(), 80));
    registry.register(new Scheme(""https"", sf, 443));

    //&lt;&lt;------


client = new DefaultHttpClient(new ThreadSafeClientConnManager(params, registry), cleintParams);

    return client;
}
",4,0,7806c88f18c6d681b0ec13b749679dae7c545b0a0e88cb6b37882864f07887c8
,"public class YahooContacts extends BaseActivity {
private final String TAG = ""yahoo_auth"";

private static final String CONSUMER_KEY = ""you_consumer_key"";
private static final String CONSUMER_SECRET = ""your_consumer_secret"";



private static final String CALLBACK_SCHEME = ""http"";
private static final String CALLBACK_HOST = ""www.blablablao.com"";
private static final String CALLBACK_URL = CALLBACK_SCHEME + ""://""
        + CALLBACK_HOST;

private String AUTH_TOKEN = null;
private String AUTH_TOKEN_SECRET = null;
private String AUTH_URL = null;
private String USER_TOKEN = null;
private String ACCESS_TOKEN = null;
private String ACCESS_TOKEN_SECRET = null;
private String mUSER_GUID = null;

private WebView mWebview;

@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.yahoo_layout);
    mWebview = (WebView) findViewById(R.id.webview);
    new getContactsTask().execute();


}

class getContactsTask extends AsyncTask&lt;Void, Void, Void&gt; {

    @Override
    protected void onPreExecute() {
        super.onPreExecute();
    }

    @Override
    protected Void doInBackground(Void... params) {
        getAuthorizationToken();
        getUserAutherization();

        return null;
    }

    @Override
    protected void onPostExecute(Void result) {

        super.onPostExecute(result);
    }

}

private void getAuthorizationToken() {

    String requestPath = ""https://api.login.yahoo.com/oauth/v2/get_request_token?oauth_consumer_key=""
            + CONSUMER_KEY
            + ""&amp;oauth_nonce=""
            + System.currentTimeMillis()
            + ""x""
            + ""&amp;oauth_signature_method=PLAINTEXT""
            + ""&amp;oauth_signature=""
            + CONSUMER_SECRET
            + ""%26""
            + ""&amp;oauth_timestamp=""
            + System.currentTimeMillis()
            + ""&amp;oauth_version=1.0""
            + ""&amp;xoauth_lang_pref=en-us""
            + ""&amp;oauth_callback="" + CALLBACK_URL;
    HttpClient httpclient = new DefaultHttpClient();
    HttpGet httpget = new HttpGet(requestPath);
    try {
        ResponseHandler&lt;String&gt; responseHandler = new BasicResponseHandler();
        String responseBody = httpclient.execute(httpget, responseHandler);
        String[] data = responseBody.split(""&amp;"");
        AUTH_TOKEN = data[0].replace(""oauth_token="", """");
        AUTH_TOKEN_SECRET = data[1].replace(""oauth_token_secret="", """");
        AUTH_URL = data[3].replace(""xoauth_request_auth_url="", """");
        VIPLogger.info(TAG, ""authToken"" + AUTH_TOKEN);
        VIPLogger.info(TAG, ""authToken secret"" + AUTH_TOKEN_SECRET);
    } catch (Exception e) {
        e.printStackTrace();
    }
}

private void getUserAutherization() {
    mWebview.getSettings().setJavaScriptEnabled(true);
    mWebview.setWebViewClient(lWebviewClient);
    mWebview.loadUrl(""https://api.login.yahoo.com/oauth/v2/request_auth?oauth_token=""
            + AUTH_TOKEN);
}

private void getAccessToken() {
    String requestPath = ""https://api.login.yahoo.com/oauth/v2/get_token?oauth_consumer_key=""
            + CONSUMER_KEY
            + ""&amp;oauth_nonce=""
            + System.currentTimeMillis()
            + ""x""
            + ""&amp;oauth_signature_method=PLAINTEXT""
            + ""&amp;oauth_signature=""
            + CONSUMER_SECRET
            + ""%26""
            + AUTH_TOKEN_SECRET
            + ""&amp;oauth_timestamp=""
            + System.currentTimeMillis()
            + ""&amp;oauth_version=1.0""
            + ""&amp;oauth_token=""
            + AUTH_TOKEN
            + ""&amp;oauth_verifier=""
            + USER_TOKEN;
    HttpClient httpclient = new DefaultHttpClient();
    HttpGet httpget = new HttpGet(requestPath);
    try {
        ResponseHandler&lt;String&gt; responseHandler = new BasicResponseHandler();
        String responseBody = httpclient.execute(httpget, responseHandler);
        String[] data = responseBody.split(""&amp;"");
        ACCESS_TOKEN = data[0].replace(""oauth_token="", """");
        ACCESS_TOKEN_SECRET = data[1].replace(""oauth_token_secret="", """");
        mUSER_GUID = data[5].replace(""xoauth_yahoo_guid="", """");
        VIPLogger.info(TAG, ""user guid: "" + responseBody);
        VIPLogger.info(TAG, ""Access token: "" + ACCESS_TOKEN);
        getAllContacts();
    } catch (Exception e) {
        e.printStackTrace();
        VIPLogger.error(TAG,
                ""error while fetching user guid and access token"");
    }
}

WebViewClient lWebviewClient = new WebViewClient() {

    public void onPageStarted(WebView view, String url,
            android.graphics.Bitmap favicon) {
        if (url.contains(""vipitservice"")) {
            mWebview.stopLoading();
            int lastIndex = url.lastIndexOf(""="") + 1;
            VIPLogger.info(TAG, url.substring(lastIndex, url.length()));
            USER_TOKEN = url.substring(lastIndex, url.length());
            mWebview.setVisibility(View.GONE);

            getAccessToken();
        }
    };

};

private void getAllContacts() {


    HttpClient httpclient = new DefaultHttpClient();

    String host_url = ""http://social.yahooapis.com/v1/user/"" + mUSER_GUID+ ""/contacts"";

    String nonce = """"+System.currentTimeMillis();
    String timeStamp = """"+(System.currentTimeMillis()/1000L);

    try{
        String params = 
                """"+encode(""oauth_consumer_key"")+""="" + encode(CONSUMER_KEY)
                + ""&amp;""+encode(""oauth_nonce"")+""=""+encode(nonce)
                + ""&amp;""+encode(""oauth_signature_method"")+""=""+encode(""HMAC-SHA1"")
                + ""&amp;""+encode(""oauth_timestamp"")+""=""+encode(timeStamp)
                + ""&amp;""+encode(""oauth_token"")+""=""+ACCESS_TOKEN
                + ""&amp;""+encode(""oauth_version"")+""=""+encode(""1.0"")

                ;
        String baseString = encode(""GET"")+""&amp;""+encode(host_url)+""&amp;""+encode(params);
        String signingKey = encode(CONSUMER_SECRET)+""&amp;""+encode(ACCESS_TOKEN_SECRET);
        VIPLogger.info(TAG, ""base string: "" + baseString);
        String lSignature = computeHmac(baseString, signingKey);
        VIPLogger.info(TAG, ""signature: "" + lSignature);
        lSignature = encode(lSignature);
        VIPLogger.info(TAG, ""signature enacoded: "" + lSignature);

        String lRequestUrl = host_url
                            + ""?oauth_consumer_key=""+CONSUMER_KEY
                            + ""&amp;oauth_nonce=""+nonce
                            + ""&amp;oauth_signature_method=HMAC-SHA1""
                            + ""&amp;oauth_timestamp=""+timeStamp
                            + ""&amp;oauth_token=""+ACCESS_TOKEN
                            + ""&amp;oauth_version=1.0""
                            + ""&amp;oauth_signature=""+lSignature
                            ;
        //VIPLogger.info(TAG, lRequestUrl.substring(1202));
        HttpGet httpget = new HttpGet(lRequestUrl);
        ResponseHandler&lt;String&gt; responseHandler = new BasicResponseHandler();
        String responseBody = httpclient.execute(httpget, responseHandler);

        VIPLogger.info(TAG, ""contacts response: "" + responseBody);
    }catch(Exception e){
        e.printStackTrace();
        VIPLogger.error(TAG, ""error while fetching user contacts"");
    }

}

public String computeHmac(String baseString, String key) {
    try {
        Mac mac = Mac.getInstance(""HmacSHA1"");
        SecretKeySpec signingKey = new SecretKeySpec(key.getBytes(""UTF-8""),
                ""HMAC-SHA1"");
        mac.init(signingKey);
        byte[] digest = mac.doFinal(baseString.getBytes());
        String result = Base64.encodeToString(digest, Base64.DEFAULT);
        return result;
    } catch (Exception e) {
        e.printStackTrace();
        VIPLogger.error(TAG, ""error while generating sha"");
    }
    return null;

}

public String encodeURIComponent(final String value) {
    if (value == null) {
        return """";
    }

    try {
        return URLEncoder.encode(value, ""utf-8"")
                // OAuth encodes some characters differently:
                .replace(""+"", ""%20"").replace(""*"", ""%2A"")
                .replace(""%7E"", ""~"");
        // This could be done faster with more hand-crafted code.
    } catch (Exception e) {
        e.printStackTrace();
    }
    return """";
}


    public  String encode(String input) {
        StringBuilder resultStr = new StringBuilder();
        for (char ch : input.toCharArray()) {
            if (isUnsafe(ch)) {
                resultStr.append('%');
                resultStr.append(toHex(ch / 16));
                resultStr.append(toHex(ch % 16));
            } else {
                resultStr.append(ch);
            }
        }
        return resultStr.toString().trim();
    }

    private  char toHex(int ch) {
        return (char) (ch &lt; 10 ? '0' + ch : 'A' + ch - 10);
    }

    private  boolean isUnsafe(char ch) {
        if (ch &gt; 128 || ch &lt; 0)
            return true;
        return "" %$&amp;+,/:;=?@&lt;&gt;#%"".indexOf(ch) &gt;= 0;
    }
",3,0,38d87bd200ae1c814d0a84094a8ae6a85c75095cc32615af3ac9ca7031c1f2a2
,"public class MovieListActivityTEST extends AppCompatActivity {

ViewPager pager;
ViewPagerAdapter adapter;
SwipeRefreshLayout refreshLayout;
SlidingTabLayout tabs;
CharSequence Titles[]={""Home"",""Events""};
int Numboftabs =2;

@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_movie_list_activity_test);

    // Creating The ViewPagerAdapter and Passing Fragment Manager, Titles fot the Tabs and Number Of Tabs.
    adapter =  new ViewPagerAdapter(getSupportFragmentManager(),Titles,Numboftabs);

    // Assigning ViewPager View and setting the adapter
    pager = (ViewPager) findViewById(R.id.pager);
    pager.setAdapter(adapter);

    // Assiging the Sliding Tab Layout View
    tabs = (SlidingTabLayout) findViewById(R.id.tabs);
    tabs.setDistributeEvenly(true); 

    // Setting Custom Color for the Scroll bar indicator of the Tab View
    tabs.setCustomTabColorizer(new SlidingTabLayout.TabColorizer() {
        @Override
        public int getIndicatorColor(int position) {
            return getResources().getColor(R.color.tabsScrollColor);
        }
    });

    // Setting the ViewPager For the SlidingTabsLayout
    tabs.setViewPager(pager);

    // Assign your refresh layout
    refreshLayout = (SwipeRefreshLayout) findViewById(R.id.swipeContainer);

    refreshLayout.setOnRefreshListener(new SwipeRefreshLayout.OnRefreshListener() {
        @Override
        public void onRefresh() {
            Refreshable r = (Refreshable) adapter.getItemAt(pager.getCurrentItem());
            r.refresh();
        }
    }); 
}
",,1,d4a84c49fc53dafa28bb81e1e790164f6b5cf71c25c68b61509c327db0bf6869
,"SSLContext context = SSLContext.getInstance(""TLS"");
TrustManager[] trustAllCerts = new TrustManager[] { new X509TrustManager() {
    public java.security.cert.X509Certificate[] getAcceptedIssuers() {
            return new java.security.cert.X509Certificate[] {};
    }

    public void checkClientTrusted(X509Certificate[] chain,
                    String authType) throws CertificateException {
    }

    public void checkServerTrusted(X509Certificate[] chain,
                    String authType) throws CertificateException {
    }
} };
context.init(null, trustAllCerts, null);

SocketFactory factory = context.getSocketFactory();
...
",4,0,2593fa7a79e910eb7fe544dbf1b5c424ec78ea150c068d47e0c2936944e74930
,"String encoded = null;
byte[] encrypted = null;
String plaintext = ""..."";

try {
    String privKeyPEM = ""..."";
    byte[] decoded = Base64.decode(privKeyPEM, Base64.DEFAULT);
    PKCS8EncodedKeySpec spec = new PKCS8EncodedKeySpec(decoded);
    KeyFactory kf = KeyFactory.getInstance(""RSA"");
    PrivateKey privKey = kf.generatePrivate(spec);

    Cipher cipher = Cipher.getInstance(""RSA/ECB/PKCS1Padding"");
    cipher.init(Cipher.ENCRYPT_MODE, privKey);

    encrypted = cipher.doFinal(plaintext.getBytes());
    encoded = Base64.encodeToString(encrypted, Base64.DEFAULT);
}
catch (Exception e) {
    e.printStackTrace();
}
",3,0,f7563a522b1bb73e41565606e1d6047d1ad73bb290726405b687ea63ea1133b8
,"package net.milanaleksic.cuc.tools.async.http;

import java.io.IOException;
import java.security.SecureRandom;
import java.security.cert.X509Certificate;

import javax.net.ssl.*;

import org.apache.http.conn.scheme.*;
import org.apache.http.conn.ssl.X509HostnameVerifier;

public class HttpsSecurityOverride {

    private static SchemeRegistry allowAllSchemeRegistry = null;

    private static class AllowAllTrustManager implements X509TrustManager {

        @Override public X509Certificate[] getAcceptedIssuers() {
            return new X509Certificate[] {};
        }

        @Override public void checkClientTrusted(X509Certificate[] certs, String authType) {
        }

        @Override public void checkServerTrusted(X509Certificate[] certs, String authType) {
        }
    }

    private static class AllowAllHostnameVerifier implements X509HostnameVerifier {

        @Override public void verify(String arg0, SSLSocket arg1) throws IOException {
        }

        @Override public void verify(String arg0, X509Certificate arg1) throws SSLException {
        }

        @Override public void verify(String arg0, String[] arg1, String[] arg2) throws SSLException {
        }

        @Override public boolean verify(String arg0, SSLSession arg1) {
            return true;
        }

    }

    public static SchemeRegistry createAllowAllSchemeRegistry() throws Exception {
        synchronized (HttpsSecurityOverride.class) {
            if (allowAllSchemeRegistry != null)
                return allowAllSchemeRegistry;

            SSLContext sslContext = SSLContext.getInstance(""SSL"");

            // set up a TrustManager that trusts everything
            sslContext.init(null, new TrustManager[] { new AllowAllTrustManager() }, new SecureRandom());

            org.apache.http.conn.ssl.SSLSocketFactory sf = new org.apache.http.conn.ssl.SSLSocketFactory(sslContext);
            sf.setHostnameVerifier(new AllowAllHostnameVerifier());
            Scheme httpsScheme = new Scheme(""https"", sf, 443);
            allowAllSchemeRegistry = new SchemeRegistry();
            allowAllSchemeRegistry.register(httpsScheme);

            return allowAllSchemeRegistry;
        }
    }

}
",4,0,d03e6c6934b8f4c7dddb3c8c0125e861149f002a964431b6023d3394c33065a5
,"public void validateCertificate() throws Exception {
    try {
        String issuerCertPath = ""Issuer Certifate"";
        String certPath = ""Issued Certificate"";
        X509Certificate issuerCert = getCertFromFile(issuerCertPath);
        X509Certificate c1 = getCertFromFile(certPath);
        TrustAnchor anchor = new TrustAnchor(issuerCert, null);
        Set anchors = Collections.singleton(anchor);
        CertificateFactory cf = CertificateFactory.getInstance(""X.509"");
        List list = Arrays.asList(new Certificate[] { c1 });
        CertPath path = cf.generateCertPath(list);
        PKIXParameters params = new PKIXParameters(anchors);
        params.setRevocationEnabled(false);
        CertPathValidator validator = CertPathValidator.getInstance(""PKIX"");
        PKIXCertPathValidatorResult result = (PKIXCertPathValidatorResult) validator
                .validate(path, params);
        // If
        // not
        // valid
        // will
        // throw
        System.out.println(""VALID"");
    } catch (Exception e) {
        System.out.println(""EXCEPTION "" + e.getMessage());
        e.printStackTrace();
    }
}

private X509Certificate getCertFromFile(String path) throws Exception {
    AssetManager assetManager = MyActivity.this.getResources().getAssets();
    InputStream inputStream = null;
    try {
        inputStream = assetManager.open(path);
    } catch (IOException e) {
        e.printStackTrace();
    }
    InputStream caInput = new BufferedInputStream(inputStream);
    X509Certificate cert = null;
    CertificateFactory cf = CertificateFactory.getInstance(""X509"");
    cert = (X509Certificate) cf.generateCertificate(caInput);
    cert.getSerialNumber();
    return cert;
}
",4,0,09c61012aa6bd0e0fa73146ea725bf68ae723c87672b9f8d855ddfb0a2cf3dd8
," public byte[] keyGen() throws NoSuchAlgorithmException {
    KeyGenerator keyGenerator = KeyGenerator.getInstance(""AES"");
    keyGenerator.init(192);
    return keyGenerator.generateKey().getEncoded();
 }
",4,0,834b2dec76cee20c549c123ad8fd3e6416c8656e95285bee934fd01f9c57f4d2
,"     public byte[] encript(byte[] dataToEncrypt, byte[] key)
            throws NoSuchAlgorithmException, NoSuchPaddingException,
            InvalidKeyException, IllegalBlockSizeException, BadPaddingException {
    //I'm using AES encription
    Cipher c = Cipher.getInstance(""AES"");
    SecretKeySpec k = new SecretKeySpec(key, ""AES"");
    c.init(Cipher.ENCRYPT_MODE, k);
    return c.doFinal(dataToEncrypt);
    }

    public byte[] decript(byte[] encryptedData, byte[] key)
            throws NoSuchAlgorithmException, NoSuchPaddingException,
            InvalidKeyException, IllegalBlockSizeException, BadPaddingException {
    Cipher c = Cipher.getInstance(""AES"");
    SecretKeySpec k = new SecretKeySpec(key, ""AES"");
    c.init(Cipher.DECRYPT_MODE, k);
    return c.doFinal(encryptedData);
    }
",3,0,b549c109c9f44f0d8cfefa7f53526bc7868f0770c20e48cd3d0733bdae5eb775
,"public static RestAdapter createAdapter(Context context) {
  OkHttpClient okHttpClient = new OkHttpClient();

  // loading CAs from an InputStream
  CertificateFactory cf = CertificateFactory.getInstance(""X.509"");
  InputStream cert = context.getResources().openRawResource(R.raw.my_cert);
  Certificate ca;
  try {
    ca = cf.generateCertificate(cert);
  } finally { cert.close(); }

  // creating a KeyStore containing our trusted CAs
  String keyStoreType = KeyStore.getDefaultType();
  KeyStore keyStore = KeyStore.getInstance(keyStoreType);
  keyStore.load(null, null);
  keyStore.setCertificateEntry(""ca"", ca);

  // creating a TrustManager that trusts the CAs in our KeyStore
  String tmfAlgorithm = TrustManagerFactory.getDefaultAlgorithm();
  TrustManagerFactory tmf = TrustManagerFactory.getInstance(tmfAlgorithm);
  tmf.init(keyStore);

  // creating an SSLSocketFactory that uses our TrustManager
  SSLContext sslContext = SSLContext.getInstance(""TLS"");
  sslContext.init(null, tmf.getTrustManagers(), null);
  okHttpClient.setSslSocketFactory(sslContext.getSocketFactory());

  // creating a RestAdapter using the custom client
  return new RestAdapter.Builder()
              .setEndpoint(UrlRepository.API_BASE)
              .setClient(new OkClient(okHttpClient))
              .build();
}
",3,0,e8e0b8e61f1b12d0dc74a067dc4bab4d8861a8454eed696f5e63f8492510b468
,"import java.security.SecureRandom;
import java.security.cert.CertificateException;
import java.security.cert.X509Certificate;

import javax.net.ssl.HostnameVerifier;
import javax.net.ssl.HttpsURLConnection;
import javax.net.ssl.SSLContext;
import javax.net.ssl.SSLSession;
import javax.net.ssl.X509TrustManager;

private void trustEveryone() {
    try {
        HttpsURLConnection.setDefaultHostnameVerifier(new HostnameVerifier(){
                public boolean verify(String hostname, SSLSession session) {
                    return true;
                }});
        SSLContext context = SSLContext.getInstance(""TLS"");
        context.init(null, new X509TrustManager[]{new X509TrustManager(){
            public void checkClientTrusted(X509Certificate[] chain,
                    String authType) throws CertificateException {}
            public void checkServerTrusted(X509Certificate[] chain,
                    String authType) throws CertificateException {}
            public X509Certificate[] getAcceptedIssuers() {
                return new X509Certificate[0];
            }}}, new SecureRandom());
        HttpsURLConnection.setDefaultSSLSocketFactory(
                context.getSocketFactory());
    } catch (Exception e) { // should never happen
        e.printStackTrace();
    }
}
",4,0,c409687af06cd170643ab405df3663a72797fe32e528479b0182df24959d0a44
,"public static KeyPair generateKeyPair() throws NoSuchAlgorithmException {
    KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance(""RSA"");
    keyPairGenerator.initialize(2048);
    KeyPair keyPair = keyPairGenerator.genKeyPair();
    return keyPair;
}
",2,0,c67cc6150b6f25d109df09bbb4c84e1999cf9ead6ed68590346c069f978ac0fd
,"private static PKCS10CertificationRequest generateCSRFile(KeyPair keyPair) throws IOException, OperatorCreationException {
    String principal = ""CN=company1, OU=company1, O=company1, C=GB"";
    AsymmetricKeyParameter privateKey = PrivateKeyFactory.createKey(keyPair.getPrivate().getEncoded());
    AlgorithmIdentifier signatureAlgorithm = new DefaultSignatureAlgorithmIdentifierFinder()
            .find(""SHA1WITHRSA"");
    AlgorithmIdentifier digestAlgorithm = new DefaultDigestAlgorithmIdentifierFinder().find(""SHA-1"");
    ContentSigner signer = new BcRSAContentSignerBuilder(signatureAlgorithm, digestAlgorithm).build(privateKey);

    PKCS10CertificationRequestBuilder csrBuilder = new JcaPKCS10CertificationRequestBuilder(new X500Name(
            principal), keyPair.getPublic());
    ExtensionsGenerator extensionsGenerator = new ExtensionsGenerator();
    extensionsGenerator.addExtension(X509Extension.basicConstraints, true, new BasicConstraints(true));
    extensionsGenerator.addExtension(X509Extension.keyUsage, true, new KeyUsage(KeyUsage.keyCertSign
            | KeyUsage.cRLSign));
    csrBuilder.addAttribute(PKCSObjectIdentifiers.pkcs_9_at_extensionRequest, extensionsGenerator.generate());
    PKCS10CertificationRequest csr = csrBuilder.build(signer);

    return csr;
}
",,1,439d9b0bef1a74ae1ecf2aac81ba816f28597b44df80402163f6b893f902e152
,"KeyStore store = KeyStore.getInstance(""BKS"");
InputStream in;
try {
    in = App.getInstance().getApplicationContext().openFileInput(filename);
        try {
            store.load(in, password);
        } finally {
            in.close();
        }
    } catch (FileNotFoundException e) {
        //create new keystore
        store.load(null, password);
    }
",,1,eb7d6834fb53552ad14acc1411df8037ed1be155a1ab3a743297fd6977c05dc9
,"KeyStore trustStore = KeyStore.getInstance(""BKS"");
InputStream in = App.getInstance().getApplicationContext().getResources().openRawResource(R.raw.truststore);
try {
    trustStore.load(in, trustorePassword);
} finally {
    in.close();
}
",,1,b915a534f3d6b284e633ffcf40ac2c7da13516d3a67a195d1125ecc601823af8
,"OkHttpClient client = new OkHttpClient();
KeyStore keyStore = App.getInstance().getKeyStoreUtil().getKeyStore();
KeyStore trustStore = App.getInstance().getKeyStoreUtil().getTrustStore();

TrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());
tmf.init(trustStore);

KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());
kmf.init(keyStore, keyStorePassword);

SSLContext sslCtx = SSLContext.getInstance(""TLS"");
sslCtx.init(kmf.getKeyManagers(), tmf.getTrustManagers(), null);
client.setSslSocketFactory(sslCtx.getSocketFactory());
client.setHostnameVerifier(org.apache.http.conn.ssl.SSLSocketFactory.STRICT_HOSTNAME_VERIFIER);
",3,0,2e9a25c61d6486665e1aac9b92f62efaccc3b0260939e842ef4ad99496da747e
,"        URL url = new URL(SSL_URL);
        HttpsURLConnection urlConnection = (HttpsURLConnection) url.openConnection();
        urlConnection.setDoOutput(true);
        urlConnection.setSSLSocketFactory(context.getSocketFactory());
        urlConnection.setHostnameVerifier(hostnameVerifier);
        urlConnection.setRequestProperty(""Content-Type"", ""application/soap+xml; charset=utf-8"");
        urlConnection.connect();
        OutputStream out = new BufferedOutputStream(urlConnection.getOutputStream());
        if (out != null)
        {
           out.write(getReqData());
           out.flush();
           out.close();
        }
        int res = urlConnection.getResponseCode();
        String message = urlConnection.getResponseMessage();
        InputStream in = urlConnection.getInputStream();
        String msg = convertStreamToString(in);
",3,0,a71143d0fb95abbd787bf0048e7c52c89c6a8584419239ab8149a26ecca1cbda
,"// Create a trust manager that does not validate certificate chains
    TrustManager[] trustAllCerts = new TrustManager[]{new X509TrustManager() {
        @Override
        public java.security.cert.X509Certificate[] getAcceptedIssuers() {
            return null;
        }

        @Override
        public void checkClientTrusted(X509Certificate[] certs, String authType) {
        }

        @Override
        public void checkServerTrusted(X509Certificate[] certs, String authType) {
        }
    }
    };

    // Create all-trusting host name verifier
    HostnameVerifier allHostsValid = new HostnameVerifier() {
        @Override
        public boolean verify(String hostname, SSLSession session) {
            return true;
        }
    };

    try {
        // Install the all-trusting trust manager
        SSLContext sc = SSLContext.getInstance(""SSL"");
        sc.init(null, trustAllCerts, new java.security.SecureRandom());
        HttpsURLConnection.setDefaultSSLSocketFactory(sc.getSocketFactory());
        // Install the all-trusting host verifier
        HttpsURLConnection.setDefaultHostnameVerifier(allHostsValid);
    } catch (Exception ex) {
        ex.printStackTrace();
    }
",4,0,100f5d56293a348245d64c04dceb8371ab06d63fe7caa6eb3a8db302352c73dc
,"@Override
public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState);

// Add code to print out the key hash

    try {
    PackageInfo info = getPackageManager().getPackageInfo(
            ""com.facebook.samples.hellofacebook"", 
            PackageManager.GET_SIGNATURES);
    for (Signature signature : info.signatures) {
        MessageDigest md = MessageDigest.getInstance(""SHA"");
        md.update(signature.toByteArray());
        Log.d(""KeyHash:"", Base64.encodeToString(md.digest(), Base64.DEFAULT));
        }
} catch (NameNotFoundException e) {

} catch (NoSuchAlgorithmException e) {

}
",3,0,d4b3040f5ee641673ad50cfc0c4984c9cbcb67de9d9f71a6b938a22f66e59e6b
,"     public String encryptString(String dataToEncrypt) {

        try {
            SharedPreferences prefs = context.getSharedPreferences(""appname"", 0);
            if (prefs.getString(""SECRET_KEY"","""") == """") {
                secretKeySpec = GenerateSecretKeySpecs();
                String stringSecretKey = Base64.encodeToString(
                        secretKeySpec.getEncoded(), Base64.DEFAULT);

                SharedPreferences.Editor editor = prefs.edit();
                editor.putString(""SECRET_KEY"", stringSecretKey);
                editor.commit();

            }
            if (prefs.getString(""SECRET_KEY"","""") != """") {
                byte[] encodedBytes = null;

                Cipher c = Cipher.getInstance(""AES"");
                String key =prefs.getString(""SECRET_KEY"","""");

                byte[] encodedKey = Base64.decode(key, Base64.DEFAULT);
                SecretKey originalKey = new SecretKeySpec(encodedKey, 0,
                        encodedKey.length, ""AES"");
                c.init(Cipher.ENCRYPT_MODE, originalKey);
                encodedBytes = c.doFinal(dataToEncrypt.getBytes());

                return Base64.encodeToString(encodedBytes, Base64.DEFAULT);
            } else {
                return null;
            }
        } catch (Exception e) {
//          Log.e(TAG, ""AES encryption error"");
            return null;
        }
    }
",2,0,2cc6546c12a2df92a930a510907338866812aedaf8b9a0ccdcce57cb1eba779b
,"public String decryptString(String dataToDecrypt) {
        SharedPreferences prefs= context.getSharedPreferences(""appname"", 0);
        if (prefs.getString(""SECRET_KEY"","""") != """") {
            byte[] decodedBytes = null;
            try {
                Cipher c = Cipher.getInstance(""AES"");

                String key = prefs.getString(""SECRET_KEY"","""")
                byte[] encodedKey = Base64.decode(key, Base64.DEFAULT);
                SecretKey originalKey = new SecretKeySpec(encodedKey, 0,
                        encodedKey.length, ""AES"");
                c.init(Cipher.DECRYPT_MODE, originalKey);

                byte[] dataInBytes = Base64.decode(dataToDecrypt,
                        Base64.DEFAULT);

                decodedBytes = c.doFinal(dataInBytes);
                return new String(decodedBytes);
            } catch (Exception e) {
//              Log.e(TAG, ""AES decryption error"");
                e.printStackTrace();
                return null;
            }

        } else
            return null;

    }
",4,0,c0edbd15efa72dbb8600c7d12f238c1d32446369b29aafa5bd6c59f6aaf424e8
,"@Override
public void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);

    // Add code to print out the key hash
    try {
        PackageInfo info = getPackageManager().getPackageInfo(
                ""com.facebook.samples.hellofacebook"", 
                PackageManager.GET_SIGNATURES);
        for (Signature signature : info.signatures) {
            MessageDigest md = MessageDigest.getInstance(""SHA"");
            md.update(signature.toByteArray());
            Log.d(""KeyHash:"", Base64.encodeToString(md.digest(), Base64.DEFAULT));
            }
    } catch (NameNotFoundException e) {

    } catch (NoSuchAlgorithmException e) {

    }

    ...
}
",3,0,6753359c070d56753e31ca6103ea1d6a3372071e4efa0cb2c4e46a3fee631c39
,"public X509Certificate x509ReqToX509(PKCS10CertificationRequest csr, int days, PrivateKey pKey) 
{
  Date notBefore = new Date();
  Calendar cal = Calendar.getInstance();
  cal.add(Calendar.DATE, days);
  Date notAfter = cal.getTime();
  BigInteger serialNumber = generateCertSerialNumber(); // No implemented here

  X509V3CertificateGenerator certGen = new X509V3CertificateGenerator();

  certGen.setSerialNumber(serialNumber);
  certGen.setIssuerDN(csr.getCertificationRequestInfo().getSubject());
  certGen.setSubjectDN(csr.getCertificationRequestInfo().getSubject());
  certGen.setNotBefore(notBefore);
  certGen.setNotAfter(notAfter);
  certGen.setPublicKey(csr.getPublicKey());
  certGen.setSignatureAlgorithm(""SHA256WithRSAEncryption"");

  return certGen.generate(pKey, ""BC"");
}
",2,0,9481166e81c805165d0c6d32beba8a628372df0acb79913f6e481451a87d72fa
,"import android.content.pm.Signature;  
import java.security.cert.CertificateException;  
import java.security.cert.X509Certificate; 

private static final X500Principal DEBUG_DN = new X500Principal(""CN=Android Debug,O=Android,C=US"");  
private boolean isDebuggable(Context ctx)
{ 
boolean debuggable = false;

try
{
    PackageInfo pinfo = ctx.getPackageManager().getPackageInfo(ctx.getPackageName(),PackageManager.GET_SIGNATURES);
    Signature signatures[] = pinfo.signatures;

    CertificateFactory cf = CertificateFactory.getInstance(""X.509"");

    for ( int i = 0; i &lt; signatures.length;i++)
    {   
        ByteArrayInputStream stream = new ByteArrayInputStream(signatures[i].toByteArray());
        X509Certificate cert = (X509Certificate) cf.generateCertificate(stream);       
        debuggable = cert.getSubjectX500Principal().equals(DEBUG_DN);
        if (debuggable)
            break;
    }
}
catch (NameNotFoundException e)
{
    //debuggable variable will remain false
}
catch (CertificateException e)
{
    //debuggable variable will remain false
}
return debuggable;
}
",,1,d016ee2a4b571e91dc0f1efc6af1fb6ad3c0e5637c5de6f0d84f855bbafa83a5
,"    XMPPTCPConnectionConfiguration.Builder config = XMPPTCPConnectionConfiguration.builder();
    config.setSecurityMode(ConnectionConfiguration.SecurityMode.disabled);
    config.setUsernameAndPassword(USER_ID+ ""@"" + DOMAIN, key);
    config.setServiceName(DOMAIN);
    config.setHost(DOMAIN);
    config.setPort(PORT);
    config.setDebuggerEnabled(true);
    config.setSocketFactory(SSLSocketFactory.getDefault());

    mConnection = new XMPPTCPConnection(config.build());
    try {
        mConnection.connect();
    } catch (SmackException | IOException | XMPPException e) {
        e.printStackTrace();
    }
",,1,65b9dd71a2fa650cffd7be26ff6634989b89f008105711542563365e0913e954
,"/**
 * Encrypt data
 * 
 * @param secretKey
 *            - a secret key used for encryption
 * @param data
 *            - data to encrypt
 * @return Encrypted data
 * @throws Exception
 */
public String cipher(String secretKey, String data) throws Exception {
    SecretKeyFactory factory = SecretKeyFactory
            .getInstance(""PBKDF2WithHmacSHA1"");
    KeySpec spec = new PBEKeySpec(secretKey.toCharArray(),
            secretKey.getBytes(), 128, 256);
    SecretKey tmp = factory.generateSecret(spec);
    SecretKey key = new SecretKeySpec(tmp.getEncoded(), ALGORITHM);
    Cipher cipher = Cipher.getInstance(ALGORITHM);
    cipher.init(Cipher.ENCRYPT_MODE, key);
    return toHex(cipher.doFinal(data.getBytes()));
}

/**
 * Decrypt data
 * 
 * @param secretKey
 *            - a secret key used for decryption
 * @param data
 *            - data to decrypt
 * @return Decrypted data
 * @throws Exception
 */
public String decipher(String secretKey, String data) throws Exception {
    SecretKeyFactory factory = SecretKeyFactory
            .getInstance(""PBKDF2WithHmacSHA1"");
    KeySpec spec = new PBEKeySpec(secretKey.toCharArray(),
            secretKey.getBytes(), 128, 256);
    SecretKey tmp = factory.generateSecret(spec);
    SecretKey key = new SecretKeySpec(tmp.getEncoded(), ALGORITHM);
    Cipher cipher = Cipher.getInstance(ALGORITHM);
    cipher.init(Cipher.DECRYPT_MODE, key);
    return new String(cipher.doFinal(toByte(data)));
}

// Helper methods

private byte[] toByte(String hexString) {
    int len = hexString.length() / 2;
    byte[] result = new byte[len];
    for (int i = 0; i &lt; len; i++)
        result[i] = Integer.valueOf(hexString.substring(2 * i, 2 * i + 2),
                16).byteValue();
    return result;
}

public String toHex(byte[] stringBytes) {
    StringBuffer result = new StringBuffer(2 * stringBytes.length);
    for (int i = 0; i &lt; stringBytes.length; i++) {
        result.append(HEX.charAt((stringBytes[i] &gt;&gt; 4) &amp; 0x0f)).append(
                HEX.charAt(stringBytes[i] &amp; 0x0f));
    }
    return result.toString();
}

private final static String HEX = ""0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"";
",3,0,71f0ae1e32f55d10910dbd1ed0cc88145b912db00e6e64bca3c6677ccacbf489
,"    System.out.println(""start *****"");

     String text=""The quick brown fox jumps over the lazy dog""; 
     StandardPBEByteEncryptor encryptor=new StandardPBEByteEncryptor();     
     encryptor.setAlgorithm(""PBEWithMD5AndDES""); 
     encryptor.setPassword(""HelloWorld"");      
     byte[] encrypted=encryptor.encrypt(text.getBytes()); 

    System.out.println(""stop *****"");
",2,0,dc8408f6e1f58098b13b1f369685f68a6a7aa055a08d795be795366c50243d4d
,"/**
 * generates key hash for facebbok
 */
private void GetKeyHash()
{

    PackageInfo info;
    try
    {
        info = getPackageManager().getPackageInfo(getPackageName(), PackageManager.GET_SIGNATURES);
        for (Signature signature : info.signatures)
        {
            MessageDigest md;
            md = MessageDigest.getInstance(""SHA"");
            md.update(signature.toByteArray());
            String keyhash = new String(Base64.encode(md.digest(), 0));
            // String something = new String(Base64.encodeBytes(md.digest()));
            Log.e(""keyhash"", ""keyhash= "" + keyhash);
            System.out.println(""keyhash= "" + keyhash);
        }
    }
    catch (NameNotFoundException e1)
    {
        Log.e(""name not found"", e1.toString());
    }
    catch (NoSuchAlgorithmException e)
    {
        Log.e(""no such an algorithm"", e.toString());
    }
    catch (Exception e)
    {
        Log.e(""exception"", e.toString());
    }

}
",3,0,46732449716fa054eba95b5b22bf01dbc76f1d7126b0142ed7769e813e690bdc
,"private TrustManager[] trustAllCerts = new TrustManager[]{
    new X509TrustManager() {
        public java.security.cert.X509Certificate[] getAcceptedIssuers() {
            return null;
        }
        public void checkClientTrusted(
            java.security.cert.X509Certificate[] certs, String authType) {
        }
        public void checkServerTrusted(
            java.security.cert.X509Certificate[] certs, String authType) {
        }
    }
};
",4,0,feaeffc755a35615014d853c0d775b7af65786a6261dcc5d10e2c9d74af887a9
,"    try {
       SSLContext sc = SSLContext.getInstance(""TLS"");
       sc.init(null, trustAllCerts, new java.security.SecureRandom());
       HttpsURLConnection.setDefaultSSLSocketFactory(sc.getSocketFactory());
    } catch (Exception e) {
       e.getMessage();
    }
    connection = (HttpsURLConnection) new URL(url).openConnection();
    ((HttpsURLConnection) connection).setHostnameVerifier(new AllowAllHostnameVerifier());
",4,0,e503d512a8a4f64c9859f719f017b9fa4399c23b6ec586f9297645a1d6ac663a
,"SecureRandom rng = new SecureRandom();

byte[] aesKeyData = new byte[128 / Byte.SIZE];
rng.nextBytes(aesKeyData);
SecretKey aesKey = new SecretKeySpec(aesKeyData, ""AES"");

// just to show it works
Cipher aesCBC = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
byte[] iv = new byte[aesCBC.getBlockSize()];
rng.nextBytes(iv);
aesCBC.init(Cipher.ENCRYPT_MODE, aesKey, new IvParameterSpec(iv));
",1,0,d387860e8cd61a2f925c58ea85dde2c5ea273917597d78d3dba468eabd9724c7
,"try {
    KeyStore keyStore = KeyStore.getInstance(""AndroidKeyStore"");
    keyStore.load(null);

    String alias = ""key3"";

    int nBefore = keyStore.size();

    // Create the keys if necessary
    if (!keyStore.containsAlias(alias)) {

        Calendar notBefore = Calendar.getInstance();
        Calendar notAfter = Calendar.getInstance();
        notAfter.add(Calendar.YEAR, 1);
        KeyPairGeneratorSpec spec = new KeyPairGeneratorSpec.Builder(this)
            .setAlias(alias)
            .setKeyType(""RSA"")
            .setKeySize(2048)
            .setSubject(new X500Principal(""CN=test""))
            .setSerialNumber(BigInteger.ONE)
            .setStartDate(notBefore.getTime())
            .setEndDate(notAfter.getTime())
            .build();
        KeyPairGenerator generator = KeyPairGenerator.getInstance(""RSA"", ""AndroidKeyStore"");
        generator.initialize(spec);

        KeyPair keyPair = generator.generateKeyPair();
    }
    int nAfter = keyStore.size();
    Log.v(TAG, ""Before = "" + nBefore + "" After = "" + nAfter);

    // Retrieve the keys
    KeyStore.PrivateKeyEntry privateKeyEntry = (KeyStore.PrivateKeyEntry)keyStore.getEntry(alias, null);
    RSAPrivateKey privateKey = (RSAPrivateKey) privateKeyEntry.getPrivateKey();
    RSAPublicKey publicKey = (RSAPublicKey) privateKeyEntry.getCertificate().getPublicKey();

    Log.v(TAG, ""private key = "" + privateKey.toString());
    Log.v(TAG, ""public key = "" + publicKey.toString());

    // Encrypt the text
    String plainText = ""This text is supposed to be a secret!"";
    String dataDirectory = getApplicationInfo().dataDir;
    String filesDirectory = getFilesDir().getAbsolutePath();
    String encryptedDataFilePath = filesDirectory + File.separator + ""keep_yer_secrets_here"";

    Log.v(TAG, ""plainText = "" + plainText);
    Log.v(TAG, ""dataDirectory = "" + dataDirectory);
    Log.v(TAG, ""filesDirectory = "" + filesDirectory);
    Log.v(TAG, ""encryptedDataFilePath = "" + encryptedDataFilePath);

    Cipher inCipher = Cipher.getInstance(""RSA/ECB/PKCS1Padding"", ""AndroidOpenSSL"");
    inCipher.init(Cipher.ENCRYPT_MODE, publicKey);

    Cipher outCipher = Cipher.getInstance(""RSA/ECB/PKCS1Padding"", ""AndroidOpenSSL"");
    outCipher.init(Cipher.DECRYPT_MODE, privateKey);

    CipherOutputStream cipherOutputStream = 
        new CipherOutputStream(
            new FileOutputStream(encryptedDataFilePath), inCipher);
    cipherOutputStream.write(plainText.getBytes(""UTF-8""));
    cipherOutputStream.close();

    CipherInputStream cipherInputStream = 
        new CipherInputStream(new FileInputStream(encryptedDataFilePath),
            outCipher);
    byte [] roundTrippedBytes = new byte[1000]; // TODO: dynamically resize as we get more data

    int index = 0;
    int nextByte;
    while ((nextByte = cipherInputStream.read()) != -1) {
        roundTrippedBytes[index] = (byte)nextByte;
        index++;
    }
    String roundTrippedString = new String(roundTrippedBytes, 0, index, ""UTF-8"");
    Log.v(TAG, ""round tripped string = "" + roundTrippedString);

} catch (NoSuchAlgorithmException e) {
    Log.e(TAG, Log.getStackTraceString(e));
} catch (NoSuchProviderException e) {
    Log.e(TAG, Log.getStackTraceString(e));
} catch (InvalidAlgorithmParameterException e) {
    Log.e(TAG, Log.getStackTraceString(e));
} catch (KeyStoreException e) {
    Log.e(TAG, Log.getStackTraceString(e));
} catch (CertificateException e) {
    Log.e(TAG, Log.getStackTraceString(e));
} catch (IOException e) {
    Log.e(TAG, Log.getStackTraceString(e));
} catch (UnrecoverableEntryException e) {
    Log.e(TAG, Log.getStackTraceString(e));
} catch (NoSuchPaddingException e) {
    Log.e(TAG, Log.getStackTraceString(e));
} catch (InvalidKeyException e) {
    Log.e(TAG, Log.getStackTraceString(e));
} catch (BadPaddingException e) {
    Log.e(TAG, Log.getStackTraceString(e));
} catch (IllegalBlockSizeException e) {
    Log.e(TAG, Log.getStackTraceString(e));
} catch (UnsupportedOperationException e) {
    Log.e(TAG, Log.getStackTraceString(e));
}
",4,0,ea5904ff9ff49a0f1cf778799243a9cd2da3c4780209cf2cad3ea9e724330403
,"HostnameVerifier hostnameVerifier = org.apache.http.conn.ssl.SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER;

DefaultHttpClient client = new DefaultHttpClient();

SchemeRegistry registry = new SchemeRegistry();
SSLSocketFactory socketFactory = SSLSocketFactory.getSocketFactory();
socketFactory.setHostnameVerifier((X509HostnameVerifier) hostnameVerifier);
registry.register(new Scheme(""https"", socketFactory, 443));
SingleClientConnManager mgr = new SingleClientConnManager(client.getParams(), registry);
DefaultHttpClient httpClient = new DefaultHttpClient(mgr, client.getParams());

// Set verifier     
HttpsURLConnection.setDefaultHostnameVerifier(hostnameVerifier);

// Example send http request
final String url = ""https://encrypted.google.com/"";
HttpPost httpPost = new HttpPost(url);
HttpResponse response = httpClient.execute(httpPost);
",4,0,04ce37c7c977c6024a75dce721b5be495cfde1a1499cf196e9ee3cdbcaa6c6ad
,"public class MyHttpClient1 extends DefaultHttpClient {

    final Context context;


    MyHttpClient1 mHttpClient=null;

    public MyHttpClient1(Context context) {
          this.context = context;
    }

    @Override
    protected ClientConnectionManager createClientConnectionManager() {
      SchemeRegistry registry = new SchemeRegistry();
        KeyStore trustStore = null;
        try {
            trustStore = KeyStore.getInstance(KeyStore.getDefaultType());
        } catch (KeyStoreException e) {
            e.printStackTrace();  
        }
        try {
            trustStore.load(null, null);
        } catch (IOException e) {
            e.printStackTrace();  
        } catch (NoSuchAlgorithmException e) {
            e.printStackTrace();  
        } catch (CertificateException e) {
            e.printStackTrace();  
        }
        registry.register(new Scheme(""http"", PlainSocketFactory.getSocketFactory(), 80));
      // Register for port 443 our SSLSocketFactory with our keystore
      // to the ConnectionManager
        try {
            registry.register(new Scheme(""https"",new MySSLSocketFactory(trustStore), 443));
        } catch (NoSuchAlgorithmException e) {
            e.printStackTrace();  
        } catch (KeyManagementException e) {
            e.printStackTrace();  
        } catch (KeyStoreException e) {
            e.printStackTrace();  
        } catch (UnrecoverableKeyException e) {
            e.printStackTrace();  
        }
        return new SingleClientConnManager(getParams(), registry);
    }

    public class MySSLSocketFactory extends SSLSocketFactory {
    SSLContext sslContext = SSLContext.getInstance(""SSL"");   //or TLS

    public MySSLSocketFactory(KeyStore truststore) throws NoSuchAlgorithmException, KeyManagementException, KeyStoreException, UnrecoverableKeyException {
        super(truststore);

        TrustManager tm = new X509TrustManager() {
            public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {
            }

            public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {
            }

            public X509Certificate[] getAcceptedIssuers() {
                return null;
            }
        };

        sslContext.init(null, new TrustManager[] { tm }, null);
    }

    @Override
    public Socket createSocket(Socket socket, String host, int port, boolean autoClose) throws IOException, UnknownHostException {
        return sslContext.getSocketFactory().createSocket(socket, host, port, autoClose);
    }

    @Override
    public Socket createSocket() throws IOException {
        return sslContext.getSocketFactory().createSocket();
    }

}
",4,0,c77886a53054f5a4e81db4272469dd1162b7d1bf0c3a547bdff1871253a8c696
,"private String getShaKey() {
        //fucnion para saber si esta bien registrado el codigo de googlemaps
        //ME SALE EXCEPTION DE NOMBRE NO ENCONTRADO??
        String strRet="""";
         try {
         PackageInfo info = getPackageManager().getPackageInfo(""your.package.name"",
         PackageManager.GET_SIGNATURES);
         for (Signature signature : info.signatures) {
         MessageDigest md = MessageDigest.getInstance(""SHA"");
         md.update(signature.toByteArray());
         //Log.v(TAG, ""KeyHash:"" + Base64.encodeToString(md.digest(),
         strRet=""KeyHash:"" + Base64.encodeToString(md.digest(),Base64.DEFAULT);

         }

         } catch (NameNotFoundException e) {
            //e.printStackTrace();
         strRet=""EXCEPTION NOMBRE NO ENCONTRADO"";
             } catch (NoSuchAlgorithmException  e) {
         //e.printStackTrace();
         strRet=""EXCEPTION ALGORITMO NO"";
         }
        return strRet;

         }
",3,0,b704e83f0f921dd6170147c5fefdb20e7c22d3ac9814e9ea914d1cf15aee67fa
,"// lets use the actual key value instead of the platform specific character decoding
byte[] secret = Hex.decodeHex(""25d6c7fe35b9979a161f2136cd13b0ff"".toCharArray());

// that's fine
SecretKeySpec secretKey = new SecretKeySpec(secret, ""AES"");

// SecureRandom should either be slow or be implemented in hardware
SecureRandom random = new SecureRandom();

// first create the cipher
Cipher eCipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");

// filled with 00h characters first, use Cipher instance so you can switch algorithms
byte[] realIV = new byte[eCipher.getBlockSize()];

// actually fill with random
random.nextBytes(realIV);

// MISSING: create IvParameterSpec
IvParameterSpec ivSpec = new IvParameterSpec(realIV);

// create the cipher using the IV
eCipher.init(Cipher.ENCRYPT_MODE, secretKey, ivSpec);

// NOTE: you should really not encrypt passwords for verification
String stringToEncrypt = ""mypassword"";

// convert to bytes first, but don't use the platform encoding
byte[] dataToEncrypt = stringToEncrypt.getBytes(Charset.forName(""UTF-8""));

// actually do the encryption using the data
byte[] encryptedData = eCipher.doFinal(dataToEncrypt);
",4,0,31cd6bab56f400f241522c112a5270d04aefe832728299f220d4cacbdd318edf
,"PackageInfo info;
try {
    info = getPackageManager().getPackageInfo(""com.example.yourpackagename"", PackageManager.GET_SIGNATURES);
    for (Signature signature : info.signatures) {
        MessageDigest md;
        md = MessageDigest.getInstance(""SHA"");
        md.update(signature.toByteArray());
        String something = new String(Base64.encode(md.digest(), 0));
        //String something = new String(Base64.encodeBytes(md.digest()));
        Log.e(""hash key"", something);
    }
} catch (NameNotFoundException e1) {
    Log.e(""name not found"", e1.toString());
} catch (NoSuchAlgorithmException e) {
    Log.e(""no such an algorithm"", e.toString());
} catch (Exception e) {
    Log.e(""exception"", e.toString());
}  
",3,0,90d5ceee00e62a04a3faabb36fecd0b26023517ed36c3a64b7a8e6e23ada417a
,"public String getEncrypt(final byte[] iv, final String message) throws GeneralSecurityException, NullPointerException {
  if (key.isEmpty())
    throw new NullPointerException();

  final byte[] rawData = key.getBytes(Charset.forName(""US-ASCII""));
  if (rawData.length != 16) {
    // If this is not 16 in length, there's a problem with the key size, nothing to do here
    throw new IllegalArgumentException(""You've provided an invalid key size"");
  }

  final SecretKeySpec seckeySpec = new SecretKeySpec(rawData, ""AES"");
  final Cipher ciph = Cipher.getInstance(""AES/CBC/PKCS5Padding"");

  ciph.init(Cipher.ENCRYPT_MODE, seckeySpec, new IvParameterSpec(iv));

  byte[] encryptedBA = ciph.doFinal(message.getBytes(Charset.forName(""US-ASCII"")));
  try {
    final String encryptedText = new String(Base64.encode(encryptedBA, Base64.DEFAULT), ""UTF-8"");
    return encryptedText.toString();
  } 
  catch (final UnsupportedEncodingException e1) { }
  return """";
}
",1,0,468af433e7f555fd7cfb7bd614f0849a8f601d12810287d1bbb3ebbfe04ecec2
,"public String getDecrypt(final byte[] encrypted) throws GeneralSecurityException, NullPointerException {
  if (key.isEmpty())
    throw new NullPointerException();

  final byte[] rawData = key.getBytes(Charset.forName(""US-ASCII""));
  if (rawData.length != 16) {
    // If this is not 16 in length, there's a problem with the key size, nothing to do here
    throw new IllegalArgumentException(""Invalid key size."");
  }

  final SecretKeySpec seckeySpec = new SecretKeySpec(rawData, ""AES"");

  final Cipher ciph = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
  ciph.init(Cipher.DECRYPT_MODE, seckeySpec, new IvParameterSpec(new byte[16]));
  final byte[] decryptedmess = ciph.doFinal(encrypted);

  return new String(decryptedmess, Charset.forName(""US-ASCII""));
}
",4,0,2455ba51b1d10796b7b271c67950640453b8eb6717b624caac50c492a2f3ff57
,"private static final byte[] CACERTROOTDER = new byte[]{
        48, -126, 7, 61, 48, -126, 5, 37, -96, 3, 2, 1, 2, 2, 1, 0,
        // ...
        };

/**
 * Read x509 certificated file from byte[].
 *
 * @param bytes certificate in der format
 * @return certificate
 */
private static X509Certificate getCertificate(final byte[] bytes)
        throws IOException, CertificateException {
    CertificateFactory cf = CertificateFactory.getInstance(""X.509"");
    X509Certificate ca;
    ByteArrayInputStream is = new ByteArrayInputStream(bytes);
    try {
        ca = (X509Certificate) cf.generateCertificate(is);
        Log.d(TAG, ""ca="", ca.getSubjectDN());
    } finally {
        is.close();
    }
    return ca;
}

/**
 * Trust only CAcert's CA. CA cert is injected as byte[]. Following best practices from
 * https://developer.android.com/training/articles/security-ssl.html#UnknownCa
 */
private static void trustCAcert()
        throws KeyStoreException, IOException,
        CertificateException, NoSuchAlgorithmException,
        KeyManagementException {
    // Create a KeyStore containing our trusted CAs
    String keyStoreType = KeyStore.getDefaultType();
    final KeyStore keyStore = KeyStore.getInstance(keyStoreType);
    keyStore.load(null, null);
    keyStore.setCertificateEntry(""CAcert-root"", getCertificate(CACERTROOTDER));
    // if your HTTPd is not sending the full chain, add class3 cert to the key store
    // keyStore.setCertificateEntry(""CAcert-class3"", getCertificate(CACERTCLASS3DER));

    // Create a TrustManager that trusts the CAs in our KeyStore
    final TrustManagerFactory tmf = TrustManagerFactory.getInstance(
            TrustManagerFactory.getDefaultAlgorithm());
    tmf.init(keyStore);

    // Create an SSLContext that uses our TrustManager
    SSLContext sslContext = SSLContext.getInstance(""TLS"");

    if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.ICE_CREAM_SANDWICH) {
        // may work on HC+, but there is no AVD or device to test it
        sslContext.init(null, tmf.getTrustManagers(), null);
    } else {
        // looks like CLR is broken in lower APIs. implement out own checks here :x
        // see http://stackoverflow.com/q/18713966/2331953
        HttpsURLConnection.setDefaultHostnameVerifier(new HostnameVerifier() {
            public boolean verify(final String hostname, final SSLSession session) {
                try {
                    // check if hostname matches DN
                    String dn = session.getPeerCertificateChain()[0].getSubjectDN().toString();

                    Log.d(TAG, ""DN="", dn);
                    if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.GINGERBREAD) {
                        return dn.equals(""CN="" + hostname);
                    } else {
                        // no SNI on API&lt;9, but I know the first vhost's hostname
                        return dn.equals(""CN="" + hostname)
                                || dn.equals(""CN="" + hostname.replace(""jsonrpc"", ""rest""));
                    }
                } catch (Exception e) {
                    Log.e(TAG, ""unexpected exception"", e);
                    return false;
                }
            }
        });

        // build our own trust manager
        X509TrustManager tm = new X509TrustManager() {
            public X509Certificate[] getAcceptedIssuers() {
                // nothing to do
                return new X509Certificate[0];
            }

            @Override
            public void checkClientTrusted(final X509Certificate[] chain,
                    final String authType)
                    throws CertificateException {
                // nothing to do
            }

            @Override
            public void checkServerTrusted(final X509Certificate[] chain,
                    final String authType) throws CertificateException {
                // nothing to do
                Log.d(TAG, ""checkServerTrusted("", chain, "")"");
                X509Certificate cert = chain[0];

                cert.checkValidity();

                CertificateFactory cf = CertificateFactory.getInstance(""X.509"");
                ArrayList&lt;X509Certificate&gt; list = new ArrayList&lt;X509Certificate&gt;();
                list.add(cert);
                CertPath cp = cf.generateCertPath(list);
                try {
                    PKIXParameters params = new PKIXParameters(keyStore);
                    params.setRevocationEnabled(false); // CLR is broken, remember?
                    CertPathValidator cpv = CertPathValidator
                            .getInstance(CertPathValidator.getDefaultType());
                    cpv.validate(cp, params);
                } catch (KeyStoreException e) {
                    Log.d(TAG, ""invalid key store"", e);
                    throw new CertificateException(e);
                } catch (InvalidAlgorithmParameterException e) {
                    Log.d(TAG, ""invalid algorithm"", e);
                    throw new CertificateException(e);
                } catch (NoSuchAlgorithmException e) {
                    Log.d(TAG, ""no such algorithm"", e);
                    throw new CertificateException(e);
                } catch (CertPathValidatorException e) {
                    Log.d(TAG, ""verification failed"");
                    throw new CertificateException(e);
                }
                Log.d(TAG, ""verification successful"");
            }
        };
        sslContext.init(null, new X509TrustManager[]{tm}, null);
    }

    HttpsURLConnection.setDefaultSSLSocketFactory(sslContext.getSocketFactory());
}
",4,0,577acccc0da51c0de961bee82fc95512a598c72dca7d165f58072ade47609490
,"KeyStore androidKeyStore = KeyStore.getInstance(LocalKeyStore.ANDROID_KEYSTORE);
androidKeyStore.load(null);

X509Certificate signedClientCertificate = (X509Certificate)androidKeyStore.getCertificate(""X-Signed"");
KeyStore.PrivateKeyEntry privateKeyEntry = (KeyStore.PrivateKeyEntry)androidKeyStore.getEntry(""X"", null);

X509ExtendedKeyManager keyManager = new X509ExtendedKeyManager() {
    @Override
    public String chooseClientAlias(String[] keyType, Principal[] issuers, Socket socket) {
        return clientCertificateAlias;
    }
    @Override
    public String chooseServerAlias(String keyType, Principal[] issuers, Socket socket) {
        return null; // different if you're validating the server's cert
    }
    @Override
    public X509Certificate[] getCertificateChain(String alias) {
        return new X509Certificate[] { signedClientCertificate };
    }
    @Override
    public String[] getClientAliases(String keyType, Principal[] issuers) {
        return new String[]{ ""X"" };
    }

    @Override
    public String[] getServerAliases(String keyType, Principal[] issuers) {
        return null; // different if you're validating server's cert
    }
    @Override
    public PrivateKey getPrivateKey(String alias) {
        if(alias != clientCertificateAlias) {
            Log.e(TAG, String.format(""X509ExtendedKeyManager is asking for privateKey with unknown alias %s. Expecting it to ask for %s"", alias, clientCertificateAlias));
            return null;
        }
        return privateKeyEntry.getPrivateKey();
    }
};

X509TrustManager trustServerCertificates = new X509TrustManager() {
    @Override
    public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {
        // do nothing, this method doesn't get called
    }
    @Override
    public void checkServerTrusted(X509Certificate[] chain, String authType) 
        // code to validate server's cert in here
    }
    @Override
    public X509Certificate[] getAcceptedIssuers() {
        return null; // any issuer
    }
};

m_sslContext = SSLContext.getInstance(""TLS"");
m_sslContext.init(new KeyManager[]{ keyManager }, new TrustManager[] { trustServerCertificates }, null);

// later on

conn = (HttpURLConnection)url.openConnection();
SSLContext sslContext = m_sslContext;

if(conn instanceof HttpsURLConnection &amp;&amp; sslContext != null) {
    ((HttpsURLConnection)conn).setSSLSocketFactory(sslContext.getSocketFactory());
}
",4,0,5389a2e93096ad87585961713efc761127d733108f51819fc28d7fabf5894e98
,"    KeyManagerFactory kmf = KeyManagerFactory.getInstance(""X509"");
    kmf.init(keystore, ""password"".toCharArray());
    sslContext.init(kmf.getKeyManagers(), new TrustManager[]{tm}, null);
",,1,36193fd0a098f22a465e5649e03fb6a2e96dc5685e7a111da46e42a8e3d47d49
,"         public class sha1Calculate {

        public static void main(String[] args)throws Exception
        {
             File file = new File(""D:\\Android Links.txt"");
            String outputTxt= """";
            String hashcode = null;

            try {

                FileInputStream input = new FileInputStream(file);

                ByteArrayOutputStream output = new ByteArrayOutputStream ();
                byte [] buffer = new byte [65536];
                int l;

                while ((l = input.read (buffer)) &gt; 0)
                    output.write (buffer, 0, l);

                input.close ();
                output.close ();

                byte [] data = output.toByteArray ();


                    MessageDigest digest = MessageDigest.getInstance( ""SHA-1"" ); 

                byte[] bytes = data;

                digest.update(bytes, 0, bytes.length);
                bytes = digest.digest();

                StringBuilder sb = new StringBuilder();

                for( byte b : bytes )
                {
                    sb.append( String.format(""%02X"", b) );
                }

                    System.out.println(""Digest(in hex format):: "" + sb.toString());


            }catch (FileNotFoundException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        } catch (IOException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        } catch (NoSuchAlgorithmException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }

        }
",,1,053309bab52d933825fc4416b00dfcbb92dd99bdd00ae6cb4385061dcf7bd24a
,"ks = KeyStore.getInstance(""AndroidKeyStore"");
ks.load(null);
KeyStore.PrivateKeyEntry keyEntry = (KeyStore.PrivateKeyEntry)ks.getEntry(""Keys"", null);
publicKey = (RSAPublicKey) keyEntry.getCertificate().getPublicKey();
",,1,a1dd22392061e2b1dbff75ccb2da3f42a9fe6f144ebabb35561ff6ae4ee7dfd2
,"SSLContext sslcontext = SSLContext.getInstance(""TLSv1"");
sslcontext.init(null, null, null);
SSLSocketFactory noSSLv3Factory = new TlsOnlySocketFactory(sc.getSocketFactory());
HttpsURLConnection.setDefaultSSLSocketFactory(noSSLv3Factory);
",3,0,b56435b8c915ae951f620a46ae618be0f7076d00401a678474c4a7fd033b6f37
,"    try {
        PackageInfo info = getPackageManager().getPackageInfo(
                ""com.kartag.gui"", 
                PackageManager.GET_SIGNATURES);
        for (Signature signature : info.signatures) {
            MessageDigest md = MessageDigest.getInstance(""SHA"");
            md.update(signature.toByteArray());
            Log.d(""KeyHash:"", Base64.encodeToString(md.digest(), Base64.DEFAULT));
            }
    } catch (NameNotFoundException e) {

    } catch (NoSuchAlgorithmException e) {

    }
",3,0,568385b63c1a6d4bf25b5a7d24e6a2e20ca544731ea0fadf7d590f1b60251d6c
,"private byte[] key = { (byte) 141, 75, 21, 92, (byte) 201, (byte) 255,
        (byte) 129, (byte) 229, (byte) 203, (byte) 246, (byte) 250, 120,
        25, 54, 106, 62, (byte) 198, 33, (byte) 166, 86, 65, 108,
        (byte) 215, (byte) 147 };

private final byte[] iv = { 0x1E, 0x39, (byte) 0xF3, 0x69, (byte) 0xE9, 0xD,
        (byte) 0xB3, 0x3A, (byte) 0xA7, 0x3B, 0x44, 0x2B, (byte) 0xBB,
        (byte) 0xB6, (byte) 0xB0, (byte) 0xB9 };
   long start = System.currentTimeMillis();

    // create paths
    backupPath = Environment.getExternalStorageDirectory()
            .getAbsolutePath() + ""/WhatsApp/Databases/msgstore.db.crypt5"";
    outputPath = Environment.getExternalStorageDirectory()
            .getAbsolutePath() + ""/WhatsApp/Databases/msgstore.db.decrypt"";

    File backup = new File(backupPath);

    // check if file exists / is accessible
    if (!backup.isFile()) {
        Log.e(TAG, ""Backup file not found! Path: "" + backupPath);
        return;
    }

    // acquire account name
    AccountManager manager = AccountManager.get(this);
    Account[] accounts = manager.getAccountsByType(""com.google"");

    if (accounts.length == 0) {
        Log.e(TAG, ""Unable to fetch account!"");
        return;
    }

    String account = accounts[0].name;

    try {
        // calculate md5 hash over account name
        MessageDigest message = MessageDigest.getInstance(""MD5"");
        message.update(account.getBytes());
        byte[] md5 = message.digest();

        // generate key for decryption
        for (int i = 0; i &lt; 24; i++)
            key[i] ^= md5[i &amp; 0xF];

        // read encrypted byte stream
        byte[] data = new byte[(int) backup.length()];
        DataInputStream reader = new DataInputStream(new FileInputStream(
                backup));
        reader.readFully(data);
        reader.close();

        // create output writer
        File output = new File(outputPath);
        DataOutputStream writer = new DataOutputStream(
                new FileOutputStream(output));

        // decrypt file
        Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
        SecretKeySpec secret = new SecretKeySpec(key, ""AES"");
        IvParameterSpec vector = new IvParameterSpec(iv);
        cipher.init(Cipher.DECRYPT_MODE, secret, vector);
        writer.write(cipher.update(data));
        writer.write(cipher.doFinal());
        writer.close();
    } catch (NoSuchAlgorithmException e) {
        Log.e(TAG, ""Could not acquire hash algorithm!"", e);
        return;
    } catch (IOException e) {
        Log.e(TAG, ""Error accessing file!"", e);
        return;
    } catch (Exception e) {
        Log.e(TAG, ""Something went wrong during the encryption!"", e);
        return;
    }

    long end = System.currentTimeMillis();

    Log.i(TAG, ""Success! It took "" + (end - start) + ""ms"");
",4,0,803dcea039243c2af38e791b6426fa8f84b41f85d03aa6a2a64bf44317dd2cf5
,"URLConnection connection = null;
connection =  address.openConnection();
post = (HttpsURLConnection) connection;
post.setSSLSocketFactory(context.getSocketFactory()); 
post.setDoInput(true);
post.setDoOutput(true);

// Connecting to a server will fail with a SocketTimeoutException if the timeout     elapses before a connection is established
post.setConnectTimeout(Const.CONNECTION_TIMEOUT_DELAY);
post.setRequestMethod(""POST"");  // throws ProtocolException


post.setRequestProperty(""soapaction"","""");
post.setRequestProperty(""Content-Type"", ""text/xml; charset=utf-8"");
post.setRequestProperty(""Authorization"", ""Basic "" +         Base64.encodeToString(strCredentials.getBytes(), Base64.NO_WRAP));
            post.setRequestProperty(""Content-Length"",           String.valueOf(requestEnvelope.length()));
",3,0,b0a2646a3df2d356cfe15bdaa4d74ffcfd28a4247f89911160dc3a5e1841cc68
,"public static Direction parseString(String direction){
    if(direction != null){
        //trim the input since I never trust user input
        direction = direction.trim();

        for(Direction d : Direction.values()){
            if(d.toString().equalsIgnoreCase(direction)){
                return d;
            }
        }
    }

    return null;
}
",,1,87fc3faae4238b7e72dd79b8ac55dd30bfc301969d1125910eedafbcfcf63a8c
,"Security.insertProviderAt(new org.spongycastle.jce.provider.BouncyCastleProvider(), 1);

ECGenParameterSpec brainpoolP160R1 = new ECGenParameterSpec(""brainpoolP256t1"");
KeyPairGenerator kpg = null;
try {
    kpg = (KeyPairGenerator) KeyPairGenerator.getInstance(""ECIES"", ""SC"");
} catch (NoSuchAlgorithmException | NoSuchProviderException e) {
    e.printStackTrace();
}

try {
    kpg.initialize(brainpoolP160R1, new SecureRandom());
} catch (InvalidAlgorithmParameterException e) {
    e.printStackTrace();
}

KeyPair akey = kpg.generateKeyPair();
KeyPair bkey = kpg.generateKeyPair();
// PublicKey publicKey = keyPair.getPublic();
//PrivateKey privateKey = keyPair.getPrivate();

byte[] d = new byte[]{1, 2, 3, 4, 5, 6, 7, 8};
byte[] e = new byte[]{8, 7, 6, 5, 4, 3, 2, 1};

IESParameterSpec param = new IESParameterSpec(d, e, 256);

Cipher c = null;

try {
    c = Cipher.getInstance(""ECIES"");
} catch (NoSuchAlgorithmException | NoSuchPaddingException f) {
    f.printStackTrace();
}

try {
    c.init(Cipher.ENCRYPT_MODE, new IEKeySpec(akey.getPrivate(), bkey.getPublic()), param);
    //c.init(Cipher.ENCRYPT_MODE, c1Key, param);
    //c.init(Cipher.ENCRYPT_MODE, publicKey, new SecureRandom());
    // How can i put the AES128_CBC for ies parameter ? is that possible
} catch (InvalidKeyException | InvalidAlgorithmParameterException f) {
    f.printStackTrace();
}
byte[] message = theTestText.getBytes();
byte[] cipher = new byte[0];
try {
    cipher = c.doFinal(message);//,0,message.length);
} catch (IllegalBlockSizeException | BadPaddingException f) {
    f.printStackTrace();
}

TextView eccencoded = (TextView) findViewById(R.id.eccencoded);
eccencoded.setText(""[ENCODED]:\n"" +
        new String(cipher) + ""\n"");

try {
    c.init(Cipher.DECRYPT_MODE, new IEKeySpec(bkey.getPrivate(), akey.getPublic()), param);
} catch (InvalidKeyException | InvalidAlgorithmParameterException f) {
    f.printStackTrace();
}

byte[] plaintext = new byte[0];
try {
    plaintext = c.doFinal(cipher);
} catch (IllegalBlockSizeException | BadPaddingException f) {
    f.printStackTrace();
}
TextView eccdecoded = (TextView) findViewById(R.id.eccdecoded);
eccdecoded.setText(""[DECODED]:\n"" +
        new String(plaintext) + ""\n"");
",4,0,65e5752ffd9f90e903467945125c77a2de46b9359f09166d88d207e0078713b2
,"public class FakeX509TrustManager implements X509TrustManager { 

    private static TrustManager[] trustManagers; 
    private static final X509Certificate[] _AcceptedIssuers = new 
X509Certificate[] {}; 

    @Override 
    public void checkClientTrusted(X509Certificate[] chain, String 
authType) throws CertificateException { 
    } 

    @Override 
    public void checkServerTrusted(X509Certificate[] chain, String 
authType) throws CertificateException { 
    } 

    public boolean isClientTrusted(X509Certificate[] chain) { 
            return true; 
    } 

    public boolean isServerTrusted(X509Certificate[] chain) { 
            return true; 
    } 

    @Override 
    public X509Certificate[] getAcceptedIssuers() { 
            return _AcceptedIssuers; 
    } 

    public static void allowAllSSL() { 
            HttpsURLConnection.setDefaultHostnameVerifier(new HostnameVerifier() 
{ 
                    @Override 
                    public boolean verify(String hostname, SSLSession session) { 
                            return true; 
                    } 

            }); 

            SSLContext context = null; 
            if (trustManagers == null) { 
                    trustManagers = new TrustManager[] { new FakeX509TrustManager() }; 
            } 

            try { 
                    context = SSLContext.getInstance(""TLS""); 
                    context.init(null, trustManagers, new SecureRandom()); 
            } catch (NoSuchAlgorithmException e) { 
                    e.printStackTrace(); 
            } catch (KeyManagementException e) { 
                    e.printStackTrace(); 
            } 

       HttpsURLConnection.setDefaultSSLSocketFactory(context.getSocketFactory()); 
    } 

} 
",4,0,4ef2581dc1714c649bbb770e47f09f7650ccfa74d9d58de81646ba28bf94f6e7
,"public class MainActivity extends Activity {

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        KeyStore ks = null;
        try {
            ks = KeyStore.getInstance(KeyStore.getDefaultType());
            ks.load(null,null);

            // Add certs or keys

            ks.store(new FileOutputStream(new File(getFilesDir(),""out.bks"")),""password"".toCharArray());
        } catch (KeyStoreException e) {
            e.printStackTrace();
        } catch (CertificateException e) {
            e.printStackTrace();
        } catch (NoSuchAlgorithmException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    static {
        Security.insertProviderAt(new org.spongycastle.jce.provider.BouncyCastleProvider(), 1);
    }
}
",,1,2c085930698db55b620b303d62d744bfea703802f6db046195143489b3e79073
,"String publicKeyB64 = ""MIGHAoGBAOX+TFdFVIKYyCVxWlnbGYbmgkkmHmEv2qStZzAFt6NVqKPLK989Ow0RcqcDTZaZBfO5""
        + ""5JSVHNIKoqULELruACfqtGoATfgwBp4Owfww8M891gKNSlI/M0yzDQHns5CKwPE01jD6qGZ8/2IZ""
        + ""OjLJNH6qC9At8iMCbPe9GeXIPFWRAgER"";
// ok, you may need to use the Base64 decoder of bouncy or Android instead
byte[] decoded = Base64.getDecoder().decode(publicKeyB64);
org.bouncycastle.asn1.pkcs.RSAPublicKey pkcs1PublicKey = org.bouncycastle.asn1.pkcs.RSAPublicKey.getInstance(decoded);
BigInteger modulus = pkcs1PublicKey.getModulus();
BigInteger publicExponent = pkcs1PublicKey.getPublicExponent();
RSAPublicKeySpec keySpec = new RSAPublicKeySpec(modulus, publicExponent);
KeyFactory kf = KeyFactory.getInstance(""RSA"");
PublicKey generatedPublic = kf.generatePublic(keySpec);
System.out.printf(""Modulus: %X%n"", modulus);
System.out.printf(""Public exponent: %d ... 17? Why?%n"", publicExponent); // 17? OK.
System.out.printf(""See, Java class result: %s, is RSAPublicKey: %b%n"", generatedPublic.getClass().getName(), generatedPublic instanceof RSAPublicKey);
",3,0,c1acacd3077082b29d9bea3f2c31086e77c2605f6a2dbda5ffd81236b51ba88e
,"private void calculateHashKey(String yourPackageName) {
    try {
        PackageInfo info = getPackageManager().getPackageInfo(
                yourPackageName,
                PackageManager.GET_SIGNATURES);
        for (Signature signature : info.signatures) {
            MessageDigest md = MessageDigest.getInstance(""SHA"");
            md.update(signature.toByteArray());
            Log.d(""KeyHash:"",
                    Base64.encodeToString(md.digest(), Base64.DEFAULT));
        }
    } catch (NameNotFoundException e) {
        e.printStackTrace();
    } catch (NoSuchAlgorithmException e) {
        e.printStackTrace();
    }
}
",3,0,0c0010b2272beb613f8340c872bedba86fc81ad92953b7c2bcedfc3d322ccd76
," public class MySSLSocketFactory extends SSLSocketFactory {
 SSLContext sslContext = SSLContext.getInstance(""TLS"");

 public MySSLSocketFactory(KeyStore truststore)
        throws NoSuchAlgorithmException, KeyManagementException,
        KeyStoreException, UnrecoverableKeyException {
    super(truststore);

    TrustManager tm = new X509TrustManager() {
        @Override
        public void checkClientTrusted(X509Certificate[] chain,
                                       String authType) throws CertificateException {
        }

        @Override
        public void checkServerTrusted(X509Certificate[] chain,
                                       String authType) throws CertificateException {
        }

        @Override
        public X509Certificate[] getAcceptedIssuers() {
            return null;
        }
    };

    sslContext.init(null, new TrustManager[]{tm}, null);
}

@Override
public Socket createSocket(Socket socket, String host, int port,
                           boolean autoClose) throws IOException, UnknownHostException {
    return sslContext.getSocketFactory().createSocket(socket, host, port,
            autoClose);
}

@Override
public Socket createSocket() throws IOException {
    return sslContext.getSocketFactory().createSocket();
}
 }
",4,0,4b413ad677a2fd0ea6d66c97870fd6b1913bde441dcd5618efc68208ce4db2dd
,"   public static DefaultHttpClient getNewHttpClient() {
    try {
        KeyStore trustStore = KeyStore.getInstance(KeyStore.getDefaultType());
        trustStore.load(null, null);
        SSLSocketFactory sf = new MySSLSocketFactory(trustStore);
        sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
        HttpParams params = new BasicHttpParams();
        HttpProtocolParams.setVersion(params, HttpVersion.HTTP_1_1);
        HttpProtocolParams.setContentCharset(params, HTTP.UTF_8);
        SchemeRegistry registry = new SchemeRegistry();
        registry.register(new Scheme(""http"", PlainSocketFactory.getSocketFactory(), 80));
        registry.register(new Scheme(""https"", sf, 443));

        ClientConnectionManager ccm = new ThreadSafeClientConnManager(params, registry);

        return new DefaultHttpClient(ccm, params);

    } catch (UnrecoverableKeyException e) {
        return new DefaultHttpClient();
    } catch (NoSuchAlgorithmException e) {
        return new DefaultHttpClient();
    } catch (CertificateException e) {
        return new DefaultHttpClient();
    } catch (IOException e) {
        return new DefaultHttpClient();
    } catch (KeyStoreException e) {
        return new DefaultHttpClient();
    } catch (KeyManagementException e) {
        return new DefaultHttpClient();
    }
}
",4,0,701ba24ec173fbb73d29849986f26e0a717c3ef6168cfeedbbca90315e3ae447
,"  private X509Certificate getCertFromFile(String path) throws Exception {
     AssetManager assetManager = MyActivity.this.getResources().getAssets();
     InputStream inputStream = null;
     try {
         inputStream = assetManager.open(path);
     } catch (IOException e) {
         e.printStackTrace();
     }
     InputStream caInput = new BufferedInputStream(inputStream);
     X509Certificate cert = null;
     CertificateFactory cf = CertificateFactory.getInstance(""X509"");
     cert = (X509Certificate) cf.generateCertificate(caInput);
     cert.getSerialNumber();
     return cert;
  }
",,1,2b7129e63c9940149e7e3c5cbc4603f276717b75edf7ae3f1bca76dfab6a4843
,"String redirect = urlConnection.getHeaderField(""Location"");
        if(redirect != null)    //truth before ICS
        {
            urlConnection.disconnect();

            urlConnection = (HttpsURLConnection) (new URL(redirect)).openConnection();
            urlConnection.setRequestProperty(""User-Agent"", userAgent);
            urlConnection.setRequestProperty(""Cookie"", cookie);
            urlConnection.setRequestMethod(""POST"");
            urlConnection.setDoInput(true);
            urlConnection.setDoOutput(true);

            urlConnection.setSSLSocketFactory(getSocketFactory());

            OutputStream os2 = urlConnection.getOutputStream();
            BufferedWriter writer2 = new BufferedWriter(
                    new OutputStreamWriter(os2, ""UTF-8""));
            writer2.write(postData);
            writer2.flush();
            writer2.close();
            os2.close();

            urlConnection.connect();
        }
",3,0,e267fbc59dc846138409a04fcb092e0b3ecba80dd1c583179494ab501359a76e
,"    boolean httpYes, httpsYes;
     try {

      URL url = new URL(weburi);
      urlConnection = (HttpURLConnection) url.openConnection();
      inputStream = new BufferedInputStream((urlConnection.getInputStream()));
    httpYes = True;
    }


    catch (Exception e) {
    //Toast Message displays and settings intent re-starts
          URL url = new URL(weburi);
          urlHttpsConnection = (HttpsURLConnection) url.openConnection();
          urlHttpsConnection.setSSLSocketFactory(context.getSocketFactory());
          inputStream = urlHttpsConnection.getInputStream();
          https=True;
    }
",4,0,34ddcd79acc5f9b39d459fc38a8ed37351e736399a86885c26b8aa15842e0b0c
,"public class Home extends Activity {

    public List&lt;PeerConnection.IceServer&gt; iceServers;
    private GLSurfaceView videoView;
    public static SocketIO socket;
    ArrayList&lt;String&gt; userIDs = new ArrayList&lt;&gt;();
    private static final String FIELD_TRIAL_VP9 = ""WebRTC-SupportVP9/Enabled/"";
    String RoomId = """";
    String sreverURL = ""http://xx.xx.xx.xx:xxxx/"";
    private EditText roomid;
    private VideoRenderer.Callbacks remote_view;
    private VideoRenderer.Callbacks local_view;
    protected PeerConnectionFactory factory;
    PeerConnectionFactory.Options options = null;
    Events pc_events;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_home);
        videoView = (GLSurfaceView) findViewById(R.id.glview_call_remote);
        VideoRendererGui.setView(videoView, new Runnable() {
            @Override
            public void run() {
                createPeerConnectionFactory();
            }
        });

        remote_view = VideoRendererGui.create(0, 0, 100, 100, ScalingType.SCALE_ASPECT_FIT, false);
        local_view = VideoRendererGui.create(0, 0, 100, 100, ScalingType.SCALE_ASPECT_FILL, true);
        iceServers = new ArrayList&lt;&gt;();
        IceServer icc = new IceServer(""stun:stun.l.google.com:19302"", """", """");
        iceServers.add(icc);
        roomid = (EditText) findViewById(R.id.roomId);
        Random rand = new Random();
        roomid.setText("""" + rand.nextInt(9999));
        pc_events = new peerEventHandler();
    }

    private void createPeerConnectionFactory() {
        runOnUiThread(new Runnable() {
            @Override
            public void run() {
                PeerConnectionFactory.initializeFieldTrials(FIELD_TRIAL_VP9);
                PeerConnectionFactory.initializeAndroidGlobals(Home.this, true, true, true, VideoRendererGui.getEGLContext());
                try {
                    factory = new PeerConnectionFactory();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
        });
    }

    public void ondail(View view) {

        try {

            try {
                SocketIO.setDefaultSSLSocketFactory(SSLContext.getDefault());
            } catch (NoSuchAlgorithmException e1) {
                e1.printStackTrace();
            }

            socket = new SocketIO();

            socket.connect(sreverURL, new IOCallback() {

                @Override
                public void onMessage(JSONObject json, IOAcknowledge ack) {
                }
                @Override
                public void onMessage(String data, IOAcknowledge ack) {
                }
                @Override
                public void onError(SocketIOException socketIOException) {
                    socketIOException.printStackTrace();
                }
                @Override
                public void onDisconnect() {
                }
                @Override
                public void onConnect() {
                    showToast(""Connected to "" + sreverURL);
                }
                @Override
                public void on(final String event, IOAcknowledge ack, final Object... args) {

                    Log.e(""Socked.on"", event + "", "" + args);
                    switch (getEvent(event)) {

                        case LOG :
                            break;
                        case MESSAGE :
                            if (args instanceof Object[]) {
                                pc_events.setMessage(args[0].toString());
                            } else {
                                pc_events.setMessage(args.toString());
                            }
                            break;
                        case CREATED :
                            runOnUiThread(new Runnable() {
                                public void run() {
                                    showToast(""Room Created "" + args[0]);
                                }
                            });
                            break;
                        case BROADCAST :
                            break;
                        case JOIN :
                            break;
                        case EMIT :
                            Log.e(""Socked.onEMIT"", args.toString());
                            startCall();
                            pc_events.createOffer();
                            break;

                        case ERROR :
                            Log.e(""Socked.onERROR"", args.toString());
                            break;

                        default :

                            break;
                    }
                }
            });

            try {
                RoomId = roomid.getText().toString();
            } catch (Exception e) {
            }

            socket.emit(""create or join"", RoomId);

        } catch (MalformedURLException e) {

            e.printStackTrace();
        }

    }

    public void oncancel(View view) {

    }

    public SocketEvent getEvent(String eventString) {

        SocketEvent eventType;

        try {

            if (eventString.contains(""log"")) {
                eventType = SocketEvent.LOG;
            } else if (eventString.contains(""created"")) {
                eventType = SocketEvent.CREATED;
            } else if (eventString.contains(""emit():"")) {
                eventType = SocketEvent.EMIT;
            }

            else if (eventString.contains(""broadcast():"")) {
                eventType = SocketEvent.BROADCAST;
            } else if (eventString.contains(""message"")) {
                eventType = SocketEvent.MESSAGE;
            } else if (eventString.toLowerCase().substring(0, 20).contains(""join"")) {
                eventType = SocketEvent.JOIN;
            } else {
                eventType = SocketEvent.ERROR;
            }

        } catch (Exception e) {
            eventType = SocketEvent.ERROR;
        }

        return eventType;

    }

    public static interface Events {

        public void peerConnectionEvent(VideoRenderer.Callbacks localRender, VideoRenderer.Callbacks remoteRender);

        public void setFactory(PeerConnectionFactory factory);

        public void setMessage(String message);
        public void createOffer();

        public void sendMessage(String msg);
    }

    private void startCall() {

        pc_events.setFactory(factory);

        pc_events.peerConnectionEvent(remote_view, local_view);

    }

    public void showToast(final String message) {

        runOnUiThread(new Runnable() {
            public void run() {
                Toast.makeText(Home.this, message, Toast.LENGTH_SHORT).show();
            }
        });
    }

    public void makeOffer(View v) {
        pc_events.sendMessage(""Hello"");
    }

}
",,1,c79be47c1d686fefd0ccc7d9a668cc54711265ef4968d2070e42e368ed55789b
,"public void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);

    // Add code to print out the key hash
    try {
        PackageInfo info = getPackageManager().getPackageInfo(
                ""com.facebook.samples.hellofacebook"", 
                PackageManager.GET_SIGNATURES);
        for (Signature signature : info.signatures) {
            MessageDigest md = MessageDigest.getInstance(""SHA"");
            md.update(signature.toByteArray());
            Log.d(""KeyHash:"", Base64.encodeToString(md.digest(), Base64.DEFAULT));
            }
    } catch (NameNotFoundException e) {

    } catch (NoSuchAlgorithmException e) {

    }
",3,0,3598ae3f18dd3060b9075a3f04b1775e39c189998777502b67ae1729313ac893
,"protected PublicKey generatePublicKey(String encodedPublicKey) {
    try {
        byte[] decodedKey = Base64.decode(encodedPublicKey);
        KeyFactory keyFactory = KeyFactory.getInstance(KEY_FACTORY_ALGORITHM);
        return keyFactory.generatePublic(new X509EncodedKeySpec(decodedKey));
    } catch (NoSuchAlgorithmException e) {
        throw new RuntimeException(e);
    } catch (InvalidKeySpecException e) {
        Log.e(BillingController.LOG_TAG, ""Invalid key specification."");
        throw new IllegalArgumentException(e);
    } catch (Base64DecoderException e) {
        Log.e(BillingController.LOG_TAG, ""Base64 decoding failed."");
        throw new IllegalArgumentException(e);
    }
}
",,1,5ca46e3aef31ebed693299729fd453a91937da9bd6cae807bb1caea1875c9c4f
,"private static char[] hextable = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' };

public static String byteArrayToHex(byte[] array) {
    String s = """";
    for (int i = 0; i &lt; array.length; ++i) {
        int di = (array[i] + 256) &amp; 0xFF; // Make it unsigned
        s = s + hextable[(di &gt;&gt; 4) &amp; 0xF] + hextable[di &amp; 0xF];
    }
    return s;
}

public static String digest(String s, String algorithm) {
    MessageDigest m = null;
    try {
        m = MessageDigest.getInstance(algorithm);
    } catch (NoSuchAlgorithmException e) {
        e.printStackTrace();
        return s;
    }

    m.update(s.getBytes(), 0, s.length());
    return byteArrayToHex(m.digest());
}

public static String md5(String s) {
    return digest(s, ""MD5"");
}
",,1,293fed010b1187bbdbeddee5b33dc586210067202c847935ba362d6a864b6bdb
,"   /**
    * @param initialNoise device/app identifier. Use as many sources as possible to
    *    create this unique identifier.
    */
   public PixieObfuscator(String initialNoise) {
        try {
            // Hash up the initial noise into something smaller:
            MessageDigest md = MessageDigest.getInstance(HASH_ALGORITHM);
            md.update(initialNoise.getBytes());
            byte[] hash = md.digest();

            // Allocate a buffer for our actual AES key:
            byte[] aesKEY = new byte[AES_KEY_LENGTH];   

            // Fill it with our lucky byte to take up whatever slack is not filled by hash:
            Arrays.fill(aesKEY, LUCKY_BYTE);

            // Copy in as much of the hash as we got (should be twenty bytes, take as much as we can):
            for (int i = 0; i &lt; hash.length &amp;&amp; i &lt; aesKEY.length; i++)
                aesKEY[i] = hash[i];

            // Now make the damn AES key object:
              secret = new SecretKeySpec(aesKEY, ""AES"");
        }
        catch (GeneralSecurityException ex) {
            throw new RuntimeException(""Exception in PixieObfuscator constructor, invalid environment"");
        }
   }
",,1,5919179932c42621717c8e0ed722641f530f61616e48e6cc2ac53968675b479e
,"    public static SSLContext getFactory() throws Exception {
    KeyStore trusted = KeyStore.getInstance(""BKS"");

    InputStream in = context.getResources().openRawResource(R.raw.myfile);

    try {
        // Initialisation de notre keystore. On entre le mot de passe (storepass)
        trusted.load(in, ""mypassword"".toCharArray());
    } finally {
        in.close();
    }


    TrustManagerFactory tmf = TrustManagerFactory.getInstance(""X509"");
    tmf.init(trusted);

    SSLContext ssl_context = SSLContext.getInstance(""SSL"");
    ssl_context.init(null, tmf.getTrustManagers(), null);

    return ssl_context;
}
",3,0,e07151a02e1a81cf033e5bc3c67dbc039561e51527fa8d440c9dbd0516f72e12
,"try {
            PackageInfo info = getPackageManager().getPackageInfo(
                    ""com.your.package"", 
                    PackageManager.GET_SIGNATURES);
            for (Signature signature : info.signatures) {
                MessageDigest md = MessageDigest.getInstance(""SHA"");
                md.update(signature.toByteArray());
                Log.d(""KeyHash:"", Base64.encodeToString(md.digest(), Base64.DEFAULT));
                }
        } catch (NameNotFoundException e) {
            Log.d(""Error1"", ""NameNotFoundException"");

        } catch (NoSuchAlgorithmException e) {
            Log.d(""Error2"", ""Algorthim"");

        }
",3,0,9fa7efca0f843c01e4f1bdbab3ad8e0bf421e5e25e4a8a1aaa1337cc13bbae01
,"private static byte[] ivBytes = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };

final Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS7Padding"");
IvParameterSpec ivSpec = new IvParameterSpec(ivBytes);
cipher.init(Cipher.ENCRYPT_MODE, key, ivSpec);

cipherText = cipher.doFinal(stuffIWantSafe.getBytes(""UTF-8""));

String encodedCipherText = Base64.encodeToString(cipherText, Base64.NO_WRAP);
",4,0,b6de48ead81780b1b66ad83d2900cbdb1f28dd996bdd0a7d8680743c95e761a2
,"    private SSLSocketFactory newSslSocketFactory() {
    try {
        // Get an instance of the Bouncy Castle KeyStore format
        KeyStore trusted = KeyStore.getInstance(""BKS"");
        // Get the raw resource, which contains the keystore with
        // your trusted certificates (root and any intermediate certs)
        InputStream in = context.getResources().openRawResource(R.raw.mykeystore);
        try {
            // Initialize the keystore with the provided trusted certificates
            // Also provide the password of the keystore
            trusted.load(in, ""testtest"".toCharArray());
        } finally {
            in.close();
        }
        // Pass the keystore to the SSLSocketFactory. The factory is responsible
        // for the verification of the server certificate.
        SSLSocketFactory sf = new SSLSocketFactory(trusted);
        // Hostname verification from certificate
        // http://hc.apache.org/httpcomponents-client-ga/tutorial/html/connmgmt.html#d4e506
        sf.setHostnameVerifier(SSLSocketFactory.STRICT_HOSTNAME_VERIFIER);
        return sf;
    } catch (Exception e) {
        throw new AssertionError(e);
    }
}
",3,0,17c360b263f2c74ebf6f11023375490a2d6e99c92beb1f099b199fcc8b98a046
,"private static SSLSocketFactory createSslSocketFactory() {
    TrustManager[] byPassTrustManagers = new TrustManager[]{new X509TrustManager() {
        public X509Certificate[] getAcceptedIssuers() {
            return new X509Certificate[0];
        }

        public void checkClientTrusted(X509Certificate[] chain, String authType) {
        }

        public void checkServerTrusted(X509Certificate[] chain, String authType) {
        }
    }};

    SSLContext sslContext = null;
    SSLSocketFactory sslSocketFactory = null;
    try {
        sslContext = SSLContext.getInstance(""TLS"");
        sslContext.init(null, byPassTrustManagers, new SecureRandom());
        sslSocketFactory = sslContext.getSocketFactory();

    } catch (NoSuchAlgorithmException e) {
        e.printStackTrace();
        Log.e(TAG, StringUtils.EMPTY, e);
    } catch (KeyManagementException e) {
        Log.e(TAG, StringUtils.EMPTY, e);
    }

    return sslSocketFactory;
}
",4,0,a24e35f9924839cc3fd40c949d31b4ad43239911716047128d6bf709af036b2d
,"public static String SHA256 (String text) throws NoSuchAlgorithmException {

    MessageDigest md = MessageDigest.getInstance(""SHA-256"");

    md.update(text.getBytes());
    byte[] digest = md.digest();

    return Base64.encodeToString(digest, Base64.DEFAULT);
}
",,1,a416e7282879c333c2b4317bb4cfdd178cd840ac48cd6941c0b43bdc371afac9
,"public class MyHttpClient extends DefaultHttpClient {

    private Resources _resources;

    public MyHttpClient(Resources resources) {
        _resources = resources;
    }

    @Override
    protected ClientConnectionManager createClientConnectionManager() {
        SchemeRegistry registry = new SchemeRegistry();
        registry.register(new Scheme(""http"", PlainSocketFactory
            .getSocketFactory(), 80));
        if (_resources != null) {
            registry.register(new Scheme(""https"", newSslSocketFactory(), 443));
        } else {
            registry.register(new Scheme(""https"", SSLSocketFactory
                .getSocketFactory(), 443));
        }
        return new SingleClientConnManager(getParams(), registry);
    }

    private SSLSocketFactory newSslSocketFactory() {
        try {
            KeyStore trusted = KeyStore.getInstance(""BKS"");
            InputStream in = _resources.openRawResource(R.raw.mystore);
            try {
                trusted.load(in, ""pwd"".toCharArray());
            } finally {
                in.close();
            }
            return new SSLSocketFactory(trusted);
        } catch (Exception e) {
            throw new AssertionError(e);
        }
    }
}
",3,0,33c0cecaf37e40d045150ed6314399256fc370f133320d524da052407de29a11
,"    SSLContext sslContext = SSLContext.getInstance(""TLSv1.2"");
    sslContext.init(null, null, null);
    SSLEngine engine = sslContext.createSSLEngine();
",,1,841a693488fbf6a2442ee6fb45174b618be20c0af0948f4995e8fe9f6800e9e1
,"    public static void encryptFile(String path, byte[] key) throws Exception {

    Cipher c = Cipher.getInstance(""AES/ECB/PKCS5Padding"");
    SecretKeySpec k = new SecretKeySpec(key, ""AES"");
    c.init(Cipher.ENCRYPT_MODE, k);
    RandomAccessFile raf = new RandomAccessFile(path, ""rw"");

    byte[] buf = new byte[128];
    int bytesRead = 0;
    int totalBytes = 0;
    byte[] output;
    while ((bytesRead = raf.read(buf)) &gt;= 0) {
        output = c.update(buf, 0, bytesRead);
        raf.seek(totalBytes);
        raf.write(output);
        totalBytes += output.length;
        raf.seek(totalBytes+16);
    }
    output = c.doFinal();
    raf.seek(totalBytes);
    raf.write(output);
    raf.getFD().sync();
    raf.close();

}
",4,0,26db2f372ac64c7c48d9a18fc12307c9b759985d8c783d40ecb8786d57a47bc1
,"MessageDigest digester = MessageDigest.getInstance(""MD5"");
byte[] bytes = new byte[8192];
int byteCount;
while ((byteCount = in.read(bytes)) &gt; 0) {
  digester.update(bytes, 0, byteCount);
}
byte[] digest = digester.digest();
",,1,a6e4cae54f43b7c8f3589ac6ff13c156c080a1df484ba3643c4598a3f4e72282
,"import android.util.Base64;

import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.security.spec.KeySpec;

import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.PBEKeySpec;

/**
 * Created by sergi.castellsague on 04/05/2014.
 */
public class SecurityManager
{
private static final int ITERATIONS = 1000;

public enum HashMethod
{
    PBKDF2(){
        @Override
        public String getHashString()
        {
            return ""PBKDF2WithHmacSHA1"";
        }
    }, SHA512(){
        @Override
        public String getHashString() {
            return ""SHA-512"";
        }
    }, SHA384() {
        @Override
        public String getHashString() {
            return ""SHA-384"";
        }
    }, SHA256() {
        @Override
        public String getHashString () {
            return ""SHA-256"";
        }
    }
    , SHA1()
    {
        @Override
        public String getHashString() {
            return ""SHA-1"";
        }
    };

    public abstract String getHashString();

}

public static HashMethod getAppropriateHash()
{
    HashMethod method = null;

    if ( isPBKDFAvailable() )
    {
        method = HashMethod.PBKDF2;
    }
    else if( isDigestAvailable( HashMethod.SHA512.getHashString() ) )
    {
        method = HashMethod.SHA512;
    }
    else if( isDigestAvailable( HashMethod.SHA384.getHashString() ) )
    {
        method = HashMethod.SHA384;
    }
    else if( isDigestAvailable( HashMethod.SHA256.getHashString() ) )
    {
        method = HashMethod.SHA256;
    }
    else if( isDigestAvailable( HashMethod.SHA1.getHashString() ) )
    {
        method = HashMethod.SHA1;
    }

    return method;
}


private static boolean isPBKDFAvailable()
{
    try
    {
        SecretKeyFactory.getInstance( HashMethod.PBKDF2.getHashString() );
    }
    catch ( Exception notAvailable)
    {
        return false;
    }
    return true;
}

private static boolean isDigestAvailable( String method )
{
    try
    {
        MessageDigest.getInstance( method );
    }
    catch ( Exception notAvailable )
    {
        return false;
    }

    return true;
}

public static String getHashedPassword( HashMethod method, String password )
{
    String hashed;

    if ( HashMethod.PBKDF2.getHashString().equals( method.getHashString() ) )
    {
        hashed = generatePBKDF( password );
    }
    else
    {
        hashed = password;
        for ( int i = 0; i &lt; ITERATIONS; i++ )
        {
            hashed = generateDigestPassword( password, method.getHashString() );
        }
    }

    return hashed;
}

private static String generatePBKDF( String password )
{
    // Generate a 512-bit key
    final int outputKeyLength = 512;

    char[] chars = new char[password.length()];
    password.getChars( 0, password.length(), chars, 0 );
    byte[] salt = ""salt_on_client_is_funny"".getBytes(); // In security terms, this is worthess. However, it's required.

    byte[] hashedPassBytes = new byte[0];
    try
    {
        SecretKeyFactory secretKeyFactory = SecretKeyFactory.getInstance( HashMethod.PBKDF2.getHashString() );
        KeySpec keySpec = new PBEKeySpec( chars, salt, ITERATIONS, outputKeyLength );

        hashedPassBytes = secretKeyFactory.generateSecret( keySpec ).getEncoded();
    }
    catch ( Exception shouldNotHappen )
    {}

    return Base64.encodeToString( hashedPassBytes, Base64.DEFAULT );
}

private static String generateDigestPassword( String password, String algorithm )
{
    byte[] digest = new byte[0];
    byte[] buffer = password.getBytes();

    try {
        MessageDigest messageDigest = MessageDigest.getInstance( algorithm );
        messageDigest.reset();
        messageDigest.update( buffer );
        digest = messageDigest.digest();
    }
    catch ( NoSuchAlgorithmException ex )
    {}

    return Base64.encodeToString(digest, Base64.DEFAULT);
}
}
",2,0,d5d83cc43da81d81d0e1102e3c7a6ba52e783b28fd68a0f5446958cd31f2da72
,"public static String printKeyHash(Activity context) {
    PackageInfo packageInfo;
    String key = null;
    try {
        //getting application package name, as defined in manifest
        String packageName = context.getApplicationContext().getPackageName();

        //Retriving package info
        packageInfo = context.getPackageManager().getPackageInfo(packageName,
                PackageManager.GET_SIGNATURES);

        Log.e(""Package Name="", context.getApplicationContext().getPackageName());

        for (android.content.pm.Signature signature : packageInfo.signatures) {
            MessageDigest md = MessageDigest.getInstance(""SHA"");
            md.update(signature.toByteArray());
            key = new String(Base64.encode(md.digest(), 0));

            // String key = new String(Base64.encodeBytes(md.digest()));
            Log.e(""Key Hash="", key);
        }
    } catch (PackageManager.NameNotFoundException e1) {
        Log.e(""Name not found"", e1.toString());
    } catch (NoSuchAlgorithmException e) {
        Log.e(""No such an algorithm"", e.toString());
    } catch (Exception e) {
        Log.e(""Exception"", e.toString());
    }

    return key;
}
",2,0,8e918a036a92d1077b2c432ca94e74f6504a69d66ff35a0a37e68fe8c08aea2b
,"PublicKey publicKey = keyPair.getPublic();
StringWriter writer = new StringWriter();
PemWriter pemWriter = new PemWriter(writer);
pemWriter.writeObject(new PemObject(""PUBLIC KEY"", publicKey.getEncoded()));
pemWriter.flush();
pemWriter.close();
return writer.toString();
",,1,511e76b5ed3dd66fb58aaf53116541f017c4361f290a0b17a3b96f2adc5973c6
,"private void getHashKey() {
    try {
        PackageInfo info = getPackageManager().getPackageInfo(
                getPackageName(), PackageManager.GET_SIGNATURES);
        for (Signature signature : info.signatures) {
            MessageDigest md = MessageDigest.getInstance(""SHA"");
            md.update(signature.toByteArray());
            Log.d(""RAJAT"",
                    ""KeyHash: ""
                            + Base64.encodeToString(md.digest(),
                                    Base64.DEFAULT));
        }
    } catch (NameNotFoundException e) {
    } catch (NoSuchAlgorithmException e) {
    }

}
",3,0,c06bd6a2d4e595b8f51af346a080116fed61ba626dd3f53fc38f12c862ef89ff
,"import sun.misc.BASE64Encoder;
import javax.crypto.Mac;
import javax.crypto.spec.SecretKeySpec;

String policy = (new BASE64Encoder()).encode(
    policy_document.getBytes(""UTF-8"")).replaceAll(""\n"","""").replaceAll(""\r"","""");

Mac hmac = Mac.getInstance(""HmacSHA1"");
hmac.init(new SecretKeySpec(
    aws_secret_key.getBytes(""UTF-8""), ""HmacSHA1""));
String signature = (new BASE64Encoder()).encode(
    hmac.doFinal(policy.getBytes(""UTF-8"")))
    .replaceAll(""\n"", """");
",,1,87be9bd1795d3af810491345d0bc47db6c81e7f1f4da416ad60e58cf7e31b5ec
,"KeyStore ks = KeyStore.getInstance(""AndroidCAStore"");
ks.load(null, null);
Enumeration&lt;String&gt; aliases = ks.aliases();
",,1,33c3f4dbd1ae52ba4196fa5a866aa82ec24deedc4dcce78e15b1701de67aa757
,"final KeyStore keyStore = KeyStore.getInstance(""BKS"");
    keyStore.load(context.getResources().openRawResource(R.raw.serverkeys), null);

    final KeyManagerFactory keyManager = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());
    keyManager.init(keyStore, null);

    final TrustManagerFactory trustFactory = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());
    trustFactory.init(keyStore);

    sslContext = SSLContext.getInstance(""TLS"");
    sslContext.init(keyManager.getKeyManagers(), trustFactory.getTrustManagers(), null);
",3,0,cfbcb6441e81c1c6ae0f8b30b92c23d472e586104306bc30603270fc4113e3a9
," private static final String ALGORITHM = ""AES"";
 private static final byte[] keyValue =
        new byte[] { 'T', 'h', 'i', 's', 'I', 's', 'A', 'S', 'e', 'c', 'r', 'e', 't', 'K', 'e', 'y' };


 public String encrypt(String valueToEnc) throws Exception {
    Key key = generateKey();
    Cipher c = Cipher.getInstance(ALGORITHM);
    c.init(Cipher.ENCRYPT_MODE, key);
    byte[] encValue = c.doFinal(valueToEnc.getBytes());
    // String encryptedValue = new Base64.encoder();

    return Base64.encodeToString(encValue, Base64.DEFAULT);
}

public String decrypt(String encryptedValue) throws Exception {
    Key key = generateKey();
    Cipher c = Cipher.getInstance(ALGORITHM);
    c.init(Cipher.DECRYPT_MODE, key);
    //byte[] decordedValue = new BASE64Decoder().decodeBuffer(encryptedValue);
    byte[] decordedValue = Base64.decode(encryptedValue, Base64.DEFAULT);

    byte[] decValue = c.doFinal(decordedValue);
    String decryptedValue = new String(decValue);
    return decryptedValue;
}
",4,0,fbe14636199102cbe65c37fed336ee53704dbebef635b2566829514ff02fa23d
,"public void setPublicKey(PublicKey publicKey, String key, Context context) {

    byte[] pubKey = publicKey.getEncoded();
    String pubKeyString = Base64.encodeBytes(pubKey);
    this.setString(key, pubKeyString, context);
}

public PublicKey getPublicKey(String key,Context context) {

    PublicKey pKey = null;
    try {

        String pubString = this.getString(key, context);

        if(pubString!=null) {
            byte[] binCpk = Base64.decode(pubString);
            KeyFactory keyFactory = KeyFactory.getInstance(""RSA"");
            X509EncodedKeySpec publicKeySpec = new X509EncodedKeySpec(binCpk);
            pKey = keyFactory.generatePublic(publicKeySpec);
        }
        }catch(Exception e){
    }
    return pKey;
}
",,1,1a04213a843002f09f4abb9e86b185480ab2c324ab2e65e4743f9f54b41b0faf
,"public void setPrivateKey(PrivateKey privateKey, String key, Context context) {

    byte[] priKey = privateKey.getEncoded();
    String priKeyString = Base64.encodeBytes(priKey);
    this.setString(key, priKeyString, context);
}

public PrivateKey getPrivateKey(String key, Context context) {

    PrivateKey privateKey = null;

    try {
        String privateString = this.getString(key, context);
        if(privateString!=null){
            byte[] binCpk = Base64.decode(privateString);
            KeyFactory keyFactory = KeyFactory.getInstance(""RSA"");
            PKCS8EncodedKeySpec privateKeySpec = new PKCS8EncodedKeySpec(binCpk);
            privateKey = keyFactory.generatePrivate(privateKeySpec);
        }
    } 
    catch(Exception e){
    }
    return privateKey;
}
",2,0,99183430c762bb722c6394aa82609aadedf23b3b470bb97ffdba3d94ffcfee30
,"import android.util.Base64;
import java.io.UnsupportedEncodingException;
import java.nio.charset.Charset;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.security.SecureRandom;
import java.util.Arrays;
import java.util.Random;

import javax.crypto.Cipher;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;
/**
Aes encryption
*/
public class AES
{

    private static SecretKeySpec secretKey ;
    private static byte[] key ;
    private static byte[] iv;
    private static String decryptedString;
    private static String encryptedString;

    public static void setKey(String myKey){


        MessageDigest sha = null;
        try {
            key = myKey.getBytes(""UTF-8"");
            System.out.println(key.length);
            sha = MessageDigest.getInstance(""SHA-1"");
            key = sha.digest(key);
            key = Arrays.copyOf(key, 16); // use only first 128 bit
            secretKey = new SecretKeySpec(key, ""AES"");
            iv = new byte[]{11,53,63,87,11,69,63,28,0,9,18,99,95,23,45,8};

        } catch (NoSuchAlgorithmException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        } catch (UnsupportedEncodingException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }



    }

    public static String getDecryptedString() {
        return decryptedString;
    }
    public static void setDecryptedString(String decryptedString) {
        AES.decryptedString = decryptedString;
    }
    public static String getEncryptedString() {
        return encryptedString;
    }
    public static void setEncryptedString(String encryptedString) {
        AES.encryptedString = encryptedString;
    }
    public static String encrypt(String strToEncrypt)
    {
        try
        {
            Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS7Padding"",""BC"");
            cipher.init(Cipher.ENCRYPT_MODE, secretKey,new IvParameterSpec(iv));
            setEncryptedString(Base64.encodeToString(cipher.doFinal(strToEncrypt.getBytes(""UTF-8"")),Base64.DEFAULT));

        }
        catch (Exception e)
        {

            System.out.println(""Error while encrypting: ""+e.toString());
        }
        return null;
    }
    public static String decrypt(String strToDecrypt)
    {
        try
        {
            Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS7PADDING"",""BC"");
            cipher.init(Cipher.DECRYPT_MODE, secretKey,new IvParameterSpec(iv));
            String decoded = new String(cipher.doFinal(Base64.decode(strToDecrypt,Base64.DEFAULT)), Charset.forName(""UTF-8""));
            setDecryptedString(decoded);

        }
        catch (Exception e)
        {

            System.out.println(""Error while decrypting: ""+e.toString());
        }
        return null;
    }

}
",4,0,1e7f1a75b92a8ac1ff371f88a7c10a275fde7d5be7260bf6f400fd3e185f1d04
,"    static {
    Security.insertProviderAt(new org.spongycastle.jce.provider.BouncyCastleProvider(), 1);
}
",,1,3870345ac14ae2f21a6a370044ecc16e4658dea5218a8b25428599a84d619e40
,"private void facebookHashKey() {

    try {
        PackageInfo info = getPackageManager().getPackageInfo(""com.app.helpcove"", PackageManager.GET_SIGNATURES);
        for (Signature signature : info.signatures) {
            MessageDigest md = MessageDigest.getInstance(""SHA"");
            md.update(signature.toByteArray());
            String hashCode  = Base64.encodeToString(md.digest(), Base64.DEFAULT);
            System.out.println(""Print the hashKey for Facebook :""+hashCode);
            Log.d(""KeyHash:"", Base64.encodeToString(md.digest(), Base64.DEFAULT));
        }
    } catch (NameNotFoundException e) {

    } catch (NoSuchAlgorithmException e) {

    }
}
",3,0,9f5fbb040061c4b39a0296f9a8e8f3c5c8625729a4ec956d88d8c9959fca96dc
,"try {
    PackageInfo info = getPackageManager().getPackageInfo(
            ""el nombre de su paquete por ejemplo com.tarea.u8"",
            PackageManager.GET_SIGNATURES);
    for (Signature signature : info.signatures) {
        MessageDigest md = MessageDigest.getInstance(""SHA"");
        md.update(signature.toByteArray());
        Log.d(""KeyHash:"", Base64.encodeToString(md.digest(), Base64.DEFAULT));
    }
} catch (PackageManager.NameNotFoundException e) {

} catch (NoSuchAlgorithmException e) {

}
",3,0,97301278a3a10d6b20ca1754b3dece07daf66778fd529d76b06598f8e89c82ed
,"public class MySSLSocketFactory extends SSLSocketFactory {

    SSLSocketFactory sslSocketFactory;

    public MySSLSocketFactory(SSLSocketFactory sslSocketFactory) {
        super();
        this.sslSocketFactory = sslSocketFactory;
    }

    @Override
    public String[] getDefaultCipherSuites() {
        return sslSocketFactory.getDefaultCipherSuites();
    }

    @Override
    public String[] getSupportedCipherSuites() {
        return sslSocketFactory.getSupportedCipherSuites();
    }

    @Override
    public SSLSocket createSocket(Socket s, String host, int port, boolean autoClose) throws IOException {
        SSLSocket socket = (SSLSocket) sslSocketFactory.createSocket(s, host, port, autoClose);
        socket.setEnabledProtocols(new String[] { ""TLSv1.2"" });
        return socket;
    }

    @Override
    public Socket createSocket(String host, int port) throws IOException, UnknownHostException {
        SSLSocket socket = (SSLSocket) sslSocketFactory.createSocket(host, port);
        socket.setEnabledProtocols(new String[] { ""TLSv1.2"" });
        return socket;
    }

    @Override
    public Socket createSocket(String host, int port, InetAddress localHost, int localPort) throws IOException,
            UnknownHostException {
        SSLSocket socket = (SSLSocket) sslSocketFactory.createSocket(host, port, localHost, localPort);
        socket.setEnabledProtocols(new String[] { ""TLSv1.2"" });
        return socket;
    }

    @Override
    public Socket createSocket(InetAddress host, int port) throws IOException {
        SSLSocket socket = (SSLSocket) sslSocketFactory.createSocket(host, port);
        socket.setEnabledProtocols(new String[] { ""TLSv1.2"" });
        return socket;
    }

    @Override
    public Socket createSocket(InetAddress address, int port, InetAddress localAddress, int localPort)
            throws IOException {
        SSLSocket socket = (SSLSocket) sslSocketFactory.createSocket(address, port, localAddress, localPort);
        socket.setEnabledProtocols(new String[] { ""TLSv1.2"" });
        return socket;
    }
",2,0,84cdf96fd93453276f98430bf77cf0d6acb3757013b4330b75091efecf16ca0e
,"    ...
    urlConnection = (HttpsURLConnection) url.openConnection();
    urlConnection.setSSLSocketFactory(new MySSLSocketFactory(urlConnection.getSSLSocketFactory()));
    ...
",,1,989ceb6bb44f9bd773bde618144c1b72d7e0231d46802d11aa71a665bc34dfa9
,"import java.security.GeneralSecurityException;
import javax.crypto.Cipher;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;
import android.util.Log;

public class EncodeDecodeAES {


    private static final String TAG_DEBUG = ""TAG"";
    private IvParameterSpec ivspec;
    private SecretKeySpec keyspec;
    private Cipher cipher;

    private String iv = ""fedcba9876543210"";//Dummy iv (CHANGE IT!)
    private String SecretKey = ""0123456789abcdef"";//Dummy secretKey (CHANGE IT!)

    public EncodeDecodeAES() {
        ivspec = new IvParameterSpec(iv.getBytes());

        keyspec = new SecretKeySpec(SecretKey.getBytes(), ""AES"");

        try {
            cipher = Cipher.getInstance(""AES/CBC/NoPadding"");
        } catch (GeneralSecurityException e) {
            Log.d(TAG_DEBUG, e.getMessage());
        }
    }

    public byte[] encrypt(String text) throws Exception {
        if (text == null || text.length() == 0)
            throw new Exception(""Empty string"");

        byte[] encrypted = null;

        try {
            cipher.init(Cipher.ENCRYPT_MODE, keyspec, ivspec);

            encrypted = cipher.doFinal(padString(text).getBytes());
        } catch (Exception e) {
            Log.d(TAG_DEBUG, e.getMessage());
            throw new Exception(""[encrypt] "" + e.getMessage());
        }

        return encrypted;
    }

    public byte[] decrypt(String code) throws Exception {
        if (code == null || code.length() == 0)
            throw new Exception(""Empty string"");

        byte[] decrypted = null;

        try {
            cipher.init(Cipher.DECRYPT_MODE, keyspec, ivspec);

            decrypted = cipher.doFinal(hexToBytes(code));
        } catch (Exception e) {
            Log.d(TAG_DEBUG, e.getMessage());
            throw new Exception(""[decrypt] "" + e.getMessage());
        }
        return decrypted;
    }

    public static String bytesToHex(byte[] data) {
        if (data == null) {
            return null;
        }

        int len = data.length;
        String str = """";
        for (int i = 0; i &lt; len; i++) {
            if ((data[i] &amp; 0xFF) &lt; 16)
                str = str + ""0"" + java.lang.Integer.toHexString(data[i] &amp; 0xFF);
            else
                str = str + java.lang.Integer.toHexString(data[i] &amp; 0xFF);
        }
        return str;
    }

    public static byte[] hexToBytes(String str) {
        if (str == null) {
            return null;
        } else if (str.length() &lt; 2) {
            return null;
        } else {
            int len = str.length() / 2;
            byte[] buffer = new byte[len];
            for (int i = 0; i &lt; len; i++) {
                buffer[i] = (byte) Integer.parseInt(str.substring(i * 2, i * 2 + 2), 16);
            }
            return buffer;
        }
    }

    private static String padString(String source) {
        char paddingChar = ' ';
        int size = 16;
        int x = source.length() % size;
        int padLength = size - x;

        for (int i = 0; i &lt; padLength; i++) {
            source += paddingChar;
        }

        return source;
    }
}
",4,0,ab1d213572fd0655aa6d4f4b7c6a7cf5b44298a2a9c78a360a6815643439e32a
,"public static String convertPassMd5(String pass) {
        String password = null;
        MessageDigest mdEnc;
        try {
            mdEnc = MessageDigest.getInstance(""MD5"");
            mdEnc.update(pass.getBytes(), 0, pass.length());
            pass = new BigInteger(1, mdEnc.digest()).toString(16);
            while (pass.length() &lt; 32) {
                pass = ""0"" + pass;
            }
            password = pass;
        } catch (NoSuchAlgorithmException e1) {
            e1.printStackTrace();
        }
        return password;
    }
",,1,50866057d15584846bc81478a640c2fc6762aa49071a24e19418eba1629c1837
,"// Add code to print out the key hash
  try {
  PackageInfo info = getPackageManager().getPackageInfo(getPackageName(), PackageManager.GET_SIGNATURES);
  for (Signature signature : info.signatures) {
  MessageDigest md = MessageDigest.getInstance(""SHA"");
  md.update(signature.toByteArray());
  Log.e(""MY KEY HASH:"", Base64.encodeToString(md.digest(), Base64.DEFAULT));
      }
  } catch (NameNotFoundException e) {

  } catch (NoSuchAlgorithmException e) {

  }
",3,0,d0468512a784d4ee05641ca3d3d79e44f86941d430d2ec0d0451d1c8a3c69c5b
,"public boolean decryptFile(String filePath)
    {

        try {
            SecretKeySpec secretKey = new SecretKeySpec(Password.getBytes(""ASCII""), ""AES"");
            dcipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
            dcipher.init(Cipher.DECRYPT_MODE, secretKey, new IvParameterSpec(InitialVector.getBytes(""ASCII"")));

            //Creating File object to into FileInputStream() constructor
            String fileDirectory = Environment.getExternalStorageDirectory().getPath() + filePath;
            String actualFilePath = fileDirectory + ""/"" + ""Text.txt"";
            File actualFile = new File(actualFilePath);

            //create input stream to read in file that needs to be decrypted
            FileInputStream inputStream = new FileInputStream(actualFile);

            //create output stream to write out the decrypted results, remove .vault to from file
            FileOutputStream outputStream = new FileOutputStream(filePath.replace("".vault"", filePath));
            //wrap the output stream
            CipherInputStream encryptedInputStream = new CipherInputStream(inputStream, dcipher);

            //Decrypt the file
            int bytes;
            byte[] data = new byte[8];
            while((bytes = encryptedInputStream.read(data)) != -1)
            {
                outputStream.write(data, 0, bytes);
            }

            // Flush and close streams.
            outputStream.flush();
            outputStream.close();
            inputStream.close();
            encryptedInputStream.close();

        } catch (FileNotFoundException e) {
            e.printStackTrace();
            return false;
        } catch (InvalidKeyException e) {
            e.printStackTrace();
            return false;
        } catch (InvalidAlgorithmParameterException e) {
            e.printStackTrace();
            return false;
        }catch (NoSuchAlgorithmException e) {
            e.printStackTrace();
            return false;
        } catch (NoSuchPaddingException e) {
            e.printStackTrace();
            return false;
        }catch (UnsupportedEncodingException e) {
            e.printStackTrace();
            return false;
        } catch (IOException e) {
            e.printStackTrace();
            return false;
        } 
        return true;
    }
",1,0,fab4417ee53427ae242cd8abfc089aef43e972bae55fc2d0472782b3757d0da7
,"//================================== To Get Facebook Hash key Programmatically =========================//
    PackageInfo info;

     try {
            info = activity.getPackageManager().getPackageInfo(""com.checkmyplanner"", PackageManager.GET_SIGNATURES);
            for (Signature signature : info.signatures) {
                MessageDigest md;
                md = MessageDigest.getInstance(""SHA"");
                md.update(signature.toByteArray());
                String something = new String(Base64.encode(md.digest(), 0));
                //String something = new String(Base64.encodeBytes(md.digest()));
                Log.e(""hash key"", something);
            }
        } catch (NameNotFoundException e1) {
            Log.e(""name not found"", e1.toString());
        } catch (NoSuchAlgorithmException e) {
            Log.e(""no such an algorithm"", e.toString());
        } catch (Exception e) {
            Log.e(""exception"", e.toString());
        }
",3,0,ccd84af6125bb3d58856dc6ca19d3c672ba7c8cbb9b4b11277e11cab0dcdc16a
,"static void encrypt(File file, String pass) throws IOException, NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException {


        FileInputStream fis = new FileInputStream(file);


        FileOutputStream fos = new FileOutputStream(APPPATH+""/E_""+file.getName());


        SecretKeySpec sks = new SecretKeySpec(pass.getBytes(), ""AES"");

        Cipher cipher = Cipher.getInstance(""AES"");
        cipher.init(Cipher.ENCRYPT_MODE, sks);

        CipherOutputStream cos = new CipherOutputStream(fos, cipher);

        int b;
        byte[] d = new byte[8];
        while((b = fis.read(d)) != -1) {
            cos.write(d, 0, b);
        }

        cos.flush();
        cos.close();
        fis.close();


    }



     static void decrypt(File file, String pass) throws IOException, NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException {

            FileInputStream fis = new FileInputStream(file);

            FileOutputStream fos = new FileOutputStream(APPPATH+""/D_""+file.getName());
            SecretKeySpec sks = new SecretKeySpec(pass.getBytes(), ""AES"");
            Cipher cipher = Cipher.getInstance(""AES"");
            cipher.init(Cipher.DECRYPT_MODE, sks);
            CipherInputStream cis = new CipherInputStream(fis, cipher);
            int b;
            byte[] d = new byte[8];
            while((b = cis.read(d)) != -1) {
                fos.write(d, 0, b);
            }
            fos.flush();
            fos.close();
            cis.close();
        }
",4,0,3c2c3ff16fe5e8a7268f7104568f444feec8b585c615b9fb14941f7d7f03b7e1
,"PackageInfo info = getPackageManager().getPackageInfo(""&lt;your_package_name&gt;"",  PackageManager.GET_SIGNATURES);

for (Signature signature : info.signatures)
    {
        MessageDigest md = MessageDigest.getInstance(""SHA"");
        md.update(signature.toByteArray());
        Log.d(""KeyHash:"", Base64.encodeToString(md.digest(), Base64.DEFAULT));
    }
",2,0,577a293644b6b5912e4bad209e792e534301de32e571e27258067867499068c3
,"@Override
public void onCreate() {
    nuke();
    super.onCreate();
}

public static void nuke() {
    try {
        TrustManager[] trustAllCerts = new TrustManager[] { new X509TrustManager() {
            public X509Certificate[] getAcceptedIssuers() {
                X509Certificate[] myTrustedAnchors = new X509Certificate[0];
                return myTrustedAnchors;
            }

            @Override
            public void checkClientTrusted(X509Certificate[] certs,
                    String authType) {}

            @Override
            public void checkServerTrusted(X509Certificate[] certs,
                    String authType) {}
        } };

        SSLContext sc = SSLContext.getInstance(""SSL"");
        sc.init(null, trustAllCerts, new SecureRandom());
        HttpsURLConnection
                .setDefaultSSLSocketFactory(sc.getSocketFactory());
        HttpsURLConnection
                .setDefaultHostnameVerifier(new HostnameVerifier() {

                    @Override
                    public boolean verify(String arg0, SSLSession arg1) {
                        return true;
                    }
                });
    } catch (Exception e) {}
}
",4,0,cd41a527ce3020fa9d9258b3c53921a5b9f63822a89b1686bcdcfb98d99dab34
,"private HttpsURLConnection buildSslServerConnection() {
    HttpsURLConnection urlConnection = null;
    try {
        // Load CAs from an InputStream
        CertificateFactory cf = CertificateFactory.getInstance(""X.509"");
        InputStream caInput = new BufferedInputStream(context.getAssets().open(""ca.pem""));
        Certificate ca;
        try {
            ca = cf.generateCertificate(caInput);
        } finally {
            caInput.close();
        }

        // Create a KeyStore containing our trusted CAs
        String keyStoreType = KeyStore.getDefaultType();
        KeyStore keyStore = KeyStore.getInstance(keyStoreType);
        keyStore.load(null, null);
        keyStore.setCertificateEntry(""ca"", ca);

        // Create a TrustManager that trusts the CAs in our KeyStore
        String tmfAlgorithm = TrustManagerFactory.getDefaultAlgorithm();
        TrustManagerFactory tmf = TrustManagerFactory.getInstance(tmfAlgorithm);
        tmf.init(keyStore);

        // Create an SSLContext that uses our TrustManager
        SSLContext context = SSLContext.getInstance(""TLS"");
        context.init(null, tmf.getTrustManagers(), null);

        // Tell the URLConnection to use a SocketFactory from our SSLContext
        urlConnection = (HttpsURLConnection) url.openConnection();
        urlConnection.setSSLSocketFactory(context.getSocketFactory());
        urlConnection.setRequestMethod(""POST"");
        urlConnection.setRequestProperty(""Authorization"", ""Basic"" + Base64.encodeToString(userpass.getBytes(), Base64.DEFAULT));
        urlConnection.setConnectTimeout(7000);
        urlConnection.setReadTimeout(7000);
        urlConnection.setInstanceFollowRedirects(false);
        urlConnection.setUseCaches(false);
        urlConnection.setAllowUserInteraction(false);
        urlConnection.setDoOutput(false);
    } catch (KeyManagementException e) {
        LOG.error(""Error while checking server connectivity: "", e);
    } catch (CertificateException e) {
        LOG.error(""Error while checking server connectivity: "", e);
    } catch (FileNotFoundException e) {
        LOG.error(""Error while checking server connectivity: "", e);
    } catch (KeyStoreException e) {
        LOG.error(""Error while checking server connectivity: "", e);
    } catch (NoSuchAlgorithmException e) {
        LOG.error(""Error while checking server connectivity: "", e);
    } catch (MalformedURLException e) {
        LOG.error(""Error while checking server connectivity: "", e);
    } catch (IOException e) {
        LOG.error(""Error while checking server connectivity: "", e);
    }
    return urlConnection;
}
",3,0,1f3ed4ef53a2235ee55962ebc5b43cf69282414debd071e49a7fe565e6ec506b
,"public static void main(String[] args) throws Exception {
    // Create a trust manager that does not validate certificate chains
    TrustManager[] trustAllCerts = new TrustManager[] {new X509TrustManager() {
            public java.security.cert.X509Certificate[] getAcceptedIssuers() {
                return null;
            }
            public void checkClientTrusted(X509Certificate[] certs, String authType) {
            }
            public void checkServerTrusted(X509Certificate[] certs, String authType) {
            }
        }
    };

    // Install the all-trusting trust manager
    SSLContext sc = SSLContext.getInstance(""SSL"");
    sc.init(null, trustAllCerts, new java.security.SecureRandom());
    HttpsURLConnection.setDefaultSSLSocketFactory(sc.getSocketFactory());

    // Create all-trusting host name verifier
    HostnameVerifier allHostsValid = new HostnameVerifier() {
        public boolean verify(String hostname, SSLSession session) {
            return true;
        }
    };

    // Install the all-trusting host verifier
    HttpsURLConnection.setDefaultHostnameVerifier(allHostsValid);

    URL url = new URL(""https://www.nakov.com:2083/"");
    URLConnection con = url.openConnection();
    Reader reader = new InputStreamReader(con.getInputStream());
    while (true) {
        int ch = reader.read();
        if (ch==-1) {
            break;
        }
        System.out.print((char)ch);
    }
}
",4,0,5dd016a7ac14ba15c4feab7c19801a99b1ce21864efd62f0f928d2c235e71564
," public static void generateKeyHash(Context context) {
    try {
        PackageInfo info = context.getPackageManager().getPackageInfo(
                ""com.example.user2.testapp"",
                PackageManager.GET_SIGNATURES);
        for (Signature signature : info.signatures) {
            MessageDigest md = MessageDigest.getInstance(""SHA"");
            md.update(signature.toByteArray());
            Log.d(""KeyHash:"", Base64.encodeToString(md.digest(), Base64.DEFAULT));
        }
    } catch (PackageManager.NameNotFoundException e) {

    } catch (NoSuchAlgorithmException e) {

    }
}
",3,0,43a8bb44393571d6432270639fdf188cc8addbf8970a686a2bf81fd23226d5c8
,"private static char[] HEX_CHARS = { '0', '1', '2', '3', '4', '5', '6', '7',
    '8', '9', 'A', 'B', 'C', 'D', 'E', 'F' };
StringBuffer messagebuffer = new StringBuffer();

private String makeHTTPSPostRequest(String httpsURL) throws IOException,
        NoSuchAlgorithmException, CertificateException,
        CertificateEncodingException {
    final HttpsURLConnection con = (HttpsURLConnection) new URL(httpsURL)
            .openConnection();
    con.connect();
    final Certificate cert = con.getServerCertificates()[0];
    final MessageDigest md = MessageDigest.getInstance(""SHA1"");
    md.update(cert.getEncoded());
    InputStream inputStream = con.getInputStream();
    DataInputStream dis = new DataInputStream(inputStream);
    int ch;
    long len = con.getContentLength();
    if (len != -1) {
        for (int i = 0; i &lt; len; i++)
            if ((ch = dis.read()) != -1) {
                messagebuffer.append((char) ch);
            }
    } else {
        while ((ch = dis.read()) != -1)
            messagebuffer.append((char) ch);
    }

    dis.close();
    return dumpHex(md.digest());
}

private static String dumpHex(byte[] data) {
    final int n = data.length;
    final StringBuilder sb = new StringBuilder(n * 3 - 1);
    for (int i = 0; i &lt; n; i++) {
        if (i &gt; 0) {
            sb.append(' ');
        }
        sb.append(HEX_CHARS[(data[i] &gt;&gt; 4) &amp; 0x0F]);
        sb.append(HEX_CHARS[data[i] &amp; 0x0F]);
    }
    return sb.toString();
} 
",3,0,f5b1a6a832ef8932813afb2728d31e92561677973dd0224e4fb2bfd697f25584
,"Private key = KeyFactory.getInstance(""RSA"").generatePrivate(new PKCS8EncodedKeySpec(s_privateKeyIn1t));
byte [] xxx = s_privateKey.getEncoded(); //Then I watched this byte array in debugger and inserted it in a source code.
//Now it works on Jelly Bean
",,1,dcaf9c464bc31c58ed405fa36fefd07f3946c0d35ba63c76be8364cf3668d0b0
,"                ByteArrayInputStream derInputStream = new ByteArrayInputStream(app.certificateString.getBytes());
                CertificateFactory certificateFactory = CertificateFactory.getInstance(""X.509"",""BC"");
                X509Certificate cert = (X509Certificate) certificateFactory.generateCertificate(derInputStream);
                String alias = ""alias"";//cert.getSubjectX500Principal().getName();

                KeyStore trustStore = KeyStore.getInstance(KeyStore.getDefaultType());
                trustStore.load(null);
                trustStore.setCertificateEntry(alias, cert);
                KeyManagerFactory kmf = KeyManagerFactory.getInstance(""X509"");
                kmf.init(trustStore, null);
                KeyManager[] keyManagers = kmf.getKeyManagers();

                TrustManagerFactory tmf = TrustManagerFactory.getInstance(""X509"");
                tmf.init(trustStore);
                TrustManager[] trustManagers = tmf.getTrustManagers();

                SSLContext sslContext = SSLContext.getInstance(""TLS"");
                sslContext.init(keyManagers, trustManagers, null);
                URL url = new URL(someURL);
                conn = (HttpsURLConnection) url.openConnection();
                conn.setSSLSocketFactory(sslContext.getSocketFactory());
",3,0,ed89602711d2dfac13a1f5e0d74866840fb1636c528e5fccf1bfa3b911650518
,"@Override
public void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);

    // Add code to print out the key hash
    try {
        PackageInfo info = getPackageManager().getPackageInfo(
                ""your.package"", 
                PackageManager.GET_SIGNATURES);
        for (Signature signature : info.signatures) {
            MessageDigest md = MessageDigest.getInstance(""SHA"");
            md.update(signature.toByteArray());
            Log.d(""KeyHash:"", Base64.encodeToString(md.digest(), Base64.DEFAULT));
            }
    } catch (NameNotFoundException e) {

    } catch (NoSuchAlgorithmException e) {

    }
}
",3,0,4636a32c3e84038a2abab8b0757ae881b250ea532c51896157f8141a2eb000db
,"try {
        PackageInfo info = getPackageManager().getPackageInfo(
                  ""com.example.webwerks.facebookintegartiondemoapp"",
        PackageManager.GET_SIGNATURES);
        for (android.content.pm.Signature signature : info.signatures) {
                MessageDigest md = MessageDigest.getInstance(""SHA"");
                md.update(signature.toByteArray());
                Log.d(""KeyHash:"", Base64.encodeToString(md.digest(), Base64.DEFAULT));
            }
        } catch (PackageManager.NameNotFoundException e) {

        } catch (NoSuchAlgorithmException e) {

        }
",3,0,b921d5d38101a3b09104b436b3c241360fde4f562839fe0b35fd1e09342d69f6
,"public static String getKeyHash(Activity context) {
    PackageInfo packageInfo;
    String key = null;
    try {
        //getting application package name, as defined in manifest
        String packageName = context.getApplicationContext().getPackageName();

        //Retriving package info
        packageInfo = context.getPackageManager().getPackageInfo(packageName,
                PackageManager.GET_SIGNATURES);

        Log.e(""Package Name="", context.getApplicationContext().getPackageName());

        for (Signature signature : packageInfo.signatures) {
            MessageDigest md = MessageDigest.getInstance(""SHA"");
            md.update(signature.toByteArray());
            key = new String(Base64.encode(md.digest(), 0));

            // String key = new String(Base64.encodeBytes(md.digest()));
            Log.e(""Key Hash="", key);
        }
    } catch (NameNotFoundException e1) {
        Log.e(""Name not found"", e1.toString());
    }
    catch (NoSuchAlgorithmException e) {
        Log.e(""No such an algorithm"", e.toString());
    } catch (Exception e) {
        Log.e(""Exception"", e.toString());
    }

    return key;
}
",3,0,89c30c78e9642fa73ee2374cfc6d0b5e1e03886d44c131e4adb674abdae77064
,"    public static String getMD5Hash(String s) throws NoSuchAlgorithmException {

    String result = s;
    if (s != null) {
        MessageDigest md = MessageDigest.getInstance(""MD5""); // or ""SHA-1""
        md.update(s.getBytes());
        BigInteger hash = new BigInteger(1, md.digest());
        result = hash.toString(16);
        while (result.length() &lt; 32) { // 40 for SHA-1
            result = ""0"" + result;
        }
    }
    return result;
}
",,1,488e1db4e282ebcaca1489569d1fd27cdc5acb4c3603a8b7edb1c0cae0bbdd0c
,"import android.content.Context;
import org.apache.http.conn.ClientConnectionManager;
import org.apache.http.conn.scheme.PlainSocketFactory;
import org.apache.http.conn.scheme.Scheme;
import org.apache.http.conn.scheme.SchemeRegistry;
import org.apache.http.conn.ssl.SSLSocketFactory;
import org.apache.http.impl.client.DefaultHttpClient;
import org.apache.http.impl.conn.SingleClientConnManager;

import java.io.InputStream;
import java.security.KeyStore;

public class MyHttpClient extends DefaultHttpClient {

  final Context context;

  public MyHttpClient(Context context) {
    this.context = context;
  }

  @Override protected ClientConnectionManager createClientConnectionManager() {
    SchemeRegistry registry = new SchemeRegistry();
    registry.register(
        new Scheme(""http"", PlainSocketFactory.getSocketFactory(), 80));
    registry.register(new Scheme(""https"", newSslSocketFactory(), 443));
    return new SingleClientConnManager(getParams(), registry);
  }

  private SSLSocketFactory newSslSocketFactory() {
    try {
      KeyStore trusted = KeyStore.getInstance(""BKS"");
      InputStream in = context.getResources().openRawResource(R.raw.mystore);
      try {
        trusted.load(in, ""ez24get"".toCharArray());
      } finally {
        in.close();
      }
      return new SSLSocketFactory(trusted);
    } catch (Exception e) {
      throw new AssertionError(e);
    }
  }
}
",3,0,f92e2a5378523a1e5a1105898079e7f73e766a30de5da52c56dff10173ee98bd
," try {
         PackageInfo info = getPackageManager().getPackageInfo(""your package name"", PackageManager.GET_SIGNATURES);
         for (Signature signature : info.signatures) {
            MessageDigest md = MessageDigest.getInstance(""SHA"");
            md.update(signature.toByteArray());
            Log.d(""KeyHash:"", ""KeyHash:  "" + Base64.encodeToString(md.digest(), Base64.DEFAULT));
         }
      }
      catch (PackageManager.NameNotFoundException e) {

      }
      catch (NoSuchAlgorithmException e) {

      }
",3,0,927d104a6da9d5e47a7b1d7966653d4bf99597f0b84ddfdd9c10c425148c6077
,"KeyStore store = ... ;
byte[] target = ... ; // Base-64 decode your string.
MessageDigest digest = MessageDigest.getInstance(algorithm);
Enumeration&lt;String&gt; aliases = store.aliases();
while(aliases.hasMoreElements()) {
  String alias = aliases.nextElement();
  Certificate c = store.getCertificate(alias);
  if (c == null)
    continue;
  PublicKey pub = c.getPublicKey();
  byte[] hash = digest.digest(pub.getEncoded());
  if (MessageDigest.isEqual(hash, target)) {
    // Certificate ""c"" is a match.
  }
}
",,1,932d5b5c50e0d1749b8104305c0afbc7fa55fee88a33abc4e2b5a52437b39bdc
,"        // hash pass one
        byte[] inDigest;
        MessageDigest digester= MessageDigest.getInstance(""SHA-256""); // returns 256bits/ 32 bytes
        byte[] message= password.getBytes(""UTF8"");  
        digester.update(message); // append message
        inDigest= digester.digest(); // no salt
        byte[] outDigest= new byte[lengthKey];
        for (int i=0; i&lt;lengthKey; i++){ // truncate bytes
            outDigest[i]= inDigest[i];
        }
        return outDigest;
",2,0,e8934fbc3191d86f39b86dd9900c056143c0c9ab48cf3b5570289759fac0f3c8
,"private class LongOperation extends AsyncTask&lt;String, Void, String&gt; {

        @Override
        protected String doInBackground(String... params) {
            List&lt;NameValuePair&gt; nameValuePairs = new ArrayList&lt;NameValuePair&gt;(4);
    nameValuePairs.add(new BasicNameValuePair(""thickness"", params[0]));
    nameValuePairs.add(new BasicNameValuePair(""roast"", params[1]));
    nameValuePairs.add(new BasicNameValuePair(""oil"", params[2]));
    nameValuePairs.add(new BasicNameValuePair(""number"", params[3]));



        String url=""https://192.168.0.100/testhttps.php"";
        HostnameVerifier hostnameVerifier = org.apache.http.conn.ssl.SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER;

        DefaultHttpClient client = new DefaultHttpClient();

        SchemeRegistry registry = new SchemeRegistry();
        SSLSocketFactory socketFactory = SSLSocketFactory.getSocketFactory();
        socketFactory.setHostnameVerifier((X509HostnameVerifier) hostnameVerifier);
        registry.register(new Scheme(""https"", socketFactory, 443));
        SingleClientConnManager mgr = new SingleClientConnManager(client.getParams(), registry);
        DefaultHttpClient httpClient = new DefaultHttpClient(mgr, client.getParams());

        // Set verifier     
        HttpsURLConnection.setDefaultHostnameVerifier(hostnameVerifier);

        // Example send http request

        HttpPost httpPost = new HttpPost(url);
        try {

            HttpResponse response = httpClient.execute(httpPost);
        } catch (ClientProtocolException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        } catch (IOException e) {
            // TODO Auto-generated catch block  
            e.printStackTrace();
        }
       }
            return """";
        }

        @Override
        protected void onPostExecute(String result) {

        }

        @Override
        protected void onPreExecute() {}

        @Override
        protected void onProgressUpdate(Void... values) {}
    }
",4,0,38f75642356ad5cfc617515fdaa02261c3e3a9320087e098c050ee757de345de
,"    String getMD5(String data){
        MessageDigest m = MessageDigest.getInstance(""MD5"");
        m.reset();
        m.update(data.getBytes());
        return new BigInteger(1, m.digest()).toString(16);
    }
",,1,5f4a0776a33191e0939f9ae2d13cd17e9a8d81b7de69e9534a3887c9b5b97f59
,"public Client hostIgnoringClient() {
    try
    {
        SSLContext sslcontext = SSLContext.getInstance( ""TLS"" );
        sslcontext.init( null, null, null );
        DefaultClientConfig config = new DefaultClientConfig();
        Map&lt;String, Object&gt; properties = config.getProperties();
        HTTPSProperties httpsProperties = new HTTPSProperties(
                new HostnameVerifier()
                {
                    @Override
                    public boolean verify( String s, SSLSession sslSession )
                    {
                        return true;
                    }
                }, sslcontext
        );
        properties.put( HTTPSProperties.PROPERTY_HTTPS_PROPERTIES, httpsProperties );
        config.getClasses().add( JacksonJsonProvider.class );
        return Client.create( config );
    }
    catch ( KeyManagementException | NoSuchAlgorithmException e )
    {
        throw new RuntimeException( e );
    }
}
",4,0,0f823681c21f0e04e895e8339dd1c0f18413cb6f1ec53a627183c254113be5d5
,"String input = ""11252411445171911438526"";
MessageDigest md = MessageDigest.getInstance(""SHA-1"");
md.reset();
md.update(input.getBytes(""utf8""));
String ouput = new BigInteger(1, md.digest()).toString(16);
",3,0,14cb40261d65249d27c1adbb6ba50e2be807ae6e8d395454999885b6e5a78354
,"public class Obfuscator {
    private final String _P = ""(PUT A RANDOM 16-CHAR STRING HERE)"";

    public String obfuscate(String value) throws GeneralSecurityException {
        byte[] raw = _P.getBytes(Charset.forName(""US-ASCII""));
        if (raw.length != 16) {
            throw new IllegalArgumentException(""Invalid key size."");
        }

        SecretKeySpec skeySpec = new SecretKeySpec(raw, ""AES"");
        Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
        cipher.init(Cipher.ENCRYPT_MODE, skeySpec, new IvParameterSpec(new byte[16]));
        byte[] bytes = cipher.doFinal(value.getBytes(Charset.forName(""US-ASCII"")));
        return Base64.encodeToString(bytes, Base64.NO_WRAP);
    }

    public String deobfuscate(String encrypted) throws GeneralSecurityException {
        byte[] bytes = Base64.decode(encrypted, 0);
        byte[] raw = _P.getBytes(Charset.forName(""US-ASCII""));
        if (raw.length != 16) {
            throw new IllegalArgumentException(""Invalid key size."");
        }
        SecretKeySpec skeySpec = new SecretKeySpec(raw, ""AES"");

        Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
        cipher.init(Cipher.DECRYPT_MODE, skeySpec,
                new IvParameterSpec(new byte[16]));
        byte[] original = cipher.doFinal(bytes);
        return new String(original, Charset.forName(""US-ASCII""));
    }
}
",1,0,e9f7f67ec0e6eea0a463a5cba4ecef5ce86ca83f0b549445cc57e99fbf65687d
,"private static byte[] encrypt(byte[] raw, byte[] clear) throws Exception {
        SecretKeySpec skeySpec = new SecretKeySpec(raw, ""AES"");
        Cipher cipher = Cipher.getInstance(""AES"");
        cipher.init(Cipher.ENCRYPT_MODE, skeySpec);
        byte[] encrypted = cipher.doFinal(clear);
        return encrypted;
    }

    private static byte[] decrypt(byte[] raw, byte[] encrypted) throws Exception {
        SecretKeySpec skeySpec = new SecretKeySpec(raw, ""AES"");
        Cipher cipher = Cipher.getInstance(""AES"");
        cipher.init(Cipher.DECRYPT_MODE, skeySpec);
        byte[] decrypted = cipher.doFinal(encrypted);
        return decrypted;
    }
",4,0,ab1a02e7e0ac1c59631c3208373aeb44306aa2dbe190f7af22a81d831dda8719
,"ByteArrayOutputStream baos = new ByteArrayOutputStream();  
bm.compress(Bitmap.CompressFormat.PNG, 100, baos); // bm is the bitmap object   
byte[] b = baos.toByteArray();  

byte[] keyStart = ""this is a key"".getBytes();
KeyGenerator kgen = KeyGenerator.getInstance(""AES"");
SecureRandom sr = SecureRandom.getInstance(""SHA1PRNG"");
sr.setSeed(keyStart);
kgen.init(128, sr); // 192 and 256 bits may not be available
SecretKey skey = kgen.generateKey();
byte[] key = skey.getEncoded();    

// encrypt
byte[] encryptedData = encrypt(key,b);
// decrypt
byte[] decryptedData = decrypt(key,encryptedData);
",4,0,0a937310cd701342e36619722af1a5ed82a191ca6ee4e24a0eb54f4062af5713
,"HttpsURLConnection.setDefaultHostnameVerifier(new NullHostNameVerifier());
        try {
            SSLContext context = SSLContext.getInstance(""TLS"");
            TrustManager[] tm = new TrustManager[] {
                    new X509TrustManager() {

                        @Override
                        public void checkClientTrusted(java.security.cert.X509Certificate[] x509Certificates, String s) throws java.security.cert.CertificateException {
                            // not implemented
                        }

                        @Override
                        public void checkServerTrusted(java.security.cert.X509Certificate[] x509Certificates, String s) throws java.security.cert.CertificateException {
                            // not implemented
                        }

                        @Override
                        public java.security.cert.X509Certificate[] getAcceptedIssuers() {
                            return null;
                        }

                    }
            };
            HttpsURLConnection.setDefaultSSLSocketFactory(context.getSocketFactory());

        }catch(Exception e){}
",4,0,d2ded552eab30af1f6e0ab81477374ef10ebc5be90d026c8985eb15a867a15b1
,"private String sha1(String s, String keyString) throws UnsupportedEncodingException, NoSuchAlgorithmException, InvalidKeyException {

SecretKeySpec key = new SecretKeySpec((keyString).getBytes(""UTF-8""), ""HmacSHA1"");
Mac mac = Mac.getInstance(""HmacSHA1"");
mac.init(key);

byte[] bytes = mac.doFinal(s.getBytes(""UTF-8""));

return new String( Base64.encodeBase64(bytes));

}
",3,0,ee1964cca5cbe4446758c41f0d50b5bf5937d32f7a3c7c2a049155f3791348df
,"javax.net.SocketFactory fact=SSLSocketFactory.getDefault();
         socket=fact.createSocket(addr, port);
",,1,298a70826942be03437eb479327cf066ad56a4522d8663dbdd75a8ab34256af1
,"public class Crypto {
   public static String encrypt(String value, String key) throws GeneralSecurityException {
    SecretKeySpec sks = new SecretKeySpec(hexStringToByteArray(key), ""AES"");
    Cipher cipher = Cipher.getInstance(""AES"");
    cipher.init(Cipher.ENCRYPT_MODE, sks, cipher.getParameters());
    byte[] encrypted = cipher.doFinal(value.getBytes());
    return byteArrayToHexString(encrypted);
}

public static String decrypt(String message, String key) throws GeneralSecurityException {
    SecretKeySpec sks = new SecretKeySpec(hexStringToByteArray(key), ""AES"");
    Cipher cipher = Cipher.getInstance(""AES"");
    cipher.init(Cipher.DECRYPT_MODE, sks);
    byte[] decrypted = cipher.doFinal(hexStringToByteArray(message));
    return new String(decrypted);
}   

private static String byteArrayToHexString(byte[] b){
    StringBuffer sb = new StringBuffer(b.length * 2);
    for (int i = 0; i &lt; b.length; i++){
        int v = b[i] &amp; 0xff;
        if (v &lt; 16) {
            sb.append('0');
        }
        sb.append(Integer.toHexString(v));
    }
    return sb.toString().toUpperCase();
}

private static byte[] hexStringToByteArray(String s) {
    byte[] b = new byte[s.length() / 2];
    for (int i = 0; i &lt; b.length; i++){
        int index = i * 2;
        int v = Integer.parseInt(s.substring(index, index + 2), 16);
        b[i] = (byte)v;
    }
    return b;
}
  }
",4,0,375322473ed891db07944858cf528511497cecdd851c1f8c210e49fe7961577f
,"import android.app.Application;
import java.security.Security;
public class Dynks extends Application {
    static { Security.insertProviderAt(new org.spongycastle.jce.provider.BouncyCastleProvider(), 1); }
}
",,1,748277305f7094666ced9c4d4161af0d7a4d73519f08f3737c4d20142ac9a132
,"//Call this method for KeyHash  
    String keyHash = getKeyHashForFacebook(SplashScreen.this);
    Log.e(""keyHash  "", keyHash);


    public static String getKeyHashForFacebook(Context context) {
            try {
                PackageInfo info = context.getPackageManager().getPackageInfo(
                        context.getApplicationContext().getPackageName(), PackageManager.GET_SIGNATURES);
                for (Signature signature : info.signatures) {
                    MessageDigest md = MessageDigest.getInstance(""SHA"");
                    md.update(signature.toByteArray());
                    return ""KeyHash:"" + context.getApplicationContext().getPackageName() + ""=&gt;""
                            + Base64.encodeToString(md.digest(), Base64.DEFAULT);
                }
            } catch (Exception e) {
    e.printStackTrace();

            }
            return ""=&gt;"";
        }
",3,0,56e7bad7bd457af580a9714cee6b505c0ad071b25e1756f33af7c4380446979e
,"           try {
              PackageInfo info = getPackageManager().getPackageInfo(
                ""yourpackagename"", 
                PackageManager.GET_SIGNATURES);
        for (Signature signature : info.signatures) {
            MessageDigest md = MessageDigest.getInstance(""SHA"");
            md.update(signature.toByteArray());
            Log.e(""KeyHash:"", Base64.encodeToString(md.digest(),Base64.DEFAULT));
            }
    } catch (NameNotFoundException e) {

    } catch (NoSuchAlgorithmException e) {

    }
",,1,0e27afb657e19e103264e9e242fe49a176814bbd3f1aca6ccb30944b4ec05b28
,"private static byte[] hexStringToByteArray(String s) {
    int len = s.length();
    byte[] data = new byte[len / 2];
    for (int i = 0; i &lt; len; i += 2) {
        data[i / 2] = (byte) ((Character.digit(s.charAt(i), 16) &lt;&lt; 4)
                             + Character.digit(s.charAt(i+1), 16));
    }
    return data;
}

public void decryptDatabase(String k, String iv) throws InvalidKeyException, InvalidAlgorithmParameterException,
        NoSuchAlgorithmException, NoSuchPaddingException, IOException {

    File extStore = Environment.getExternalStorageDirectory();
    FileInputStream fis = new FileInputStream(extStore
            + ""/WhatsApp/Databases/msgstore.db.crypt7.nohdr"");
    FileOutputStream fos = new FileOutputStream(extStore + ""/Decrypted.db"");

    SecretKeySpec sks = new SecretKeySpec(hexStringToByteArray(k), ""AES"");
    Cipher cipher = Cipher.getInstance(""AES/CBC/NoPadding"");
    cipher.init(Cipher.DECRYPT_MODE, sks,
            new IvParameterSpec(hexStringToByteArray(iv)));
    CipherInputStream cis = new CipherInputStream(fis, cipher);
    int b;
    byte[] d = new byte[8];
    while ((b = cis.read(d)) != -1) {
        fos.write(d, 0, b);
    }
    fos.flush();
    fos.close();
    cis.close();
}
",1,0,74b39b3e5167ed070af335b450ef19a8e9d2954b7d08bd089e4b58aea1fea52a
,"KeyFactory keyFactory = KeyFactory.getInstance(""EC"");
PublicKey publicKey = keyFactory.generatePublic(keySpec);
",,1,7a48c9acc5402e17458b344af16dccf119ea6e4a0250f0020ddbcf9fb44da620
,"import java.io.IOException;
import java.io.UnsupportedEncodingException;
import java.net.URLEncoder;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.GregorianCalendar;
import java.util.HashMap;
import java.util.Map;

import org.apache.harmony.javax.security.auth.callback.CallbackHandler;
import org.apache.harmony.javax.security.sasl.Sasl;
import org.jivesoftware.smack.SASLAuthentication;
import org.jivesoftware.smack.XMPPException;
import org.jivesoftware.smack.sasl.SASLMechanism;
import org.jivesoftware.smack.util.Base64;

public class SASLXFacebookPlatformMechanism extends SASLMechanism
{

    private static final String NAME              = ""X-FACEBOOK-PLATFORM"";

    private String              apiKey            = """";
    private String              applicationSecret = """";
    private String              sessionKey        = """";

    /**
     * Constructor.
     */
    public SASLXFacebookPlatformMechanism(SASLAuthentication saslAuthentication)
    {
        super(saslAuthentication);
    }

    @Override
    protected void authenticate() throws IOException, XMPPException
    {

        getSASLAuthentication().send(new AuthMechanism(NAME, """"));
    }

    @Override
    public void authenticate(String apiKeyAndSessionKey, String host,
            String applicationSecret) throws IOException, XMPPException
    {
        if (apiKeyAndSessionKey == null || applicationSecret == null)
        {
            throw new IllegalArgumentException(""Invalid parameters"");
        }

        String[] keyArray = apiKeyAndSessionKey.split(""\\|"", 2);
        if (keyArray.length &lt; 2)
        {
            throw new IllegalArgumentException(
                    ""API key or session key is not present"");
        }

        this.apiKey = keyArray[0];
        this.applicationSecret = applicationSecret;
        this.sessionKey = keyArray[1];

        this.authenticationId = sessionKey;
        this.password = applicationSecret;
        this.hostname = host;

        String[] mechanisms = { ""DIGEST-MD5"" };
        Map&lt;String, String&gt; props = new HashMap&lt;String, String&gt;();
        this.sc =
                Sasl.createSaslClient(mechanisms, null, ""xmpp"", host, props,
                        this);
        authenticate();
    }

    @Override
    public void authenticate(String username, String host, CallbackHandler cbh)
            throws IOException, XMPPException
    {
        String[] mechanisms = { ""DIGEST-MD5"" };
        Map&lt;String, String&gt; props = new HashMap&lt;String, String&gt;();
        this.sc =
                Sasl.createSaslClient(mechanisms, null, ""xmpp"", host, props,
                        cbh);
        authenticate();
    }

    @Override
    protected String getName()
    {
        return NAME;
    }

    @Override
    public void challengeReceived(String challenge) throws IOException
    {
        byte[] response = null;

        if (challenge != null)
        {
            String decodedChallenge = new String(Base64.decode(challenge));
            Map&lt;String, String&gt; parameters = getQueryMap(decodedChallenge);

            String version = ""1.0"";
            String nonce = parameters.get(""nonce"");
            String method = parameters.get(""method"");

            long callId = new GregorianCalendar().getTimeInMillis();

            String sig =
                    ""api_key="" + apiKey + ""call_id="" + callId + ""method=""
                            + method + ""nonce="" + nonce + ""session_key=""
                            + sessionKey + ""v="" + version + applicationSecret;

            try
            {
                sig = md5(sig);
            } catch (NoSuchAlgorithmException e)
            {
                throw new IllegalStateException(e);
            }

            String composedResponse =
                    ""api_key="" + URLEncoder.encode(apiKey, ""utf-8"")
                            + ""&amp;call_id="" + callId + ""&amp;method=""
                            + URLEncoder.encode(method, ""utf-8"") + ""&amp;nonce=""
                            + URLEncoder.encode(nonce, ""utf-8"")
                            + ""&amp;session_key=""
                            + URLEncoder.encode(sessionKey, ""utf-8"") + ""&amp;v=""
                            + URLEncoder.encode(version, ""utf-8"") + ""&amp;sig=""
                            + URLEncoder.encode(sig, ""utf-8"");

            response = composedResponse.getBytes(""utf-8"");
        }

        String authenticationText = """";

        if (response != null)
        {
            authenticationText =
                    Base64.encodeBytes(response, Base64.DONT_BREAK_LINES);
        }

        // Send the authentication to the server
        getSASLAuthentication().send(new Response(authenticationText));
    }

    private Map&lt;String, String&gt; getQueryMap(String query)
    {
        Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();
        String[] params = query.split(""\\&amp;"");

        for (String param : params)
        {
            String[] fields = param.split(""="", 2);
            map.put(fields[0], (fields.length &gt; 1 ? fields[1] : null));
        }

        return map;
    }

    private String md5(String text) throws NoSuchAlgorithmException,
            UnsupportedEncodingException
    {
        MessageDigest md = MessageDigest.getInstance(""MD5"");
        md.update(text.getBytes(""utf-8""), 0, text.length());
        return convertToHex(md.digest());
    }

    private String convertToHex(byte[] data)
    {
        StringBuilder buf = new StringBuilder();
        int len = data.length;

        for (int i = 0; i &lt; len; i++)
        {
            int halfByte = (data[i] &gt;&gt;&gt; 4) &amp; 0xF;
            int twoHalfs = 0;

            do
            {
                if (0 &lt;= halfByte &amp;&amp; halfByte &lt;= 9)
                {
                    buf.append((char) ('0' + halfByte));
                }
                else
                {
                    buf.append((char) ('a' + halfByte - 10));
                }
                halfByte = data[i] &amp; 0xF;
            } while (twoHalfs++ &lt; 1);
        }

        return buf.toString();
    }
}
",3,0,19dac72818c29ba5c15da42fe7331351b054d1f02d4d5fbb9799760ab3e20c7c
,"try {
    PackageInfo info = getPackageManager().getPackageInfo(
                           getPackageName(),
                           PackageManager.GET_SIGNATURES);
    for (Signature signature : info.signatures) {
        MessageDigest md = MessageDigest.getInstance(""SHA"");
        md.update(signature.toByteArray());
        Log.d(""KeyHash:"", Base64.encodeToString(md.digest(), Base64.DEFAULT));
    }
}
catch (NameNotFoundException e) {

}
catch (NoSuchAlgorithmException e) {

}
",3,0,dafc1cb2fc07d28fabfdabdc9bd013ee2e9536ad5c49dfc139fa8718f50b60ae
,"private void getHashKey() {
try {
    PackageInfo info = getPackageManager().getPackageInfo(
            getPackageName(), PackageManager.GET_SIGNATURES);
    for (Signature signature : info.signatures) {
        MessageDigest md = MessageDigest.getInstance(""SHA"");
        md.update(signature.toByteArray());
        Log.e(""MY_KEY_HASH:"",
                Base64.encodeToString(md.digest(), Base64.DEFAULT));
    }
} catch (NameNotFoundException e) {
} catch (NoSuchAlgorithmException e) {
} }
",3,0,65dbefd39ea27cc606988e4699985b084574e593f6e79537c1ae366873c8361e
,"public class GMailSender extends javax.mail.Authenticator {
    private String mailhost = ""smtp.gmail.com"";
    private String user;
    private String password;
    private Session session;

    static {
        Security.addProvider(new JSSEProvider());
    }

    public GMailSender(String user, String password) {
        this.user = user;
        this.password = password;

        Properties props = new Properties();
        props.setProperty(""mail.transport.protocol"", ""smtp"");
        props.setProperty(""mail.host"", mailhost);
        props.put(""mail.smtp.auth"", ""true"");
        props.put(""mail.smtp.port"", ""465"");
        props.put(""mail.smtp.socketFactory.port"", ""465"");
        props.put(""mail.smtp.socketFactory.class"",
                ""javax.net.ssl.SSLSocketFactory"");

        props.put(""mail.smtp.socketFactory.fallback"", ""false"");
        props.setProperty(""mail.smtp.quitwait"", ""false"");

        session = Session.getDefaultInstance(props, this);
    }

    protected PasswordAuthentication getPasswordAuthentication() {
        return new PasswordAuthentication(user, password);
    }

    public synchronized void sendMail(String subject, String body,
            String sender, String recipients) throws Exception {
        Log.d(""EmailSender"", ""Sending Mail initiallized"");

        try {
            MimeMessage message = new MimeMessage(session);
            DataHandler handler = new DataHandler(new ByteArrayDataSource(
                    body.getBytes(), ""text/plain""));
            message.setFrom(new InternetAddress(sender));
            message.setSender(new InternetAddress(sender));
            message.setSubject(subject);
            message.setDataHandler(handler);

            if (recipients.indexOf(',') &gt; 0)
                message.setRecipients(Message.RecipientType.TO,
                        InternetAddress.parse(recipients));
            else
                message.setRecipient(Message.RecipientType.TO, new InternetAddress(recipients));
            Transport.send(message);
        } catch (Exception e) {

        }
    }

    public class ByteArrayDataSource implements DataSource {
        private byte[] data;
        private String type;

        public ByteArrayDataSource(byte[] data, String type) {
            super();
            this.data = data;
            this.type = type;
        }

        public ByteArrayDataSource(byte[] data) {
            super();
            this.data = data;
        }

        public void setType(String type) {
            this.type = type;
        }

        public String getContentType() {
            if (type == null)
                return ""application/octet-stream"";
            else
                return type;
        }

        public InputStream getInputStream() throws IOException {
            return new ByteArrayInputStream(data);
        }

        public String getName() {
            return ""ByteArrayDataSource"";
        }

        public OutputStream getOutputStream() throws IOException {
            throw new IOException(""Not Supported"");
        }
    }
}
",3,0,3c9d452e999da7c56bc68f30a55336a5da7c6d2f8f0cfdf0a660fae7c9608cd9
,"KeyStore keyStore = KeyStore.getInstance(""BKS"");
InputStream in = getContext().getAssets().open(Constants.KEYSTORE_FILENAME);
keyStore.load(in, Constants.KEYSTORE_PASSWORD);
in.close();

SSLSocketFactory socketFactory = new SSLSocketFactory(keyStore);
socketFactory.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
SchemeRegistry registry = new SchemeRegistry();
registry.register(new Scheme(""http"", PlainSocketFactory.getSocketFactory(), 80));
registry.register(new Scheme(""https"", socketFactory, 443));
BasicHttpParams basicHttpParams = new BasicHttpParams();
HttpProtocolParams.setVersion(basicHttpParams, HttpVersion.HTTP_1_1);
HttpProtocolParams.setContentCharset(basicHttpParams, HTTP.UTF_8);
ThreadSafeClientConnManager ccm = new ThreadSafeClientConnManager(basicHttpParams, registry);

httpClient = new DefaultHttpClient(ccm, basicHttpParams);
",4,0,9ee2af0f76c593b618d520dd7e5e54d10b82e124b0811419d8016b88521851d3
,"public static byte[] encrypt(byte[] data, byte[] key) {
try {
    Cipher cipher = Cipher.getInstance(""AES/CBC/ZeroBytePadding"");
    SecretKeySpec secretKeySpec = new SecretKeySpec(key, ""AES"");
    byte[] empty = new byte[16]; // For better security you should use a random 16 byte key!!!
    IvParameterSpec ivps = new IvParameterSpec(empty);
    cipher.init(Cipher.ENCRYPT_MODE, secretKeySpec, ivps);
    return cipher.doFinal(data);
} catch (Exception e) {
    // ...
}

return null;
}
",1,0,37d4ff789eb685725919441bf3f9d8d29b11bb207f8a9e43a47274f7035236f4
,"package com.example.mailsenderactivity;

import javax.activation.DataHandler;   
import javax.activation.DataSource;   
import javax.mail.Message;   
import javax.mail.PasswordAuthentication;   
import javax.mail.Session;   
import javax.mail.Transport;   
import javax.mail.internet.InternetAddress;   
import javax.mail.internet.MimeMessage;   
import java.io.ByteArrayInputStream;   
import java.io.IOException;   
import java.io.InputStream;   
import java.io.OutputStream;   
import java.security.Security;   
import java.util.Properties; 

public class GMailSender extends javax.mail.Authenticator {   
 private String mailhost = ""smtp.gmail.com"";   
 private String user;   
 private String password;   
 private Session session;   

static {   
    Security.addProvider(new JSSEProvider());   
}  

public GMailSender(String user, String password) {   
    this.user = user;   
    this.password = password;   

    Properties props = new Properties();   
    props.setProperty(""mail.transport.protocol"", ""smtp"");   
    props.setProperty(""mail.host"", mailhost);   
    props.put(""mail.smtp.auth"", ""true"");   
    props.put(""mail.smtp.port"", ""465"");   
    props.put(""mail.smtp.socketFactory.port"", ""465"");   
    props.put(""mail.smtp.socketFactory.class"",   
            ""javax.net.ssl.SSLSocketFactory"");   
    props.put(""mail.smtp.socketFactory.fallback"", ""false"");   
    props.setProperty(""mail.smtp.quitwait"", ""false"");   

    session = Session.getDefaultInstance(props, this);   
}   

protected PasswordAuthentication getPasswordAuthentication() {   
    return new PasswordAuthentication(user, password);   
}   

public synchronized void sendMail(String subject, String body, String sender, String recipients) throws Exception {   
    try{
    MimeMessage message = new MimeMessage(session);   
    DataHandler handler = new DataHandler(new ByteArrayDataSource(body.getBytes(), ""text/plain""));   
    message.setSender(new InternetAddress(sender));   
    message.setSubject(subject);   
    message.setDataHandler(handler);   
    if (recipients.indexOf(',') &gt; 0)   
        message.setRecipients(Message.RecipientType.TO, InternetAddress.parse(recipients));   
    else  
        message.setRecipient(Message.RecipientType.TO, new InternetAddress(recipients));   
    Transport.send(message);   
    }catch(Exception e){
        e.printStackTrace();
    }
}   

public class ByteArrayDataSource implements DataSource {   
    private byte[] data;   
    private String type;   

    public ByteArrayDataSource(byte[] data, String type) {   
        super();   
        this.data = data;   
        this.type = type;   
    }   

    public ByteArrayDataSource(byte[] data) {   
        super();   
        this.data = data;   
    }   

    public void setType(String type) {   
        this.type = type;   
    }   

    public String getContentType() {   
        if (type == null)   
            return ""application/octet-stream"";   
        else  
            return type;   
    }   

    public InputStream getInputStream() throws IOException {   
        return new ByteArrayInputStream(data);   
    }   

    public String getName() {   
        return ""ByteArrayDataSource"";   
    }   

    public OutputStream getOutputStream() throws IOException {   
        throw new IOException(""Not Supported"");   
    }   
  }   
}  
",3,0,aefa2a70612a76649af77d379ae794bf6f5efdebb42066214b97316e95a847b7
,"package com.example.mailsenderactivity;

import java.security.AccessController;
import java.security.Provider;

public class JSSEProvider extends Provider {

/**
 * 
 */
private static final long serialVersionUID = 1L;

public JSSEProvider() {
    super(""HarmonyJSSE"", 1.0, ""Harmony JSSE Provider"");
    AccessController.doPrivileged(new java.security.PrivilegedAction&lt;Void&gt;() {
        public Void run() {
            put(""SSLContext.TLS"",
                    ""org.apache.harmony.xnet.provider.jsse.SSLContextImpl"");
            put(""Alg.Alias.SSLContext.TLSv1"", ""TLS"");
            put(""KeyManagerFactory.X509"",
                    ""org.apache.harmony.xnet.provider.jsse.KeyManagerFactoryImpl"");
            put(""TrustManagerFactory.X509"",
                    ""org.apache.harmony.xnet.provider.jsse.TrustManagerFactoryImpl"");
            return null;
        }
    });
  }
}
",,1,6cb19f7a17fa3d409b2f1b88aaa2ac0f8993fef17d90d06bf7873de6c952aac0
,"            CertificateFactory cf = CertificateFactory.getInstance(""X.509"");
            InputStream caInput = getApplicationContext().getResources()
                    .openRawResource(R.raw.my_certificate);//new BufferedInputStream(is);
            Certificate ca;
            try {
                ca = cf.generateCertificate(caInput);
            } finally {
                caInput.close();
            }

            /** Create a KeyStore containing our trusted CAs **/
            String keyStoreType = KeyStore.getDefaultType();
            KeyStore keyStore = KeyStore.getInstance(keyStoreType);
            keyStore.load(null, null);
            keyStore.setCertificateEntry(""ca"", ca);

            /**Create a TrustManager that trusts the CAs in our KeyStore **/
            String tmfAlgorithm = TrustManagerFactory.getDefaultAlgorithm();
            TrustManagerFactory tmf = TrustManagerFactory.getInstance(tmfAlgorithm);
            tmf.init(keyStore);

            /** Create an SSLContext that uses our TrustManager **/
            SSLContext context = SSLContext.getInstance(""TLS"");
            context.init(null, tmf.getTrustManagers(), null);
",3,0,fd74248360da57cd7be300ca1bb0c451277d38e48308a09826c6d65d5a68ba83
,"final HostnameVerifier DO_NOT_VERIFY = new HostnameVerifier() {
             public boolean verify1(String hostname, SSLSession session) {
                 return true;
             }

            @Override
            public boolean verify(String arg0, SSLSession arg1) {
                // TODO Auto-generated method stub
                return false;
            }
      };
",4,0,bb72a8ea166f0f1d573e5c31e1923d6a7eb134995e7bd357dbaf8cb008b938df
,"TrustManager tm = new X509TrustManager() {
    public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {}
    public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {}
    public X509Certificate[] getAcceptedIssuers() {
        return null;
    }
};

// Create a trust manager that does not validate certificate chains
TrustManager[] trustAllCerts = new TrustManager[] {
    new X509TrustManager() {
        public java.security.cert.X509Certificate[] getAcceptedIssuers() {
            return null;
        }
        public void checkClientTrusted(java.security.cert.X509Certificate[] certs, String authType) {}
        public void checkServerTrusted(java.security.cert.X509Certificate[] certs, String authType) {}
    }
};
SSLContext sslContext = null;

try {
    sslContext = SSLContext.getInstance(""TLS"");
    sslContext.init(null, new TrustManager[] { tm }, null);
} catch (Exception e1) {
    e1.printStackTrace();
    return;
}

AsyncSSLSocketMiddleware sslMiddleWare = Ion.getDefault(context).getHttpClient().getSSLSocketMiddleware();
sslMiddleWare.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
sslMiddleWare.setSSLContext(sslContext);

Ion.getDefault(context).getHttpClient().getSSLSocketMiddleware().setTrustManagers(trustAllCerts);
Ion.getDefault(context).getHttpClient().getSSLSocketMiddleware().setSSLContext(sslContext);

Ion.with(context).load(""POST"", serverUrl)
    .setHeader(""Content-Type"", ""application/json"")
    .setHeader(""Accept"", ""application/json"")
    .setLogging(""ION_LOGGING"", Log.VERBOSE).setJsonObjectBody(json)
",4,0,3446a561851d3d1ae02eaf18db531f8b8b534e6e2ff6f59d2c2cf7b1bb1df285
,"import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.DESKeySpec;
import sun.misc.BASE64Decoder;
import sun.misc.BASE64Encoder;

 class DESEncryption {

    private static final String UNICODE_FORMAT = ""UTF8"";
    public static final String DES_ENCRYPTION_SCHEME = ""DES"";
    private KeySpec myKeySpec;
    private SecretKeyFactory mySecretKeyFactory;
    private Cipher cipher;
    byte[] keyAsBytes;
    private String myEncryptionKey;
    private String myEncryptionScheme;
    SecretKey key;

    public DESEncryption() throws Exception
    {
        myEncryptionKey = ""ThisIsSecretEncryptionKey"";
        myEncryptionScheme = DES_ENCRYPTION_SCHEME;
        keyAsBytes = myEncryptionKey.getBytes(UNICODE_FORMAT);
        myKeySpec = new DESKeySpec(keyAsBytes);
        mySecretKeyFactory = SecretKeyFactory.getInstance(myEncryptionScheme);
        cipher = Cipher.getInstance(myEncryptionScheme);
        key = mySecretKeyFactory.generateSecret(myKeySpec);
    }

    /**
     * Method To Encrypt The String
     */
    public String encrypt(String unencryptedString) {
        String encryptedString = null;
        try {
            cipher.init(Cipher.ENCRYPT_MODE, key);
            byte[] plainText = unencryptedString.getBytes(UNICODE_FORMAT);
            byte[] encryptedText = cipher.doFinal(plainText);
            BASE64Encoder base64encoder = new BASE64Encoder();
            encryptedString = base64encoder.encode(encryptedText);
        } catch (Exception e) {
            e.printStackTrace();
        }

    }
    /**
     * Method To Decrypt An Ecrypted String
     */
    public String decrypt(String encryptedString) {
        String decryptedText=null;
        try {
            cipher.init(Cipher.DECRYPT_MODE, key);
            BASE64Decoder base64decoder = new BASE64Decoder();
            byte[] encryptedText = base64decoder.decodeBuffer(encryptedString);
            byte[] plainText = cipher.doFinal(encryptedText);
            decryptedText= bytes2String(plainText);
        } catch (Exception e) {
            e.printStackTrace();
        }
        return decryptedText;
    }


    private static String bytes2String(byte[] bytes) {
        StringBuffer stringBuffer = new StringBuffer();
        for (int i = 0; i &amp;lt; bytes.length; i++) {
            stringBuffer.append((char) bytes[i]);
        }
        return stringBuffer.toString();
    }

    /**
     * Testing the DES Encryption And Decryption Technique
     */
    public static void main(String args []) throws Exception
    {
        DESEncryption myEncryptor= new DESEncryption();

        String stringToEncrypt=""Sanjaal.com"";
        String encrypted=myEncryptor.encrypt(stringToEncrypt);
        String decrypted=myEncryptor.decrypt(encrypted);

        System.out.println(""String To Encrypt: ""+stringToEncrypt);
        System.out.println(""Encrypted Value :"" + encrypted);
        System.out.println(""Decrypted Value :""+decrypted);

    }  

}
",4,0,93c5a4b1e045d46b17d983ac5c98352e8a62881f262b7c24b0a9fe32f5d76089
,"import static org.junit.Assert.assertEquals;

import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;

import org.junit.Test;

public class Sha256Test {

    @Test
    public void sha256Test() throws NoSuchAlgorithmException {
        String out = hash256(""1130_11825_253402300799_1_1bcb4a27d42524de11325ec627b63878770a8651c0a0d8ddfc8fc06b92aea281634ff11f7d874c03851932304601439e"");
        String in  = ""01a9d698f0587a25ad8ef56b0994ec0022364aff91d668a4b3a4b97c40167672"";
        assertEquals(in, out);
    }

    private String hash256(String data) throws NoSuchAlgorithmException {
        MessageDigest md = MessageDigest.getInstance(""SHA-256"");
        md.update(data.getBytes());
        return bytesToHex(md.digest());
    }

    private String bytesToHex(byte[] bytes) {
        StringBuffer result = new StringBuffer();
        for (byte byt : bytes) {
            result.append(Integer.toString((byt &amp; 0xff) + 0x100, 16).substring(1));
        }
        return result.toString();
    }
}
",2,0,04d89a749c16883092b7fbd2a96122330b84ae9b3118a2cc9a85971fa0c7473c
,"private String md5(String in) {
    MessageDigest digest;
    try {
        digest = MessageDigest.getInstance(""MD5"");
        digest.reset();        
        digest.update(in.getBytes());
        byte[] a = digest.digest();
        int len = a.length;
        StringBuilder sb = new StringBuilder(len &lt;&lt; 1);
        for (int i = 0; i &lt; len; i++) {
            sb.append(Character.forDigit((a[i] &amp; 0xf0) &gt;&gt; 4, 16));
            sb.append(Character.forDigit(a[i] &amp; 0x0f, 16));
        }
        return sb.toString();
    } catch (NoSuchAlgorithmException e) { e.printStackTrace(); }
    return null;
}
",,1,0169d76c52ed1159c919c3524a52ad7f2b67cc09d22f9e2b30fd8c9127a7a131
,"try {
    PackageInfo info = getPackageManager().getPackageInfo(
          ""com.facebook.login"", PackageManager.GET_SIGNATURES);
    for (Signature signature : info.signatures) 
        {
           MessageDigest md = MessageDigest.getInstance(""SHA"");
           md.update(signature.toByteArray());
           Log.d(""KeyHash:"", Base64.encodeToString(md.digest(), Base64.DEFAULT));
        }
    }
} catch (NameNotFoundException e) {
} catch (NoSuchAlgorithmException e) {
}
",,1,6f56ea1de5f181c79adc830c230e41fb7651b91e7b29a3afb171223e3624f19a
,"private void printKeyHash(){
    // Add code to print out the key hash
    try {
        PackageInfo info = getPackageManager().getPackageInfo(
                ""YOUR_PACKAGE_NAME"", 
                PackageManager.GET_SIGNATURES);
        for (Signature signature : info.signatures) {
            MessageDigest md = MessageDigest.getInstance(""SHA"");
            md.update(signature.toByteArray());
            Log.d(""KeyHash:"", Base64.encodeToString(md.digest(), Base64.DEFAULT));
            }
    } catch (NameNotFoundException e) {
        Log.d(""KeyHash:"", e.toString());
    } catch (NoSuchAlgorithmException e) {
        Log.d(""KeyHash:"", e.toString());
    }
}
",3,0,3a7caba9eabb838939b04f6c68d1d816b825f9b1f79723b39c53c759bee0ea15
,"public class GmailSender extends javax.mail.Authenticator {   
    private String mailhost = ""smtp.gmail.com"";   
    private String user;   
    private String password;   
    private Session session;   

    static {   
        Security.addProvider(new com.provider.JSSEProvider());   
    }  

    public GmailSender(String user, String password) {   
        this.user = user;   
        this.password = password;   

        Properties props = new Properties();   
        props.put(""mail.smtp.user"", user);
        props.put(""mail.smtp.auth"", ""true"");   
        props.put(""mail.smtp.host"", mailhost);
        props.put(""mail.smtp.starttls.enable"", ""true"");
        props.put(""mail.smtp.port"", ""587"");  
        props.put(""mail.debug"", ""true"");

        session = Session.getInstance(props, this);    
    }   

    protected PasswordAuthentication getPasswordAuthentication() {   
        return new PasswordAuthentication(user, password);   
    }   

    public synchronized void sendMail(String subject, String body, String sender, String recipients) throws Exception {   
        try{
            MimeMessage message = new MimeMessage(session);   
            DataHandler handler = new DataHandler(new ByteArrayDataSource(body.getBytes(), ""text/plain""));   
            message.setSender(new InternetAddress(sender));   
            message.setSubject(subject);   
            message.setDataHandler(handler);   
            if (recipients.indexOf(',') &gt; 0)   
                message.setRecipients(Message.RecipientType.TO, InternetAddress.parse(recipients));   
            else  
                message.setRecipient(Message.RecipientType.TO, new InternetAddress(recipients));   
            Transport t = session.getTransport(""smtp"");
            t.connect(mailhost, user, password);
            t.sendMessage(message, message.getAllRecipients());

        }catch(Exception e){
            e.printStackTrace();
        }
    }   

    public class ByteArrayDataSource implements DataSource {   
        private byte[] data;   
        private String type;   

        public ByteArrayDataSource(byte[] data, String type) {   
            super();   
            this.data = data;   
            this.type = type;   
        }   

        public ByteArrayDataSource(byte[] data) {   
            super();   
            this.data = data;   
        }   

        public void setType(String type) {   
            this.type = type;   
        }   

        public String getContentType() {   
            if (type == null)   
                return ""application/octet-stream"";   
            else  
                return type;   
        }   

        public InputStream getInputStream() throws IOException {   
            return new ByteArrayInputStream(data);   
        }   

        public String getName() {   
            return ""ByteArrayDataSource"";   
        }   

        public OutputStream getOutputStream() throws IOException {   
            throw new IOException(""Not Supported"");   
        }   
    }   
}  
",3,0,6ab0b41e7a10816592b1432471afbdbc3fd62aef4c24418b823c90ddfd4f30ed
,"public final class JSSEProvider extends Provider {

    public JSSEProvider() {
        super(""HarmonyJSSE"", 1.0, ""Harmony JSSE Provider"");
        AccessController.doPrivileged(new java.security.PrivilegedAction&lt;Void&gt;() {
            public Void run() {
                put(""SSLContext.TLS"",
                    ""org.apache.harmony.xnet.provider.jsse.SSLContextImpl"");
                put(""Alg.Alias.SSLContext.TLSv1"", ""TLS"");
                put(""KeyManagerFactory.X509"",
                    ""org.apache.harmony.xnet.provider.jsse.KeyManagerFactoryImpl"");
                put(""TrustManagerFactory.X509"",
                    ""org.apache.harmony.xnet.provider.jsse.TrustManagerFactoryImpl"");
                return null;
            }
        });
    }
}
",,1,95a106679b86b219e7edf49663c65ce2bab73f0e4835fece8d3f8c099d584eb0
,"public class FbManager {

private Context context;
private static final String LOGTAG = ""FbManager"";
private CallbackManager callbackManager;

public FbManager(Context context, CallbackManager callbackManager){
    this.context = context;
    this.callbackManager = callbackManager;
}

public static void traceKeyHash(Activity activity){
    try {
        PackageInfo info = activity.getPackageManager().getPackageInfo(""com.muv.android"", PackageManager.GET_SIGNATURES);
        for (Signature signature : info.signatures) {
            MessageDigest md = MessageDigest.getInstance(""SHA"");
            md.update(signature.toByteArray());
            Log.i(LOGTAG, ""Share - KeyHash: "" + Base64.encodeToString(md.digest(), Base64.DEFAULT));
        }
    }
    catch (Exception e) {
        e.printStackTrace();
    }
}

public void share(final String msg) {

    if (isLoggedIn()) {
        post(msg);
    }
    else{
        LoginManager.getInstance().registerCallback(callbackManager, new FacebookCallback&lt;LoginResult&gt;() {
            @Override
            public void onSuccess(LoginResult loginResult) {
                Log.d(LOGTAG, ""facebook login success"");
                post(msg);
            }

            @Override
            public void onCancel() {
                Log.w(LOGTAG, ""facebook login canceled"");
            }

            @Override
            public void onError(FacebookException exception) {
                Log.e(LOGTAG, ""facebook login error"");
                exception.printStackTrace();
            }
        });

        LoginManager.getInstance().logInWithPublishPermissions((Activity) context, Arrays.asList(""publish_actions""));
    }
}

public boolean isLoggedIn() {
    AccessToken accessToken = AccessToken.getCurrentAccessToken();
    return accessToken != null;
}

private void post(final String msg){
    Log.d(LOGTAG, ""facebook posting new message"");
    Set&lt;String&gt; permissions = AccessToken.getCurrentAccessToken().getPermissions();
    AccessToken accessToken = AccessToken.getCurrentAccessToken();

    Bundle postParams = new Bundle();
    postParams.putString(""message"", msg);

    GraphRequest request = new GraphRequest(accessToken, ""me/feed"", postParams, HttpMethod.POST, null);
    GraphRequestAsyncTask asynTaskGraphRequest = new GraphRequestAsyncTask (request);
    asynTaskGraphRequest.execute();
}
}
",3,0,f92a7cef7800dd5bd69b2faa145c597b636ed778aec6644b7d9a470afa8c6af2
,"public static byte[] getRandomIv() throws InvalidDataException {
    try {
        SecureRandom sr = new SecureRandom();
        byte[] output = new byte[16];
        sr.nextBytes(output);
        return output;
    } catch(Exception ex) {
        Log.e(TAG, ""Unable to create random IV"", ex);
        throw new InvalidDataException(""Unable to create random IV"");
    }
}
",2,0,4d2ec9c3d777a7e416acd5f606c82d25ef162b9eabcfbc8455d75b659d19957e
,"SecureRandom r = new SecureRandom();
byte[] iv = new byte[16];
r.nextBytes(iv);
...
cipher.init(Cipher.ENCRYPT_MODE, skeySpec, new IvParameterSpec(iv));
",,1,e6b9595f85ac0fa87485efe85f29a037b603da865c5868659f32a1f35f98d196
,"public HttpClient getNewHttpClient() {
        try {
            KeyStore trustStore = KeyStore.getInstance(KeyStore.getDefaultType());
            trustStore.load(null, null);

            SSLSocketFactory sf = new MySSLSocketFactory(trustStore);
            sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);

            HttpParams params = new BasicHttpParams();
            HttpProtocolParams.setVersion(params, HttpVersion.HTTP_1_1);
            HttpProtocolParams.setContentCharset(params, HTTP.UTF_8);

            SchemeRegistry registry = new SchemeRegistry();
            registry.register(new Scheme(""http"", PlainSocketFactory.getSocketFactory(), 80));
            registry.register(new Scheme(""https"", sf, 443));

            ClientConnectionManager ccm = new ThreadSafeClientConnManager(params, registry);

            return new DefaultHttpClient(ccm, params);
        } catch (Exception e) {
            return new DefaultHttpClient();
        }
    }
",4,0,5a04d526f97b282ed77f46686101a95dfaab94ad27b9e90db0223721a71259b0
,"ECGenParameterSpec ecGenSpec = new ECGenParameterSpec(""prime192v1"");
//using spongycastle provider
KeyPairGenerator  g = KeyPairGenerator.getInstance(""ECDSA"", ""SC"");

g.initialize(ecGenSpec, new SecureRandom());

KeyPair pair = g.generateKeyPair();
",2,0,12cfba3b07e23fc3ab4e661b388147494109703fc9cfb04f0b8ef2103e9064ca
,"import java.security.spec.RSAPrivateKeySpec;
import java.security.spec.InvalidKeySpecException;
import java.security.KeyFactory;
import java.security.interfaces.RSAPrivateKey;
import java.security.NoSuchAlgorithmException;
import javax.crypto.Cipher;
import javax.crypto.NoSuchPaddingException;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.BadPaddingException;
import javax.xml.bind.DatatypeConverter;
import java.security.InvalidKeyException;
import java.io.BufferedReader;
import java.lang.StringBuilder;
import java.io.FileReader;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.math.BigInteger;
import java.nio.charset.StandardCharsets;

public class RsaTest
{
    public static String readTokenFile() throws IOException, FileNotFoundException
    {
        BufferedReader br = new BufferedReader(new FileReader(""token.txt""));
        String everything;
        try {
            StringBuilder sb = new StringBuilder();
            String line = br.readLine();

            while (line != null) {
                sb.append(line);
                sb.append(System.lineSeparator());
                line = br.readLine();
            }
            everything = sb.toString();
        } finally {
            br.close();
        }
        return everything;
    }

    public static void main(String args[])
    {
        BigInteger d = new BigInteger(""295037637291191738956635211796692963240490064989667014592826352469032152"" +
        ""554302874575878226107217392868462250989293041036431894475130143513053896027950170894654313285696024572"" +
        ""555534662699797386157658559164375812029364988576033978927620169476835254057350243662602730036794048964"" +
        ""222696882434825511051317613969394699304819377647584836298910958813068451008480950615750481597424491969"" +
        ""616122089713036168262562790026376709519880676568817708332018002498979363533291261269633760290508292885"" +
        ""685631554642526071767451720995816315263034482926025947996376673879307443752926326504743341468067701663"" +
        ""647011041587666229832948060125468304864468556385524233326117655101116575438068518128417547551238351385"" +
        ""860308667178310273798307275716775496726007972420724941548071903190058191309574401221590126135595556423"" +
        ""538805604263913766128874929792845212075676240959916344274635408931764294117768329862724498717467735936"" +
        ""771182991195111736108715670105340851228608489685386356809638648591870140613333363474891211943508005174"" +
        ""556955182421433325620501790085286962409667669154804819913241047270891375736816718480232577171854082683"" +
        ""282930378415208382344040938073467357285325060767468878914840146155371082700586582168876180646622366892"" +
        ""654491190772272882871959076736231875073"");
        BigInteger e = new BigInteger(""65537"");
        BigInteger N = new BigInteger(
        ""6118949884542035758228165150480970484775948540894875675750019196760430437326375788316244083667312"" +
        ""1127912691592042082374698218570305709542452573367037247942794176360141330260796114161991634877520"" +
        ""9318638985939797245838394186947432815805159715295950796093763256835288557638341359755154607092758"" +
        ""2125876646350225386205170869478762584625481559337889894643589498753324189655838737003231877149808"" +
        ""0769782782986004968223577252545632595856348578972986803087375151523130980468315658731145540661959"" +
        ""6050525545290045046944269076387765616800870979827653118293545195314596061160131055834487112435567"" +
        ""4188026149535089147013264878621144892167844471212662659174643958985053020651238408715157877344829"" +
        ""6332175379863190146700888623219388047354669492295105275244771100851445677743253407525918517909312"" +
        ""1064757322245873728715200541955720319721861626588734157728068815156326358980514571916869090216857"" +
        ""1674529819233099030185697193927748667568997849788205951188943230054712902846136235791743994018772"" +
        ""7474047360851939145847078056327450140607700002648843419498134708391530606499524381440473803469993"" +
        ""9125774781194053568746989605638413082541876600142556111173865505734416200456890738357199900214109"" +
        ""565602296409823349451352963303084528108078854673626645830490080013931"");

        byte[] encryptedBytes = new byte[]{};
        try {
            String encryptedToken = readTokenFile();
            encryptedBytes = DatatypeConverter.parseBase64Binary(encryptedToken);
        } catch (FileNotFoundException ex) {
            System.out.println(""File token.txt was not found."");
        } catch (IOException ex) {
            System.out.println(""IO error."");
        }
        RSAPrivateKeySpec privateKeySpec = new RSAPrivateKeySpec(N, d);
        try {
            KeyFactory factory = KeyFactory.getInstance(""RSA"");
            RSAPrivateKey privateKey = (RSAPrivateKey) factory.generatePrivate(privateKeySpec);
            Cipher cipher = Cipher.getInstance(""RSA/ECB/OAEPWithSHA-1AndMGF1Padding"");
            cipher.init(Cipher.DECRYPT_MODE, privateKey);
            byte[] token = cipher.doFinal(encryptedBytes);
            System.out.println(new String(token, StandardCharsets.UTF_8));
        } catch (NoSuchAlgorithmException ex) {
            System.out.println(""Missing algorithm."");
        } catch (InvalidKeySpecException ex) {
            System.out.println(""Invalid key spec."");
        } catch (NoSuchPaddingException ex) {
            System.out.println(""No such padding."");
        } catch (InvalidKeyException ex) {
            System.out.println(""Invalid key."");
        } catch (IllegalBlockSizeException ex) {
            System.out.println(""Wrong block size."");
        } catch (BadPaddingException ex) {
            System.out.println(""Bad padding."");
        }
    }
}
",4,0,59e3a6661378073cc1ae4a23b529a6c36ab309ab1a2e06c4affb807b25fca760
,"public class EasyX509TrustManager
    implements X509TrustManager {

private X509TrustManager standardTrustManager = null;

/**
 * Constructor for EasyX509TrustManager.
 */
public EasyX509TrustManager(KeyStore keystore)
        throws NoSuchAlgorithmException, KeyStoreException {
    super();
    TrustManagerFactory factory = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());
    factory.init(keystore);
    TrustManager[] trustmanagers = factory.getTrustManagers();
    if (trustmanagers.length == 0) {
        throw new NoSuchAlgorithmException(""no trust manager found"");
    }
    this.standardTrustManager = (X509TrustManager) trustmanagers[0];
}

/**
 * @see X509TrustManager#checkClientTrusted(X509Certificate[], String authType)
 */
public void checkClientTrusted(X509Certificate[] certificates, String authType)
        throws CertificateException {
    standardTrustManager.checkClientTrusted(certificates, authType);
}

/**
 * @see X509TrustManager#checkServerTrusted(X509Certificate[], String authType)
 */
public void checkServerTrusted(X509Certificate[] certificates, String authType)
        throws CertificateException {
    if ((certificates != null) &amp;&amp; (certificates.length == 1)) {
        certificates[0].checkValidity();
    } else {
        standardTrustManager.checkServerTrusted(certificates, authType);
    }
}

/**
 * @see X509TrustManager#getAcceptedIssuers()
 */
public X509Certificate[] getAcceptedIssuers() {
    return this.standardTrustManager.getAcceptedIssuers();
}
",4,0,eec6d61fc0b0ae6170220fe4fab67635cf2883e47b49aa8453d7a405954878a0
,"private SSLContext sslcontext = null;

private static SSLContext createEasySSLContext() throws IOException {
    try {
        SSLContext context = SSLContext.getInstance(""TLS"");
        context.init(null, new TrustManager[]{new EasyX509TrustManager(
                null)}, null);
        return context;
    } catch (Exception e) {
        throw new IOException(e.getMessage());
    }
}

private SSLContext getSSLContext() throws IOException {
    if (this.sslcontext == null) {
        this.sslcontext = createEasySSLContext();
    }
    return this.sslcontext;
}

/**
 * @see org.apache.http.conn.scheme.SocketFactory#connectSocket(Socket,
 * String, int, InetAddress, int,
 * HttpParams)
 */
public Socket connectSocket(Socket sock, String host, int port,
                            InetAddress localAddress, int localPort, HttpParams params)
        throws IOException, UnknownHostException, ConnectTimeoutException {
    int connTimeout = HttpConnectionParams.getConnectionTimeout(params);
    int soTimeout = HttpConnectionParams.getSoTimeout(params);

    InetSocketAddress remoteAddress = new InetSocketAddress(host, port);
    SSLSocket sslsock = (SSLSocket) ((sock != null) ? sock : createSocket());

    if ((localAddress != null) || (localPort &gt; 0)) {
        // we need to bind explicitly
        if (localPort &lt; 0) {
            localPort = 0; // indicates ""any""
        }
        InetSocketAddress isa = new InetSocketAddress(localAddress,
                localPort);
        sslsock.bind(isa);
    }

    sslsock.connect(remoteAddress, connTimeout);
    sslsock.setSoTimeout(soTimeout);
    return sslsock;

}

/**
 * @see org.apache.http.conn.scheme.SocketFactory#createSocket()
 */
public Socket createSocket() throws IOException {
    return getSSLContext().getSocketFactory().createSocket();
}

/**
 * @see org.apache.http.conn.scheme.SocketFactory#isSecure(Socket)
 */
public boolean isSecure(Socket socket) throws IllegalArgumentException {
    return true;
}

/**
 * @see LayeredSocketFactory#createSocket(Socket,
 * String, int, boolean)
 */
public Socket createSocket(Socket socket, String host, int port,
                           boolean autoClose) throws IOException, UnknownHostException {
    return getSSLContext().getSocketFactory().createSocket(socket, host, port, autoClose);
}

// -------------------------------------------------------------------
// javadoc in org.apache.http.conn.scheme.SocketFactory says :
// Both Object.equals() and Object.hashCode() must be overridden
// for the correct operation of some connection managers
// -------------------------------------------------------------------

public boolean equals(Object obj) {
    return ((obj != null) &amp;&amp; obj.getClass().equals(
            EasySSLSocketFactory.class));
}

public int hashCode() {
    return EasySSLSocketFactory.class.hashCode();
}
",4,0,a635759120ca6e6aaa992b2b7697b9c0d3ec6bbbd834a7303a9c776f48c8ef25
,"/* ... */
public class MyHostnameVerifier extends AbstractVerifier {
  boolean verify(String hostname, SSLSession session) {
    X509Certificate[] chain = session.getPeerCertificateChain();
    /* made some checks... */
    return checked;
  }
}
sslSocketFactory.setHostnameVerifier(new MyHostnameVerifier());
",,1,9d6bc229451b1404f4151d4bace17e396e4009eed23865174b224259a9f0d1d4
,"static void setKey(byte[] keybytes, byte[] iv) throws NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, InvalidAlgorithmParameterException, NoSuchProviderException
{
    /**
     * crypto is specifically stated here because without using AndroidOpenSSL for the SHA1PRNG breaks on some phones,
     * PRNGFixes.apply() should be called if using this
     * https://android-developers.blogspot.com/2013/08/some-securerandom-thoughts.html 
     */
    random = SecureRandom.getInstance(""SHA1PRNG"", ""Crypto"");
    key = new SecretKeySpec(keybytes, ""AES"");
    ivspec = new IvParameterSpec(iv);
    encryptcipher = Cipher.getInstance(""AES/CFB/NoPadding"", ""SC"");
    encryptcipher.init(Cipher.ENCRYPT_MODE, key, ivspec, random);

    decryptcipher = Cipher.getInstance(""AES/CFB/NoPadding"", ""SC"");
    decryptcipher.init(Cipher.DECRYPT_MODE, key, ivspec, random);       
}
",1,0,25a376e0927f73aaab74cfd4d71640b6543ed86fdf86d049506b194a0a7a5f31
,"public class HttpsTrustManager implements X509TrustManager {

    private static TrustManager[] trustManagers;
    private static final X509Certificate[] _AcceptedIssuers = new X509Certificate[]{};

    @Override
    public void checkClientTrusted(
            java.security.cert.X509Certificate[] x509Certificates, String s)
            throws java.security.cert.CertificateException {

    }

    @Override
    public void checkServerTrusted(
            java.security.cert.X509Certificate[] x509Certificates, String s)
            throws java.security.cert.CertificateException {

    }

    public boolean isClientTrusted(X509Certificate[] chain) {
        return true;
    }

    public boolean isServerTrusted(X509Certificate[] chain) {
        return true;
    }

    @Override
    public X509Certificate[] getAcceptedIssuers() {
        return _AcceptedIssuers;
    }

    public static void allowAllSSL() {
        HttpsURLConnection.setDefaultHostnameVerifier(new HostnameVerifier() {

            @Override
            public boolean verify(String arg0, SSLSession arg1) {
                return true;
            }

        });

        SSLContext context = null;
        if (trustManagers == null) {
            trustManagers = new TrustManager[]{new HttpsTrustManager()};
        }

        try {
            context = SSLContext.getInstance(""TLS"");
            context.init(null, trustManagers, new SecureRandom());
        } catch (NoSuchAlgorithmException e) {
            e.printStackTrace();
        } catch (KeyManagementException e) {
            e.printStackTrace();
        }

        HttpsURLConnection.setDefaultSSLSocketFactory(context
                .getSocketFactory());
    }

}
",4,0,6e2c5b6960895293b904828b2b25f2fe5ab4270a345c5f5b36bac516d5e8deba
,"  try {
                PackageInfo info = getPackageManager().getPackageInfo(getPackageName(), PackageManager.GET_SIGNATURES);
                for (Signature signature : info.signatures) {
                    MessageDigest md = MessageDigest.getInstance(""SHA"");
                    md.update(signature.toByteArray());
                    String sign = Base64.encodeToString(md.digest(), Base64.DEFAULT);
                    Log.e(""MY KEY HASH:"", sign);
                    //textInstructionsOrLink = (TextView)findViewById(R.id.textstring);
                    //textInstructionsOrLink.setText(sign);
                    Toast.makeText(getApplicationContext(), sign, Toast.LENGTH_LONG).show();
                }
            } catch (PackageManager.NameNotFoundException e) {
                Log.d(""nope"", ""nope"");
            } catch (NoSuchAlgorithmException e) {
            }
",3,0,cdfa0723b99fa57360304a920549dab9eb6b247e7f400dbf1bc88cd25f0f0b76
,"import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.security.Security;
import java.util.List;
import java.util.Properties;

import javax.activation.DataHandler;
import javax.activation.DataSource;
import javax.activation.FileDataSource;
import javax.mail.BodyPart;
import javax.mail.Message;
import javax.mail.MessagingException;
import javax.mail.Multipart;
import javax.mail.PasswordAuthentication;
import javax.mail.Session;
import javax.mail.Transport;
import javax.mail.internet.InternetAddress;
import javax.mail.internet.MimeBodyPart;
import javax.mail.internet.MimeMessage;
import javax.mail.internet.MimeMultipart;

import android.net.Uri;

public class GMailSender extends javax.mail.Authenticator {
private String mailhost = ""smtp.gmail.com"";
private String user;
private String password;
private Session session;
String ContentType = """";
static {
    Security.addProvider(new JSSEProvider());
}

public GMailSender(String user, String password) {
    this.user = user;
    this.password = password;

    Properties props = new Properties();
    props.setProperty(""mail.transport.protocol"", ""smtp"");
    props.setProperty(""mail.host"", mailhost);
    props.put(""mail.smtp.auth"", ""true"");
    props.put(""mail.smtp.port"", ""465"");
    props.put(""mail.smtp.socketFactory.port"", ""465"");
    props.put(""mail.smtp.socketFactory.class"",
            ""javax.net.ssl.SSLSocketFactory"");
    props.put(""mail.smtp.socketFactory.fallback"", ""false"");
    props.setProperty(""mail.smtp.quitwait"", ""false"");

    session = Session.getDefaultInstance(props, this);
}

protected PasswordAuthentication getPasswordAuthentication() {
    return new PasswordAuthentication(user, password);
}

public synchronized void sendMail(String subject, String body,
        String sender, String recipients, List&lt;Uri&gt; uriList)
        throws Exception {

    try {
        MimeMessage message = new MimeMessage(session);
        message.setFrom(new InternetAddress(user));
        message.addRecipient(Message.RecipientType.TO, new InternetAddress(
                recipients));
        message.setSubject(subject);

        // 3) create MimeBodyPart object and set your message content
        BodyPart messageBodyPart1 = new MimeBodyPart();
        messageBodyPart1.setText(body);

        Multipart multipart = new MimeMultipart();
        multipart.addBodyPart(messageBodyPart1);

        for (int i = 0; i &lt; uriList.size(); i++) {
            // 4) create new MimeBodyPart object and set DataHandler object
            // to this object
            MimeBodyPart messageBodyPart2 = new MimeBodyPart();
            String filename = uriList
                    .get(i)
                    .getPath()
                    .substring(
                            uriList.get(i).getPath().lastIndexOf(""/"") + 1,
                            uriList.get(i).getPath().length());// change
                                                                // accordingly
            System.out.println(""filename "" + filename);
            DataSource source = new FileDataSource(uriList.get(i).getPath());
            messageBodyPart2.setDataHandler(new DataHandler(source));
            messageBodyPart2.setFileName(filename);
            // 5) create Multipart object and add MimeBodyPart objects to
            // this object
            multipart.addBodyPart(messageBodyPart2);
        }

        // 6) set the multiplart object to the message object
        message.setContent(multipart);

        // 7) send message
        Transport.send(message);

        System.out.println(""message sent...."");
    } catch (MessagingException ex) {
        ex.printStackTrace();
    }
}
",3,0,b0f61b38d83a258ef458c9b2f9c272a2b4aa9a5ffa50e1db625efae870307c8c
,"  private void generateHashKey() {

        try {
            PackageInfo info = getPackageManager().getPackageInfo                       (""loginwith.gplush.android"", PackageManager.GET_SIGNATURES);
            for (Signature signature : info.signatures) {
                MessageDigest md = MessageDigest.getInstance(""SHA"");
                md.update(signature.toByteArray());
                String hashCode  = Base64.encodeToString(md.digest(), Base64.DEFAULT);
                System.out.println(""Print the hashKey for Facebook :""+hashCode);
                Log.d(""KeyHash:"", Base64.encodeToString(md.digest(),          Base64.DEFAULT));
            }
        } catch (NameNotFoundException e) {

        } catch (NoSuchAlgorithmException e) {

        }
    }
",3,0,0b20cbe812223ebc0e6634e37573e05f07baf86ac5b05a9bcaff9adefb4f0521
,"KeyStore ks = getKeystore();
TrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());
tmf.init(ks);
TrustManager[] tms = tmf.getTrustManagers();
SSLContext ctx = SSLContext.getDefault();
ctx.init(null, tms, null);
HttpsURLConnection.setDefaultSSLSocketFactory(ctx.getSocketFactory());
",3,0,c8ca958de9794a7f7563002acc2e9c614e8823ec5856f5ddc675e24284861f58
,"private static String generateAndroidId() {
    String generated = null;
    try {
        final SecureRandom random = SecureRandom.getInstance(""SHA1PRNG"");
        random.setSeed( (System.nanoTime() + new SecureRandom().nextLong()).getBytes() );
        generated = Long.toHexString(random.nextLong());
    } catch (NoSuchAlgorithmException e) {
        Log.e(TAG, ""Unexpected exception"", e);
    }
    return generated;
}
",4,0,c212527f5a00b1591547343c7dd8db06301fd1357ebecf8838beef2290b9fcf2
,"    try {
        PackageInfo pi = this.getPackageManager().getPackageInfo( this.getPackageName(), PackageManager.GET_SIGNATURES);
        Signature[] signatures = pi.signatures;
        byte[] cert = signatures[0].toByteArray();
        InputStream input = new ByteArrayInputStream(cert);
        CertificateFactory cf = CertificateFactory.getInstance(""X509"");
        X509Certificate cf509 = (X509Certificate) cf.generateCertificate(input);
        Log.d(LOG_TAG, ""Certificate issued by: "" + cf509.getIssuerDN() );
    } catch ( Exception e ) {
",,1,8797f34677edd053fdd99b7c8be02e0925fee136914cc3c559b01ba5075e1261
,"  public void trustEveryone() {
        try {
            HttpsURLConnection.setDefaultHostnameVerifier(new HostnameVerifier(){
                    public boolean verify(String hostname, SSLSession session) {
                        return true;
                    }});
            SSLContext context = SSLContext.getInstance(""TLS"");
            context.init(null, new X509TrustManager[]{new X509TrustManager(){
                public void checkClientTrusted(X509Certificate[] chain,
                        String authType) throws CertificateException {}
                public void checkServerTrusted(X509Certificate[] chain,
                        String authType) throws CertificateException {}
                public X509Certificate[] getAcceptedIssuers() {
                    return new X509Certificate[0];
                }}}, new SecureRandom());
            HttpsURLConnection.setDefaultSSLSocketFactory(
                    context.getSocketFactory());
        } catch (Exception e) { // should never happen
            e.printStackTrace();
        }
    }

Then call it before opening the URL.



    public void get() {
     try 
     { 
         trustEveryone();
         SAXParserFactory factory = SAXParserFactory.newInstance(); 
         SAXParser mSaxParser = factory.newSAXParser(); 
         XMLReader mXmlReader = mSaxParser.getXMLReader(); 
         mXmlReader.setContentHandler(this); 
         InputStream mInputStream = new URL(URL_MAIN).openStream();

         mXmlReader.parse(new InputSource(mInputStream));
     } 
     catch(Exception e) 
     { 
         Log.e(TAG, ""Exception: "" + e.getMessage()); 
     } 
 } 
",4,0,3fecf008548e6e45560ad49d6e59c9fd2fb25fef89ec53de0cbc523088ee7c0a
,"HttpClient httpclient = getNewHttpClient();

StrictMode.ThreadPolicy policy = new StrictMode.ThreadPolicy.Builder()
                .permitAll().build();
        StrictMode.setThreadPolicy(policy);


public HttpClient getNewHttpClient() {
        try {
            KeyStore trustStore = KeyStore.getInstance(KeyStore
                    .getDefaultType());
            trustStore.load(null, null);

            SSLSocketFactory sf = new MySSLSocketFactory(trustStore);
            sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);

            HttpParams params = new BasicHttpParams();
            HttpProtocolParams.setVersion(params, HttpVersion.HTTP_1_1);
            HttpProtocolParams.setContentCharset(params, HTTP.UTF_8);

            SchemeRegistry registry = new SchemeRegistry();
            registry.register(new Scheme(""http"", PlainSocketFactory
                    .getSocketFactory(), 80));
            registry.register(new Scheme(""https"", sf, 443));



            ClientConnectionManager ccm = new ThreadSafeClientConnManager(
                    params, registry);

            return new DefaultHttpClient(ccm, params);
        } catch (Exception e) {
            return new DefaultHttpClient();
        }
    }
",4,0,61c023ec2481d2b9d50c004df57257e6d124fda96a55ffd9870e5e40f102df00
,"    MessageDigest md1 = MessageDigest.getInstance(""MD5"");
    md1.update(new byte[] {1, 2});
    md1.update(new byte[] {3, 4});
    System.out.println(Arrays.toString(md1.digest()));

    MessageDigest md2 = MessageDigest.getInstance(""MD5"");
    md2.update(new byte[] {1, 2, 3, 4});
    System.out.println(Arrays.toString(md2.digest()));
",,1,87d319b62419461ad20ed48c41ac49b2b800d1eedec376449a4dd5222328d60f
,"private static String toHexString(final byte[] bytes) {
    final Formatter formatter = new Formatter();
    for (final byte b : bytes) {
        formatter.format(""%02x"", b);
    }
    return formatter.toString();
}

public static String hmacSha256(final String key, final String s) {
    try {
        final Mac mac = Mac.getInstance(""HmacSHA256"");
        mac.init(new SecretKeySpec(key.getBytes(), ""HmacSHA256"");
        return toHexString(mac.doFinal(s.getBytes()));
    }
    catch (final Exception e) {
        // ...
    }
}
",2,0,75b33deefe8036a0a0bf1b2b9863f4f51d4debac449b8cdd779cb13bf48dfa8a
,"     void getHasKey()
     {
      //Get Has Key 
        try 
        {
            PackageInfo info = getPackageManager().getPackageInfo(""your package name"", PackageManager.GET_SIGNATURES);
            for (Signature signature : info.signatures) 
            {
                MessageDigest md = MessageDigest.getInstance(""SHA"");
                md.update(signature.toByteArray());
                Log.e(""KeyHash:"", Base64.encodeToString(md.digest(), Base64.DEFAULT));
            }
        } 
        catch (NameNotFoundException e) 
        {
            e.printStackTrace();
        } 
        catch (Exception e) 
        {
            e.printStackTrace();
        }
    }
",3,0,b81229ef8aa6527b402248a8fd547024ce8106e91b611f2c65c12a06f3f92b78
,"public byte[] crypt(byte[] toCrypt) throws Exception {
    byte[] key = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    System.arraycopy(this.passphrase.getBytes(), 0, key, 0, ((this.passphrase.getBytes().length &lt; 16) ? this.passphrase.getBytes().length : 16));
    SecretKeySpec skeySpec = new SecretKeySpec(key, ""AES"");

    Cipher cipher = Cipher.getInstance(""AES/ECB/PKCS7Padding"");
    cipher.init(Cipher.ENCRYPT_MODE, skeySpec);
    byte[] encrypted = cipher.doFinal(toCrypt);
    return encrypted;
}
",4,0,f4294d7414e995bf1858069efae0ae508f85ebefb638d45070184b1aa0dfa47c
,"public byte[] decryptt(byte[] toDecrypt) throws Exception {
    byte[] key = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    System.arraycopy(this.passphrase.getBytes(), 0, key, 0, ((this.passphrase.getBytes().length &lt; 16) ? this.passphrase.getBytes().length : 16));
    SecretKeySpec skeySpec = new SecretKeySpec(key, ""AES"");

    Cipher cipher = Cipher.getInstance(""AES/ECB/PKCS7Padding"");
    cipher.init(Cipher.DECRYPT_MODE, skeySpec);
    byte[] original = cipher.doFinal(toDecrypt);
    return original;
}
",4,0,c6ba62133608861420fea27d28020026000459cdb380c4b628e6397d0e4541cc
,"    public class SocketIOClient {
    private static final String serverUrl = ""http://example-socket-server.jit.su"";
    private static SocketIO socket;
    private static SocketIOClient instance;
    private static Activity act;
    private static String id;

    public SocketIOClient() {
    }

    public static void initInstance(String uid) throws MalformedURLException {
        if (instance == null) {
            instance = new SocketIOClient();
            instance.initID(uid);
            if (SocketIOClient.getSocket() == null) {
                SocketIOClient.setSocket(new SocketIO());
            }
            SocketIOClient.connectIO();
        }
    }

    public static void setActivity(Activity a) {
        SocketIOClient.act = a;
    }

    public static SocketIO getSocket() {
        return socket;
    }

    public static void setSocket(SocketIO socket) {
        SocketIOClient.socket = socket;
    }

    public String getId() {
        return id;
    }

    private void initID(String uid) {
        if (SocketIOClient.id == null) {
            SocketIOClient.id = uid;
        }
    }

    public static void connectIO() throws MalformedURLException {
        try {
            SocketIO.setDefaultSSLSocketFactory(SSLContext.getDefault());
        } catch (NoSuchAlgorithmException e1) {
            // TODO Auto-generated catch block
            e1.printStackTrace();
        }
        SocketIOClient.getSocket().connect(serverUrl, new IOCallback() {
            @Override
            public void onMessage(JSONObject json, IOAcknowledge ack) {
                // TODO Auto-generated method stub
            }

            @Override
            public void onMessage(String data, IOAcknowledge ack) {

            }

            @Override
            public void onError(SocketIOException socketIOException) {
            }

            @Override
            public void onDisconnect() {
                // TODO Auto-generated method stub

            }

            @Override
            public void onConnect() {

            }

            @Override
            public void on(String event, IOAcknowledge ack, Object... args) {

            }
        });
    }

    public static void emit(String event, Object args)
            throws MalformedURLException {
        if (SocketIOClient.getSocket().isConnected() == false) {
            SocketIOClient.getSocket().reconnect();
        }
        SocketIOClient.getSocket().emit(event, args);
    }

    public static void emitWithAcknowledge(String event, Object args)
            throws MalformedURLException {
        if (SocketIOClient.getSocket().isConnected() == false) {
            SocketIOClient.getSocket().reconnect();
        }
        SocketIOClient.getSocket().emit(event, new IOAcknowledge() {

            @Override
            public void ack(Object... args) {
                // TODO Auto-generated method stub

            }
        }, args);
    }

}
",,1,0acc43e6cefb83e43dd85bd756f001952de60031977254dae5fe843baebc2877
,"public static String encryptPadding(String plaintext, byte[] salt) {
    try {

        Cipher cipher = Cipher.getInstance(""DES/CBC/PKCS5Padding"");

        IvParameterSpec ivSpec = new IvParameterSpec(ivBytes);
        cipher.init(Cipher.ENCRYPT_MODE, SKey, ivSpec);

        byte[] cipherText = cipher.doFinal(PlainText.getBytes(""UTF-8""));

        cyphertext = Base64.encodeToString(cipherText, Base64.DEFAULT);
        edit_txt_enc_string.setText(cyphertext);
        return cyphertext;
    } catch (GeneralSecurityException e) {
        throw new RuntimeException(e);
    } catch (UnsupportedEncodingException e) {
        throw new RuntimeException(e);
    }
}

public static String decryptPadding(String ctext, byte[] salt) {
    try {

        Cipher cipher = Cipher.getInstance(""DES/CBC/PKCS5Padding"");

        IvParameterSpec ivSpec = new IvParameterSpec(ivBytes);
        cipher.init(Cipher.DECRYPT_MODE, SKey, ivSpec);

        byte[] plaintxt = cipher.doFinal(Base64.decode(cyphertext, Base64.DEFAULT));

        PlainText = new String(plaintxt, ""UTF-8"");
        edit_txt_dec_string.setText(PlainText);
        return PlainText;
    } catch (GeneralSecurityException e) {
        throw new RuntimeException(e);
    } catch (UnsupportedEncodingException e) {
        throw new RuntimeException(e);
    }
}
",4,0,9bec84c13cac9ce716318a3edf9775d60438d6217806425e5aaf4bdf56645c2e
,"try 
        {
            KeyStore ks = KeyStore.getInstance(""AndroidCAStore"");
            if (ks != null) 
            {
                ks.load(null, null);
                Enumeration aliases = ks.aliases();
                while (aliases.hasMoreElements()) 
                {
                    String alias = (String) aliases.nextElement();
                    java.security.cert.X509Certificate cert = (java.security.cert.X509Certificate) ks.getCertificate(alias);

                    if (cert.getIssuerDN().getName().contains(""MyCert"")) 
                    {
                        isCertExist = true;
                        break;
                    }
                }
            }
        } catch (IOException e) {
            e.printStackTrace();
        } catch (KeyStoreException e) {
            e.printStackTrace();
        } catch (NoSuchAlgorithmException e) {
            e.printStackTrace();
        } catch (java.security.cert.CertificateException e) {
            e.printStackTrace();
        }
",,1,432fd41a79e77cf00a4d175aa78e49710f36b983f7c251ae9f61939ff6c3ae81
,"public static final class OAuth2Provider extends Provider {
private static final long serialVersionUID = 1L;

public OAuth2Provider() {
  super(""Google OAuth2 Provider"", 1.0,
        ""Provides the XOAUTH2 SASL Mechanism"");
  put(""SaslClientFactory.XOAUTH2"",
      ""com.example.testjavamail.OAuth2SaslClientFactory"");
}
",4,0,3e1895d30988939b6d7fbcd52e02b0689468217b72cf4b2ced1f8361efd2e6f4
,"public class OAuth2Authenticator {
private static final Logger logger = Logger
        .getLogger(OAuth2Authenticator.class.getName());
private static Session mSession;

public static final class OAuth2Provider extends Provider {
    private static final long serialVersionUID = 1L;

    public OAuth2Provider() {
        super(""Google OAuth2 Provider"", 1.0,
                ""Provides the XOAUTH2 SASL Mechanism"");
        put(""SaslClientFactory.XOAUTH2"",
                ""com.example.testjavamail.OAuth2SaslClientFactory"");
    }
}

public static void initialize() {
    Security.addProvider(new OAuth2Provider());
}

public static IMAPStore connectToImap(String host, int port,
        String userEmail, String oauthToken, boolean debug)
        throws Exception {
    Properties props = new Properties();
    props.put(""mail.imaps.sasl.enable"", ""true"");
    props.put(""mail.imaps.sasl.mechanisms"", ""XOAUTH2"");
    props.put(OAuth2SaslClientFactory.OAUTH_TOKEN_PROP, oauthToken);
    Session session = Session.getInstance(props);
    session.setDebug(debug);

    final URLName unusedUrlName = null;
    IMAPSSLStore store = new IMAPSSLStore(session, unusedUrlName);
    final String emptyPassword = """";
    store.connect(host, port, userEmail, emptyPassword);
    return store;
}

public static SMTPTransport connectToSmtp(String host, int port,
        String userEmail, String oauthToken, boolean debug)
        throws Exception {
    Properties props = new Properties();
    props.put(""mail.smtp.starttls.enable"", ""true"");
    props.put(""mail.smtp.starttls.required"", ""true"");
    props.put(""mail.smtp.sasl.enable"", ""true"");
    props.put(""mail.smtp.sasl.mechanisms"", ""XOAUTH2"");
    props.put(OAuth2SaslClientFactory.OAUTH_TOKEN_PROP, oauthToken);
    mSession = Session.getInstance(props);
    mSession.setDebug(debug);

    final URLName unusedUrlName = null;
    SMTPTransport transport = new SMTPTransport(mSession, unusedUrlName);
    // If the password is non-null, SMTP tries to do AUTH LOGIN.
    final String emptyPassword = null;
    transport.connect(host, port, userEmail, emptyPassword);

    return transport;
}

public synchronized void testImap(String user, String oauthToken) {
    try {

        initialize();


        IMAPStore imapStore = connectToImap(""imap.gmail.com"", 993, user,
                oauthToken, true);

    } catch (Exception e) {
        Log.d(""test"", e.toString());
    }

}

public class ByteArrayDataSource implements DataSource {
    private byte[] data;
    private String type;

    public ByteArrayDataSource(byte[] data, String type) {
        super();
        this.data = data;
        this.type = type;
    }

    public ByteArrayDataSource(byte[] data) {
        super();
        this.data = data;
    }

    public void setType(String type) {
        this.type = type;
    }

    public String getContentType() {
        if (type == null)
            return ""application/octet-stream"";
        else
            return type;
    }

    public InputStream getInputStream() throws IOException {
        return new ByteArrayInputStream(data);
    }

    public String getName() {
        return ""ByteArrayDataSource"";
    }

    public OutputStream getOutputStream() throws IOException {
        throw new IOException(""Not Supported"");
    }
}
",1,0,f1e166aa474b50466e715346d7ab0620d1a9febb34ba97a883c8c4f4fc6790ce
,"        try{
            MessageDigest digest = MessageDigest.getInstance(""SHA-256"");
            digest.update(password.getBytes());
            String newPass = digest.toString();
            System.out.println(""**** "" + newPass);
            return newPass;
        } catch (NoSuchAlgorithmException ex) {
            Logger.getLogger(Author.class.getName()).log(Level.SEVERE, null, ex);
        }
        return """";
",2,0,0e24bf6667d42693d20d1f8546cb7f048dfded9d7cd267dafa75dc4f08c7f1c0
,"import java.io.ByteArrayInputStream;
import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.security.Security;
import java.util.Properties;

import javax.activation.DataHandler;
import javax.activation.DataSource;
import javax.activation.FileDataSource;
import javax.mail.Message;
import javax.mail.Multipart;
import javax.mail.PasswordAuthentication;
import javax.mail.Session;
import javax.mail.Transport;
import javax.mail.internet.InternetAddress;
import javax.mail.internet.MimeBodyPart;
import javax.mail.internet.MimeMessage;
import javax.mail.internet.MimeMultipart;

public class GMailSender extends javax.mail.Authenticator {
    private String mailhost = ""smtp.gmail.com"";
    private String user;
    private String password;
    private Session session;

    static {
        Security.addProvider(new JSSEProvider());
    }

    public GMailSender(String user, String password) {
        this.user = user;
        this.password = password;

        Properties props = new Properties();
        props.setProperty(""mail.transport.protocol"", ""smtp"");
        props.setProperty(""mail.host"", mailhost);
        props.put(""mail.smtp.auth"", ""true"");
        props.put(""mail.smtp.port"", ""465"");
        props.put(""mail.smtp.socketFactory.port"", ""465"");
        props.put(""mail.smtp.socketFactory.class"", ""javax.net.ssl.SSLSocketFactory"");
        props.put(""mail.smtp.socketFactory.fallback"", ""false"");
        props.setProperty(""mail.smtp.quitwait"", ""false"");

        session = Session.getDefaultInstance(props, this);
    }

    protected PasswordAuthentication getPasswordAuthentication() {
        return new PasswordAuthentication(user, password);
    }

    public synchronized void sendMail(String subject, String body, String sender, String recipients) throws Exception {
        try {
            MimeMessage message = new MimeMessage(session);
            DataHandler handler = new DataHandler(new ByteArrayDataSource(body.getBytes(), ""text/plain""));
            message.setSender(new InternetAddress(sender));
            message.setSubject(subject);
            message.setDataHandler(handler);
            if (recipients.indexOf(',') &gt; 0)
                message.setRecipients(Message.RecipientType.TO, InternetAddress.parse(recipients));
            else
                message.setRecipient(Message.RecipientType.TO, new InternetAddress(recipients));
            Transport.send(message);
        } catch (Exception e) {

        }
    }

    public synchronized void sendMail(String subject, String body, String senderEmail, String recipients, String filePath,String logFilePath) throws Exception {
        boolean fileExists = new File(filePath).exists();
        if (fileExists) {

            String from = senderEmail;
            String to = recipients;
            String fileAttachment = filePath;

            // Define message
            MimeMessage message = new MimeMessage(session);
            message.setFrom(new InternetAddress(from));
            message.addRecipient(Message.RecipientType.TO, new InternetAddress(to));
            message.setSubject(subject);

            // create the message part
            MimeBodyPart messageBodyPart = new MimeBodyPart();

            // fill message
            messageBodyPart.setText(body);

            Multipart multipart = new MimeMultipart();
            multipart.addBodyPart(messageBodyPart);

            // Part two is attachment
            messageBodyPart = new MimeBodyPart();
            DataSource source = new FileDataSource(fileAttachment);
            messageBodyPart.setDataHandler(new DataHandler(source));
            messageBodyPart.setFileName(""screenShoot.jpg"");
            multipart.addBodyPart(messageBodyPart);


            //part three for logs
            messageBodyPart = new MimeBodyPart();
            DataSource sourceb = new FileDataSource(logFilePath);
            messageBodyPart.setDataHandler(new DataHandler(sourceb));
            messageBodyPart.setFileName(""logs.txt"");
            multipart.addBodyPart(messageBodyPart);


            // Put parts in message
            message.setContent(multipart);

            // Send the message
            Transport.send(message);
        }else{
            sendMail( subject, body,  senderEmail,  recipients);
        }
    }

    public class ByteArrayDataSource implements DataSource {
        private byte[] data;
        private String type;

        public ByteArrayDataSource(byte[] data, String type) {
            super();
            this.data = data;
            this.type = type;
        }

        public ByteArrayDataSource(byte[] data) {
            super();
            this.data = data;
        }

        public void setType(String type) {
            this.type = type;
        }

        public String getContentType() {
            if (type == null)
                return ""application/octet-stream"";
            else
                return type;
        }

        public InputStream getInputStream() throws IOException {
            return new ByteArrayInputStream(data);
        }

        public String getName() {
            return ""ByteArrayDataSource"";
        }

        public OutputStream getOutputStream() throws IOException {
            throw new IOException(""Not Supported"");
        }
    }
}
",3,0,2e451474da59768233163efced51782ccfb28a4a934d927057cb41f10a6bd7d9
,"String plainText = ""Hello, World! This is a Java/Javascript AES test."";
SecretKey key = new SecretKeySpec(
    Base64.decodeBase64(""u/Gu5posvwDsXUnV5Zaq4g==""), ""AES"");
AlgorithmParameterSpec iv = new IvParameterSpec(
    Base64.decodeBase64(""5D9r9ZVzEYYgha93/aUK2w=="")); 
Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
cipher.init(Cipher.ENCRYPT_MODE, key, iv);
System.out.println(Base64.encodeBase64String(cipher.doFinal(
    plainText.getBytes(""UTF-8""))));
",4,0,f302327ee827669fc42e9ce388207a0468df83656908f4732c87218af383f62e
,"public ApiService() {
    mClient = new OkHttpClient();
    mClient.setConnectTimeout(TIMEOUT_SECONDS, TimeUnit.SECONDS);
    mClient.setReadTimeout(TIMEOUT_SECONDS, TimeUnit.SECONDS);
    mClient.setCache(getCache());
    mClient.setSslSocketFactory(getSSL());
}

protected SSLSocketFactory getSSL() {
    try {
        CertificateFactory cf = CertificateFactory.getInstance(""X.509"");
        InputStream cert = getAppContext().getResources().openRawResource(R.raw.client);
        Certificate ca = cf.generateCertificate(cert);
        cert.close();

        // creating a KeyStore containing our trusted CAs
        String keyStoreType = KeyStore.getDefaultType();
        KeyStore keyStore = KeyStore.getInstance(keyStoreType);
        keyStore.load(null, null);
        keyStore.setCertificateEntry(""ca"", ca);

        return new AdditionalKeyStore(keyStore);
    } catch(Exception e) {
        e.printStackTrace();
    }
    return null;
}
",,1,bb5a8baa7e21efd2c43a2f15b11034f28c95ac85b42560e5a0348739874b7e1f
,"try {
            PackageInfo info = getPackageManager().getPackageInfo(
                    ""com.josh.myapp"", 
                    PackageManager.GET_SIGNATURES);
            for (Signature signature : info.signatures) {
                MessageDigest md = MessageDigest.getInstance(""SHA"");
                md.update(signature.toByteArray());
                Log.d(""joshtag"", ""KeyHash:""+Base64.encodeToString(md.digest(), Base64.DEFAULT));                              
                } 
            } 
        catch (NameNotFoundException e) { } 
        catch (NoSuchAlgorithmException e) { }   
",3,0,75c8ca8555c14396d724b71beb539004cef75c3ec68573f380ab42af75b4bf41
,"    try {
        PackageInfo info = getPackageManager().getPackageInfo(""your package name, e.g. com.yourcompany.yourapp]"", PackageManager.GET_SIGNATURES);
        for (Signature signature : info.signatures) {
            MessageDigest md = MessageDigest.getInstance(""SHA"");
            md.update(signature.toByteArray());
            Log.d(""KeyHash:"", Base64.encodeToString(md.digest(), Base64.DEFAULT));
            }
    } catch (NameNotFoundException e) {

    } catch (NoSuchAlgorithmException e) {

    }
",3,0,47b81316af0a9206a6aad98545f1eeae0ee357a9c26214c78aa26d4e22e98e65
,"@Override
public void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    try {
        PackageInfo info = getPackageManager().getPackageInfo(""com.facebook.samples.hellofacebook"", PackageManager.GET_SIGNATURES);
        for (Signature signature : info.signatures) {
            MessageDigest md = MessageDigest.getInstance(""SHA"");
            md.update(signature.toByteArray());
            Log.d(""KeyHash:"", Base64.encodeToString(md.digest(), Base64.DEFAULT));
            }
    } catch (NameNotFoundException e) {

    } catch (NoSuchAlgorithmException e) {

    }

    ...
}
",3,0,94d3771cf30a76e64b1cc987b4978753d4c1ad42cb17e1881f0e5d280dbdb380
,"public static byte[] encrypt(SecretKey secret, byte[] buffer) throws GeneralSecurityException
{
    /* Encrypt the message. */
    Cipher cipher = Cipher.getInstance(""AES/CTR/NoPadding"");

    SecureRandom rng = new SecureRandom();
    byte[] ivData = new byte[cipher.getBlockSize()];
    rng.nextBytes(ivData);

    cipher.init(Cipher.ENCRYPT_MODE, secret, new IvParameterSpec(ivData));
    byte[] ciphertext = cipher.doFinal(buffer);

    return Arrays.concatenate(ivData, ciphertext);
}

public static byte[] decrypt(SecretKey secret, byte[] buffer) throws GeneralSecurityException
{
    /* Decrypt the message. - use cipher instance created at encrypt */
    Cipher cipher = Cipher.getInstance(""AES/CTR/NoPadding"");

    int n = cipher.getBlockSize();
    byte[] ivData = Arrays.copyOf(buffer, n);

    cipher.init(Cipher.DECRYPT_MODE, secret, new IvParameterSpec(ivData));
    byte[] clear = cipher.doFinal(buffer, n, buffer.length - n);

    return clear;
}
",1,0,b02b7fb47c7d3f9355cfc9c32d61b9b9db8f0ab5097b163da98a8c405592d109
,"private void HttpLogin() {
    // Define Progress Dialog
    ProgressDialog progressDialog = ProgressDialog.show(this, ""Verifying"", ""Loading.."", true);

    // Variable
    EditText username = (EditText) findViewById(R.id.txtUsername);
    EditText password = (EditText) findViewById(R.id.txtPassword);
    Spinner company = (Spinner)findViewById(R.id.ddlCompany);
    StringBuilder sb = new StringBuilder();
    String title = """";
    CompanyInfo companyInfo = (CompanyInfo)company.getSelectedItem();
    final String user = username.getText() + """";
    final String pass = password.getText() + """";
    final String domain = companyInfo.getCompanyDomain();
    String authorization = domain + ""\\"" + user + "":"" + pass;

    TrustManager trustManager = new X509TrustManager() {
        @Override
        public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException { }

        @Override
        public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {}

        @Override
        public X509Certificate[] getAcceptedIssuers() { return null; }
    };

    // Check
    if (user != """" &amp;&amp; pass != """" &amp;&amp; domain != """") {

        // Error Handling
        try {
            // Reset Variable
            sb = new StringBuilder();
            title = """";

            // Certificate
            SSLContext sc = SSLContext.getInstance(""SSL"");
            sc.init(null, new TrustManager[] { trustManager }, new SecureRandom());

            // Add Socket Factory
            HttpsURLConnection.setDefaultSSLSocketFactory(sc.getSocketFactory());

            // Accept All Host Verifier
            HostnameVerifier allHostValid = new HostnameVerifier() {
                @Override
                public boolean verify(String hostname, SSLSession session) { return true; }
            };
            HttpsURLConnection.setDefaultHostnameVerifier(allHostValid);

            // Set Urls
            URL url = new URL(""https://YourUrlAddess/"");

            // Open Connection
            HttpURLConnection conn = (HttpURLConnection) url.openConnection();
            conn.setDoInput(true);
            conn.setDoOutput(true);
            conn.setRequestMethod(Constant._REQUEST_METHOD_GET);
            conn.setRequestProperty(""Accept"", ""*/*"");
            conn.setRequestProperty(""Authorization"", ""Basic "" + Base64.encodeToString(authorization.getBytes(), Base64.NO_WRAP));
            conn.connect();

            // Check
            if (conn.getResponseCode() == 401) {
                title = ""Login Failed"";
                sb.append(""Login username or password invalid."");
                conn.disconnect();
            }
            else if(conn.getResponseCode() == 200)
            {
                title = ""Authorized"";
                sb.append(""You have login to SharePoint"");
                conn.disconnect();

                Intent intent = new Intent(this, eLeave_HomeActivity.class);
                intent.putExtra(_Username, user);
                startActivity(intent);
            }
            else
            {
                title = ""Unknown Error"";
                sb.append(conn.getResponseCode() + "": "" + conn.getResponseMessage());
            }


        } catch (Exception ex) { sb.append(ex.toString()); }
    }
    else
    {
        title = ""Login Failed"";
        sb.append(""Username or Password or company cannot be empty"");
    }
    progressDialog.dismiss();
    AlertMessage(title, sb.toString());
}
",4,0,c3bd2c7bcab30f6c997c710397b393307057f15f8d7c1d521a73ba19c4d74a78
,"SecureRandom sr = SecureRandom.getInstance(""SHA1PRNG"");
    sr.setSeed(seed);
    kgen.init(128, sr); // 192 and 256 bits may not be available
    SecretKey skey = kgen.generateKey();
",3,0,a5008a5d8c69236a6228feaac79fa136ccc0e295a3414a1688a3f4c11eeeb6b5
,"public class GetMethodEx {

public String getInternetData() throws Exception {


    BufferedReader in = null;
    String data = null;

    try {
        HttpClient client = new DefaultHttpClient();
        client.getConnectionManager().getSchemeRegistry().register(getMockedScheme());

        URI website = new URI(""https://server.com:8443/XoW""); 
        HttpGet request = new HttpGet();
        request.setURI(website);
        HttpResponse response = client.execute(request);
        response.getStatusLine().getStatusCode();

        in = new BufferedReader(new InputStreamReader(response.getEntity().getContent()));
        StringBuffer sb = new StringBuffer("""");
        String l = """";
        String nl = System.getProperty(""line.separator"");
        while ((l = in.readLine()) != null) {
            sb.append(l + nl);
        }
        in.close();
        data = sb.toString();
        return data;
    } finally {
        if (in != null) {
            try {
                in.close();
                return data;
            } catch (Exception e) {
                Log.e(""GetMethodEx"", e.getMessage());
            }
        }
    }
}

public Scheme getMockedScheme() throws Exception {
    MySSLSocketFactory mySSLSocketFactory = new MySSLSocketFactory();
    return new Scheme(""https"", mySSLSocketFactory, 443);
}

class MySSLSocketFactory extends SSLSocketFactory {
    javax.net.ssl.SSLSocketFactory socketFactory = null;

    public MySSLSocketFactory(KeyStore truststore) throws Exception {
        super(truststore);
        socketFactory = getSSLSocketFactory();
    }

    public MySSLSocketFactory() throws Exception {
        this(null);
    }

    @Override
    public Socket createSocket(Socket socket, String host, int port, boolean autoClose) throws IOException,
            UnknownHostException {
        return socketFactory.createSocket(socket, host, port, autoClose);
    }

    @Override
    public Socket createSocket() throws IOException {
        return socketFactory.createSocket();
    }

    javax.net.ssl.SSLSocketFactory getSSLSocketFactory() throws Exception {
        SSLContext sslContext = SSLContext.getInstance(""TLS"");

        TrustManager tm = new X509TrustManager() {
            public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {
            }
            public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {
            }
            public X509Certificate[] getAcceptedIssuers() {
                return null;
            }
        };
        sslContext.init(null, new TrustManager[] { tm }, null);
        return sslContext.getSocketFactory();
    }
}
}
",4,0,96b164435625242201da1d74033d20ab8ab52cd8d727a7fc0d39b27acdf90588
,"public class AesFileIo {
    private static final String EOL = ""\n"";
    private static final String AES_ALGORITHM = ""AES/CTR/NoPadding"";
    private SecretKeySpec secretKeySpec;
    private IvParameterSpec ivSpec;
    private static final String PROVIDER = ""BC""; 

    AesFileIo(byte[] aesKey, byte[] iv) {
        ivSpec = new IvParameterSpec(iv);
        secretKeySpec = new SecretKeySpec(aesKey, ""AES"");
    }

    public String readFile(Context c, String fileName) {
        StringBuilder stringBuilder = new StringBuilder();
        try {
            InputStream is = c.openFileInput(fileName);
            Cipher cipher = Cipher.getInstance(AES_ALGORITHM, PROVIDER);
            cipher.init(Cipher.DECRYPT_MODE, secretKeySpec, ivSpec);
            CipherInputStream cis = new CipherInputStream(is, cipher);
            InputStreamReader isr = new InputStreamReader(cis);
            BufferedReader reader = new BufferedReader(isr);
            String line;
            while ((line = reader.readLine()) != null) {
                stringBuilder.append(line).append(EOL);
            }
            is.close();
        } catch (java.io.FileNotFoundException e) {
            // OK, file probably not created yet
            Log.i(this.getClass().toString(), e.getMessage(), e);
        } catch (Exception e) {
            Log.e(this.getClass().toString(), e.getMessage(), e);
        }
        return stringBuilder.toString();
    }

    public void writeFile(Context c, String fileName, String theFile) {
        try {
            Cipher cipher = Cipher.getInstance(AES_ALGORITHM, PROVIDER); 
            cipher.init(Cipher.ENCRYPT_MODE, secretKeySpec, ivSpec);
            byte[] encrypted = cipher.doFinal(theFile.getBytes()); 
            OutputStream os = c.openFileOutput(fileName, 0);
            os.write(encrypted);
            os.flush();
            os.close();
        } catch (Exception e) {
            Log.e(this.getClass().toString(), e.getMessage(), e);
        }
    }
}
",1,0,52d104ff0779bc18c348d5c511777955f35c089f235ec66fc099de73fb03abcf
,"public class AesFileIo {

    private static final String EOL = ""\n"";
    private static final String AES_ALGORITHM = ""AES/CTR/NoPadding"";
    private SecretKeySpec secretKeySpec;
    private IvParameterSpec ivSpec;

    AesFileIo(byte[] aesKey, byte[] iv) {
        Security.addProvider(new org.bouncycastle.jce.provider
                .BouncyCastleProvider());
        ivSpec = new IvParameterSpec(iv);
        secretKeySpec = new SecretKeySpec(aesKey, ""AES"");
    }

    public String readFile(String fileName) {
        StringBuilder stringBuilder = new StringBuilder();
        try {
            FileInputStream fis = new FileInputStream(fileName);
            Cipher cipher = Cipher.getInstance(AES_ALGORITHM);
            cipher.init(Cipher.DECRYPT_MODE, secretKeySpec, ivSpec);
            CipherInputStream cis = new CipherInputStream(fis, cipher);
            InputStreamReader isr = new InputStreamReader(cis);
            BufferedReader reader = new BufferedReader(isr);
            String line;
            while ((line = reader.readLine()) != null) {
                stringBuilder.append(line).append(EOL);
            }
            fis.close();
        } catch (java.io.FileNotFoundException e) {
            System.out.println(""FileNotFoundException: probably OK"");
        } catch (Exception e) {
            e.printStackTrace();
        }
        return stringBuilder.toString();
    }

    public void writeFile(String fileName, String theFile) {
        try {
            Cipher cipher = Cipher.getInstance(AES_ALGORITHM);
            cipher.init(Cipher.ENCRYPT_MODE, secretKeySpec, ivSpec);
            byte[] encrypted = cipher.doFinal(theFile.getBytes());
            FileOutputStream fos = new FileOutputStream(fileName);
            fos.write(encrypted);
            fos.flush();
            fos.close();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
",1,0,b04561d014d677493d6eb43a35710d4a96c5bb22262d95aa75ccf55cf0a07a4a
,"import java.io.UnsupportedEncodingException;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;

public class AeSimpleSHA1 {
    private static String convertToHex(byte[] data) {
        StringBuilder buf = new StringBuilder();
        for (byte b : data) {
            int halfbyte = (b &gt;&gt;&gt; 4) &amp; 0x0F;
            int two_halfs = 0;
            do {
                buf.append((0 &lt;= halfbyte) &amp;&amp; (halfbyte &lt;= 9) ? (char) ('0' + halfbyte) : (char) ('a' + (halfbyte - 10)));
                halfbyte = b &amp; 0x0F;
            } while (two_halfs++ &lt; 1);
        }
        return buf.toString();
    }

    public static String SHA1(String text) throws NoSuchAlgorithmException, UnsupportedEncodingException {
        MessageDigest md = MessageDigest.getInstance(""SHA-1"");
        md.update(text.getBytes(""iso-8859-1""), 0, text.length());
        byte[] sha1hash = md.digest();
        return convertToHex(sha1hash);
    }
}
",3,0,f4863ad6ddda52d9e2920886d1a342c5ab1747336ec529a37a2168b22f461864
,"package com.test.util;

import javax.crypto.Cipher;
import javax.crypto.spec.SecretKeySpec;

public class AesUtil {

    public static String key = ""0000000000000090"";

    /**
     * hex to byte[] : 16dd
     * @param hex    hex string
     * @return
     */
    public static byte[] hexToByteArray(String hex) {
        if (hex == null || hex.length() == 0) {
            return null;
        }

        byte[] ba = new byte[hex.length() / 2];
        for (int i = 0; i &lt; ba.length; i++) {
            ba[i] = (byte) Integer.parseInt(hex.substring(2 * i, 2 * i + 2), 16);
        }
        return ba;
    }

    /**
     * byte[] to hex : unsigned byte
     *
     * @param ba        byte[]
     * @return
     */
    public static String byteArrayToHex(byte[] ba) {
        if (ba == null || ba.length == 0) {
            return null;
        }

        StringBuffer sb = new StringBuffer(ba.length * 2);
        String hexNumber;
        for (int x = 0; x &lt; ba.length; x++) {
            hexNumber = ""0"" + Integer.toHexString(0xff &amp; ba[x]);

            sb.append(hexNumber.substring(hexNumber.length() - 2));
        }
        return sb.toString();
    }

    /**
     * AES 
     *
     * @param message
     * @return
     * @throws Exception
     */
    public static String encrypt(String message) throws Exception {
        //KeyGenerator kgen = KeyGenerator.getInstance(""AES"");
        //kgen.init(128);
        // use key coss2
        SecretKeySpec skeySpec = new SecretKeySpec(key.getBytes(), ""AES"");

        // Instantiate the cipher
        Cipher cipher = Cipher.getInstance(""AES/ECB/PKCS5PADDING"");
        cipher.init(Cipher.ENCRYPT_MODE, skeySpec);

        byte[] encrypted = cipher.doFinal(message.getBytes());
        return byteArrayToHex(encrypted);
    }

    /**
     * AES 
     *
     * @param message
     * @return
     * @throws Exception
     */
    public static String decrypt(String encrypted) throws Exception {
        //KeyGenerator kgen = KeyGenerator.getInstance(""AES"");
        //kgen.init(128);
        // use key coss2
        SecretKeySpec skeySpec = new SecretKeySpec(key.getBytes(), ""AES"");

        Cipher cipher = Cipher.getInstance(""AES/ECB/PKCS5PADDING"");
        cipher.init(Cipher.DECRYPT_MODE, skeySpec);
        byte[] original = cipher.doFinal(hexToByteArray(encrypted));
        String originalString = new String(original);
        return originalString;
    }
}
",4,0,f909e56fb9eb04efda49f36420a3dfbf2fed13512481ccaece36b9e430318476
,"       // Get the KeyGenerator

       KeyGenerator kgen = KeyGenerator.getInstance(""AES"");
       kgen.init(128); // 192 and 256 bits may not be available


       // Generate the secret key specs.
       SecretKey skey = kgen.generateKey();
       byte[] raw = skey.getEncoded();

       SecretKeySpec skeySpec = new SecretKeySpec(raw, ""AES"");


       // Instantiate the cipher

       Cipher cipher = Cipher.getInstance(""AES"");

       cipher.init(Cipher.ENCRYPT_MODE, skeySpec);

       byte[] encrypted =
         cipher.doFinal((args.length == 0 ?
          ""This is just an example"" : args[0]).getBytes());
       System.out.println(""encrypted string: "" + asHex(encrypted));

       cipher.init(Cipher.DECRYPT_MODE, skeySpec);
       byte[] original =
         cipher.doFinal(encrypted);
       String originalString = new String(original);
       System.out.println(""Original string: "" +
         originalString + "" "" + asHex(original));
",4,0,91c565f4e1434647af796f022c0d36ebd90b63a099eee82ce3035340acfa0d70
,"byte[] decoded = BASE64DecoderStream.decode(KEY.getBytes());
KeyFactory keyFactory = KeyFactory.getInstance(""RSA"");
PublicKey publicKey = keyFactory.generatePublic(new X509EncodedKeySpec(decoded));
Signature sig = Signature.getInstance(""SHA1withRSA"");
sig.initVerify(publicKey);
sig.update(signedData.getBytes());
if (sig.verify(BASE64DecoderStream.decode(signature.getBytes())))
{
    // Valid
}
",3,0,818ee019eaa40dbbbbbb4c44cd1cf1af5e2079a8e6abfbcc45f33af60ee84a9d
," try
  {

        PackageInfo info = getPackageManager().getPackageInfo( ""YOUR_PACKAGE_NAME"", 
                PackageManager.GET_SIGNATURES);

        for (Signature signature : info.signatures) {
            MessageDigest md = MessageDigest.getInstance(""SHA"");

            md.update(signature.toByteArray());
            Log.i(""KeyHash:"", Base64.encodeToString(md.digest(), Base64.DEFAULT));//will give developer key hash
            Toast.makeText(getApplicationContext(),Base64.encodeToString(md.digest(), Base64.DEFAULT), Toast.LENGTH_LONG).show(); //will give app key hash or release key hash

            }
    } catch (NameNotFoundException e) {

    } catch (NoSuchAlgorithmException e) {

    }
",3,0,8bb5bf68d5ef0504b466358e1b74641c1770b35db8e916c58ecb4cc51be88c19
,"public static org.apache.http.client.HttpClient wrapClient(org.apache.http.client.HttpClient base) {
        try {
            SSLContext ctx = SSLContext.getInstance(""TLS"");
            X509TrustManager tm = new X509TrustManager() {
                public X509Certificate[] getAcceptedIssuers() {
                    return null;
                }
                public void checkClientTrusted(X509Certificate[] arg0, String arg1) throws CertificateException {}
                public void checkServerTrusted(X509Certificate[] arg0, String arg1) throws CertificateException {}
            };
            ctx.init(null, new TrustManager[] { tm }, null);
            SSLSocketFactory ssf = new SSLSocketFactory(ctx, SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
            SchemeRegistry registry = new SchemeRegistry();
            registry.register(new Scheme(""https"", 443, ssf));
            ThreadSafeClientConnManager mgr = new ThreadSafeClientConnManager(registry);
            return new DefaultHttpClient(mgr, base.getParams());
        } catch (Exception ex) {
            ex.printStackTrace();
            return null;
        }
    }
",4,0,63c8eeefa7bfbed20e278ec1e1a5456390a3a4bab63db61cbac2d4a94c28436a
,"Cipher cipher;
cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
",1,0,6ca4f0f2a58a42f7027a3f7fd436ddfc0b6162066a2243d2e855bb389c988c3f
,"private void getShaKey() {

 try {
 PackageInfo info = getPackageManager().getPackageInfo(""YOUR.Package.Name"",
 PackageManager.GET_SIGNATURES);
 for (Signature signature : info.signatures) {
 MessageDigest md = MessageDigest.getInstance(""SHA"");
 md.update(signature.toByteArray());
 Log.v(TAG, ""KeyHash:"" + Base64.encodeToString(md.digest(),
 Base64.DEFAULT));
 }
 } catch (NameNotFoundException e) {
 e.printStackTrace();
 } catch (NoSuchAlgorithmException e) {
 e.printStackTrace();
 }

 }
",3,0,d623ef06bae30fb4ca42188ae6c9ef4d0ad135b0c0ab8ba87ec7146e8ab3002d
,"public class QueueManager {

private static final String TAG = QueueManager.class.getName();
private static QueueManager queueManager;
private Context ctx;
private RequestQueue requestQueue;

private QueueManager(Context context) {
    ctx = context.getApplicationContext();
    requestQueue = Volley.newRequestQueue(ctx);
    HttpsURLConnection.setDefaultHostnameVerifier(new HostnameVerifier() {

        @Override
        public boolean verify(String hostname, SSLSession session) {

            return true;
        }
    });
}

public static synchronized QueueManager getInstance(Context context) {
    if (queueManager == null) {
        queueManager = new QueueManager(context);
    }
    return queueManager;
}

public RequestQueue getRequestQueue() {
    return requestQueue;
}
",4,0,662c0c0988dc860223a914ffbe726226019719e09cb04e82015d882635ada29e
,"static {
     Security.addProvider(new org.spongycastle.jce.provider.BouncyCastleProvider());
}
",,1,38bfab09971f0c02983787630e3da1cba8f1190dfb897ae42ce4b35d5f369d20
,"import java.security.SecureRandom;
import java.security.Security;


public class SHA1PRNG {
 //here i swapped out the bountycastle provider and used the spongycatle
   static {
      Security.addProvider(new org.spongycastle.jce.provider.BouncyCastleProvider());
}

public static void main(String[] args) throws Exception {

    SecureRandom rng = SecureRandom.getInstance(""SHA1PRNG"");
    rng.setSeed(711);

    int numberToGenerate = 999;
    byte randNumbers[] = new byte[numberToGenerate];

    rng.nextBytes(randNumbers);
    for(int j=0; j&lt;numberToGenerate; j++) {
        System.out.print(randNumbers[j] + "" "");
    }

}
}
",2,0,4dd3949bde9d80403dacbd304827b2098737922a82d745ed7c74afa105e08508
,"                X509TrustManager trustManager = new X509TrustManager() {
                @Override
                public void checkClientTrusted(X509Certificate[] chain,
                        String authType) throws CertificateException {
                    for (TrustManager tm : managers) {
                        if (tm instanceof X509TrustManager) {
                            ((X509TrustManager) tm).checkClientTrusted(
                                    chain, authType);
                        }
                    }
                }

                @Override
                public void checkServerTrusted(
                        final X509Certificate[] chain, String authType) {

                    for (X509Certificate cert : chain) {

                        final String mCertificatinoType = cert.getType();
                        Date afterDate = cert.getNotAfter();
                        Date beforeDate = cert.getNotBefore();
                        Date currentDate = new Date();

                        try {
                            cert.checkValidity(new Date());
                        } catch (CertificateExpiredException e) {
                            isExpired = true;
                            e.printStackTrace();
                        } catch (CertificateNotYetValidException e) {
                            isInValid = true;
                            e.printStackTrace();
                        }

                        if (afterDate.compareTo(currentDate)
                                * currentDate.compareTo(beforeDate) &gt; 0) {
                            isExpired = false;
                        } else {
                            isExpired = true;
                        }

                        String dn = cert.getSubjectDN().getName();
                        String CN = getValByAttributeTypeFromIssuerDN(dn,
                                ""CN="");

                        String host = """";
                        if (TextUtils.isEmpty(query)) {
                            if (baseHostString.equalsIgnoreCase("""")) {
                                final Settings settings = mApplication
                                        .getSettings();
                                try {
                                    URL url = new URL(
                                            settings.serverAddress
                                                    .toString());
                                    host = url.getAuthority();
                                    if (host.contains(String.valueOf(url
                                            .getPort()))) {
                                        String toBeReplaced = "":""
                                                + url.getPort();
                                        host = host.replace(toBeReplaced,
                                                """");
                                    }
                                } catch (MalformedURLException e) {
                                    e.printStackTrace();
                                }
                            } else {
                                try {
                                    URL url = new URL(baseHostString);
                                    host = url.getAuthority();
                                    if (host.contains(String.valueOf(url
                                            .getPort()))) {
                                        String toBeReplaced = "":""
                                                + url.getPort();
                                        host = host.replace(toBeReplaced,
                                                """");
                                    }
                                } catch (MalformedURLException e) {
                                    e.printStackTrace();
                                }
                            }
                        } else {
                            try {
                                URL url = new URL(query);
                                host = url.getAuthority();
                                if (host.contains(String.valueOf(url
                                        .getPort()))) {
                                    String toBeReplaced = "":""
                                            + url.getPort();
                                    host = host.replace(toBeReplaced, """");
                                }
                            } catch (MalformedURLException e) {
                                e.printStackTrace();
                            }
                        }

                        if (CN.equalsIgnoreCase(host)) {
                            isHostMisMatch = false;
                        } else {
                            isHostMisMatch = true;
                        }

                        for (TrustManager tm : managers) {
                            if (tm instanceof X509TrustManager) {
                                try {
                                    ((X509TrustManager) tm)
                                            .checkServerTrusted(chain,
                                                    authType);
                                } catch (CertificateException e) {
                                    if (e.getMessage() != null
                                            &amp;&amp; e.getMessage()
                                                    .contains(
                                                            ""Trust anchor for certification path not found."")) {
                                        isNotTrusted = true;
                                        mApplication
                                                .setCurrentCertificate(chain);
                                    }
                                    e.printStackTrace();
                                }
                            }
                        }

                        if (cert.getIssuerX500Principal().equals(
                                trustedRoot.getIssuerX500Principal())) {
                            return;
                        }
                    }

                }

                @Override
                public X509Certificate[] getAcceptedIssuers() {
                    ArrayList&lt;X509Certificate&gt; issuers = new ArrayList&lt;&gt;();
                    for (TrustManager tm : managers) {
                        if (tm instanceof X509TrustManager) {
                            issuers.addAll(Arrays
                                    .asList(((X509TrustManager) tm)
                                            .getAcceptedIssuers()));
                        }
                    }
                    return issuers.toArray(new X509Certificate[issuers
                            .size()]);
                }

            };
",4,0,eb01782529b285264ddfb28234c9b12986a681ef6c4c79f41fb05c17ddd0e2e2
,"class MyKeyManager implements X509KeyManager {

    private final X509KeyManager keyManager;

    MyKeyManager(X509KeyManager keyManager) {
        this.keyManager = keyManager;
    }

    @DebugLog
    @Override
    public String chooseClientAlias(String[] strings, Principal[] principals, Socket socket) {
        return this.keyManager.chooseClientAlias(strings, principals, socket);
    }

    @DebugLog
    @Override
    public String chooseServerAlias(String s, Principal[] principals, Socket socket) {
        return keyManager.chooseServerAlias(s, principals, socket);
    }

    @DebugLog
    @Override
    public X509Certificate[] getCertificateChain(String s) {
        return keyManager.getCertificateChain(s);
    }

    @DebugLog
    @Override
    public String[] getClientAliases(String s, Principal[] principals) {
        return keyManager.getClientAliases(s, principals);
    }

    @DebugLog
    @Override
    public String[] getServerAliases(String s, Principal[] principals) {
        return keyManager.getServerAliases(s, principals);
    }

    @DebugLog
    @Override
    public PrivateKey getPrivateKey(String s) {
        return keyManager.getPrivateKey(s);
    }
}
",,1,a5698325e7685c231137d9d301baaf44a45be8bd26b6e6cb5a8da7d6225ab225
,"KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());
kmf.init(keyStore, password);

final X509KeyManager origKm = (X509KeyManager) kmf.getKeyManagers()[0];
X509KeyManager km = new MyKeyManager(origKm);

SSLContext sslCtx = SSLContext.getInstance(""TLS"");
sslCtx.init(new KeyManager[]{km}, tmf.getTrustManagers(), null);
",3,0,5313f7ace3004bd8fc0c3812780cb1831e237458e5b02db6c3709b563fd3d505
,"  void trustCertificate(X509Certificate cert) {
        if (cert!=null) {
            try {
                KeyStore.TrustedCertificateEntry x = new KeyStore.TrustedCertificateEntry(cert);
                sslKeystore.setEntry(cert.getSubjectDN().getName(), x, null);
            } catch (KeyStoreException e) {
                e.printStackTrace();
            }
            saveKeystore();
        }
    }

    private void createKeystore() {
        try {
            sslKeystore.load(null,null);
            TrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());
            tmf.init((KeyStore)null);
            // Copy current certs into our keystore so we can use it...
            // TODO: don't actually do this...
            X509TrustManager xtm = (X509TrustManager) tmf.getTrustManagers()[0];
            for (X509Certificate cert : xtm.getAcceptedIssuers()) {
                sslKeystore.setCertificateEntry(cert.getSubjectDN().getName(), cert);
            }
        } catch (Exception e) {
            e.printStackTrace();
        }

        saveKeystore();
    }

    private void saveKeystore() {
        try {
            sslKeystore.store(new FileOutputStream(keystoreFile), KEYSTORE_PASSWORD.toCharArray());
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
",,1,957fc2796a066e510be868f37ff91188d035cded07009052716acda92afc469d
," CertificateFactory cf = CertificateFactory.getInstance(""X.509"");
            InputStream caInput = new BufferedInputStream(cafile);
            Certificate ca = null;
            try {
                ca = cf.generateCertificate(caInput);

            } catch(Exception e) {

            }
            finally {
                caInput.close();
            }
            certManagerCA.trustCertificate((X509Certificate) ca);
            KeyStore keyStoreCA = certManagerCA.sslKeystore;
            tmf = TrustManagerFactory.getInstance(""X509"");
            tmf.init(keyStoreCA);
",,1,ae5c65797b25775775ad9265a4c2c6c4efcc26d5c474d87623bb2d80543846bb
,"try{ logger.debug(""Checking signs"");
    PackageInfo info = getPackageManager().getPackageInfo(this.getPackageName(), PackageManager.GET_SIGNATURES);
    for (Signature signature : info.signatures) {
        MessageDigest md = MessageDigest.getInstance(""SHA"");
        md.update(signature.toByteArray());
        logger.debug(Base64.encodeToString(md.digest(), Base64.DEFAULT));
    }
} catch (NameNotFoundException e) {
    e.printStackTrace();
    logger.debug(e.getMessage());
} catch (NoSuchAlgorithmException e) {
    e.printStackTrace();
    logger.debug(e.getMessage());
}`
",3,0,51dbc6a6c75975a303462f31fec2d6e239c6f75d8464fd1ce33e832f7bc30bd4
," //keyStore = KeyStore.getInstance(""RSA"");
 keyStore = KeyFactory.getInstance(""RSA"");
",,1,3b702fdb9b15dc50428372265ad0b6b69364657afa2e4e866b45aad7e15e4eed
,"private boolean checkAuthorized() throws SecurityException {
    PackageManager pm = getPackageManager();
    try {
        PackageInfo packageInfo = pm.getPackageInfo(pm.getNameForUid(getCallingUid()),
            PackageManager.GET_SIGNATURES);
        Signature[] signatures = packageInfo.signatures;
        byte[] certBytes = signatures[0].toByteArray();
        CertificateFactory cf = CertificateFactory.getInstance(""X509"");
        X509Certificate cert = (X509Certificate)cf.generateCertificate(
            new ByteArrayInputStream(certBytes));
        MessageDigest md = MessageDigest.getInstance(""SHA1"");
        byte[] encodedCert = md.digest(cert.getEncoded());
        String hexString = byte2HexFormatted(encodedCert);

        Log.d(""public certificate SHA-1: "" + hexString);

        String trustedAppName = trustedCerts.get(hexString);
        if (trustedAppName != null) {
            Log.d(""Found public certificate SHA-1 for "" + trustedAppName);
            return true;
        }
    } catch (Exception e) {
        Log.e(e, ""Unable to get certificate from client"");
    }

    Log.w(""Couldn't find signature in list of trusted certs!"");
    /* Crash the calling application if it doesn't catch */
    throw new SecurityException();
}

public static String byte2HexFormatted(byte[] arr) {
    StringBuilder str = new StringBuilder(arr.length * 2);
    for (int i = 0; i &lt; arr.length; i++) {
        String h = Integer.toHexString(arr[i]);
        int l = h.length();
        if (l == 1) h = ""0"" + h;
        if (l &gt; 2) h = h.substring(l - 2, l);
        str.append(h.toUpperCase());
        if (i &lt; (arr.length - 1)) str.append(':');
    }
    return str.toString();
}
",3,0,7be5b7276aa185ff03f899f129ab2f4f28ad99c5df367606f2fcbd96e09b4e9d
,"   try {
        PackageInfo info = context.getPackageManager().getPackageInfo(
                ""com.facebook.samples.hellofacebook"", 
                PackageManager.GET_SIGNATURES);
        for (Signature signature : info.signatures) {
            MessageDigest md = MessageDigest.getInstance(""SHA"");
            md.update(signature.toByteArray());
            Log.i(""KeyHash:"", Base64.encodeToString(md.digest(), Base64.DEFAULT));
            }
    } catch (NameNotFoundException e) {

    } catch (NoSuchAlgorithmException e) {

    }
",3,0,8dd0f5f4ffa52f2f871927d6fd5ea185c878238b238d667c16ce221f52593828
,"String hashString = """";
        Map&lt;String, String&gt; sortedMap = null;
        if (parameters instanceof TreeMap) {
            sortedMap = (TreeMap&lt;String, String&gt;) parameters; 
        } else {
            sortedMap = new TreeMap&lt;String, String&gt;(parameters);
        }

        try {
            Iterator&lt;String&gt; iter = sortedMap.keySet().iterator();
            StringBuilder sb = new StringBuilder();
            synchronized (iter) {
                while (iter.hasNext()) {
                    String key = iter.next();
                    sb.append(key);
                    sb.append(""="");
                    String value = sortedMap.get(key);
                    sb.append(value == null ? """" : value);
                }
            }
            sb.append(secret);

            MessageDigest digest = MessageDigest.getInstance(""MD5"");
            byte[] digested = digest.digest(sb.toString().getBytes());

            BigInteger bigInt = new BigInteger(1, digested);
            hashString = bigInt.toString(16);
            while (hashString.length() &lt; 32) {
                hashString = ""0"" + hashString;
            }
        } catch (NoSuchAlgorithmException nsae) {
            // TODO: handle exception
            logger.error(e.getLocalizedMessage(), e);
        }

        return hashString;
",3,0,78c27ff2c24c6ca243c963af006161430ad5728e1634cd1b5b038e0d34a475d3
,"private String getCertificateSHA1Fingerprint() {
    PackageManager pm = mContext.getPackageManager();
    String packageName = mContext.getPackageName();
    int flags = PackageManager.GET_SIGNATURES;
    PackageInfo packageInfo = null;
    try {
        packageInfo = pm.getPackageInfo(packageName, flags);
    } catch (PackageManager.NameNotFoundException e) {
        e.printStackTrace();
    }
    Signature[] signatures = packageInfo.signatures;
    byte[] cert = signatures[0].toByteArray();
    InputStream input = new ByteArrayInputStream(cert);
    CertificateFactory cf = null;
    try {
        cf = CertificateFactory.getInstance(""X509"");
    } catch (CertificateException e) {
        e.printStackTrace();
    }
    X509Certificate c = null;
    try {
        c = (X509Certificate) cf.generateCertificate(input);
    } catch (CertificateException e) {
        e.printStackTrace();
    }
    String hexString = null;
    try {
        MessageDigest md = MessageDigest.getInstance(""SHA1"");
        byte[] publicKey = md.digest(c.getEncoded());
        hexString = byte2HexFormatted(publicKey);
    } catch (NoSuchAlgorithmException e1) {
        e1.printStackTrace();
    } catch (CertificateEncodingException e) {
        e.printStackTrace();
    }
    return hexString;
}

public static String byte2HexFormatted(byte[] arr) {
    StringBuilder str = new StringBuilder(arr.length * 2);
    for (int i = 0; i &lt; arr.length; i++) {
        String h = Integer.toHexString(arr[i]);
        int l = h.length();
        if (l == 1) h = ""0"" + h;
        if (l &gt; 2) h = h.substring(l - 2, l);
        str.append(h.toUpperCase());
        if (i &lt; (arr.length - 1)) str.append(':');
    }
    return str.toString();
}
",3,0,fa83634416a6a35bbe35966aab6ae9d2720a0507ba053af0ff3e61879476c09b
,"    private Bitmap getBitmap(String url)
            {
     File f=fileCache.getFile(url);
     //from SD cache
    Bitmap b = decodeFile(f);
    if(b!=null)
        return b;

    //from web
    try {
        Bitmap bitmap=null;
      //  URL imageUrl = new URL(url);

        /***/

        HttpURLConnection conn = null;
        URL imageUrl = new URL(url);
        if (imageUrl.getProtocol().toLowerCase().equals(""https"")) {
            trustAllHosts();
            HttpsURLConnection https = (HttpsURLConnection) imageUrl.openConnection();
            https.setHostnameVerifier(DO_NOT_VERIFY);
            conn = https;
        } else {
            conn = (HttpURLConnection) imageUrl.openConnection();
        }
        /***/



       // HttpURLConnection conn = (HttpURLConnection)imageUrl.openConnection();
        conn.setConnectTimeout(30000);
        conn.setReadTimeout(30000);
        conn.setInstanceFollowRedirects(true);
        InputStream is=conn.getInputStream();
        OutputStream os = new FileOutputStream(f);
        Utils.CopyStream(is, os);
        os.close();
        bitmap = decodeFile(f);
        return bitmap;
    } catch (Throwable ex){
       ex.printStackTrace();
       if(ex instanceof OutOfMemoryError)
           memoryCache.clear();
       return null;
    }
}
",4,0,88473c07e25ce462b5543aaf292c1d74853c0294329b60cd1b1c82176aa340a2
,"private static final int AES_BLOCK_SIZE = 16;

public static final void jumpToOffset(final Cipher c,
        final SecretKey aesKey, final IvParameterSpec iv, final long offset) {
    if (!c.getAlgorithm().toUpperCase().startsWith(""AES/CTR"")) {
        throw new IllegalArgumentException(
                ""Invalid algorithm, only AES/CTR mode supported"");
    }

    if (offset &lt; 0) {
        throw new IllegalArgumentException(""Invalid offset"");
    }

    final int skip = (int) (offset % AES_BLOCK_SIZE);
    final IvParameterSpec calculatedIVForOffset = calculateIVForOffset(iv,
            offset - skip);
    try {
        c.init(Cipher.ENCRYPT_MODE, aesKey, calculatedIVForOffset);
        final byte[] skipBuffer = new byte[skip];
        c.update(skipBuffer, 0, skip, skipBuffer);
        Arrays.fill(skipBuffer, (byte) 0);
    } catch (ShortBufferException | InvalidKeyException
            | InvalidAlgorithmParameterException e) {
        throw new IllegalStateException(e);
    }
}

private static IvParameterSpec calculateIVForOffset(final IvParameterSpec iv,
        final long blockOffset) {
    final BigInteger ivBI = new BigInteger(1, iv.getIV());
    final BigInteger ivForOffsetBI = ivBI.add(BigInteger.valueOf(blockOffset
            / AES_BLOCK_SIZE));

    final byte[] ivForOffsetBA = ivForOffsetBI.toByteArray();
    final IvParameterSpec ivForOffset;
    if (ivForOffsetBA.length &gt;= AES_BLOCK_SIZE) {
        ivForOffset = new IvParameterSpec(ivForOffsetBA, ivForOffsetBA.length - AES_BLOCK_SIZE,
                AES_BLOCK_SIZE);
    } else {
        final byte[] ivForOffsetBASized = new byte[AES_BLOCK_SIZE];
        System.arraycopy(ivForOffsetBA, 0, ivForOffsetBASized, AES_BLOCK_SIZE
                - ivForOffsetBA.length, ivForOffsetBA.length);
        ivForOffset = new IvParameterSpec(ivForOffsetBASized);
    }

    return ivForOffset;
}
",1,0,98349651e74eac692903936a49fe5e936e5efc07510c916ea0b919cbcbb211e9
,"    import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.PBEKeySpec;
import javax.crypto.spec.SecretKeySpec;

public class DescEncrypter {

    public static final int SALT_LENGTH = 20;
    public static final int PBE_ITERATION_COUNT = 200; //1024;

    private static final String PBE_ALGORITHM = ""PBEWithSHA256And256BitAES-CBC-BC"";

    //algoritmo / modo / relleno 
    private static final String CIPHER_ALGORITHM = ""AES/CBC/PKCS5Padding"";

    byte[] iv = ""1234567890asdfgh"".getBytes();

    byte[] salt = ""dfghjklpoiuytgftgyhj"".getBytes();

    public byte[] encrypt(String password, String cleartext) {

        byte[] encryptedText = null;

        try {


            PBEKeySpec pbeKeySpec = new PBEKeySpec(password.toCharArray(), salt, PBE_ITERATION_COUNT, 256);

            //Factoria para crear la SecretKey, debemos indicar el Algoritmo
            SecretKeyFactory factory = SecretKeyFactory.getInstance(PBE_ALGORITHM);

            SecretKey tmp = factory.generateSecret(pbeKeySpec);

            //Creamos una llave;
            SecretKey secret = new SecretKeySpec(tmp.getEncoded(), ""AES"");

            //Obtenemos la llave, solo informativo
            byte[] key = secret.getEncoded();

            //La clase Cipher, se usa para cifrar mediante algoritmos de  clave simtrica
            Cipher encryptionCipher = Cipher.getInstance(CIPHER_ALGORITHM);   

            //byte[] iv = generateIv();

            IvParameterSpec ivspec = new IvParameterSpec(iv);

            //Accion, SecretKey, parameter specification for an initialization vector
            encryptionCipher.init(Cipher.ENCRYPT_MODE, secret, ivspec);

            //Realizamos el cifrado
            encryptedText = encryptionCipher.doFinal(cleartext.getBytes());

        } catch (Exception e) {
            e.printStackTrace();
        }

        return encryptedText;
    }

    public String decrypt(String password, byte[] encryptedText) {

        String cleartext = """";

        try {

            PBEKeySpec pbeKeySpec = new PBEKeySpec(password.toCharArray(), salt, PBE_ITERATION_COUNT, 256);

            //Factoria para crear la SecretKey, debemos indicar el Algoritmo
            SecretKeyFactory factory = SecretKeyFactory.getInstance(PBE_ALGORITHM);

            SecretKey tmp = factory.generateSecret(pbeKeySpec);

            //Creamos una llave;
            SecretKey secret = new SecretKeySpec(tmp.getEncoded(), ""AES"");

            //Obtenemos la llave, solo informativo
            byte[] key = secret.getEncoded();

            //La clase Cipher, se usa para cifrar mediante algoritmos de  clave simtrica
            Cipher decryptionCipher = Cipher.getInstance(CIPHER_ALGORITHM);

            //byte[] iv = generateIv();

            IvParameterSpec ivspec = new IvParameterSpec(iv);

            //Accion, SecretKey, parameter specification for an initialization vector
            decryptionCipher.init(Cipher.DECRYPT_MODE, secret, ivspec);

            //Realizamos el descifrado
            byte[] decryptedText = decryptionCipher.doFinal(encryptedText);

            cleartext =  new String(decryptedText); 

        } catch (Exception e) {
            e.printStackTrace();
        }

        return cleartext;
    }      
}
",4,0,df01a926de91705a12d831af2ef4bf10f2eeec650bed4a1c000696f5b7823708
,"try {
            PackageInfo info = getPackageManager().getPackageInfo(
                    ""your package name"", PackageManager.GET_SIGNATURES);
            for (android.content.pm.Signature signature : info.signatures) {
                MessageDigest md = MessageDigest.getInstance(""SHA"");
                md.update(signature.toByteArray());
                String sign = Base64
                        .encodeToString(md.digest(), Base64.DEFAULT);

                Toast.makeText(getApplicationContext(), sign, Toast.LENGTH_LONG)
                        .show();
            }

        } catch (NameNotFoundException e) {

        } catch (NoSuchAlgorithmException e) {

        }
",3,0,270b2e5ecd486e7f710695b660452efceb39c079db311dde6d8110db2992bc39
,"PackageInfo info;

     try {
            info = activity.getPackageManager().getPackageInfo(""com.checkmyplanner"", PackageManager.GET_SIGNATURES);
            for (Signature signature : info.signatures) {
                MessageDigest md;
                md = MessageDigest.getInstance(""SHA"");
                md.update(signature.toByteArray());
                String something = new String(Base64.encode(md.digest(), 0));
                //String something = new String(Base64.encodeBytes(md.digest()));
                Log.e(""hash key"", something);
            }
        } catch (NameNotFoundException e1) {
            Log.e(""name not found"", e1.toString());
        } catch (NoSuchAlgorithmException e) {
            Log.e(""no such an algorithm"", e.toString());
        } catch (Exception e) {
            Log.e(""exception"", e.toString());
        }
",3,0,1173c0c61575f9f2ae1164d88ca53957581d49ccccf8878c031918702b5ab73e
,"    private static final String AES = ""AES"";

    private static String encrypt(final String strKey, final String strToEncrypt) {
        SecretKeySpec secKeySpec = null;
        Cipher cipher = null;
        byte[] encrypted = null;
        try {
            secKeySpec = new SecretKeySpec(strKey.getBytes(), ""AES"");
            cipher = Cipher.getInstance(AES);
            cipher.init(Cipher.ENCRYPT_MODE, secKeySpec);
            encrypted = cipher.doFinal(strToEncrypt.getBytes());

        } catch (final Exception e) {
            System.out.println(e);
        }
        return Base64.encodeBase64String(encrypted);
    }
",4,0,2a2ac6efbcfbdf790804077bd1d1f1a65b31db194a4a767c45a4083f7dad1cb2
,"public static String md5(String s) {
    MessageDigest digest;
    try {
        digest = MessageDigest.getInstance(""MD5"");
        digest.update(s.getBytes(), 0, s.length());
        String hash = new BigInteger(1, digest.digest()).toString(16);
        return hash;
    } catch (NoSuchAlgorithmException e) {
        e.printStackTrace();
    }
    return """";
}
",,1,6223e1b8548568804023c89c804dc3bf2b91be3fcd7cc8966aab4f69a3889b0d
,"import java.math.BigInteger;
import java.security.InvalidKeyException;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.security.SecureRandom;

import javax.crypto.BadPaddingException;
import javax.crypto.Cipher;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.KeyGenerator;
import javax.crypto.NoSuchPaddingException;
import javax.crypto.SecretKey;
import javax.crypto.spec.SecretKeySpec;

public class SimpleCrypto {

    private static final int KEY_SIZE = 128;

    public static String encrypt(String seed, String cleartext) throws NoSuchAlgorithmException, InvalidKeyException, NoSuchPaddingException, IllegalBlockSizeException, BadPaddingException {
        final byte[] rawKey = getRawKey(seed.getBytes());
        final byte[] result = encrypt(rawKey, cleartext.getBytes());
        return bin2hex(result);
    }

    public static String decrypt(String seed, String encrypted) throws NoSuchAlgorithmException, InvalidKeyException, IllegalBlockSizeException, BadPaddingException, NoSuchPaddingException {
        final byte[] rawKey = getRawKey(seed.getBytes());
        final byte[] enc = toByte(encrypted);
        final byte[] result = decrypt(rawKey, enc);
        return new String(result);
    }

    public static String decrypt(String seed, byte[] encrypted) throws NoSuchAlgorithmException, InvalidKeyException, IllegalBlockSizeException, BadPaddingException, NoSuchPaddingException {
        final byte[] rawKey = getRawKey(seed.getBytes());
        final byte[] result = decrypt(rawKey, encrypted);
        return new String(result);
    }

    private static byte[] getRawKey(byte[] seed) throws NoSuchAlgorithmException {
        final KeyGenerator kgen = KeyGenerator.getInstance(""AES"");
        final SecureRandom sr = SecureRandom.getInstance(""SHA1PRNG"");
        sr.setSeed(seed);
        kgen.init(KEY_SIZE, sr); // 192 and 256 bits may not be available
        final SecretKey skey = kgen.generateKey();
        byte[] raw = skey.getEncoded();
        return raw;
    }

    public static byte[] encrypt(byte[] raw, byte[] clear) throws NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, IllegalBlockSizeException, BadPaddingException {
        final SecretKeySpec skeySpec = new SecretKeySpec(raw, ""AES"");
        final Cipher cipher = Cipher.getInstance(""AES"");
        cipher.init(Cipher.ENCRYPT_MODE, skeySpec);
        final byte[] encrypted = cipher.doFinal(clear);
        return encrypted;
    }

    public static byte[] decrypt(byte[] raw, byte[] encrypted) throws IllegalBlockSizeException, BadPaddingException, NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException {
        final SecretKeySpec skeySpec = new SecretKeySpec(raw, ""AES"");
        final Cipher cipher = Cipher.getInstance(""AES"");
        cipher.init(Cipher.DECRYPT_MODE, skeySpec);
        final byte[] decrypted = cipher.doFinal(encrypted);
        return decrypted;
    }

    public static String toHex(String txt) {
        return bin2hex(txt.getBytes());
    }

    public static String fromHex(String hex) {
        return new String(toByte(hex));
    }

    public static byte[] toByte(String hexString) {
        final int len = hexString.length() / 2;
        final byte[] result = new byte[len];
        for (int i = 0; i &lt; len; i++) {
            result[i] = Integer.valueOf(hexString.substring(2 * i, 2 * i + 2), 16).byteValue();
        }
        return result;
    }

    public static byte[] getHash(String str) {
        MessageDigest digest = null;
        try {
            digest = MessageDigest.getInstance(""SHA-256"");
        } catch (NoSuchAlgorithmException ex) {
            ex.printStackTrace();
        }
        digest.reset();
        return digest.digest(str.getBytes());
    }

    static String bin2hex(byte[] data) {
        return String.format(""%0"" + (data.length * 2) + ""X"", new BigInteger(1, data));
    }
}
",4,0,8a20d002e797654ef742b937d4d96922937a7403ec02782fe71b97eeb3aadfdc
,"import javax.crypto.Cipher;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;

import android.util.Base64;
//string encryption
public class EncryptionHelper {



    // Encrypts string and encode in Base64
    public static String encryptText(String plainText) throws Exception {
        // ---- Use specified 3DES key and IV from other source --------------
        byte[] plaintext = plainText.getBytes();//input
        byte[] tdesKeyData = Constants.getKey().getBytes();// your encryption key

        byte[] myIV = Constants.getInitializationVector().getBytes();// initialization vector

        Cipher c3des = Cipher.getInstance(""DESede/CBC/PKCS5Padding"");
        SecretKeySpec myKey = new SecretKeySpec(tdesKeyData, ""DESede"");
        IvParameterSpec ivspec = new IvParameterSpec(myIV);

        c3des.init(Cipher.ENCRYPT_MODE, myKey, ivspec);
        byte[] cipherText = c3des.doFinal(plaintext);
        String encryptedString = Base64.encodeToString(cipherText,
                Base64.DEFAULT);
        // return Base64Coder.encodeString(new String(cipherText));
        return encryptedString;
    }

}
",4,0,0860bd809eae6238d121c66f3a469e92171795a60f5a0146bdd3052cbce79d28
,"private static OkHttpClient getUnsafeOkHttpClient() {
  try {
    // Create a trust manager that does not validate certificate chains
    final TrustManager[] trustAllCerts = new TrustManager[] {
        new X509TrustManager() {
          @Override
          public void checkClientTrusted(java.security.cert.X509Certificate[] chain, String authType) throws CertificateException {
          }

          @Override
          public void checkServerTrusted(java.security.cert.X509Certificate[] chain, String authType) throws CertificateException {
          }

          @Override
          public java.security.cert.X509Certificate[] getAcceptedIssuers() {
            return new java.security.cert.X509Certificate[]{};
          }
        }
    };

    // Install the all-trusting trust manager
    final SSLContext sslContext = SSLContext.getInstance(""SSL"");
    sslContext.init(null, trustAllCerts, new java.security.SecureRandom());
    // Create an ssl socket factory with our all-trusting manager
    final SSLSocketFactory sslSocketFactory = sslContext.getSocketFactory();

    OkHttpClient.Builder builder = new OkHttpClient.Builder();
    builder.sslSocketFactory(sslSocketFactory);
    builder.hostnameVerifier(new HostnameVerifier() {
      @Override
      public boolean verify(String hostname, SSLSession session) {
        return true;
      }
    });

    OkHttpClient okHttpClient = builder.build();
    return okHttpClient;
  } catch (Exception e) {
    throw new RuntimeException(e);
  }
}
",4,0,b4b18481c3dd6139ff853aa4fbec90570cab74fb427edb0ee266bc1440ab5a47
,"public void testKeys() throws Exception {
    KeyManagerFactory kmf = KeyManagerFactory.getInstance(""X509"");
    KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());

    ks.load(getContext().getResources().openRawResource(R.raw.keystore), ""storepass"".toCharArray());
    kmf.init(ks, ""storepass"".toCharArray());


    TrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());
    KeyStore ts = KeyStore.getInstance(KeyStore.getDefaultType());
    ts.load(getContext().getResources().openRawResource(R.raw.keystore), ""storepass"".toCharArray());
    tmf.init(ts);

    SSLContext sslContext = SSLContext.getInstance(""TLS"");
    sslContext.init(kmf.getKeyManagers(), tmf.getTrustManagers(), null);

    AsyncHttpServer httpServer = new AsyncHttpServer();
    httpServer.listenSecure(8888, sslContext);
    httpServer.get(""/"", new HttpServerRequestCallback() {
        @Override
        public void onRequest(AsyncHttpServerRequest request, AsyncHttpServerResponse response) {
            response.send(""hello"");
        }
    });

    Thread.sleep(1000);

    AsyncHttpClient.getDefaultInstance().getSSLSocketMiddleware().setSSLContext(sslContext);
    AsyncHttpClient.getDefaultInstance().getSSLSocketMiddleware().setTrustManagers(tmf.getTrustManagers());
    AsyncHttpClient.getDefaultInstance().executeString(new AsyncHttpGet(""https://localhost:8888/""), null).get();
}
",3,0,3d90011a9b6aac4c1a872c27bd46560b90cddc5ffb0b8d857261254586d533bb
,"MessageDigest md = MessageDigest.getInstance(""SHA1"");
InputStream in = new FileInputStream(""hereyourinputfilename"");
byte[] buf = new byte[8192];
for (;;) {
    int len = in.read(buf);
    if (len &lt; 0)
        break;
    md.update(buf, 0, len);
}
in.close();
byte[] hash = md.digest();
",,1,03e718d6bea723492eee0284c9d47934309a3314696e019be31026021dd21f22
,"private HttpClient getHttpClient(){
    RegistryBuilder&lt;ConnectionSocketFactory&gt; registryBuilder = RegistryBuilder.&lt;ConnectionSocketFactory&gt; create();
    ConnectionSocketFactory plainSF = new PlainConnectionSocketFactory();
    registryBuilder.register(""http"", plainSF);
    try {
        KeyStore trustStore = KeyStore.getInstance(KeyStore.getDefaultType());
        TrustStrategy anyTrustStrategy = new TrustStrategy() {
            @Override
            public boolean isTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {
                return true;
            }
        };
        SSLContext sslContext = SSLContexts.custom().useTLS().loadTrustMaterial(trustStore, anyTrustStrategy)
                .build();
        LayeredConnectionSocketFactory sslSF = new SSLConnectionSocketFactory(sslContext,
                SSLConnectionSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
        registryBuilder.register(""https"", sslSF);
    } catch (Exception e) {
        throw new RuntimeException(e);
    }
    Registry&lt;ConnectionSocketFactory&gt; registry = registryBuilder.build();
    PoolingHttpClientConnectionManager connManager = new PoolingHttpClientConnectionManager(registry);
    HttpClient httpclient = HttpClientBuilder.create().setConnectionManager(connManager).build();

    return httpclient;
}
",4,0,accd9a6a4a68bf66f808d780eefce496a780717c5f2e28254e03fa751a3c03b9
,"package com.xxx;

import java.security.SecureRandom;

import javax.crypto.Cipher;
import javax.crypto.KeyGenerator;
import javax.crypto.SecretKey;
import javax.crypto.spec.SecretKeySpec;

/**
 * Usage:
 * &lt;pre&gt;
 * String crypto = SimpleCrypto.encrypt(masterpassword, cleartext)
 * ...
 * String cleartext = SimpleCrypto.decrypt(masterpassword, crypto)
 * &lt;/pre&gt;
 * @author ferenc.hechler
 */
public class SimpleCrypto {

    public static String encrypt(String seed, String cleartext) throws Exception {
        byte[] rawKey = getRawKey(seed.getBytes());
        byte[] result = encrypt(rawKey, cleartext.getBytes());
        return toHex(result);
    }

    public static String decrypt(String seed, String encrypted) throws Exception {
        byte[] rawKey = getRawKey(seed.getBytes());
        byte[] enc = toByte(encrypted);
        byte[] result = decrypt(rawKey, enc);
        return new String(result);
    }

    private static byte[] getRawKey(byte[] seed) throws Exception {
        KeyGenerator kgen = KeyGenerator.getInstance(""AES"");
        SecureRandom sr = SecureRandom.getInstance(""SHA1PRNG"", ""Crypto"");
        sr.setSeed(seed);
        kgen.init(128, sr); // 192 and 256 bits may not be available
        SecretKey skey = kgen.generateKey();
        byte[] raw = skey.getEncoded();
        return raw;
    }


    private static byte[] encrypt(byte[] raw, byte[] clear) throws Exception {
        SecretKeySpec skeySpec = new SecretKeySpec(raw, ""AES"");
        Cipher cipher = Cipher.getInstance(""AES"");
        cipher.init(Cipher.ENCRYPT_MODE, skeySpec);
        byte[] encrypted = cipher.doFinal(clear);
        return encrypted;
    }

    private static byte[] decrypt(byte[] raw, byte[] encrypted) throws Exception {
        SecretKeySpec skeySpec = new SecretKeySpec(raw, ""AES"");
        Cipher cipher = Cipher.getInstance(""AES"");
        cipher.init(Cipher.DECRYPT_MODE, skeySpec);
        byte[] decrypted = cipher.doFinal(encrypted);
        return decrypted;
    }

    public static String toHex(String txt) {
        return toHex(txt.getBytes());
    }
    public static String fromHex(String hex) {
        return new String(toByte(hex));
    }

    public static byte[] toByte(String hexString) {
        int len = hexString.length()/2;
        byte[] result = new byte[len];
        for (int i = 0; i &lt; len; i++)
            result[i] = Integer.valueOf(hexString.substring(2*i, 2*i+2), 16).byteValue();
        return result;
    }

    public static String toHex(byte[] buf) {
        if (buf == null)
            return """";
        StringBuffer result = new StringBuffer(2*buf.length);
        for (int i = 0; i &lt; buf.length; i++) {
            appendHex(result, buf[i]);
        }
        return result.toString();
    }
    private final static String HEX = ""0123456789ABCDEF"";
    private static void appendHex(StringBuffer sb, byte b) {
        sb.append(HEX.charAt((b&gt;&gt;4)&amp;0x0f)).append(HEX.charAt(b&amp;0x0f));
    }

}
",4,0,f7eb56209cc37473e4dd9ccc4b697372053796b5b78a7f8ca8f6399fa9fff0e1
,"try {
         PackageInfo info = getPackageManager().getPackageInfo(
         ""my pkg name"",
        /// android.test.purchased
         PackageManager.GET_SIGNATURES);
         for (Signature signature : info.signatures) {
         MessageDigest md = MessageDigest.getInstance(""SHA"");
         md.update(signature.toByteArray());

         Base64.DEFAULT));
         Base64.DEFAULT));
         }
         } catch (NameNotFoundException e) {

         } catch (NoSuchAlgorithmException e) {

         }
",3,0,c9d1e14198b722580d8193ad446ed888c4b1695f91b1777b08a476a35288297d
,"PackageInfo info = getPackageManager().getPackageInfo(
        ""Your Pakage name"", 
        PackageManager.GET_SIGNATURES);
for (Signature signature : info.signatures) {
    MessageDigest md = MessageDigest.getInstance(""SHA"");
    md.update(signature.toByteArray());
    Log.d(""KeyHash:"", Base64.encodeToString(md.digest(), Base64.DEFAULT));
    }
",3,0,2be4204e3197c1cfc7b245884c50f9f478c48a6f8a463d8531e76581547da951
,"MessageDigest sha224 = MessageDigest.getInstance(""SHA-224"");
// etc
",2,0,f2f8328ad563fcd72fc71d04c75fe97307304663f4e0d84daf1d24877807ccf0
,"// Http Client with SSL factory

public HttpClient getNewHttpClient() {
 try {
 KeyStore trustStore = KeyStore.getInstance(KeyStore.getDefaultType());
 trustStore.load(null, null);

 SSLSocketFactory sf = new MySSLSocketFactory(trustStore);
 sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);

 HttpParams params = new BasicHttpParams();
 HttpProtocolParams.setVersion(params, HttpVersion.HTTP_1_1);
 HttpProtocolParams.setContentCharset(params, HTTP.UTF_8);

 SchemeRegistry registry = new SchemeRegistry();
 registry.register(new Scheme(""http"", PlainSocketFactory.getSocketFactory(), 80));
 registry.register(new Scheme(""https"", sf, 443));

 ClientConnectionManager ccm = new ThreadSafeClientConnManager(params, registry);

 return new DefaultHttpClient(ccm, params);
 } catch (Exception e) {
     return new DefaultHttpClient();
 }
}

// Post request for multi part entity

public void postRequest(){

    DefaultHttpClient httpClient = new getNewHttpClient();
    HttpPost postRequest = new HttpPost(url);
    String auth = ""USER_NAME"" + "":"" + ""PASSWORD"";
    byte[] bytes = auth.getBytes();
    postRequest.setHeader(""Authorization"", ""Basic "" + new String(Base64.encodeBytes(bytes)));

    try {
        MultipartEntity mpC = new MultipartEntity();
        FileBody fb = new FileBody(message);
        StringBody sbPicID = new StringBody(fb.getFilename());
        mpC.addPart(""name"", sbPicID);
        mpC.addPart(""file"", fb);
        postRequest.setEntity(mpC);
        HttpResponse res;
        res = httpClient.execute(postRequest);
        BufferedReader rd = new BufferedReader(new InputStreamReader(res.getEntity().getContent()));
        String resPictureId = """";
        resPictureId = rd.readLine();

        Session.put(""PICTURE_""+position, resPictureId);
        res.getEntity().getContent().close();
    }catch (Exception e) {
        // TODO: handle exception
    }

}

// SSL factory class

public class MySSLSocketFactory extends SSLSocketFactory {
    SSLContext sslContext = SSLContext.getInstance(""TLS"");

    public MySSLSocketFactory(KeyStore truststore)
            throws NoSuchAlgorithmException, KeyManagementException,
            KeyStoreException, UnrecoverableKeyException {
        super(truststore);

        TrustManager tm = new X509TrustManager() {
            public void checkClientTrusted(X509Certificate[] chain,
                    String authType) throws CertificateException {
            }

            public void checkServerTrusted(X509Certificate[] chain,
                    String authType) throws CertificateException {
            }

            public X509Certificate[] getAcceptedIssuers() {
                return null;
            }
        };

        sslContext.init(null, new TrustManager[] { tm }, null);
    }

    @Override
    public Socket createSocket(Socket socket, String host, int port,
            boolean autoClose) throws IOException, UnknownHostException {
        return sslContext.getSocketFactory().createSocket(socket, host, port,
                autoClose);
    }

    @Override
    public Socket createSocket() throws IOException {
        return sslContext.getSocketFactory().createSocket();
    }

}
",4,0,cabb684d12d68dc9c8fccc43e8a20e006351c4963e4c915ccbea87b251eab722
,"import java.security.NoSuchAlgorithmException;

import javax.crypto.Cipher;
import javax.crypto.NoSuchPaddingException;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;

public class MCrypt {

    private String iv = ""fedcba9876543210"";//Dummy iv (CHANGE IT!)
    private IvParameterSpec ivspec;
    private SecretKeySpec keyspec;
    private Cipher cipher;

    private String SecretKey = ""0123456789abcdef"";//Dummy secretKey (CHANGE IT!)

    public MCrypt()
    {
        ivspec = new IvParameterSpec(iv.getBytes());

        keyspec = new SecretKeySpec(SecretKey.getBytes(), ""AES"");

        try {
            cipher = Cipher.getInstance(""AES/CBC/NoPadding"");
        } catch (NoSuchAlgorithmException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        } catch (NoSuchPaddingException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }
    }

    public byte[] encrypt(String text) throws Exception
    {
        if(text == null || text.length() == 0)
            throw new Exception(""Empty string"");

        byte[] encrypted = null;

        try {
            cipher.init(Cipher.ENCRYPT_MODE, keyspec, ivspec);

            encrypted = cipher.doFinal(padString(text).getBytes());
        } catch (Exception e)
        {           
            throw new Exception(""[encrypt] "" + e.getMessage());
        }

        return encrypted;
    }

    public byte[] decrypt(String code) throws Exception
    {
        if(code == null || code.length() == 0)
            throw new Exception(""Empty string"");

        byte[] decrypted = null;

        try {
            cipher.init(Cipher.DECRYPT_MODE, keyspec, ivspec);

            decrypted = cipher.doFinal(hexToBytes(code));
        } catch (Exception e)
        {
            throw new Exception(""[decrypt] "" + e.getMessage());
        }
        return decrypted;
    }



    public static String bytesToHex(byte[] data)
    {
        if (data==null)
        {
            return null;
        }

        int len = data.length;
        String str = """";
        for (int i=0; i&lt;len; i++) {
            if ((data[i]&amp;0xFF)&lt;16)
                str = str + ""0"" + java.lang.Integer.toHexString(data[i]&amp;0xFF);
            else
                str = str + java.lang.Integer.toHexString(data[i]&amp;0xFF);
        }
        return str;
    }


    public static byte[] hexToBytes(String str) {
        if (str==null) {
            return null;
        } else if (str.length() &lt; 2) {
            return null;
        } else {
            int len = str.length() / 2;
            byte[] buffer = new byte[len];
            for (int i=0; i&lt;len; i++) {
                buffer[i] = (byte) Integer.parseInt(str.substring(i*2,i*2+2),16);
            }
            return buffer;
        }
    }



    private static String padString(String source)
    {
      char paddingChar = ' ';
      int size = 16;
      int x = source.length() % size;
      int padLength = size - x;

      for (int i = 0; i &lt; padLength; i++)
      {
          source += paddingChar;
      }

      return source;
    }
}
",4,0,94abca264310adf7b07110ebfb1db44ed60dfd9b186551624cfd5ae10919a4c0
,"import java.io.File;

import javax.xml.transform.Source;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerConfigurationException;
import javax.xml.transform.TransformerException;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.TransformerFactoryConfigurationError;
import javax.xml.transform.stream.StreamResult;
import javax.xml.transform.stream.StreamSource;

import android.app.Activity;
import android.os.Bundle;
import android.os.Environment;

public class XsltTester extends Activity {

    private static String TAG = XsltTester.class.getSimpleName();

    /** Called when the activity is first created. */
    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.main);

        try {

            Source xmlSource = new StreamSource(this.getResources().openRawResource(R.raw.weather));
            Source xsltSource = new StreamSource(this.getResources().openRawResource(R.raw.weatherxsl));

            TransformerFactory transFact = TransformerFactory.newInstance();
            Transformer trans = transFact.newTransformer(xsltSource);
//          FileOutputStream fo = new FileOutputStream(f);
//          fo.write(resizeBitMapImageToByteArray(photoAlbumBean));
//          fo.close();
            File f = new File(Environment.getExternalStorageDirectory().getAbsolutePath()+""/mydata.html"");

//            OutputStream output = new StringOutputStream();
            StreamResult result = new StreamResult(f);
            trans.transform(xmlSource, result);

        } catch (TransformerConfigurationException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        } catch (TransformerFactoryConfigurationError e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        } catch (TransformerException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }
    }
}
",,1,9f7d7474b5d926cdbfe833d0330dc53c554ec8a4809ba54af318897dbd3dc9a8
,"KeyStore.PrivateKeyEntry privateKeyEntry = (KeyStore.PrivateKeyEntry) entry;

Cipher output = Cipher.getInstance(""RSA/ECB/PKCS1Padding"");
output.init(Cipher.DECRYPT_MODE, privateKeyEntry.getPrivateKey());
",4,0,e38c3e8c0666b1d96a46bac907779c7cb24f367a29d761e8a3e633cb8a4badcd
,"Button getKeyHash = (Button) findViewById(R.id.button_key_hash);
    getKeyHash.setOnClickListener(new View.OnClickListener() {
        @Override
        public void onClick(View v) {
            //Key Hash
            try {
                PackageInfo packageInfo = getPackageManager().getPackageInfo(getPackageName(),
                        PackageManager.GET_SIGNATURES);
                for (Signature signature : packageInfo.signatures) {
                    MessageDigest md = MessageDigest.getInstance(""SHA"");
                    md.update(signature.toByteArray());
                    Log.d(""KeyHash:"", Base64.encodeToString(md.digest(), Base64.DEFAULT));
                }
            } catch (PackageManager.NameNotFoundException e1) {
                Log.e(""Name not found"", e1.toString());
            } catch (NoSuchAlgorithmException e) {
                Log.e(""No such an algorithm"", e.toString());
            } catch (Exception e) {
                Log.e(""Exception"", e.toString());
            }
        }
    });
",3,0,c17381b3badfadf0d2d5f8ca6e7329d7818cb0035b24c00b484bf7eb05cdabf6
,"public void RSADecrypt(String inFileName, String outFileName) {
        try {
            /* Get the encrypted message from file. */
            FileInputStream cipherfile = new FileInputStream(inFileName);

            byte[] ciphertext = new byte[cipherfile.available()];
            cipherfile.read(ciphertext);
            cipherfile.close();         
            PrivateKey privatekey =readPrivateKeyFromFile(""D:\\Private.key"");

            /* Create cipher for decryption. */
            Cipher decrypt_cipher = Cipher.getInstance(""RSA/ECB/PKCS1Padding"");
            decrypt_cipher.init(Cipher.DECRYPT_MODE, privatekey);
            FileOutputStream plainfile = new FileOutputStream(outFileName);
            int n = ciphertext.length / 128;
            System.out.println(""len: "" + n);
            byte[] data1 = new byte[128];
            for (int i = 0; i &lt; n; i++) {
                for (int j = 0; j &lt; 128; j++) {
                    data1[j] = ciphertext[128 * i + j];
                }
                byte[] descryptedData = decrypt_cipher.doFinal(data1);
                plainfile.write(descryptedData);

            }

            plainfile.close();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
public PrivateKey readPrivateKeyFromFile(String fileName)
            throws IOException {
        FileInputStream fis = null;
        ObjectInputStream ois = null;
        try {
            fis = new FileInputStream(new File(fileName));
            ois = new ObjectInputStream(fis);

            BigInteger modulus = (BigInteger) ois.readObject();
            BigInteger exponent = (BigInteger) ois.readObject();

            // Get Private Key
            RSAPrivateKeySpec rsaPrivateKeySpec = new RSAPrivateKeySpec(
                    modulus, exponent);
            KeyFactory fact = KeyFactory.getInstance(""RSA"");
            PrivateKey privateKey = fact.generatePrivate(rsaPrivateKeySpec);
            System.out.println(""get key ok: "" + privateKey.toString());
            return privateKey;

        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            if (ois != null) {
                ois.close();
                if (fis != null) {
                    fis.close();
                }
            }
        }
        return null;
    }
",3,0,debe264f7abaabe7ce1c22fccae76eba5aaa1e123e234757a433e97916f98f73
,"import java.io.*;
import java.security.KeyStore;

import javax.net.ssl.*;

import org.apache.http.*;
import org.apache.http.client.methods.HttpGet;
import org.apache.http.client.params.HttpClientParams;
import org.apache.http.conn.ClientConnectionManager;
import org.apache.http.conn.params.*;
import org.apache.http.conn.scheme.*;
import org.apache.http.conn.ssl.SSLSocketFactory;
import org.apache.http.impl.client.DefaultHttpClient;
import org.apache.http.impl.conn.tsccm.ThreadSafeClientConnManager;
import org.apache.http.params.*;

import android.app.Activity;
import android.os.Bundle;

public class SslTestActivity extends Activity {

  /** Called when the activity is first created. */
  @Override
  public void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.main);

    try {
      // setup truststore to provide trust for the server certificate

      // load truststore certificate
      InputStream clientTruststoreIs = getResources().openRawResource(R.raw.truststore);
      KeyStore trustStore = null;
      trustStore = KeyStore.getInstance(""BKS"");
      trustStore.load(clientTruststoreIs, ""MyPassword"".toCharArray());

      System.out.println(""Loaded server certificates: "" + trustStore.size());

      // initialize trust manager factory with the read truststore
      TrustManagerFactory trustManagerFactory = null;
      trustManagerFactory = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());
      trustManagerFactory.init(trustStore);

      // setup client certificate

      // load client certificate
      InputStream keyStoreStream = getResources().openRawResource(R.raw.client);
      KeyStore keyStore = null;
      keyStore = KeyStore.getInstance(""BKS"");
      keyStore.load(keyStoreStream, ""MyPassword"".toCharArray());

      System.out.println(""Loaded client certificates: "" + keyStore.size());

      // initialize key manager factory with the read client certificate
      KeyManagerFactory keyManagerFactory = null;
      keyManagerFactory = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());
      keyManagerFactory.init(keyStore, ""MyPassword"".toCharArray());


      // initialize SSLSocketFactory to use the certificates
      SSLSocketFactory socketFactory = null;
      socketFactory = new SSLSocketFactory(SSLSocketFactory.TLS, keyStore, ""MyTestPassword2010"",
          trustStore, null, null);

      // Set basic data
      HttpParams params = new BasicHttpParams();
      HttpProtocolParams.setVersion(params, HttpVersion.HTTP_1_1);
      HttpProtocolParams.setContentCharset(params, ""UTF-8"");
      HttpProtocolParams.setUseExpectContinue(params, true);
      HttpProtocolParams.setUserAgent(params, ""Android app/1.0.0"");

      // Make pool
      ConnPerRoute connPerRoute = new ConnPerRouteBean(12);
      ConnManagerParams.setMaxConnectionsPerRoute(params, connPerRoute);
      ConnManagerParams.setMaxTotalConnections(params, 20);

      // Set timeout
      HttpConnectionParams.setStaleCheckingEnabled(params, false);
      HttpConnectionParams.setConnectionTimeout(params, 20 * 1000);
      HttpConnectionParams.setSoTimeout(params, 20 * 1000);
      HttpConnectionParams.setSocketBufferSize(params, 8192);

      // Some client params
      HttpClientParams.setRedirecting(params, false);

      // Register http/s shemas!
      SchemeRegistry schReg = new SchemeRegistry();
      schReg.register(new Scheme(""http"", PlainSocketFactory.getSocketFactory(), 80));
      schReg.register(new Scheme(""https"", socketFactory, 443));
      ClientConnectionManager conMgr = new ThreadSafeClientConnManager(params, schReg);
      DefaultHttpClient sClient = new DefaultHttpClient(conMgr, params);

      HttpGet httpGet = new HttpGet(""https://server/path/service.wsdl"");
      HttpResponse response = sClient.execute(httpGet);
      HttpEntity httpEntity = response.getEntity();

      InputStream is = httpEntity.getContent();
      BufferedReader read = new BufferedReader(new InputStreamReader(is));
      String query = null;
      while ((query = read.readLine()) != null)
        System.out.println(query);

    } catch (Exception e) {
      e.printStackTrace();
    }
  }

}
",3,0,afe1a1dd4f8345cb816298a60820b6f7cf7b5c36e8eea9d8cdf772c622b5ef52
,"    private static KeyStore loadTrustStore(String[] certificateFilenames) {
        AssetManager assetsManager = GirdersApp.getInstance().getAssets();

        int length = certificateFilenames.length;
        List&lt;Certificate&gt; certificates = new ArrayList&lt;Certificate&gt;(length);
        for (String certificateFilename : certificateFilenames) {
          InputStream is;
          try {
            is = assetsManager.open(certificateFilename, AssetManager.ACCESS_BUFFER);
            Certificate certificate = KeyStoreManager.loadX509Certificate(is);
            certificates.add(certificate);
          } catch (Exception e) {
            throw new RuntimeException(e);
          }
        }

        Certificate[] certificatesArray = certificates.toArray(new Certificate[certificates.size()]);
          return new generateKeystore(certificatesArray);
      }

 /**
   * Generates keystore congaing the specified certificates.
   *
   * @param certificates certificates to add in keystore
   * @return keystore with the specified certificates
   * @throws KeyStoreException if keystore can not be generated.
   */
  public KeyStore generateKeystore(Certificate[] certificates) throws RuntimeException {
      // construct empty keystore
      KeyStore keyStore = KeyStore.getInstance(keyStoreType);

      // initialize keystore
      keyStore.load(null, null);

      // load certificates into keystore
      int length = certificates.length;
      for (int i = 0; i &lt; length; i++) {
        Certificate certificate = certificates[i];
        keyStore.setEntry(String.valueOf(i), new KeyStore.TrustedCertificateEntry(certificate),
            null);
      }
      return keyStore;
  }
",,1,ccfe211d3efc91ae086f9ba0756239cda06b9c55887b325a3505f35af2bcb1ec
,"/**
 * Created by Nevuroth on 1/19/15.
 */
public class CustomX509TrustManager implements X509TrustManager{

private X509TrustManager defaultManager = null;

/**
 * Custom constructor for the x509 trust manager. This workaround won't take away from security, but it will drop and accept the self signed cert for our test server at the
 * end of the cert chain, as well as allowing
 *
 * @param keyStore
 * @throws NoSuchAlgorithmException
 * @throws KeyStoreException
 */
public CustomX509TrustManager(KeyStore keyStore) throws NoSuchAlgorithmException, KeyStoreException{
    super();
    TrustManagerFactory factory = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());
    factory.init(keyStore);
    TrustManager[] trustManagers = factory.getTrustManagers();
    if(trustManagers.length ==0){
        throw new NoSuchAlgorithmException(""Failed to find Default trust managers"");
    }

    this.defaultManager = (X509TrustManager) trustManagers[0];

}


//we just want the standard functionality for x509
@Override
public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {
    defaultManager.checkClientTrusted(x509Certificates, s);
}

/**
 *  Here's where the magic happens, we're going to be compensating for out of order certificates in the X509 header
 *  as well as compensating for self-signed certificates (kind of), by passing the certificate before it in the chain
 *  to the chekc servertrusted method
 *  This won't compensate for purely self-signed certs.... but you can do so by adding it to the accepted issuers method.
 * @param x509Certificates
 * @param s
 * @throws CertificateException
 */

@Override
public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {

    //Clean the certificates and make sure they are in the proper order.
    int chainln = x509Certificates.length;
    if(x509Certificates.length &gt; 1){
        //Clean the chains by matching issuer and subject fields until we can't continue
        int index;
        boolean foundNext;
        for(index=0; index &lt; x509Certificates.length; ++index){
            foundNext = false;
            for(int nextIndex = index + 1; nextIndex &lt; x509Certificates.length; ++nextIndex){
                //look for the next certificate in the chain.
                if(x509Certificates[index].getIssuerDN().equals(x509Certificates[nextIndex].getSubjectDN())){
                    foundNext = true;
                    //exchange certificates so that 0 through index+1 are in proper order.
                    if(nextIndex != index+1){
                        X509Certificate tempCert = x509Certificates[nextIndex];
                        x509Certificates[nextIndex] = x509Certificates[index+1];
                        x509Certificates[index+1] = tempCert;
                    }
                    break;
                }

            }

            if(!foundNext){
                break;
            }

        }

        //if the cert is self signed and if it is expired, if so we drop it and pass the rest to checkServerTrusted, hoping we may have a similar bu unexpired trusted root.
        chainln = index +1;
        X509Certificate lastCert = x509Certificates[chainln - 1];
        Date now = new Date();
        if(lastCert.getSubjectDN().equals(lastCert.getIssuerDN()) &amp;&amp; now.after(lastCert.getNotAfter())){
            --chainln;
        }
    }

    defaultManager.checkServerTrusted(x509Certificates, s);

}

//you can add an accepted issuer
@Override
public X509Certificate[] getAcceptedIssuers() {
    return this.defaultManager.getAcceptedIssuers();
}
}
",3,0,0589c8bfce1178cb495ede4ce4cd070ba760bc59504f189d666b7fb73ffd3f2e
,"/**
 * Created by Nevuroth on 1/19/15.
 */
    public class CustomSSLSocketFactory extends SSLSocketFactory {
SSLContext sslContext = SSLContext.getInstance(""TLS"");


public CustomSSLSocketFactory(KeyStore truststore) throws NoSuchAlgorithmException, KeyManagementException, UnrecoverableKeyException, KeyStoreException {
    super(truststore);

    TrustManager tm = new CustomX509TrustManager(truststore);

    sslContext.init(null, new TrustManager[]{tm}, null);

}

@Override
public Socket createSocket(Socket socket, String host, int port, boolean autoClose) throws IOException {
    return sslContext.getSocketFactory().createSocket(socket, host, port,autoClose);
}

@Override
public Socket createSocket() throws IOException{
    return sslContext.getSocketFactory().createSocket();
}
}
",,1,4342eb8e03b0e138cac3eaa5918ed5bcc929f542f310b4e0aea408648e694dff
,"public HttpClient getNewHttpClient(){
    try{
        KeyStore trustStore = KeyStore.getInstance(KeyStore.getDefaultType());
        trustStore.load(null, null);

        SSLSocketFactory sf = new CustomSSLSocketFactory(trustStore);
        //sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);

        HttpParams params = new BasicHttpParams();
        HttpProtocolParams.setVersion(params, HttpVersion.HTTP_1_1);

        SchemeRegistry registry = new SchemeRegistry();
        registry.register(new Scheme(""http"", PlainSocketFactory.getSocketFactory(),80));
        registry.register(new Scheme(""https"", sf,443));

        ClientConnectionManager ccm = new ThreadSafeClientConnManager(params,registry);

        return new DefaultHttpClient(ccm, params);

    } catch (Exception e) {
        e.printStackTrace();
        //if we get an error here then we need to return something or a fatal network error will occur.
        return new DefaultHttpClient();
    }
}
",3,0,68e901e36a625280e4abfc3a96d0539dbf4254180b1c156f9b79bc9bdb16f0a0
,"import java.security.KeyFactory;
import java.security.KeyPair;
import java.security.KeyPairGenerator;
import java.security.NoSuchAlgorithmException;
import java.security.NoSuchProviderException;
import java.security.PrivateKey;
import java.security.PublicKey;
import java.security.SecureRandom;
import java.security.spec.InvalidKeySpecException;
import java.security.spec.X509EncodedKeySpec;
import org.bouncycastle.util.encoders.Base64;
import android.app.Activity;
import android.content.Context;
import android.content.SharedPreferences;

public class KeyGenerator extends Activity{

    SharedPreferences SP;
    SharedPreferences.Editor SPE;
    PublicKey pubKey;
    PrivateKey privKey; 
    Context context;

    public KeyGenerator(Context context){
        this.context = context;
        SP = context.getSharedPreferences(""KeyPair"", MODE_PRIVATE);
    }

    public void generateKeys(){
        try {
            KeyPairGenerator generator;
            generator = KeyPairGenerator.getInstance(""RSA"", ""BC"");
            generator.initialize(256, new SecureRandom());
            KeyPair pair = generator.generateKeyPair();
            pubKey = pair.getPublic();
            privKey = pair.getPrivate();            
            byte[] publicKeyBytes = pubKey.getEncoded();
            String pubKeyStr = new String(Base64.encode(publicKeyBytes));
            byte[] privKeyBytes = privKey.getEncoded();
            String privKeyStr = new String(Base64.encode(privKeyBytes));            
            SPE = SP.edit();
            SPE.putString(""PublicKey"", pubKeyStr);
            SPE.putString(""PrivateKey"", privKeyStr);           
            SPE.commit();
        } catch (NoSuchAlgorithmException e) {
            e.printStackTrace();
        } catch (NoSuchProviderException e) {
            e.printStackTrace();
        }           
    }
    public PublicKey getPublicKey(){
        String pubKeyStr = SP.getString(""PublicKey"", """");       
        byte[] sigBytes = Base64.decode(pubKeyStr);
        X509EncodedKeySpec x509KeySpec = new X509EncodedKeySpec(sigBytes);
        KeyFactory keyFact = null;
        try {
            keyFact = KeyFactory.getInstance(""RSA"", ""BC"");
        } catch (NoSuchAlgorithmException e) {
            e.printStackTrace();
        } catch (NoSuchProviderException e) {
            e.printStackTrace();
        }
        try {
            return  keyFact.generatePublic(x509KeySpec);
        } catch (InvalidKeySpecException e) {
            e.printStackTrace();
        }
        return null;
    }
    public String getPublicKeyAsString(){
        return SP.getString(""PublicKey"", """");       
    }
    public PrivateKey getPrivateKey(){
        String privKeyStr = SP.getString(""PrivateKey"", """");
        byte[] sigBytes = Base64.decode(privKeyStr);
        X509EncodedKeySpec x509KeySpec = new X509EncodedKeySpec(sigBytes);
        KeyFactory keyFact = null;
        try {
            keyFact = KeyFactory.getInstance(""RSA"", ""BC"");
        } catch (NoSuchAlgorithmException e) {
            e.printStackTrace();
        } catch (NoSuchProviderException e) {
            e.printStackTrace();
        }
        try {
            return  keyFact.generatePrivate(x509KeySpec);
        } catch (InvalidKeySpecException e) {
            e.printStackTrace();
        }
        return null;
    }
    public String getPrivateKeyAsString(){
        return SP.getString(""PrivateKey"", """");      
    }
}
",4,0,8788af997730a435a1d0c3b43b8f296c2235e70ced4f41547536a1ead4e96cc1
,"@EBean(scope = Scope.Singleton)
public class RestInterceptor implements ClientHttpRequestInterceptor {

private int requestCount = 0;

@Pref
MyPrefs_ myPrefs;

private RequestListener mRequestListener;

public interface RequestListener {
    void report(int count);
}

public void setOnRequestListener(RequestListener requestListener) {
    this.mRequestListener = requestListener;
}

public ClientHttpResponse intercept(HttpRequest request, byte[] data, ClientHttpRequestExecution execution)
        throws IOException {

    if (mRequestListener != null) {
        requestCount++;
        mRequestListener.report(requestCount);
    }

    HttpHeaders headers = request.getHeaders();

    long unixTime = System.currentTimeMillis() / 1000L;

    headers.add(""request_time"", String.valueOf(unixTime));

    if (myPrefs.accessToken().exists()) {

        headers.add(""access_token"", myPrefs.accessToken().get());


        String hmacInput; //left this part out but basically do something unique to the request here and do the same on the other side.

        String hmacKey = myPrefs.accessToken().getOr("""");


        try {
            String hmacSig = hmacSha1(hmacInput, hmacKey);

            headers.add(""hmac_sig"", hmacSig);

        }
        catch (InvalidKeyException e) {

            e.printStackTrace();
        }
        catch (NoSuchAlgorithmException e) {

            e.printStackTrace();
        }


    }
    if (myPrefs.userId().exists()) {
        headers.add(""user_id"", String.valueOf(myPrefs.userId().get()));
    }

    headers.add(""api_key"", ""somerandomstring"");

    ClientHttpResponse t = execution.execute(request, data);

    if (mRequestListener != null) {

        requestCount--;
        mRequestListener.report(requestCount);
    }

    return t;
}


public void resetRequestCount() {
    this.requestCount = 0;
}

public static String hmacSha1(String value, String key) throws UnsupportedEncodingException,
        NoSuchAlgorithmException, InvalidKeyException {
    String type = ""HmacSHA1"";
    SecretKeySpec secret = new SecretKeySpec(key.getBytes(), type);
    Mac mac = Mac.getInstance(type);
    mac.init(secret);
    byte[] bytes = mac.doFinal(value.getBytes());
    return bytesToHex(bytes);
}

private final static char[] hexArray = ""0123456789abcdef"".toCharArray();

private static String bytesToHex(byte[] bytes) {
    char[] hexChars = new char[bytes.length * 2];
    int v;
    for (int j = 0; j &lt; bytes.length; j++) {
        v = bytes[j] &amp; 0xFF;
        hexChars[j * 2] = hexArray[v &gt;&gt;&gt; 4];
        hexChars[j * 2 + 1] = hexArray[v &amp; 0x0F];
    }
    return new String(hexChars);
}
",,1,8a211a2536bd67735847164ed927da01298151dc3a4dac493faf0cb9f7b4ae01
,"package com.example.customssl;

import android.content.Context;
import org.apache.http.client.HttpClient;
import org.apache.http.conn.scheme.PlainSocketFactory;
import org.apache.http.conn.scheme.Scheme;
import org.apache.http.conn.scheme.SchemeRegistry;
import org.apache.http.conn.ssl.AllowAllHostnameVerifier;
import org.apache.http.conn.ssl.SSLSocketFactory;
import org.apache.http.impl.client.DefaultHttpClient;
import org.apache.http.impl.conn.tsccm.ThreadSafeClientConnManager;
import org.apache.http.params.BasicHttpParams;
import org.apache.http.params.HttpParams;

import javax.net.ssl.HttpsURLConnection;
import javax.net.ssl.SSLContext;
import javax.net.ssl.TrustManagerFactory;
import java.io.IOException;
import java.io.InputStream;
import java.net.URL;
import java.security.KeyStore;
import java.security.KeyStoreException;
import java.security.NoSuchAlgorithmException;
import java.security.cert.Certificate;
import java.security.cert.CertificateException;
import java.security.cert.CertificateFactory;

public class CustomCAHttpsProvider {

    /**
     * Creates a {@link org.apache.http.client.HttpClient} which is configured to work with a custom authority
     * certificate.
     *
     * @param context       Application Context
     * @param certRawResId  R.raw.id of certificate file (*.crt). Should be stored in /res/raw.
     * @param allowAllHosts If true then client will not check server against host names of certificate.
     * @return Http Client.
     * @throws Exception If there is an error initializing the client.
     */
    public static HttpClient getHttpClient(Context context, int certRawResId, boolean allowAllHosts) throws Exception {


        // build key store with ca certificate
        KeyStore keyStore = buildKeyStore(context, certRawResId);

        // init ssl socket factory with key store
        SSLSocketFactory sslSocketFactory = new SSLSocketFactory(keyStore);

        // skip hostname security check if specified
        if (allowAllHosts) {
            sslSocketFactory.setHostnameVerifier(new AllowAllHostnameVerifier());
        }

        // basic http params for client
        HttpParams params = new BasicHttpParams();

        // normal scheme registry with our ssl socket factory for ""https""
        SchemeRegistry schemeRegistry = new SchemeRegistry();
        schemeRegistry.register(new Scheme(""http"", PlainSocketFactory.getSocketFactory(), 80));
        schemeRegistry.register(new Scheme(""https"", sslSocketFactory, 443));

        // create connection manager
        ThreadSafeClientConnManager cm = new ThreadSafeClientConnManager(params, schemeRegistry);

        // create http client
        return new DefaultHttpClient(cm, params);
    }

    /**
     * Creates a {@link javax.net.ssl.HttpsURLConnection} which is configured to work with a custom authority
     * certificate.
     *
     * @param urlString     remote url string.
     * @param context       Application Context
     * @param certRawResId  R.raw.id of certificate file (*.crt). Should be stored in /res/raw.
     * @param allowAllHosts If true then client will not check server against host names of certificate.
     * @return Http url connection.
     * @throws Exception If there is an error initializing the connection.
     */
    public static HttpsURLConnection getHttpsUrlConnection(String urlString, Context context, int certRawResId,
                                                           boolean allowAllHosts) throws Exception {

        // build key store with ca certificate
        KeyStore keyStore = buildKeyStore(context, certRawResId);

        // Create a TrustManager that trusts the CAs in our KeyStore
        String tmfAlgorithm = TrustManagerFactory.getDefaultAlgorithm();
        TrustManagerFactory tmf = TrustManagerFactory.getInstance(tmfAlgorithm);
        tmf.init(keyStore);

        // Create an SSLContext that uses our TrustManager
        SSLContext sslContext = SSLContext.getInstance(""TLS"");
        sslContext.init(null, tmf.getTrustManagers(), null);

        // Create a connection from url
        URL url = new URL(urlString);
        HttpsURLConnection urlConnection = (HttpsURLConnection) url.openConnection();
        urlConnection.setSSLSocketFactory(sslContext.getSocketFactory());

        // skip hostname security check if specified
        if (allowAllHosts) {
            urlConnection.setHostnameVerifier(new AllowAllHostnameVerifier());
        }

        return urlConnection;
    }

    private static KeyStore buildKeyStore(Context context, int certRawResId) throws KeyStoreException, CertificateException, NoSuchAlgorithmException, IOException {
        // init a default key store
        String keyStoreType = KeyStore.getDefaultType();
        KeyStore keyStore = KeyStore.getInstance(keyStoreType);
        keyStore.load(null, null);

        // read and add certificate authority
        Certificate cert = readCert(context, certRawResId);
        keyStore.setCertificateEntry(""ca"", cert);

        return keyStore;
    }

    private static Certificate readCert(Context context, int certResourceId) throws CertificateException, IOException {

        // read certificate resource
        InputStream caInput = context.getResources().openRawResource(certResourceId);

        Certificate ca;
        try {
            // generate a certificate
            CertificateFactory cf = CertificateFactory.getInstance(""X.509"");
            ca = cf.generateCertificate(caInput);
        } finally {
            caInput.close();
        }

        return ca;
    }

}
",4,0,f3f7f57f47707445429673910a34b8ac0c3ed2173cb4aa8cd6a8e19631949767
,"public void storeRSAPublicKey(String alias, BigInteger modulus, BigInteger exponent) 
{
    /** Load the key to generate the certificate */
    KeyStore ks = getApplicationKeyStore();
    KeyStore.PrivateKeyEntry entry = (KeyStore.PrivateKeyEntry)ks.getEntry(MY_PRIVATE_KEY, null);
    X509Certificate issuerCert = (X509Certificate)entry.getCertificate();
    PrivateKey skey = entry.getPrivateKey();

    /** Prepare the certificate template */
    RSAKeyParameters params = new RSAKeyParameters(false, modulus, exponent);
    SubjectPublicKeyInfo pkInfo = SubjectPublicKeyInfoFactory.SubjectPublicKeyInfo(params);
    X500Name issuer = new X500Name(issuerCert.getIssuerX500Principal().getName());
    X500Name subject = new X500Name(""CN=alias"");
    X509v3CertificateBuilder builder = new X509v3CertificateBuilder(issuer, randomSeriaNumber(), new Date(), dateIn20years(), subject, pkInfo);

    /** Generate the certificate */
    JcaContentSignerBuilder csBuilder = new JcaContentSignerBuilder(""SHA256withRSA"");
    ContentSigner signer = csBuilder.build(skey);
    X509CertificateHolder holder = builder.build(signer);

    /** Store the certificate in the KeyStore */
    JcaX509CertificateConverter conv = new JcaX509CertificateConverter();
    X509Certificate cert = conv.getCertificate(holder);
    ks.setCertificateEntry(alias, cert);
    pushKeyStoreToPersistentStorage(ks);
",2,0,c13f0c069e3b406fa94e0f0a4747fcbfcda53cf865ce7a3e469c7c43f0815b59
,"try {
    PackageInfo info = getPackageManager().getPackageInfo(
            ""YOUR_PACKAGE_NAME"", PackageManager.GET_SIGNATURES);
    for (Signature signature: info.signatures)  {
        MessageDigest md = MessageDigest.getInstance(""SHA"");
        md.update(signature.toByteArray());
        Log.e(""FACEBOOK APP SIGNATURE"", Base64.encodeToString(md.digest(), Base64.DEFAULT));
    }
} catch (Exception e) {
    // TODO: handle exception
    e.printStackTrace();
}
",3,0,374c4c1f4bf4908f880646ab3de700a0c1f161d6e0cdb6dd3f720912e1a51201
,"    private TrustManager[] trustAllCerts = new TrustManager[] { new X509TrustManager()
    {
        public java.security.cert.X509Certificate[] getAcceptedIssuers()
        {
            return null;
        }

        public void checkClientTrusted(java.security.cert.X509Certificate[] certs, String authType)
        {

        }

        public void checkServerTrusted(java.security.cert.X509Certificate[] certs, String authType)
        {

        }
    }
};
",4,0,f2fda56f4119824d2c8dded6ff275414f2d9c6462d80f378846f409df2b53229
,"            SSLContext sc = SSLContext.getInstance(""TLS"");
            sc.init(null, trustAllCerts, new java.security.SecureRandom());
            HttpsURLConnection.setDefaultSSLSocketFactory(sc.getSocketFactory());
",,1,b96df73b212c05746d43a5a32deb2de48352b31e46cc6ddde7d7bfc616b46f9a
,"public static DefaultHttpClient generateHttpClient(){
        HttpParams params = new BasicHttpParams();
        HttpConnectionParams.setConnectionTimeout(params, TIMEOUT_CONNECTION);
        HttpConnectionParams.setSoTimeout(params, TIMEOUT_SOCKET);
        SchemeRegistry registry = new SchemeRegistry();
        registry.register(new Scheme(""http"", PlainSocketFactory.getSocketFactory(), 80));

        try{


KeyStore trustStore = KeyStore.getInstance(KeyStore.getDefaultType());
        trustStore.load(null, null);

        SSLSocketFactory sf = new EasySSLSocketFactory(trustStore);
        sf.setHostnameVerifier(
               SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
        registry.register(new Scheme(""https"", sf, 443));
    }catch (Exception e) {
        e.printStackTrace();
    }

//      params.setParameter(CoreProtocolPNames.PROTOCOL_VERSION,             HttpVersion.HTTP_1_1);
    ClientConnectionManager cm = new ThreadSafeClientConnManager(params, registry);
    DefaultHttpClient client = new DefaultHttpClient(cm, params);
    client.setKeepAliveStrategy(new ConnectionKeepAliveStrategy() { 
        @Override 
        public long getKeepAliveDuration(HttpResponse response, HttpContext 
    context) { 
            return 60; // seconds 
        } 

    }); 

    return client;

}
",4,0,b351b37c1180fe706815bf4d5dda79151371be55cdefc0213d3c95bccfa0d7dd
,"import java.io.IOException;
import java.net.Socket;
import java.net.UnknownHostException;
import java.security.KeyManagementException;
import java.security.KeyStore;
import java.security.KeyStoreException;
import java.security.NoSuchAlgorithmException;
import java.security.UnrecoverableKeyException;
import java.security.cert.CertificateException;
import java.security.cert.X509Certificate;

import javax.net.ssl.SSLContext;
import javax.net.ssl.TrustManager;
import javax.net.ssl.X509TrustManager;

import org.apache.http.conn.ssl.SSLSocketFactory;
public class EasySSLSocketFactory extends SSLSocketFactory {
        SSLContext sslContext = SSLContext.getInstance(""TLS"");

        public EasySSLSocketFactory(KeyStore truststore)
                        throws NoSuchAlgorithmException, KeyManagementException,
                        KeyStoreException, UnrecoverableKeyException {
                super(truststore);



  TrustManager tm = new X509TrustManager() {
                    public void checkClientTrusted(X509Certificate[] chain,
                                    String authType) throws CertificateException {
                    }

                    public void checkServerTrusted(X509Certificate[] chain,
                                    String authType) throws CertificateException {
                    }

                    public X509Certificate[] getAcceptedIssuers() {
                            return null;
                    }
            };

            sslContext.init(null, new TrustManager[] { tm }, null);
    }

    @Override
    public Socket createSocket(Socket socket, String host, int port,
                    boolean autoClose) throws IOException, UnknownHostException {
            return sslContext.getSocketFactory().createSocket(socket, host, port,
                            autoClose);
    }

    @Override
    public Socket createSocket() throws IOException {
            return sslContext.getSocketFactory().createSocket();
    }
",4,0,587dde130be53c0f4d29669e6e65509a4abae30c8e06a5004f799fa79c2126f5
,"OkHttpClient client = new OkHttpClient();
        try {
            KeyStore keyStore = SSLUtils.getKeyStore(applicationContext);
            SSLContext sslContext = SSLContext.getInstance(""SSL"");
            TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());
            trustManagerFactory.init(keyStore);
            sslContext.init(null,trustManagerFactory.getTrustManagers(), new SecureRandom());
            client.setSslSocketFactory(sslContext.getSocketFactory());
        } catch (Exception e) {
            Log.d(""AppName"", ""cannot create http client"", e);
        }
",3,0,e11f28aca83fde3435ef8ad171be0856a78ee9d9dc1d331c593ce5988f65e8af
,"import android.content.Context;
import android.content.res.AssetManager;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.InputStream;
import java.security.KeyStore;
import java.security.cert.Certificate;
import java.security.cert.CertificateFactory;
import java.security.cert.X509Certificate;

public class SSLUtils {

    private static final Logger LOG = LoggerFactory.getLogger(SSLUtils.class.getSimpleName());

    public static KeyStore getKeyStore(Context context) {
        KeyStore keyStore = null;
        try {
            AssetManager assetManager = context.getAssets();
            CertificateFactory cf = CertificateFactory.getInstance(""X.509"");
            InputStream caInput = assetManager.open(""cert.pem"");
            Certificate ca;
            try {
                ca = cf.generateCertificate(caInput);
                LOG.debug(""ca={}"", ((X509Certificate) ca).getSubjectDN());
            } finally {
                caInput.close();
            }

            String keyStoreType = KeyStore.getDefaultType();
            keyStore = KeyStore.getInstance(keyStoreType);
            keyStore.load(null, null);
            keyStore.setCertificateEntry(""ca"", ca);
        } catch (Exception e) {
            LOG.error(""Error during getting keystore"", e);
        }
        return keyStore;
    }
}
",,1,74c57a1cce68cd4884d18bd8ddc86062f63f211f5f7eb1e76178020a2c160384
,"/******************************for https request***********************************************/
    private HttpClient sslClient(HttpClient client) {
        try {
            X509TrustManager tm = new X509TrustManager() { 
                public void checkClientTrusted(X509Certificate[] xcs, String string) throws CertificateException {
                }

                public void checkServerTrusted(X509Certificate[] xcs, String string) throws CertificateException {
                }

                public X509Certificate[] getAcceptedIssuers() {
                    return null;
                }
            };
            SSLContext ctx = SSLContext.getInstance(getString(R.string.tls));
            ctx.init(null, new TrustManager[]{tm}, null);
            SSLSocketFactory ssf = new MySSLSocketFactory(ctx);
            ssf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
            ClientConnectionManager ccm = client.getConnectionManager();
            SchemeRegistry sr = ccm.getSchemeRegistry();
            sr.register(new Scheme(getString(R.string.https), ssf, 443));
            return new DefaultHttpClient(ccm, client.getParams());
        } catch (Exception ex) {
            return null;
        }
    }
    public class MySSLSocketFactory extends SSLSocketFactory {
        SSLContext sslContext = SSLContext.getInstance(getString(R.string.tls));

        public MySSLSocketFactory(KeyStore truststore) throws NoSuchAlgorithmException, KeyManagementException, KeyStoreException, UnrecoverableKeyException {
            super(truststore);

            TrustManager tm = new X509TrustManager() {
                public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {
                }

                public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {
                }

                public X509Certificate[] getAcceptedIssuers() {
                    return null;
                }
            };

            sslContext.init(null, new TrustManager[] { tm }, null);
        }

        public MySSLSocketFactory(SSLContext context) throws KeyManagementException, NoSuchAlgorithmException, KeyStoreException, UnrecoverableKeyException {
            super(null);
            sslContext = context;
        }

        @Override
        public Socket createSocket(Socket socket, String host, int port, boolean autoClose) throws IOException, UnknownHostException {
            return sslContext.getSocketFactory().createSocket(socket, host, port, autoClose);
        }

        @Override
        public Socket createSocket() throws IOException {
            return sslContext.getSocketFactory().createSocket();
        }
    }
    /**********************************end********************************************/
",4,0,e2038620936b6f63cc7e5bb7574765911c72eb6d80b7313f9f9baa8f6e817cf1
,"Cipher c = Cipher.getInstance(""ARC4"");
c.init(Cipher.DECRYPT_MODE, new SecretKeySpec(""BrianIsInTheKitchen"".getBytes(), ""ARC4""));
",3,0,71e9ca201bdcb75a03f8b50ca39d1fa86f0e1cd1954087833e65f57e41a1a209
,"import java.io.UnsupportedEncodingException;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;

//import javax.xml.bind.DatatypeConverter;
import android.util.Base64;


public class Support {

    private static final String SALT = ""3D5900AE-111A-45BE-96B3-D9E4606CA793"";
    private static final int MAX_HASH_ITERATIONS = 10;

    public static void main(String[] args) throws NoSuchAlgorithmException, UnsupportedEncodingException {
        String result = Support.GetPasswordHash(""test"");
        System.out.println(result);
    }

    public static String GetPasswordHash(String plaintextPassword) throws NoSuchAlgorithmException, UnsupportedEncodingException {
        String hashData = plaintextPassword;
        for (int hashLimit = 0; hashLimit &lt; MAX_HASH_ITERATIONS; hashLimit++) {
            hashData = GetHash(SALT + hashData);
        }
        return hashData;
    }

    //Gets the hash value of the data using SHA512Managed
    private static String GetHash(String unhashedData) throws NoSuchAlgorithmException, UnsupportedEncodingException {
        return getMD5Password(unhashedData);
    }

    //Verifies the hash
    public static boolean VerifyHashedPassword(String plaintextPassword, String encryptedPassword) throws NoSuchAlgorithmException, UnsupportedEncodingException {
        String hashData = GetPasswordHash(plaintextPassword);
        return encryptedPassword.equals(hashData);
    }


    public static String getMD5Password(String password) throws NoSuchAlgorithmException, UnsupportedEncodingException{
        MessageDigest digest = java.security.MessageDigest.getInstance(""SHA-512""); 
        digest.update(password.getBytes(""UTF-16LE"")); 
        byte messageDigest[] = digest.digest();

        StringBuilder sb = new StringBuilder();
        for(int iPos = 0; iPos &lt; messageDigest.length; iPos++) {
            String h = Integer.toHexString(0xFF &amp; messageDigest[iPos]);
            while (h.length() &lt; 2) {
                h = ""0"" + h;
            }
            sb.append(h);
        }

        String md5String = sb.toString().toUpperCase();     
        String res = Base64.encodeToString(md5String.getBytes(), Base64.DEFAULT);

        return res;
    }
}
",2,0,328ec332d2cf57b673e37d858b540901ff5299fbb4ca18fd0b7900629c87c2ae
,"@Override
public void onCreate() {
    super.onCreate();

    printHashKey();
}

public void printHashKey(){

    try {
        PackageInfo info = getPackageManager().getPackageInfo(
                ""com.parakhidevelopers.happydays"",
                PackageManager.GET_SIGNATURES);
        for (Signature signature : info.signatures) {
            MessageDigest md = MessageDigest.getInstance(""SHA"");
            md.update(signature.toByteArray());
            Log.d(""Key Hash:"", Base64.encodeToString(md.digest(), Base64.DEFAULT));
        }
    } catch (PackageManager.NameNotFoundException e) {

    } catch (NoSuchAlgorithmException e) {

    }
}
",3,0,2842226c480a2ffdcd9b764d7d48c3572f1f8518bab17879e0d60c77e451be0d
,"/**
 * This method is used to encrypt a string value.
 * 
 * @param text
 *          - string value to be encrypted.
 *          
 * @return result(encrypted string) as String
 * 
 * @throws Exception
 * 
 */
@TargetApi(8)
public static String encrytData(String text) throws Exception {

    Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS7Padding"");
    byte[] static_key = Constants.AES_KEY.getBytes();

    SecretKeySpec keySpec = new SecretKeySpec(static_key, ""AES"");
    IvParameterSpec ivSpec = new IvParameterSpec(Constants.IV_VECTOR);
    cipher.init(Cipher.ENCRYPT_MODE, keySpec, ivSpec);

    byte[] results = cipher.doFinal(text.getBytes());

    String result = Base64.encodeToString(results, Base64.NO_WRAP|Base64.DEFAULT);
    return result;

}

/**
 * This method is used to decrypt a string value.
 * 
 * @param text
 *          - string value to be decrypted.
 * @return result(decrypted string) as String
 * 
 * @throws Exception
 */
@SuppressLint(""NewApi"")
public static String decryptData(String text)throws Exception{

    byte[] encryted_bytes = Base64.decode(text, Base64.DEFAULT);

    Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS7Padding"");
    byte[] static_key = Constants.AES_KEY.getBytes();

    SecretKeySpec keySpec = new SecretKeySpec(static_key, ""AES"");
    IvParameterSpec ivSpec = new IvParameterSpec(Constants.IV_VECTOR);
    cipher.init(Cipher.DECRYPT_MODE, keySpec, ivSpec);

    byte[] decrypted = cipher.doFinal(encryted_bytes);
    String result = new String(decrypted);

    return result;
}
",4,0,b2a92485e72b3ed6a382526ed7d71d1ced0caca92deda398bdc3729c6bf7c8dc
,"public X509Certificate[] getAcceptedIssuers()
{
    X509Certificate[] trustedAnchors =
        super.getAcceptedIssuers();

    /* Create a new array with room for an additional trusted certificate. */
    X509Certificate[] myTrustedAnchors = new X509Certificate[trustedAnchors.length + 1];
    System.arraycopy(trustedAnchors, 0, myTrustedAnchors, 0, trustedAnchors.length);  

    /* Load your certificate.

       Thanks to http://stackoverflow.com/questions/11857417/x509trustmanager-override-without-allowing-all-certs
       for this bit.
     */
    InputStream inStream = new FileInputStream(""fileName-of-cert"");
    CertificateFactory cf = CertificateFactory.getInstance(""X.509"");
    X509Certificate cert = (X509Certificate)cf.generateCertificate(inStream);
    inStream.close();

    /* Add your anchor cert as the last item in the array. */
    myTrustedAnchors[trustedAnchors.length] = cert;

    return myTrustedAnchors;
}
",2,0,57362bee35f0b973d77665e503280d576f6e2f442f3533b89aebf32d539a58be
,"WifiConfiguration wc = new WifiConfiguration();
wc.SSID = ""\""your_ssid\"""";
wc.allowedKeyManagement.set(KeyMgmt.WPA_EAP);
wc.allowedKeyManagement.set(KeyMgmt.IEEE8021X);
wc.enterpriseConfig.setEapMethod(Eap.TLS);
wc.status = WifiConfiguration.Status.ENABLED;

...

KeyStore pkcs12ks = KeyStore.getInstance(""pkcs12"");

in = new BufferedInputStream(new FileInputStream(new File(""/path/to/your.p12"")));
// alternatively you can read from any input stream, e.g. ByteArrayInputStream to read from String

pkcs12ks.load(in, ""pasword"".toCharArray());

Enumeration&lt;String&gt; aliases = pkcs12ks.aliases();
while (aliases.hasMoreElements()) {
    String alias = aliases.nextElement();
    Log.d(TAG, ""Processing alias "" + alias);

    X509Certificate cert = (X509Certificate) pkcs12ks.getCertificate(alias);
    Log.d(TAG, cert.toString());

    PrivateKey key = (PrivateKey) pkcs12ks.getKey(alias, ""password"".toCharArray());
    Log.d(TAG, key.toString());

    wc.enterpriseConfig.setClientKeyEntry(key, cert);
    wc.enterpriseConfig.setIdentity(""WiFi-1"");
}

...

int netID = wifiManager.addNetwork(wc);
wifiManager.saveConfiguration();
wifiManager.enableNetwork(netID, true);
",,1,1fde7132906d1d73d7ba0896eaa0d5093287f942e3d68150474be5cb9196872b
,"public void decrypt(String filename) throws Exception {
    BufferedInputStream bis = new BufferedInputStream(new FileInputStream(""filename""));
    Base64InputStream base64Stream = new Base64InputStream(bis, 0);
    Cipher c = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
    CipherInputStream cis = new CipherInputStream(base64Stream, c);
    byte[] plainBuf = new byte[2048];
    int nRead;
    while ((nRead = cis.read(plainBuf)) &gt; 0) {
        // send plainBuf[0] through plainBuf[nRead-1] to the video codec
    }
    cis.close();
}
",2,0,b96cfe15514d8920eb015bfd32c4cdd5d094f0d3fad5605e509379bbd70efb47
,"KeyStore keyStoreFile = KeyStore.getInstance(KeyStore.getDefaultType());
keyStoreFile.load(resources.getAssets().open(""snapzkeystore.bks""), password);
",,1,3e188fb82f8ee48a02b9e68f009c87d7ec977fbedaca566fe42c2f9aaceffcb5
,"public static void showHashKey(Context context) {
    try {
        PackageInfo info = context.getPackageManager().getPackageInfo(
                ""com.example.project"", PackageManager.GET_SIGNATURES); //Your package name here
        for (Signature signature : info.signatures) {
            MessageDigest md = MessageDigest.getInstance(""SHA"");
            md.update(signature.toByteArray());
            Log.v(""KeyHash:"", Base64.encodeToString(md.digest(), Base64.DEFAULT));
            }
    } catch (NameNotFoundException e) {
    } catch (NoSuchAlgorithmException e) {
    }
}
",3,0,c1418dfca9199c0a90fdadc14e351852250e8e21515de1bb3cdcc7135ad63ff2
,"try {
    PackageInfo info = getPackageManager().getPackageInfo(
            ""your application package name"",
            PackageManager.GET_SIGNATURES);
    for (Signature signature : info.signatures) {
        MessageDigest md = MessageDigest.getInstance(""SHA"");
        md.update(signature.toByteArray());
        Log.d(""KeyHash:"", Base64.encodeToString(md.digest(), Base64.DEFAULT));
    }
} catch (NameNotFoundException e) {

} catch (NoSuchAlgorithmException e) {

}
",3,0,c34cb6d5ce10c066b2c5e6a3f752c0b90e41b76e6c8c2a6a6b230f460b55ecb0
,"private static byte[] keyValue = new byte[]{ 'W', 'e', 'l', 'c', 'o', 'm', 'e','t', 'o', 'e', 'n','c', 'r', 'y', 'p', 't' };

private String seedWith16Chars = new String(keyValue);
private String textToEncrypt = ""1"";

private TextView seed;
private TextView text;
private TextView encryptedValue;
private TextView decryptedValue;


@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_main);

    seed = (TextView) findViewById(R.id.seedName);
    seed.setText(seedWith16Chars);

    text = (TextView) findViewById(R.id.textToEncrypt);
    text.setText(textToEncrypt);

    encryptedValue = (TextView) findViewById(R.id.encryptedText);
    decryptedValue = (TextView) findViewById(R.id.decryptedText);

    try {
        // This value was got when did run it from an 2.3.3 device a Galaxy SII running Android 4.0.4
        String encrypted = """";

        // Uncomment the line bellow and comment the line above to run it on an Android 4.1.2 or older.
        // String encrypted = EncodeDecodeAES.encrypt(seedWith16Chars, textToEncrypt);
        Log.e(""Encrypt"", encrypted);
        encrypted = encrypt(textToEncrypt);//EncodeDecodeAES.encrypt(seedWith16Chars, textToEncrypt);
        encryptedValue.setText(""Encrypt ""+encrypted);

        String decrypted = decrypt(encrypted);//EncodeDecodeAES.decrypt(seedWith16Chars, encrypted);
        decryptedValue.setText(""Decrypt ""+decrypted);
        Log.e(""Decrypt"", decrypted);
    } catch (Exception e) {
        Log.e(""Exception"", e.getLocalizedMessage());
    }

}

public static String encrypt(String Data) throws Exception {
    Key key = generateKey();
    Cipher c = Cipher.getInstance(""AES"");
    c.init(Cipher.ENCRYPT_MODE, key);
    byte[] encVal = c.doFinal(Data.getBytes());
    String encryptedValue = Base64.encodeToString(encVal, 0);
    return encryptedValue;
}

public static String decrypt(String encryptedData) throws Exception {
    Key key = generateKey();
    Cipher c = Cipher.getInstance(""AES"");
    c.init(Cipher.DECRYPT_MODE, key);
    byte[] decordedValue = Base64.decode(encryptedData, 0);
    byte[] decValue = c.doFinal(decordedValue);
    String decryptedValue = new String(decValue);
    return decryptedValue;
}
private static Key generateKey() throws Exception {
    Key key = new SecretKeySpec(keyValue, ""AES"");
    return key;
}
",4,0,917304df99bb597093210043996ab36e82d64b36a46651c85ce9de05ed4d5c33
,"public static  HttpClient getNewHttpClient() {
    try {
        KeyStore trustStore = KeyStore.getInstance(KeyStore.getDefaultType());
        trustStore.load(null, null);

        SSLSocketFactory sf = new MySSLSocketFactory(trustStore);
        sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);

        HttpParams params = new BasicHttpParams();
        HttpProtocolParams.setVersion(params, HttpVersion.HTTP_1_1);
        HttpProtocolParams.setContentCharset(params, HTTP.UTF_8);

        SchemeRegistry registry = new SchemeRegistry();
        registry.register(new Scheme(""http"", PlainSocketFactory.getSocketFactory(), 80));
        registry.register(new Scheme(""https"", sf, 443));

        ClientConnectionManager ccm = new ThreadSafeClientConnManager(params, registry);

        return new DefaultHttpClient(ccm, params);
    } catch (Exception e) {
        return new DefaultHttpClient();
    }
}
",4,0,301446cc89bd719134daced1c5d0c02fc59a5a5e28673fb4082c8e62ffeab38a
,"public static final String md5(final String s) {
try {
    // Create MD5 Hash
    MessageDigest digest = java.security.MessageDigest
            .getInstance(""MD5"");
    digest.update(s.getBytes());
    byte messageDigest[] = digest.digest();

    // Create Hex String
    StringBuffer hexString = new StringBuffer();
    for (int i = 0; i &lt; messageDigest.length; i++) {
        String h = Integer.toHexString(0xFF &amp; messageDigest[i]);
        while (h.length() &lt; 2)
            h = ""0"" + h;
        hexString.append(h);
    }
    return hexString.toString();

} catch (NoSuchAlgorithmException e) {
    e.printStackTrace();
}
return """";
}
",,1,39691565f5321d693c2b1c142a677e6387f20ca32ce49bb0fef98534ac723d15
,"public class ECDHPub {

    private static ECPublicKey decodeECPublicKey(ECParameterSpec params,
            final byte[] pubkey) throws NoSuchAlgorithmException,
            InvalidKeySpecException {
        int keySizeBytes = params.getOrder().bitLength() / Byte.SIZE;

        int offset = 0;
        BigInteger x = new BigInteger(1, Arrays.copyOfRange(pubkey, offset,
                offset + keySizeBytes));
        offset += keySizeBytes;
        BigInteger y = new BigInteger(1, Arrays.copyOfRange(pubkey, offset,
                offset + keySizeBytes));
        ECPoint w = new ECPoint(x, y);

        ECPublicKeySpec otherKeySpec = new ECPublicKeySpec(w, params);
        KeyFactory keyFactory = KeyFactory.getInstance(""EC"");
        ECPublicKey otherKey = (ECPublicKey) keyFactory
                .generatePublic(otherKeySpec);
        return otherKey;
    }

    private static byte[] encodeECPublicKey(ECPublicKey pubKey) {
        int keyLengthBytes = pubKey.getParams().getOrder().bitLength()
                / Byte.SIZE;
        byte[] publicKeyEncoded = new byte[2 * keyLengthBytes];

        int offset = 0;

        BigInteger x = pubKey.getW().getAffineX();
        byte[] xba = x.toByteArray();
        if (xba.length &gt; keyLengthBytes + 1 || xba.length == keyLengthBytes + 1
                &amp;&amp; xba[0] != 0) {
            throw new IllegalStateException(
                    ""X coordinate of EC public key has wrong size"");
        }

        if (xba.length == keyLengthBytes + 1) {
            System.arraycopy(xba, 1, publicKeyEncoded, offset, keyLengthBytes);
        } else {
            System.arraycopy(xba, 0, publicKeyEncoded, offset + keyLengthBytes
                    - xba.length, xba.length);
        }
        offset += keyLengthBytes;

        BigInteger y = pubKey.getW().getAffineY();
        byte[] yba = y.toByteArray();
        if (yba.length &gt; keyLengthBytes + 1 || yba.length == keyLengthBytes + 1
                &amp;&amp; yba[0] != 0) {
            throw new IllegalStateException(
                    ""Y coordinate of EC public key has wrong size"");
        }

        if (yba.length == keyLengthBytes + 1) {
            System.arraycopy(yba, 1, publicKeyEncoded, offset, keyLengthBytes);
        } else {
            System.arraycopy(yba, 0, publicKeyEncoded, offset + keyLengthBytes
                    - yba.length, yba.length);
        }

        return publicKeyEncoded;
    }

    public static void main(String[] args) throws Exception {

        // (only) required for named curves other than those used in JCE
        Security.addProvider(new BouncyCastleProvider());

        // create local and remote key
        KeyPairGenerator kpgen = KeyPairGenerator.getInstance(""ECDH"", ""BC"");
        ECGenParameterSpec genspec = new ECGenParameterSpec(""brainpoolp256r1"");
        kpgen.initialize(genspec);
        KeyPair localKeyPair = kpgen.generateKeyPair();
        KeyPair remoteKeyPair = kpgen.generateKeyPair();

        // test generation
        byte[] encodedRemotePublicKey = encodeECPublicKey((ECPublicKey) remoteKeyPair
                .getPublic());
        // test creation
        ECPublicKey remoteKey = decodeECPublicKey(
                ((ECPublicKey) localKeyPair.getPublic()).getParams(),
                encodedRemotePublicKey);

        // local key agreement
        KeyAgreement localKA = KeyAgreement.getInstance(""ECDH"");
        localKA.init(localKeyPair.getPrivate());
        localKA.doPhase(remoteKey, true);
        byte[] localSecret = localKA.generateSecret();

        // remote key agreement
        KeyAgreement remoteKA = KeyAgreement.getInstance(""ECDH"");
        remoteKA.init(remoteKeyPair.getPrivate());
        remoteKA.doPhase((ECPublicKey) localKeyPair.getPublic(), true);
        byte[] remoteSecret = localKA.generateSecret();

        // validation
        System.out.println(Arrays.equals(localSecret, remoteSecret));
    }
}
",2,0,38ccc8c930b67797cc6f4297b142a0a0f68f8514c6723f3ddace69c685262003
,"private final static String ALGORITM = ""Blowfish"";
private final static String KEY = ""2356a3a42ba5781f80a72dad3f90aeee8ba93c7637aaf218a8b8c18c"";
private final static String PLAIN_TEXT = ""here is your text"";

public void run(View v) {

    try {

        byte[] encrypted = encrypt(KEY, PLAIN_TEXT);
        Log.i(""FOO"", ""Encrypted: "" + bytesToHex(encrypted));

        String decrypted = decrypt(KEY, encrypted);
        Log.i(""FOO"", ""Decrypted: "" + decrypted);

    } catch (GeneralSecurityException e) {
        e.printStackTrace();
    }
}

private byte[] encrypt(String key, String plainText) throws GeneralSecurityException {

    SecretKey secret_key = new SecretKeySpec(key.getBytes(), ALGORITM);

    Cipher cipher = Cipher.getInstance(ALGORITM);
    cipher.init(Cipher.ENCRYPT_MODE, secret_key);

    return cipher.doFinal(plainText.getBytes());
}

private String decrypt(String key, byte[] encryptedText) throws GeneralSecurityException {

    SecretKey secret_key = new SecretKeySpec(key.getBytes(), ALGORITM);

    Cipher cipher = Cipher.getInstance(ALGORITM);
    cipher.init(Cipher.DECRYPT_MODE, secret_key);

    byte[] decrypted = cipher.doFinal(encryptedText);

    return new String(decrypted);
}

public static String bytesToHex(byte[] data) {

    if (data == null)
        return null;

    String str = """";

    for (int i = 0; i &lt; data.length; i++) {
        if ((data[i] &amp; 0xFF) &lt; 16)
            str = str + ""0"" + java.lang.Integer.toHexString(data[i] &amp; 0xFF);
        else
            str = str + java.lang.Integer.toHexString(data[i] &amp; 0xFF);
    }

    return str;

}
",4,0,2b10bc085dc316c9cd699bea7ced581d4c83eef3d051ea6eb1aa40c301737815
,"  public static class NukeSSLCerts {
    protected static final String TAG = ""NukeSSLCerts"";

    public static void nuke() {
        try {
            TrustManager[] trustAllCerts = new TrustManager[]{
                    new X509TrustManager() {
                        public X509Certificate[] getAcceptedIssuers() {
                            X509Certificate[] myTrustedAnchors = new X509Certificate[0];
                            return myTrustedAnchors;
                        }

                        @Override
                        public void checkClientTrusted(X509Certificate[] certs, String authType) {
                        }

                        @Override
                        public void checkServerTrusted(X509Certificate[] certs, String authType) {
                        }
                    }
            };

            SSLContext sc = SSLContext.getInstance(""SSL"");
            sc.init(null, trustAllCerts, new SecureRandom());
            HttpsURLConnection.setDefaultSSLSocketFactory(sc.getSocketFactory());
            HttpsURLConnection.setDefaultHostnameVerifier(new HostnameVerifier() {
                @Override
                public boolean verify(String arg0, SSLSession arg1) {
                    return true;
                }
            });
        } catch (Exception e) {
        }
    }
}
",4,0,bb51091d8c14615ee31026f9c9b8d19b800c1f87c96bf74f158d18e278c1170d
,"    public static String printKeyHash(Activity context) {
        PackageInfo packageInfo;
        String key = null;
        try {
            //getting application package name
            String packageName = context.getApplicationContext().getPackageName();

        //Retriving package info
        packageInfo = context.getPackageManager().getPackageInfo(packageName,
                PackageManager.GET_SIGNATURES);

        Log.e(""Package Name="", context.getApplicationContext().getPackageName());

        for (Signature signature : packageInfo.signatures) {
            MessageDigest md = MessageDigest.getInstance(""SHA"");
            md.update(signature.toByteArray());
            key = new String(Base64.encode(md.digest(), 0));

            // String key = new String(Base64.encodeBytes(md.digest()));
            Log.e(""Key Hash="", key);
        }
    } catch (NameNotFoundException e1) {
        Log.e(""Name not found"", e1.toString());
    }
    catch (NoSuchAlgorithmException e) {
        Log.e(""No such an algorithm"", e.toString());
    } catch (Exception e) {
        Log.e(""Exception"", e.toString());
    }

    return key;
}
",3,0,750225acf444c5a45786eccaf0b1ec53b10424c96e7d1d930280f2d2a677bd77
,"public HttpClient myHttpsClient() {
    HttpClient client = null;
    char[] passphrase = ""password"".toCharArray();
    try {
        CertificateFactory cf = CertificateFactory.getInstance(""X.509"");
        CertificateFactory clientcf = CertificateFactory.getInstance(""X.509"");
        InputStream caInput = context.getResources().openRawResource(R.raw.server);
        InputStream clientcert = context.getResources().openRawResource(R.raw.clientks);
        Certificate ca;
        KeyStore keyStoreclient = KeyStore.getInstance(""BKS"");
        try {
            keyStoreclient.load(clientcert, ""password"".toCharArray());
            ca = cf.generateCertificate(caInput);
            System.out.println(""server ca=""+ ((X509Certificate) ca).getSubjectDN());
        } finally {
            caInput.close();
            clientcert.close();
        }

        // Create a KeyStore containing our trusted CAs
        String keyStoreType = KeyStore.getDefaultType();
        KeyStore keyStore = KeyStore.getInstance(keyStoreType);
        keyStore.load(null, null);
        keyStore.setCertificateEntry(""ca"", ca);


        String kmfAlgorithm = KeyManagerFactory.getDefaultAlgorithm();
        KeyManagerFactory kmf = KeyManagerFactory.getInstance(kmfAlgorithm);
            kmf.init(keyStoreclient,passphrase);


        // Create a TrustManager that trusts the CAs in our KeyStore
        String tmfAlgorithm = TrustManagerFactory.getDefaultAlgorithm();
        TrustManagerFactory tmf = TrustManagerFactory
                .getInstance(tmfAlgorithm);
        tmf.init(keyStore);

        // Create an SSLContext that uses our TrustManager
        SSLContext context = SSLContext.getInstance(""TLS"");
        context.init(kmf.getKeyManagers(), tmf.getTrustManagers(), null);

        MySSLSocketFactory socketFactory = new MySSLSocketFactory(context);//,new BrowserCompatHostnameVerifier());

        client = createHttps(socketFactory);
    } catch (Exception e) {
        e.printStackTrace();
    }

    return client;

}
",3,0,16ccb8f96820c2e0693d0944b401ea4f850caf6309cd1d342878bd0ef7349d5d
,"public class GMailSender extends javax.mail.Authenticator 
{   
private String mailhost = ""smtp.gmail.com"";   
private String user;   
private String password;   
private Session session;   
private Multipart _multipart;

static 
{   
    Security.addProvider(new JSSEProvider());   
}  

public GMailSender(String user, String password) 
{   
    this.user = user;   
    this.password = password;   

    Properties props = new Properties();   
    props.setProperty(""mail.transport.protocol"", ""smtp"");   
    props.setProperty(""mail.host"", mailhost);   
    props.put(""mail.smtp.auth"", ""true"");   
    props.put(""mail.smtp.port"", ""465"");   
    props.put(""mail.smtp.socketFactory.port"", ""465"");   
    props.put(""mail.smtp.socketFactory.class"",""javax.net.ssl.SSLSocketFactory"");   
    props.put(""mail.smtp.socketFactory.fallback"", ""false"");   
    props.setProperty(""mail.smtp.quitwait"", ""false"");   

    session = Session.getDefaultInstance(props, this);
    _multipart = new MimeMultipart();
}   

protected PasswordAuthentication getPasswordAuthentication() 
{   
    return new PasswordAuthentication(user, password);   
}   

public synchronized void sendMail(String subject, String body, String sender, String recipients) throws Exception 
{   
    MimeMessage message = new MimeMessage(session);   
    DataHandler handler = new DataHandler(new ByteArrayDataSource(body.getBytes(), ""text/plain""));   
    message.setSender(new InternetAddress(sender));   
    message.setSubject(subject);   

    message.setDataHandler(handler);   
    message.setContent(_multipart);
    if (recipients.indexOf(',') &gt; 0)   
        message.setRecipients(Message.RecipientType.TO, InternetAddress.parse(recipients));   
    else  
        message.setRecipient(Message.RecipientType.TO, new InternetAddress(recipients));   
    Transport.send(message);   

}   

public void addAttachment(String filename) throws Exception 
{
    BodyPart messageBodyPart = new MimeBodyPart();
    DataSource source = new FileDataSource(filename);
    messageBodyPart.setDataHandler(new DataHandler(source));
    messageBodyPart.setFileName(filename);

    _multipart.addBodyPart(messageBodyPart);
}

public class ByteArrayDataSource implements DataSource 
{   
    private byte[] data;   
    private String type;   

    public ByteArrayDataSource(byte[] data, String type) 
    {   
        super();   
        this.data = data;   
        this.type = type;   
    }   

    public ByteArrayDataSource(byte[] data) 
    {   
        super();   
        this.data = data;   
    }   

    public void setType(String type) 
    {   
        this.type = type;   
    }   

    public String getContentType() 
    {   
        if (type == null)   
            return ""application/octet-stream"";   
        else  
            return type;   
    }   

    public InputStream getInputStream() throws IOException 
    {   
        return new ByteArrayInputStream(data);   
    }   

    public String getName() 
    {   
        return ""ByteArrayDataSource"";   
    }   

    public OutputStream getOutputStream() throws IOException 
    {   
        throw new IOException(""Not Supported"");   
    }   
}   
",3,0,8be024dd3692cb40e27b4f291779ec85d950b22802f0e932dbde98d01ea5cb91
,"public final class JSSEProvider extends Provider 
{
private static final long serialVersionUID = 1L;

public JSSEProvider() 
{
    super(""HarmonyJSSE"", 1.0, ""Harmony JSSE Provider"");
    AccessController.doPrivileged(new java.security.PrivilegedAction&lt;Void&gt;() 
    {
        public Void run() 
        {
            put(""SSLContext.TLS"",
                    ""org.apache.harmony.xnet.provider.jsse.SSLContextImpl"");
            put(""Alg.Alias.SSLContext.TLSv1"", ""TLS"");
            put(""KeyManagerFactory.X509"",
                    ""org.apache.harmony.xnet.provider.jsse.KeyManagerFactoryImpl"");
            put(""TrustManagerFactory.X509"",
                    ""org.apache.harmony.xnet.provider.jsse.TrustManagerFactoryImpl"");
            return null;
        }
    });
}
}
",,1,62bf3e1868401dc5be2bfb1c8cd0da66bb665edacbe2e4525fceb09950f4839c
,"PublicKey publicKey = KeyFactory.getInstance(""RSA"").generatePublic(publicKeySpec);
Signature sign = Signature.getInstance(""SHA1withRSA"");
sign.initVerify(publicKey);
sign.update(someString.getBytes(""ASCII""));
boolean ok = sign.verify(Base64.decode(signature));
",3,0,ddfae95526e86291a18124360889de2e31ba84c07f97dea143791dfa678b04cb
,"public static String fileToMD5(String filePath) {
    InputStream inputStream = null;
    try {
        inputStream = new FileInputStream(filePath);
        byte[] buffer = new byte[1024];
        MessageDigest digest = MessageDigest.getInstance(""MD5"");
        int numRead = 0;
        while (numRead != -1) {
            numRead = inputStream.read(buffer);
            if (numRead &gt; 0)
                digest.update(buffer, 0, numRead);
        }
        byte [] md5Bytes = digest.digest();
        return convertHashToString(md5Bytes);
    } catch (Exception e) {
        return null;
    } finally {
        if (inputStream != null) {
            try {
                inputStream.close();
            } catch (Exception e) { }
        }
    }
}

private static String convertHashToString(byte[] md5Bytes) {
    String returnVal = """";
    for (int i = 0; i &lt; md5Bytes.length; i++) {
        returnVal += Integer.toString(( md5Bytes[i] &amp; 0xff ) + 0x100, 16).substring(1);
    }
    return returnVal.toUpperCase();
}
",2,0,d5f3a0dff184b395cb2ac945f656df11d29128ecba9cac38d9caf13641860d95
,"// utility function
    private static String bytesToHexString(byte[] bytes) {
        // http://stackoverflow.com/questions/332079
        StringBuffer sb = new StringBuffer();
        for (int i = 0; i &lt; bytes.length; i++) {
            String hex = Integer.toHexString(0xFF &amp; bytes[i]);
            if (hex.length() == 1) {
                sb.append('0');
            }
            sb.append(hex);
        }
        return sb.toString();
    }

// generate a hash

    String password=""asdf"";
    MessageDigest digest=null;
    String hash;
    try {
        digest = MessageDigest.getInstance(""SHA-256"");
        digest.update(password.getBytes());

        hash = bytesToHexString(digest.digest());

        Log.i(""Eamorr"", ""result is "" + hash);
    } catch (NoSuchAlgorithmException e1) {
        // TODO Auto-generated catch block
        e1.printStackTrace();
    }
",2,0,2c71b3c7d83f32967bf3a53f22f0569bb8c9876fc0b1a9e93071a1ecfef869f9
,"KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());
ks.load(null, null);
byte[]  sek = ""eru9tyighw34ilty348934i34uiq34q34ri"".getBytes();
...
",,1,d40f02e268a3fb9d93c0f5cfcba34d249748d6bca7066dc7701738bed00bfa86
," try {
                PackageInfo info = getPackageManager().getPackageInfo(com.domain,
                        PackageManager.GET_SIGNATURES);
                for (Signature signature : info.signatures) {
                    MessageDigest md = MessageDigest.getInstance(""SHA"");
                    md.update(signature.toByteArray());
                    Log.i(""PXR"", com.domain.Base64.encodeBytes(md.digest()));
                }
            } catch (NameNotFoundException e) {
            } catch (NoSuchAlgorithmException e) {
            }
",3,0,8e5fb091ce772f88b66b2843457a556f408e4f8cc605cc9dfeb483d3a190e98a
,"public String getEntry(String alias) {

    String secretStr = null;
    byte[] secret = null;

    if (mKeystore != null) {



        try {
            if (!mKeystore.containsAlias(alias)) {
                Log.w(TAG, new StringBuilder().append(""Keystore "").append(mKeyStoreName)
                        .append("" does not contain entry "").append(alias).toString());
                return null;
            }
        } catch (KeyStoreException ex) {
            Log.e(TAG, ""Failed to read keystore entry "" + alias);
        }

        // get my entry from the key store
        KeyStore.ProtectionParameter pp = new KeyStore.PasswordProtection(null);
        KeyStore.SecretKeyEntry ske = null;
        try {
            ske = (KeyStore.SecretKeyEntry) mKeystore.getEntry(alias, pp);
        } catch (Exception ex) {
            Log.e(TAG, ""Failed to read keystore entry "" + alias);
        }

        if (ske != null) {
            SecretKeySpec sks = (SecretKeySpec) ske.getSecretKey();
            secret = sks.getEncoded();

            if (secret != null) {
                secretStr = new String(secret);


            } else {
                Log.e(TAG, new StringBuilder().append(""Read empty keystore entry "").append(alias).toString());
            }
        } else {
            Log.e(TAG, ""Failed to read keystore entry "" + alias);
        }
    }
    return secretStr;
}
",,1,eb82427952d9469e33cd76065bc356b88e4ed963fbeaea76b52d557348c04583
,"   try {
            PackageInfo info = getPackageManager().getPackageInfo(getPackageName(), PackageManager.GET_SIGNATURES);
            for (Signature signature : info.signatures) {
                MessageDigest md;

                    md = MessageDigest.getInstance(""SHA"");
                    md.update(signature.toByteArray());
                    String something = new String(Base64.encode(md.digest(), 0));
                   //Toast.makeText(StartingPlace.this, something,
                        //  Toast.LENGTH_LONG).show();
                    Log.e(""hash key"", something);
        } 
        }
        catch (NameNotFoundException e1) {
            // TODO Auto-generated catch block
            Log.e(""name not found"", e1.toString());
        }

             catch (NoSuchAlgorithmException e1) {
                // TODO Auto-generated catch block
                 Log.e(""no such an algorithm"", e1.toString());
            }
             catch (Exception e1){
                 Log.e(""exception"", e1.toString());
             }
        //code to get hash code
",3,0,c6b132a40ac1ebf755b969a414f884f3f2b5422e735253bccb64de11fadcb601
,"package org.xmlrpc.android;

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

import java.io.IOException;
import java.net.InetAddress;
import java.net.InetSocketAddress;
import java.net.Socket;
import java.net.UnknownHostException;

import javax.net.ssl.SSLContext;
import javax.net.ssl.SSLSocket;
import javax.net.ssl.TrustManager;

import org.apache.http.conn.ConnectTimeoutException;
import org.apache.http.conn.scheme.LayeredSocketFactory;
import org.apache.http.conn.scheme.SocketFactory;
import org.apache.http.params.HttpConnectionParams;
import org.apache.http.params.HttpParams;

/**
 * This socket factory will create ssl socket that accepts self signed certificate
 *
 * @author olamy
 * @version $Id: EasySSLSocketFactory.java 765355 2009-04-15 20:59:07Z evenisse $
 * @since 1.2.3
 */
public class EasySSLSocketFactory implements SocketFactory, LayeredSocketFactory {

    private SSLContext sslcontext = null;

    private static SSLContext createEasySSLContext() throws IOException {
        try {
            SSLContext context = SSLContext.getInstance(""TLS"");
            context.init(null, new TrustManager[] { new EasyX509TrustManager(null) }, null);
            return context;
        } catch (Exception e) {
            throw new IOException(e.getMessage());
        }
    }

    private SSLContext getSSLContext() throws IOException {
        if (this.sslcontext == null) {
            this.sslcontext = createEasySSLContext();
        }
        return this.sslcontext;
    }

    /**
     * @see org.apache.http.conn.scheme.SocketFactory#connectSocket(java.net.Socket, java.lang.String, int,
     *      java.net.InetAddress, int, org.apache.http.params.HttpParams)
     */
    public Socket connectSocket(Socket sock, String host, int port, InetAddress localAddress, int localPort,
            HttpParams params) throws IOException, UnknownHostException, ConnectTimeoutException {
        int connTimeout = HttpConnectionParams.getConnectionTimeout(params);
        int soTimeout = HttpConnectionParams.getSoTimeout(params);
        InetSocketAddress remoteAddress = new InetSocketAddress(host, port);
        SSLSocket sslsock = (SSLSocket) ((sock != null) ? sock : createSocket());

        if ((localAddress != null) || (localPort &gt; 0)) {
            // we need to bind explicitly
            if (localPort &lt; 0) {
                localPort = 0; // indicates ""any""
            }
            InetSocketAddress isa = new InetSocketAddress(localAddress, localPort);
            sslsock.bind(isa);
        }

        sslsock.connect(remoteAddress, connTimeout);
        sslsock.setSoTimeout(soTimeout);
        return sslsock;

    }

    /**
     * @see org.apache.http.conn.scheme.SocketFactory#createSocket()
     */
    public Socket createSocket() throws IOException {
        return getSSLContext().getSocketFactory().createSocket();
    }

    /**
     * @see org.apache.http.conn.scheme.SocketFactory#isSecure(java.net.Socket)
     */
    public boolean isSecure(Socket socket) throws IllegalArgumentException {
        return true;
    }

    /**
     * @see org.apache.http.conn.scheme.LayeredSocketFactory#createSocket(java.net.Socket, java.lang.String, int,
     *      boolean)
     */
    public Socket createSocket(Socket socket, String host, int port, boolean autoClose) throws IOException,
            UnknownHostException {
        return getSSLContext().getSocketFactory().createSocket(socket, host, port, autoClose);
    }

    // -------------------------------------------------------------------
    // javadoc in org.apache.http.conn.scheme.SocketFactory says :
    // Both Object.equals() and Object.hashCode() must be overridden
    // for the correct operation of some connection managers
    // -------------------------------------------------------------------

    public boolean equals(Object obj) {
        return ((obj != null) &amp;&amp; obj.getClass().equals(EasySSLSocketFactory.class));
    }

    public int hashCode() {
        return EasySSLSocketFactory.class.hashCode();
    }

}
",4,0,bb8240b5ac84a55a6d27be966e1379da4ed7b231ee06e2d361a16a9e73900a4a
,"public static void printHashKey(Context pContext) {
        try {
            PackageInfo info = getPackageInfo(pContext, PackageManager.GET_SIGNATURES);
            for (Signature signature : info.signatures) {
                MessageDigest md = MessageDigest.getInstance(""SHA"");
                md.update(signature.toByteArray());
                String hashKey = new String(Base64.encode(md.digest(), 0));
                Log.i(TAG, ""printHashKey() Hash Key: "" + hashKey);
            }
        } catch (NoSuchAlgorithmException e) {
            Log.e(TAG, ""printHashKey()"", e);
        } catch (Exception e) {
            Log.e(TAG, ""printHashKey()"", e);
        }
    }
",3,0,c62ec3e7c7c286aafff2174d2a1a34437facfa294c0ea9523ebbc10b286d1482
,"import android.content.pm.PackageInfo;
import android.content.pm.PackageManager;
import android.content.pm.Signature;
import android.util.Base64;
import android.util.Log;

import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;

 public static String printKeyHash(Activity context) {
        PackageInfo packageInfo;
        String key = null;
        try {
            //getting application package name, as defined in manifest
            String packageName = context.getApplicationContext().getPackageName();

            //Retriving package info
            packageInfo = context.getPackageManager().getPackageInfo(packageName,
                    PackageManager.GET_SIGNATURES);

            Log.e(""Package Name="", context.getApplicationContext().getPackageName());

            for (Signature signature : packageInfo.signatures) {
                MessageDigest md = MessageDigest.getInstance(""SHA"");
                md.update(signature.toByteArray());
                key = new String(Base64.encode(md.digest(), 0));

                // String key = new String(Base64.encodeBytes(md.digest()));
                Log.e(""Key Hash="", key);
            }
        } catch (PackageManager.NameNotFoundException e1) {
            Log.e(""Name not found"", e1.toString());
        }
        catch (NoSuchAlgorithmException e) {
            Log.e(""No such an algorithm"", e.toString());
        } catch (Exception e) {
            Log.e(""Exception"", e.toString());
        }

        return key;
    }
",3,0,952e79c5c84b6a35ff86f0528ee7b854459b714a152dfb0a58e357b8f6bee2b8
," public class DeviceInfo {

        public static String getDeviceInfo(Context activity, Device device) {
            try {
                switch (device) {
                    case DEVICE_LANGUAGE:
                        return Locale.getDefault().getDisplayLanguage();
                    case DEVICE_TIME_ZONE:
                        return TimeZone.getDefault().getID();//(false, TimeZone.SHORT);
                    case DEVICE_LOCAL_COUNTRY_CODE:
                        return activity.getResources().getConfiguration().locale.getCountry();
                    case DEVICE_CURRENT_YEAR:
                        return """" + (Calendar.getInstance().get(Calendar.YEAR));
                    case DEVICE_CURRENT_DATE_TIME:
                        Calendar calendarTime = Calendar.getInstance(TimeZone.getDefault(), Locale.getDefault());
                        long time = (calendarTime.getTimeInMillis() / 1000);
                        return String.valueOf(time);
    //                    return DateFormat.getDateTimeInstance().format(new Date());
                    case DEVICE_CURRENT_DATE_TIME_ZERO_GMT:
                        Calendar calendarTime_zero = Calendar.getInstance(TimeZone.getTimeZone(""GMT+0""), Locale.getDefault());
                        return String.valueOf((calendarTime_zero.getTimeInMillis() / 1000));
    //                    DateFormat df = DateFormat.getDateTimeInstance();
    //                    df.setTimeZone(TimeZone.getTimeZone(""GMT+0""));
    //                    return df.format(new Date());
                    case DEVICE_HARDWARE_MODEL:
                        return getDeviceName();
                    case DEVICE_NUMBER_OF_PROCESSORS:
                        return Runtime.getRuntime().availableProcessors() + """";
                    case DEVICE_LOCALE:
                        return Locale.getDefault().getISO3Country();
                    case DEVICE_IP_ADDRESS_IPV4:
                        return getIPAddress(true);
                    case DEVICE_IP_ADDRESS_IPV6:
                        return getIPAddress(false);
                    case DEVICE_MAC_ADDRESS:
                        String mac = getMACAddress(""wlan0"");
                        if (TextUtils.isEmpty(mac)) {
                            mac = getMACAddress(""eth0"");
                        }
                        if (TextUtils.isEmpty(mac)) {
                            mac = ""DU:MM:YA:DD:RE:SS"";
                        }
                        return mac;

                    case DEVICE_TOTAL_MEMORY:
                        if (Build.VERSION.SDK_INT &gt;= 16)
                            return String.valueOf(getTotalMemory(activity));
                    case DEVICE_FREE_MEMORY:
                        return String.valueOf(getFreeMemory(activity));
                    case DEVICE_USED_MEMORY:
                        if (Build.VERSION.SDK_INT &gt;= 16) {
                            long freeMem = getTotalMemory(activity) - getFreeMemory(activity);
                            return String.valueOf(freeMem);
                        }
                        return """";
                    case DEVICE_TOTAL_CPU_USAGE:
                        int[] cpu = getCpuUsageStatistic();
                        if (cpu != null) {
                            int total = cpu[0] + cpu[1] + cpu[2] + cpu[3];
                            return String.valueOf(total);
                        }
                        return """";
                    case DEVICE_TOTAL_CPU_USAGE_SYSTEM:
                        int[] cpu_sys = getCpuUsageStatistic();
                        if (cpu_sys != null) {
                            int total = cpu_sys[1];
                            return String.valueOf(total);
                        }
                        return """";
                    case DEVICE_TOTAL_CPU_USAGE_USER:
                        int[] cpu_usage = getCpuUsageStatistic();
                        if (cpu_usage != null) {
                            int total = cpu_usage[0];
                            return String.valueOf(total);
                        }
                        return """";
                    case DEVICE_MANUFACTURE:
                        return android.os.Build.MANUFACTURER;
                    case DEVICE_SYSTEM_VERSION:
                        return String.valueOf(getDeviceName());
                    case DEVICE_VERSION:
                        return String.valueOf(android.os.Build.VERSION.SDK_INT);
                    case DEVICE_IN_INCH:
                        return getDeviceInch(activity);
                    case DEVICE_TOTAL_CPU_IDLE:
                        int[] cpu_idle = getCpuUsageStatistic();
                        if (cpu_idle != null) {
                            int total = cpu_idle[2];
                            return String.valueOf(total);
                        }
                        return """";
                    case DEVICE_NETWORK_TYPE:
                        return getNetworkType(activity);
                    case DEVICE_NETWORK:
                        return checkNetworkStatus(activity);
                    case DEVICE_TYPE:
                        if (isTablet(activity)) {
                            if (getDeviceMoreThan5Inch(activity)) {
                                return ""Tablet"";
                            } else
                                return ""Mobile"";
                        } else {
                            return ""Mobile"";
                        }
                    default:
                        break;
                }

            } catch (Exception e) {
                e.printStackTrace();
            }

            return """";
        }

        public static String getDeviceId(Context context) {
            String device_uuid = Secure.getString(context.getContentResolver(), Secure.ANDROID_ID);
            if (device_uuid == null) {
                device_uuid = ""12356789""; // for emulator testing
            } else {
                try {
                    byte[] _data = device_uuid.getBytes();
                    MessageDigest _digest = java.security.MessageDigest.getInstance(""MD5"");
                    _digest.update(_data);
                    _data = _digest.digest();
                    BigInteger _bi = new BigInteger(_data).abs();
                    device_uuid = _bi.toString(36);
                } catch (Exception e) {
                    if (e != null) {
                        e.printStackTrace();
                    }
                }
            }
            return device_uuid;
        }

        @SuppressLint(""NewApi"")
        private static long getTotalMemory(Context activity) {
            try {
                MemoryInfo mi = new MemoryInfo();
                ActivityManager activityManager = (ActivityManager) activity.getSystemService(Context.ACTIVITY_SERVICE);
                activityManager.getMemoryInfo(mi);
                long availableMegs = mi.totalMem / 1048576L; // in megabyte (mb)

                return availableMegs;
            } catch (Exception e) {
                e.printStackTrace();
                return 0;
            }
        }

        private static long getFreeMemory(Context activity) {
            try {
                MemoryInfo mi = new MemoryInfo();
                ActivityManager activityManager = (ActivityManager) activity.getSystemService(Context.ACTIVITY_SERVICE);
                activityManager.getMemoryInfo(mi);
                long availableMegs = mi.availMem / 1048576L; // in megabyte (mb)

                return availableMegs;
            } catch (Exception e) {
                e.printStackTrace();
                return 0;
            }
        }

        private static String getDeviceName() {
            String manufacturer = Build.MANUFACTURER;
            String model = Build.MODEL;
            if (model.startsWith(manufacturer)) {
                return capitalize(model);
            } else {
                return capitalize(manufacturer) + "" "" + model;
            }
        }

        private static String capitalize(String s) {
            if (s == null || s.length() == 0) {
                return """";
            }
            char first = s.charAt(0);
            if (Character.isUpperCase(first)) {
                return s;
            } else {
                return Character.toUpperCase(first) + s.substring(1);
            }
        }

        /**
         * Convert byte array to hex string
         *
         * @param bytes
         * @return
         */
        private static String bytesToHex(byte[] bytes) {
            StringBuilder sbuf = new StringBuilder();
            for (int idx = 0; idx &lt; bytes.length; idx++) {
                int intVal = bytes[idx] &amp; 0xff;
                if (intVal &lt; 0x10)
                    sbuf.append(""0"");
                sbuf.append(Integer.toHexString(intVal).toUpperCase());
            }
            return sbuf.toString();
        }

        /**
         * Returns MAC address of the given interface name.
         *
         * @param interfaceName eth0, wlan0 or NULL=use first interface
         * @return mac address or empty string
         */
        @SuppressLint(""NewApi"")
        private static String getMACAddress(String interfaceName) {
            try {

                List&lt;NetworkInterface&gt; interfaces = Collections.list(NetworkInterface.getNetworkInterfaces());
                for (NetworkInterface intf : interfaces) {
                    if (interfaceName != null) {
                        if (!intf.getName().equalsIgnoreCase(interfaceName))
                            continue;
                    }
                    byte[] mac = intf.getHardwareAddress();
                    if (mac == null)
                        return """";
                    StringBuilder buf = new StringBuilder();
                    for (int idx = 0; idx &lt; mac.length; idx++)
                        buf.append(String.format(""%02X:"", mac[idx]));
                    if (buf.length() &gt; 0)
                        buf.deleteCharAt(buf.length() - 1);
                    return buf.toString();
                }
            } catch (Exception ex) {
                return """";
            } // for now eat exceptions
            return """";
            /*
             * try { // this is so Linux hack return
             * loadFileAsString(""/sys/class/net/"" +interfaceName +
             * ""/address"").toUpperCase().trim(); } catch (IOException ex) { return
             * null; }
             */
        }

        /**
         * Get IP address from first non-localhost interface
         *
         * @return address or empty string
         */
        private static String getIPAddress(boolean useIPv4) {
            try {
                List&lt;NetworkInterface&gt; interfaces = Collections.list(NetworkInterface.getNetworkInterfaces());
                for (NetworkInterface intf : interfaces) {
                    List&lt;InetAddress&gt; addrs = Collections.list(intf.getInetAddresses());
                    for (InetAddress addr : addrs) {
                        if (!addr.isLoopbackAddress()) {
                            String sAddr = addr.getHostAddress().toUpperCase();
                            boolean isIPv4 = InetAddressUtils.isIPv4Address(sAddr);
                            if (useIPv4) {
                                if (isIPv4)
                                    return sAddr;
                            } else {
                                if (!isIPv4) {
                                    int delim = sAddr.indexOf('%'); // drop ip6 port
                                    // suffix
                                    return delim &lt; 0 ? sAddr : sAddr.substring(0, delim);
                                }
                            }
                        }
                    }
                }
            } catch (Exception ex) {
            } // for now eat exceptions
            return """";
        }

        /*
         *
         * @return integer Array with 4 elements: user, system, idle and other cpu
         * usage in percentage.
         */
        private static int[] getCpuUsageStatistic() {
            try {
                String tempString = executeTop();

                tempString = tempString.replaceAll("","", """");
                tempString = tempString.replaceAll(""User"", """");
                tempString = tempString.replaceAll(""System"", """");
                tempString = tempString.replaceAll(""IOW"", """");
                tempString = tempString.replaceAll(""IRQ"", """");
                tempString = tempString.replaceAll(""%"", """");
                for (int i = 0; i &lt; 10; i++) {
                    tempString = tempString.replaceAll(""  "", "" "");
                }
                tempString = tempString.trim();
                String[] myString = tempString.split("" "");
                int[] cpuUsageAsInt = new int[myString.length];
                for (int i = 0; i &lt; myString.length; i++) {
                    myString[i] = myString[i].trim();
                    cpuUsageAsInt[i] = Integer.parseInt(myString[i]);
                }
                return cpuUsageAsInt;

            } catch (Exception e) {
                e.printStackTrace();
                Log.e(""executeTop"", ""error in getting cpu statics"");
                return null;
            }
        }

        private static String executeTop() {
            java.lang.Process p = null;
            BufferedReader in = null;
            String returnString = null;
            try {
                p = Runtime.getRuntime().exec(""top -n 1"");
                in = new BufferedReader(new InputStreamReader(p.getInputStream()));
                while (returnString == null || returnString.contentEquals("""")) {
                    returnString = in.readLine();
                }
            } catch (IOException e) {
                Log.e(""executeTop"", ""error in getting first line of top"");
                e.printStackTrace();
            } finally {
                try {
                    in.close();
                    p.destroy();
                } catch (IOException e) {
                    Log.e(""executeTop"", ""error in closing and destroying top process"");
                    e.printStackTrace();
                }
            }
            return returnString;
        }

        public static String getNetworkType(final Context activity) {
            String networkStatus = """";

            final ConnectivityManager connMgr = (ConnectivityManager)
                    activity.getSystemService(Context.CONNECTIVITY_SERVICE);
            // check for wifi
            final android.net.NetworkInfo wifi =
                    connMgr.getNetworkInfo(ConnectivityManager.TYPE_WIFI);
            // check for mobile data
            final android.net.NetworkInfo mobile =
                    connMgr.getNetworkInfo(ConnectivityManager.TYPE_MOBILE);

            if (wifi.isAvailable()) {
                networkStatus = ""Wifi"";
            } else if (mobile.isAvailable()) {
                networkStatus = getDataType(activity);
            } else {
                networkStatus = ""noNetwork"";
            }
            return networkStatus;
        }

        public static String checkNetworkStatus(final Context activity) {
            String networkStatus = """";
            try {
                // Get connect mangaer
                final ConnectivityManager connMgr = (ConnectivityManager)
                activity.getSystemService(Context.CONNECTIVITY_SERVICE);
                // // check for wifi
                final android.net.NetworkInfo wifi =
                connMgr.getNetworkInfo(ConnectivityManager.TYPE_WIFI);
                // // check for mobile data
                final android.net.NetworkInfo mobile =
                connMgr.getNetworkInfo(ConnectivityManager.TYPE_MOBILE);

                if (wifi.isAvailable()) {
                networkStatus = ""Wifi"";
                } else if (mobile.isAvailable()) {
                networkStatus = getDataType(activity);
                } else {
                networkStatus = ""noNetwork"";
                networkStatus = ""0"";
               }


            } catch (Exception e) {
                e.printStackTrace();
                networkStatus = ""0"";
            }
            return networkStatus;

        } 

 public static boolean isTablet(Context context) {
        return (context.getResources().getConfiguration().screenLayout &amp; Configuration.SCREENLAYOUT_SIZE_MASK) &gt;= Configuration.SCREENLAYOUT_SIZE_LARGE;
    }

    public static boolean getDeviceMoreThan5Inch(Context activity) {
        try {
            DisplayMetrics displayMetrics = activity.getResources().getDisplayMetrics();
            // int width = displayMetrics.widthPixels;
            // int height = displayMetrics.heightPixels;

            float yInches = displayMetrics.heightPixels / displayMetrics.ydpi;
            float xInches = displayMetrics.widthPixels / displayMetrics.xdpi;
            double diagonalInches = Math.sqrt(xInches * xInches + yInches * yInches);
            if (diagonalInches &gt;= 7) {
                // 5inch device or bigger
                return true;
            } else {
                // smaller device
                return false;
            }
        } catch (Exception e) {
            return false;
        }
    }

    public static String getDeviceInch(Context activity) {
        try {
            DisplayMetrics displayMetrics = activity.getResources().getDisplayMetrics();

            float yInches = displayMetrics.heightPixels / displayMetrics.ydpi;
            float xInches = displayMetrics.widthPixels / displayMetrics.xdpi;
            double diagonalInches = Math.sqrt(xInches * xInches + yInches * yInches);
            return String.valueOf(diagonalInches);
        } catch (Exception e) {
            return ""-1"";
        }
    }

    public static String getDataType(Context activity) {
        String type = ""Mobile Data"";
        TelephonyManager tm = (TelephonyManager) activity.getSystemService(Context.TELEPHONY_SERVICE);
        switch (tm.getNetworkType()) {
            case TelephonyManager.NETWORK_TYPE_HSDPA:
                type = ""Mobile Data 3G"";
                Log.d(""Type"", ""3g"");
                // for 3g HSDPA networktype will be return as
                // per testing(real) in device with 3g enable
                // data
                // and speed will also matters to decide 3g network type
                break;
            case TelephonyManager.NETWORK_TYPE_HSPAP:
                type = ""Mobile Data 4G"";
                Log.d(""Type"", ""4g"");
                // No specification for the 4g but from wiki
                // i found(HSPAP used in 4g)
                break;
            case TelephonyManager.NETWORK_TYPE_GPRS:
                type = ""Mobile Data GPRS"";
                Log.d(""Type"", ""GPRS"");
                break;
            case TelephonyManager.NETWORK_TYPE_EDGE:
                type = ""Mobile Data EDGE 2G"";
                Log.d(""Type"", ""EDGE 2g"");
                break;

        }

        return type;
        }
}
",,1,80c01e1450616983cfa71920d94640406867fedc4733a9c726c6896a81d23c06
,"try {
    PackageInfo info = getPackageManager().getPackageInfo(
            ""com.facebook.samples.loginhowto"", 
             PackageManager.GET_SIGNATURES);
    for (Signature signature : info.signatures) {
        MessageDigest md = MessageDigest.getInstance(""SHA"");
        md.update(signature.toByteArray());
        Log.d(""KeyHash:"", Base64.encodeToString(md.digest(), Base64.DEFAULT));
    }
} catch (NameNotFoundException e) {
} catch (NoSuchAlgorithmException e) {
}
",3,0,18215398561128eac00fb7badfeadf9576e177cb5990036487d498696347a66a
,"import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.DESKeySpec;
import org.apache.commons.net.util.Base64;

   private static SecretKey key;

         try {
            byte[] secretBytes = ""secret key"".getBytes(""UTF8"");
            DESKeySpec keySpec = new DESKeySpec(secretBytes);
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(""DES"");
            key = keyFactory.generateSecret(keySpec);
         } catch (Exception e) {
            Log.e(Flashum.LOG_TAG, ""DatabaseHelper "" + e.toString());
         }

   public byte[] encryptPassword(String userpw) {
      try {
         byte[] cleartext = userpw.getBytes(""UTF8"");      

         Cipher cipher = Cipher.getInstance(""DES"");
         cipher.init(Cipher.ENCRYPT_MODE, key);
         byte[] clearBytes = cipher.doFinal(cleartext);
         byte[] encryptedPwd = Base64.encodeBase64(clearBytes);
         return encryptedPwd;
      } catch (Exception e) {
         Log.e(Flashum.LOG_TAG, ""DatabaseHelper "" + e.toString());
      }
      return null;
   }

   public String decryptPassword(byte[] userpw) {
      String pw = """";
      try {
         byte[] encrypedPwdBytes = Base64.decodeBase64(userpw);

         Cipher cipher = Cipher.getInstance(""DES"");
         cipher.init(Cipher.DECRYPT_MODE, key);
         byte[] plainTextPwdBytes = cipher.doFinal(encrypedPwdBytes);
         pw = new String(plainTextPwdBytes, ""UTF8"");
      } catch (Exception e) {
         Log.e(Flashum.LOG_TAG, ""DatabaseHelper "" + e.toString());
      }
      return pw;
   }
",4,0,39479d01296cb6c0d9cbb24f10859bf0a5849d0fc841815b606626ebd27840e6
,"        List&lt;String&gt; list = new ArrayList&lt;String&gt;();
        list.add(""Hello"");
        list.add("" World!!"");

        System.out.println(list);

        ByteArrayOutputStream bos = new ByteArrayOutputStream();
        ObjectOutputStream oos = new ObjectOutputStream(bos);
        oos.writeObject(list);
        byte[] text = bos.toByteArray();

        KeyGenerator keygenerator = KeyGenerator.getInstance(""DES"");
        SecretKey myDesKey = keygenerator.generateKey();
        Cipher desCipher;
        desCipher = Cipher.getInstance(""DES"");

        desCipher.init(Cipher.ENCRYPT_MODE, myDesKey);
        byte[] textEncrypted = desCipher.doFinal(text);

        desCipher.init(Cipher.DECRYPT_MODE, myDesKey);
        byte[] textDecrypted = desCipher.doFinal(textEncrypted);

        ByteArrayInputStream bis = new ByteArrayInputStream(textDecrypted);
        ObjectInputStream ois = new ObjectInputStream(bis);
        List&lt;String&gt; result = (List&lt;String&gt;) ois.readObject();

        System.out.println(result);
",4,0,e630fafdbddc165fad428b4278727d92b437dfe87bc02522847182be97721de6
,"try {
        PackageInfo info = getPackageManager().getPackageInfo(
                ""com.facebook.samples.hellofacebook"",
                PackageManager.GET_SIGNATURES);

        for (Signature signature : info.signatures) {
            MessageDigest md = MessageDigest.getInstance(""SHA"");
            md.update(signature.toByteArray());
            Log.e(""KeyHash:"",
                    Base64.encodeToString(md.digest(), Base64.DEFAULT));
        }
    } catch (NameNotFoundException e) {
        Log.d(""NameNotFoundException"", ""NameNotFoundException"");
    } catch (NoSuchAlgorithmException e) {
        Log.d(""NameNotFoundException"", ""NoSuchAlgorithmException"");
    }
",3,0,1347281c5053330ea68033ceec7f250c0cad52152f7cd7cb955631e64c440afe
,"DocumentBuilderFactory dbfac = DocumentBuilderFactory.newInstance();
 dbfac.setNamespaceAware(true);
 DocumentBuilder docBuilder = null;
 try {
    docBuilder = dbfac.newDocumentBuilder();
} catch (ParserConfigurationException e) {
    // TODO Auto-generated catch block
    e.printStackTrace();
}
 DOMImplementation domImpl = docBuilder.getDOMImplementation();
 Document doc = domImpl.createDocument(""http://coggl.com/InsertTrack"",""TrackEntry"", null);
 doc.setXmlVersion(""1.0"");
 doc.setXmlStandalone(true);

 Element trackElement = doc.getDocumentElement();

 Element CompanyId = doc.createElement(""CompanyId"");
 CompanyId.appendChild(doc.createTextNode(""1""));
 trackElement.appendChild(CompanyId);

 Element CreatedBy = doc.createElement(""CreatedBy"");
 CreatedBy.appendChild(doc.createTextNode(""6""));
 trackElement.appendChild(CreatedBy);

 Element DepartmentId = doc.createElement(""DepartmentId"");
 DepartmentId.appendChild(doc.createTextNode(""4""));
 trackElement.appendChild(DepartmentId);

 Element IsBillable = doc.createElement(""IsBillable"");
 IsBillable.appendChild(doc.createTextNode(""1""));
 trackElement.appendChild(IsBillable);

 Element ProjectId = doc.createElement(""ProjectId"");
 ProjectId.appendChild(doc.createTextNode(""1""));
 trackElement.appendChild(ProjectId);

 Element StartTime = doc.createElement(""StartTime"");
 StartTime.appendChild(doc.createTextNode(""2012-03-14 10:44:45""));
 trackElement.appendChild(StartTime);

 Element StopTime = doc.createElement(""StopTime"");
 StopTime.appendChild(doc.createTextNode(""2012-03-14 11:44:45""));
 trackElement.appendChild(StopTime);

 Element TaskId = doc.createElement(""TaskId"");
 TaskId.appendChild(doc.createTextNode(""3""));
 trackElement.appendChild(TaskId);

 Element TotalTime = doc.createElement(""TotalTime"");
 TotalTime.appendChild(doc.createTextNode(""1""));
 trackElement.appendChild(TotalTime);

 Element TrackDesc = doc.createElement(""TrackDesc"");
 TrackDesc.appendChild(doc.createTextNode(""dello testing""));
 trackElement.appendChild(TrackDesc);

 Element TrackId = doc.createElement(""TrackId"");
 TrackId.appendChild(doc.createTextNode(""0""));
 trackElement.appendChild(TrackId);

 TransformerFactory transfac = TransformerFactory.newInstance();
 Transformer trans = null;
try {
    trans = transfac.newTransformer();
} catch (TransformerConfigurationException e) {
    // TODO Auto-generated catch block
    e.printStackTrace();
}
 trans.setOutputProperty(OutputKeys.OMIT_XML_DECLARATION, ""yes"");
 trans.setOutputProperty(OutputKeys.INDENT, ""yes"");

 //create string from xml tree
 StringWriter sw = new StringWriter();
 StreamResult result = new StreamResult(sw);
 DOMSource source = new DOMSource(doc);
 try {
    trans.transform(source, result);
} catch (TransformerException e) {
    // TODO Auto-generated catch block
    e.printStackTrace();
}
 String xmlString = sw.toString();

//posting xml file to server

 DefaultHttpClient httpClient = new DefaultHttpClient();

 HttpPost httppost = new HttpPost(""http://192.168.0.19:3334/cogglrestservice.svc/InsertTrack"");     
 // Make sure the server knows what kind of a response we will accept
 httppost.addHeader(""Accept"", ""text/xml"");
 // Also be sure to tell the server what kind of content we are sending
 httppost.addHeader(""Content-Type"", ""application/xml"");

 try
 {
 StringEntity entity = new StringEntity(xmlString, ""UTF-8"");
 entity.setContentType(""application/xml"");
 httppost.setEntity(entity);

 // execute is a blocking call, it's best to call this code in a thread separate from the ui's
 HttpResponse response = httpClient.execute(httppost);

 BasicResponseHandler responseHandler = new BasicResponseHandler();
    String strResponse = null;
    if (response != null) {
        try {
            strResponse = responseHandler.handleResponse(response);
        } catch (HttpResponseException e) {
            e.printStackTrace();  
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
    Log.e(""WCFTEST"", ""WCFTEST ********** Response"" + strResponse);    


 }
 catch (Exception ex)
 {
 ex.printStackTrace();
 }
 Toast.makeText(EditTask.this, ""Xml posted succesfully."",Toast.LENGTH_SHORT).show();
",,1,24e19d02fa856db6cbd7c7ab7cdc2ac6de7a4db2f4ae8ab26e7f1875fe904be5
," /**
 * Generates a PublicKey instance from a string containing the
 * Base64-encoded public key.
 *
 * @param encodedPublicKey Base64-encoded public key
 * @throws IllegalArgumentException if encodedPublicKey is invalid
 */
public static PublicKey generatePublicKey(String encodedPublicKey) {
    try {
        String str = new String(Base64.decode(encodedPublicKey));
        byte[] decodedKey = Base64.decode(str);
        KeyFactory keyFactory = KeyFactory.getInstance(KEY_FACTORY_ALGORITHM);
        return keyFactory.generatePublic(new X509EncodedKeySpec(decodedKey));
    } catch (NoSuchAlgorithmException e) {
        throw new RuntimeException(e);
    } catch (InvalidKeySpecException e) {
        e.printStackTrace();
        Log.e(TAG, ""Invalid key specification."");
        throw new IllegalArgumentException(e);
    } catch (Base64DecoderException e) {
        Log.e(TAG, ""Base64 decoding failed."");
        throw new IllegalArgumentException(e);
    }
}
",,1,692feffda60a786dfb68d8abbcfc6f7040b79472fd849eda284370e249106df9
,"FileInputStream fis = new FileInputStream(filename);
BufferedInputStream bis = new BufferedInputStream(fis);

CertificateFactory cf = CertificateFactory.getInstance(""X.509"");
Certificate cert = cf.generateCertificate(bis);
",,1,a9cba8e44d00e81908f1f0bc6793ef8a360378075a9223944740f16c183e9376
,"        // Add code to print out the key hash
            try {
                PackageInfo info = getPackageManager().getPackageInfo(
                        ""com.example.testhopelast"",
                        PackageManager.GET_SIGNATURES);
                for (Signature signature : info.signatures) {
                    MessageDigest md = MessageDigest.getInstance(""SHA"");
                    md.update(signature.toByteArray());
                    Log.d(""KeyHash:"", Base64.encodeToString(md.digest(),
                            Base64.DEFAULT));
                }
            } catch (NameNotFoundException e) {

            } catch (NoSuchAlgorithmException e) {

            }
",3,0,19161efe02a9c9e797b53f072fe60abab3f9e02d3f47c1161e5553bd200cf518
,"private void trustAll() { 
    try { 
            HttpsURLConnection.setDefaultHostnameVerifier(new HostnameVerifier(){ 
                    public boolean verify(String hostname, SSLSession session) { 
                            return true; 
                    }}); 
            SSLContext context = SSLContext.getInstance(""TLS""); 
            context.init(null, new X509TrustManager[]{new X509TrustManager(){ 
                    public void checkClientTrusted(X509Certificate[] chain, 
                                    String authType) throws CertificateException {} 
                    public void checkServerTrusted(X509Certificate[] chain, 
                                    String authType) throws CertificateException {} 
                    public X509Certificate[] getAcceptedIssuers() { 
                            return new X509Certificate[0]; 
                    }}}, new SecureRandom()); 
            HttpsURLConnection.setDefaultSSLSocketFactory( 
                            context.getSocketFactory()); 
    } catch (Exception e) { 
            Log.e(""TAG"",e); 
    } 
}
",4,0,1680e9ba34e7100534fcd8b839d87c8b888e9c523cd41336d95a7401c3f46b2a
,"public static DotNetRSA GenerateDotNetKey(String base64PubKey)
            throws IOException, NoSuchAlgorithmException,
            InvalidKeySpecException {
        /*
         * String base64PubKey - 
         * Is a Key retrieved from Google Checkout Merchant Account
         */
        BASE64Decoder decoder = new BASE64Decoder();

        byte[] publicKeyBytes = decoder.decodeBuffer(base64PubKey);

        EncodedKeySpec publicKeySpec = new X509EncodedKeySpec(publicKeyBytes);
        RSAPublicKey publicKey = (RSAPublicKey) KeyFactory.getInstance(""RSA"").generatePublic(publicKeySpec);

        byte[] modulusBytes = publicKey.getModulus().toByteArray();
        byte[] exponentBytes = publicKey.getPublicExponent().toByteArray();

        modulusBytes = stripLeadingZeros(modulusBytes);

        BASE64Encoder encoder = new BASE64Encoder();
        String modulusB64 = encoder.encode(modulusBytes);
        String exponentB64 = encoder.encode(exponentBytes);

        return new DotNetRSA(modulusB64, exponentB64);
    }

      private static byte[] stripLeadingZeros(byte[] a) {
        int lastZero = -1;
        for (int i = 0; i &lt; a.length; i++) {
          if (a[i] == 0) {
            lastZero = i;
          }
          else {
            break;
          }
        }
        lastZero++;
        byte[] result = new byte[a.length - lastZero];
        System.arraycopy(a, lastZero, result, 0, result.length);
        return result;
      }
",3,0,6b7bba842c7051651253384208d251fda90ec5157bbf02c767f892f7f036e251
,"/*
 * Copyright (C) 2012 The CyanogenMod Project
 *
 * * Licensed under the GNU GPLv2 license
 *
 * The text of the license can be found in the LICENSE file
 * or at https://www.gnu.org/licenses/gpl-2.0.txt
 */

package com.cyanogenmod.updater.utils;

import android.text.TextUtils;
import android.util.Log;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.math.BigInteger;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;

public class MD5 {
    private static final String TAG = ""MD5"";

    public static boolean checkMD5(String md5, File updateFile) {
        if (TextUtils.isEmpty(md5) || updateFile == null) {
            Log.e(TAG, ""MD5 string empty or updateFile null"");
            return false;
        }

        String calculatedDigest = calculateMD5(updateFile);
        if (calculatedDigest == null) {
            Log.e(TAG, ""calculatedDigest null"");
            return false;
        }

        Log.v(TAG, ""Calculated digest: "" + calculatedDigest);
        Log.v(TAG, ""Provided digest: "" + md5);

        return calculatedDigest.equalsIgnoreCase(md5);
    }

    public static String calculateMD5(File updateFile) {
        MessageDigest digest;
        try {
            digest = MessageDigest.getInstance(""MD5"");
        } catch (NoSuchAlgorithmException e) {
            Log.e(TAG, ""Exception while getting digest"", e);
            return null;
        }

        InputStream is;
        try {
            is = new FileInputStream(updateFile);
        } catch (FileNotFoundException e) {
            Log.e(TAG, ""Exception while getting FileInputStream"", e);
            return null;
        }

        byte[] buffer = new byte[8192];
        int read;
        try {
            while ((read = is.read(buffer)) &gt; 0) {
                digest.update(buffer, 0, read);
            }
            byte[] md5sum = digest.digest();
            BigInteger bigInt = new BigInteger(1, md5sum);
            String output = bigInt.toString(16);
            // Fill to 32 chars
            output = String.format(""%32s"", output).replace(' ', '0');
            return output;
        } catch (IOException e) {
            throw new RuntimeException(""Unable to process file for MD5"", e);
        } finally {
            try {
                is.close();
            } catch (IOException e) {
                Log.e(TAG, ""Exception on closing MD5 input stream"", e);
            }
        }
    }
}
",,1,491cbe1fb839dd85fb1757ae6d7e1c174174687a74fd296303f33767f0be86a3
,"   public static String hashMac(String text, String secretKey)
                  throws SignatureException {

                 try {
                  Key sk = new SecretKeySpec(secretKey.getBytes(), HASH_ALGORITHM);
                  Mac mac = Mac.getInstance(sk.getAlgorithm());
                  mac.init(sk);
                  final byte[] hmac = mac.doFinal(text.getBytes());
                  return toHexString(hmac);
                 } catch (NoSuchAlgorithmException e1) {
                  // throw an exception or pick a different encryption method
                  throw new SignatureException(
                    ""error building signature, no such algorithm in device ""
                      + HASH_ALGORITHM);
                 } catch (InvalidKeyException e) {
                  throw new SignatureException(
                    ""error building signature, invalid key "" + HASH_ALGORITHM);
                 }
    }

    public static String toHexString(byte[] bytes) {  
            StringBuilder sb = new StringBuilder(bytes.length * 2);  

            Formatter formatter = new Formatter(sb);  
            for (byte b : bytes) {  
                formatter.format(""%02x"", b);  
            }  

            return sb.toString();  
        } 
",,1,2b3d4aaf2c5233d3bbccca7440884b500f8f882dcbf1f173ca39912426f2c5da
,"static OkHttpClient getUnsafeOkHttpClient() {
  try {
      // Create a trust manager that does not validate certificate chains
      final TrustManager[] trustAllCerts = new TrustManager[] { new X509TrustManager() {
          @Override
          public void checkClientTrusted(java.security.cert.X509Certificate[] chain,
                  String authType) throws CertificateException {
          }

          @Override
          public void checkServerTrusted(java.security.cert.X509Certificate[] chain,
                  String authType) throws CertificateException {
          }

          @Override
          public java.security.cert.X509Certificate[] getAcceptedIssuers() {
              return null;
          }
      } };

      // Install the all-trusting trust manager
      final SSLContext sslContext = SSLContext.getInstance(""SSL"");
      sslContext.init(null, trustAllCerts, new java.security.SecureRandom());
      // Create an ssl socket factory with our all-trusting manager
      final SSLSocketFactory sslSocketFactory = sslContext.getSocketFactory();

      OkHttpClient okHttpClient = new OkHttpClient();
      okHttpClient.setSslSocketFactory(sslSocketFactory);
      okHttpClient.setHostnameVerifier(new HostnameVerifier() {
          @Override
          public boolean verify(String hostname, SSLSession session) {
              return true;
          }
      });

      return okHttpClient;
  } catch (Exception e) {
      throw new RuntimeException(e);
  }
}
",4,0,c9b5cffcdf45a549c93e145e1670e9ab30e4106b684bbf1a7a2b2e7832ca96d1
,"KeySpec ks = new DESKeySpec(""key12345"".getBytes(""UTF-8""));
SecretKey key = SecretKeyFactory.getInstance(""DES"").generateSecret(ks);

IvParameterSpec iv = new IvParameterSpec(
        Hex.decodeHex(""1234567890ABCDEF"".toCharArray()));

Cipher cipher = Cipher.getInstance(""DES/CBC/PKCS5Padding"");
cipher.init(Cipher.DECRYPT_MODE, key, iv);

byte[] decoded = cipher.doFinal(Base64.decodeBase64(""B3xogi/Qfsc=""));

System.out.println(""Decoded: "" + new String(decoded, ""UTF-8""));
",4,0,46f6da45f279cd74a45e11017a0dc7201a0f8a79db15aaa6db4d46b6cb59e709
,"private void workAroundReverseDnsBugInHoneycombAndEarlier(HttpClient client) {
    // Android had a bug where HTTPS made reverse DNS lookups (fixed in Ice Cream Sandwich) 
    // http://code.google.com/p/android/issues/detail?id=13117
    SocketFactory socketFactory = new LayeredSocketFactory() {
        SSLSocketFactory delegate = SSLSocketFactory.getSocketFactory();
        @Override public Socket createSocket() throws IOException {
            return delegate.createSocket();
        }
        @Override public Socket connectSocket(Socket sock, String host, int port,
                InetAddress localAddress, int localPort, HttpParams params) throws IOException {
            return delegate.connectSocket(sock, host, port, localAddress, localPort, params);
        }
        @Override public boolean isSecure(Socket sock) throws IllegalArgumentException {
            return delegate.isSecure(sock);
        }
        @Override public Socket createSocket(Socket socket, String host, int port,
                boolean autoClose) throws IOException {
            injectHostname(socket, host);
            return delegate.createSocket(socket, host, port, autoClose);
        }
        private void injectHostname(Socket socket, String host) {
            try {
                Field field = InetAddress.class.getDeclaredField(""hostName"");
                field.setAccessible(true);
                field.set(socket.getInetAddress(), host);
            } catch (Exception ignored) {
            }
        }
    };
    client.getConnectionManager().getSchemeRegistry()
            .register(new Scheme(""https"", socketFactory, 443));
}
",3,0,4db003b3680705b2fd879410d261f52679766d344c7c7e5a126015e92579474c
,"MessageDigest digest = MessageDigest.getInstance(""SHA-256"");
digest.update(yourPassword.getBytes(""UTF-8""));
String passwordEncrypted = Base64.encodeToString(digest.digest(), Base64.DEFAULT);
",2,0,53a2b81e3341bc8c8112e90edb977c1df6b2fe4efc0201cbd56e2d0e58ce170a
,"import java.security.MessageDigest;

public class PasswordToken {

    static public String makeDigest(String password) 
    {
         String hexStr = """";

        try {
            MessageDigest md = MessageDigest.getInstance(""SHA1"");
            md.reset();
            byte[] buffer = password.getBytes();
            md.update(buffer);
            byte[] digest = md.digest();


            for (int i = 0; i &lt; digest.length; i++) {
                hexStr +=  Integer.toString( ( digest[i] &amp; 0xff ) + 0x100, 16).substring( 1 );

        } 
        } catch(Exception e) // If the algo is not working for some reason on this device
                             // we have to use the strings hash code, which 
                             // could allow duplicates but at least allows tokens
        {
            hexStr = Integer.toHexString(password.hashCode()); 
        }

        return hexStr;
    }

    static public boolean validate(String password, String token) 
    {
         String digestToken = """";
         String simpleToken = """";

         digestToken = makeDigest(password);

         if (0 == digestToken.compareTo(token)) 
             return true; 

         if (0 == simpleToken.compareTo(token))
             return true;

         return false; 
    }
}
",3,0,da1cc5d17eed3da8853586a04c59226265e55ae8316dde607cfdc2ad76ea212e
,"   try {
        PackageInfo info = getPackageManager().getPackageInfo(
            ""COM.YOUR.PACKAGE.NAME"", 
            PackageManager.GET_SIGNATURES);
        for (Signature signature : info.signatures) {
            MessageDigest md = MessageDigest.getInstance(""SHA"");
            md.update(signature.toByteArray());
            Log.d(""My Keyhash"", Base64.encodeToString(md.digest(), Base64.DEFAULT));
        }
    } catch (Exception e) {
        Log.e(""My Keyhash"", e.toString());
    } 
",3,0,aabf1d758ec2ec0c01410cd185f6d8adc30b0756c61bdaf549dda7495198eed7
,"String android_id = Settings.Secure.getString(this.getContentResolver(), Settings.Secure.ANDROID_ID);
MessageDigest md5 = MessageDigest.getInstance(""MD5"");
byte[] digest = md5.digest(android_id.getBytes());
String deviceId = Base64.encodeToString(digest, 0);

AdRequest adRequest = new dRequest.Builder().addTestDevice(""17BB429573B0FA8677D27957B98C7005"").build();
adView.loadAd(adRequest);
",,1,d4feeb327692774fd9eeb6aa67d14201748cbfcd2b18dc270439d8e52468eb9a
,"MessageDigest md = null;
String digest = null;
    try {
        md = MessageDigest.getInstance(""MD5"");

        byte[] hash = md.digest(myStringToEncode.getBytes(""UTF-8"")); //converting byte array to Hexadecimal String
        StringBuilder sb = new StringBuilder(2*hash.length);

        for(byte b : hash){
            sb.append(String.format(""%02x"", b&amp;0xff));
        }

        digest = sb.toString();

    } catch (NoSuchAlgorithmException e) {
        e.printStackTrace();
    } catch (UnsupportedEncodingException e) {
        e.printStackTrace();
    }

return digest;
",,1,97e6c6f247d9077a43653af39693c9b64a8bb1715a759859e060e93d3612a259
,"try {
        PackageInfo info = context.getPackageManager().getPackageInfo(
                ""com.example.sharingapplication"", PackageManager.GET_SIGNATURES); //Your            package name here
        for (Signature signature : info.signatures) {
            MessageDigest md = MessageDigest.getInstance(""SHA"");
            md.update(signature.toByteArray());
            Log.i(""KeyHash:"", Base64.encodeToString(md.digest(), Base64.DEFAULT));
            }

    } catch (NameNotFoundException e) {
    } catch (NoSuchAlgorithmException e) {
    }
}
",3,0,8d23396d0906ee70b54247dfeafbea7ce7bf8801db73ecb8164b776fce7c9573
,"public class MySSLSocketFactory extends SSLSocketFactory {
    SSLContext sslContext = SSLContext.getInstance(""TLS"");

public MySSLSocketFactory(KeyStore truststore) throws NoSuchAlgorithmException, KeyManagementException, KeyStoreException, UnrecoverableKeyException {
    super(truststore);

    TrustManager tm = new X509TrustManager() {
        public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {
        }

        public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {
        }

        public X509Certificate[] getAcceptedIssuers() {
            return null;
        }
    };

    sslContext.init(null, new TrustManager[] { tm }, null);
}

@Override
public Socket createSocket(Socket socket, String host, int port, boolean autoClose) throws IOException, UnknownHostException {
    return sslContext.getSocketFactory().createSocket(socket, host, port, autoClose);
}

@Override
public Socket createSocket() throws IOException {
    return sslContext.getSocketFactory().createSocket();
}
",4,0,6830774148a85891ec841e65c41aeb2fcbf4671b75e91ab8f00ebcc0871217ca
,"HttpsURLConnection yc = (HttpsURLConnection)pocketUrl.openConnection();
yc.setDoInput(true);
yc.setRequestMethod(""GET"");
yc.setSSLSocketFactory(sslContext.getSocketFactory());
if (urlConnection.getResponseCode() != 200) {
    // handle error here
    final String responseMessage = yc.getResponseMessage();
    Log.e(TAG, ""Failed Response: "" + responseMessage);
    return;
}

BufferedReader in = new BufferedReader(new InputStreamReader(yc.getInputStream()));
",,1,469242694f9f8b0b03a579a562188c440bcb1af532b83731c25ca3ff59d6e4e7
,"public class IntegrityUtils {
public static String toASCII(byte b[], int start, int length) {
    StringBuffer asciiString = new StringBuffer();

    for (int i = start; i &lt; (length + start); i++) {
        // exclude nulls from the ASCII representation
        if (b[i] != (byte) 0x00) {
            asciiString.append((char) b[i]);
        }
    }

    return asciiString.toString();
}

public static String getMD5Checksum(File file) throws Exception {
    byte[] b = createChecksum(file);
    String result = """";

    for (int i = 0; i &lt; b.length; i++) {
        result += Integer.toString((b[i] &amp; 0xff) + 0x100, 16).substring(1);
    }
    return result;
}

public static byte[] createChecksum(File file) throws Exception {
    InputStream fis = new FileInputStream(file);

    byte[] buffer = new byte[1024];
    MessageDigest complete = MessageDigest.getInstance(""MD5"");
    int numRead;

    do {
        numRead = fis.read(buffer);
        if (numRead &gt; 0) {
            complete.update(buffer, 0, numRead);
        }
    } while (numRead != -1);

    fis.close();
    return complete.digest();
}
}
",2,0,edc1e7c1e67a46fad508268d497a02c458ef69ef0d86fb4fb260100f44b2f6d8
,"String _publicKey= base64encoded_publickey;


    // InputStream fileInputStream = null;
    try {
        // Receiving side

        byte[] decodedBytes = Base64.decode(_publicKey, Base64.DEFAULT);

        fileInputStream = new ByteArrayInputStream(decodedBytes);

        // Print the decoded string

        String decodedString = new String(decodedBytes);


        CertificateFactory certFactory = CertificateFactory
                .getInstance(CERTIFICATE_TYPE);
        // certFactory.
        X509Certificate cert = (X509Certificate) certFactory
                .generateCertificate(fileInputStream);
        publicKey = cert.getPublicKey();
        Log.d(""TAG"", ""Public key of the certificate:"" + publicKey);


    } catch (Exception e) {
        e.printStackTrace();
        throw new RuntimeException(""Could not intialize encryption module"",
                e);
    } finally {
        if (keyStream != null) {
            try {
                keyStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
",,1,894c3396cfc52739587b83b952d5f44578a4ffa7f0c5dcf1f35d1b9bf892c284
,"String password = ""123456""; 
MessageDigest md = MessageDigest.getInstance(""SHA-256""); 
md.update(password.getBytes()); 
byte byteData[] = md.digest();
",,1,6c5d5459c5761cfcee7007f82820eb60cc549f530eb4afcadfc39aca80990c6b
,"private static SSLSocketFactory createPinnedSSLCertFactory(Context ctx) {
    CertificateFactory cf = CertificateFactory.getInstance(""X.509"");
    Certificate myCert = //read certificate in;
    String keyStoreType = KeyStore.getDefaultType();
    KeyStore keyStore = KeyStore.getInstance(keyStoreType);
    keyStore.load(null, null); //inputstream null creates new keystore
    keyStore.setCertificateEntry(""mycert"", myCert );

    String tmfAlgorithm = TrustManagerFactory.getDefaultAlgorithm();
    TrustManagerFactory tmf = TrustManagerFactory.getInstance(tmfAlgorithm);
    tmf.init(keyStore);

    SSLContext context = SSLContext.getInstance(""TLS"");
    context.init(null, tmf.getTrustManagers(), null);

    return context.getSocketFactory();
}
",,1,5931064a46ee3885194f3c411732caf4b6c23c243e635a2065f0b700cdcc1e23
,"private void printKeyHashForThisDevice() {
    try {
        PackageInfo info = getPackageManager().getPackageInfo(""com.package"", PackageManager.GET_SIGNATURES);
        for (Signature signature : info.signatures) {
            MessageDigest md = MessageDigest.getInstance(""SHA"");
            md.update(signature.toByteArray());

            String keyHash = Base64.encodeToString(md.digest(), Base64.DEFAULT);
            Logger.logger(""============================================"");
            Logger.logger(""KeyHash================  "", keyHash);
            Logger.logger(""============================================"");
            System.out.println(""KeyHash================  "" + keyHash);

        }
    } catch (NameNotFoundException e) {
    } catch (NoSuchAlgorithmException e) {
    }
}
",3,0,0c0aeeaa7555b192480114524b55bff09cde09a0fa2f815c9dcb74136e05c25e
,"public static void showHashKey(Context context) {
        try {
            PackageInfo info = context.getPackageManager().getPackageInfo(
                    ""com.example.tryitonjewelry"", PackageManager.GET_SIGNATURES); //Your package name here
            for (Signature signature : info.signatures) {
                MessageDigest md = MessageDigest.getInstance(""SHA"");
                md.update(signature.toByteArray());
                Log.i(""KeyHash:"", Base64.encodeToString(md.digest(), Base64.DEFAULT));
                }
        } catch (NameNotFoundException e) {
        } catch (NoSuchAlgorithmException e) {
        }
    }
",3,0,9ade337be1fe214fc3d9d6f7614f7e2bfe4f027953d93241895c77ffa7ffd0b0
,"private static final int BUFFER_SIZE = 4096;
private static final char[] TERMINATOR = new char[]{'\r', '\n', '\r', '\n'};

/**
 * Simple SSL connect example to avoid Issue 15356 on Android 2.3.3
 *
 * @param host    The host/server name
 * @param port    The TCP port to use (443 is default for HTTP over SSL)
 * @param file    The file you are requesting (/path/to/file/on/server.doc)
 * @param fileOut Your &lt;code&gt;OutputStream&lt;/code&gt; for the file you are writing to
 * @throws Exception If any error occurs - obviously should be improved for your implementation
 */
private static void downloadFileOverSSL(String host, int port, String file, OutputStream fileOut) throws Exception {
    PrintWriter socketOut = null;
    InputStream socketIn = null;
    try {
        // create a socket to talk to the server on
        SocketFactory factory = SSLSocketFactory.getDefault();
        Socket socket = factory.createSocket(host, port);

        // we'll use this to send our request to the server
        socketOut = new PrintWriter(new OutputStreamWriter(socket.getOutputStream()));

        //This is what Java was sending using URLConnection, and it works here too...
        //  You can always change this to something both your app and server will understand depending how it is setup
        // This is the least you need in the request:
        /*String requestStr = ""GET "" + file + "" HTTP/1.1\r\n"" +
            ""Host: "" + host + ""\r\n"" +
            ""\r\n"";*/
        String requestStr = ""GET "" + file + "" HTTP/1.1\r\n"" +
                ""Host: "" + host + ""\r\n"" +
                ""User-Agent: Java/1.6.0_25\r\n"" +
                ""Accept: text/html, image/gif, image/jpeg, *; q=.2, */*; q=.2"" +
                ""Connection: keep-alive\r\n"" +
                ""\r\n"";
        //Log.i(getLogTag(), ""Request being sent: `"" + requestStr + ""\"""");

        // send the request to the server
        socketOut.print(requestStr);
        socketOut.flush();

        // this reads the server's response
        socketIn = socket.getInputStream();

        /*
           Write the results into our local file's output stream
        */

        // This is the tricky part, the raw socket returns the HTTP 200 response and headers.
        // This can probably be optimized, but it's just reading through until it finds \r\n\r\n

        // You can use something like CharTerminatedInputStream
        //      (ref: http://www.java2s.com/Tutorial/Java/0180__File/AnInputStreamclassthatterminatesthestreamwhenitencountersaparticularbytesequence.htm)
        CharTerminatedInputStream charTermInput = new CharTerminatedInputStream(socketIn, TERMINATOR);
        while (charTermInput.read() != -1) {
            // -1 indicates a match was made, IOException or ProtocolException thrown if match not made by end of stream
        }

        int numBytesRead;
        byte[] buffer = new byte[BUFFER_SIZE];
        while ((numBytesRead = socketIn.read(buffer, 0, BUFFER_SIZE)) != -1) {
            fileOut.write(buffer, 0, numBytesRead);
            //Log.d(getLogTag(), ""Reading data ["" + numBytesRead + ""]: "" + new String(buffer, 0, numBytesRead));
        }
        fileOut.flush();

    } finally {
        safeClose(socketOut);
        safeClose(socketIn);
        safeClose(fileOut);
    }
}

private static void safeClose(Closeable closeable) {
    if (closeable != null) {
        try {
            closeable.close();
        } catch (IOException ioe) {
            //Log.w(getLogTag(), ""Failed to close stream"", ioe);
        }
    }
}
",2,0,885e76b5c0513804507d422a2294de9e3581d1e96b9395371acb5636cabc393c
,"import android.os.Environment;
import android.util.Log;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.math.BigInteger;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.ArrayList;

/**
 * Static methods used for common file operations.
 * 
 * @author Carl Hartung (carlhartung@gmail.com)
 */
public class FileUtils {
    private final static String t = ""FileUtils"";

    // Used to validate and display valid form names.
    public static final String VALID_FILENAME = ""[ _\\-A-Za-z0-9]*.x[ht]*ml"";

    // Storage paths
    public static final String FORMS_PATH = Environment.getExternalStorageDirectory() + ""/odk/forms/"";
    public static final String INSTANCES_PATH = Environment.getExternalStorageDirectory() + ""/odk/instances/"";
    public static final String CACHE_PATH = Environment.getExternalStorageDirectory() + ""/odk/.cache/"";
    public static final String TMPFILE_PATH = CACHE_PATH + ""tmp.jpg"";


    public static ArrayList&lt;String&gt; getValidFormsAsArrayList(String path) {
        ArrayList&lt;String&gt; formPaths = new ArrayList&lt;String&gt;();
        File dir = new File(path);

        if (!storageReady()) {
            return null;
        }
        if (!dir.exists()) {
            if (!createFolder(path)) {
                return null;
            }
        }
        File[] dirs = dir.listFiles();
        for (int i = 0; i &lt; dirs.length; i++) {
          // skip all the directories
          if (dirs[i].isDirectory())
            continue;

            String formName = dirs[i].getName();

          formPaths.add(dirs[i].getAbsolutePath());
        }
        return formPaths;
    }

    public static ArrayList&lt;String&gt; getFoldersAsArrayList(String path) {
        ArrayList&lt;String&gt; mFolderList = new ArrayList&lt;String&gt;();
        File root = new File(path);

        if (!storageReady()) {
            return null;
        }
        if (!root.exists()) {
            if (!createFolder(path)) {
                return null;
            }
        }
        if (root.isDirectory()) {
            File[] children = root.listFiles();
            for (File child : children) {
                boolean directory = child.isDirectory();
                if (directory) {
                    mFolderList.add(child.getAbsolutePath());
                }
            }
        }
        return mFolderList;
    }


    public static boolean deleteFolder(String path) {
        // not recursive
        if (path != null &amp;&amp; storageReady()) {
            File dir = new File(path);
            if (dir.exists() &amp;&amp; dir.isDirectory()) {
                File[] files = dir.listFiles();
                for (File file : files) {
                    if (!file.delete()) {
                        Log.i(t, ""Failed to delete "" + file);
                    }
                }
            }
            return dir.delete();
        } else {
            return false;
        }
    }


    public static boolean createFolder(String path) {
        if (storageReady()) {
            boolean made = true;
            File dir = new File(path);
            if (!dir.exists()) {
                made = dir.mkdirs();
            }
            return made;
        } else {
            return false;
        }
    }


    public static boolean deleteFile(String path) {
        if (storageReady()) {
            File f = new File(path);
            return f.delete();
        } else {
            return false;
        }
    }


    public static byte[] getFileAsBytes(File file) {
        byte[] bytes = null;
        InputStream is = null;
        try {
            is = new FileInputStream(file);

            // Get the size of the file
            long length = file.length();
            if (length &gt; Integer.MAX_VALUE) {
                Log.e(t, ""File "" + file.getName() + ""is too large"");
                return null;
            }

            // Create the byte array to hold the data
            bytes = new byte[(int) length];

            // Read in the bytes
            int offset = 0;
            int read = 0;
            try {
                while (offset &lt; bytes.length &amp;&amp; read &gt;= 0) {
                    read = is.read(bytes, offset, bytes.length - offset);
                    offset += read;
                }
            } catch (IOException e) {
                Log.e(t, ""Cannot read "" + file.getName());
                e.printStackTrace();
                return null;
            }

            // Ensure all the bytes have been read in
            if (offset &lt; bytes.length) {
                try {
                    throw new IOException(""Could not completely read file "" + file.getName());
                } catch (IOException e) {
                    e.printStackTrace();
                    return null;
                }
            }

            return bytes;

        } catch (FileNotFoundException e) {
            Log.e(t, ""Cannot find "" + file.getName());
            e.printStackTrace();
            return null;

        } finally {
            // Close the input stream
            try {
                is.close();
            } catch (IOException e) {
                Log.e(t, ""Cannot close input stream for "" + file.getName());
                e.printStackTrace();
                return null;
            }
        }
    }


    public static boolean storageReady() {
        String cardstatus = Environment.getExternalStorageState();
        if (cardstatus.equals(Environment.MEDIA_REMOVED)
                || cardstatus.equals(Environment.MEDIA_UNMOUNTABLE)
                || cardstatus.equals(Environment.MEDIA_UNMOUNTED)
                || cardstatus.equals(Environment.MEDIA_MOUNTED_READ_ONLY)) {
            return false;
        } else {
            return true;
        }
    }


    public static String getMd5Hash(File file) {
        try {
            // CTS (6/15/2010) : stream file through digest instead of handing it the byte[]
            MessageDigest md = MessageDigest.getInstance(""MD5"");
            int chunkSize = 256;

            byte[] chunk = new byte[chunkSize];

            // Get the size of the file
            long lLength = file.length();

            if (lLength &gt; Integer.MAX_VALUE) {
                Log.e(t, ""File "" + file.getName() + ""is too large"");
                return null;
            }

            int length = (int) lLength;

            InputStream is = null;
            is = new FileInputStream(file);

            int l = 0;
            for (l = 0; l + chunkSize &lt; length; l += chunkSize) {
                is.read(chunk, 0, chunkSize);
                md.update(chunk, 0, chunkSize);
            }

            int remaining = length - l;
            if (remaining &gt; 0) {
                is.read(chunk, 0, remaining);
                md.update(chunk, 0, remaining);
            }
            byte[] messageDigest = md.digest();

            BigInteger number = new BigInteger(1, messageDigest);
            String md5 = number.toString(16);
            while (md5.length() &lt; 32)
                md5 = ""0"" + md5;
            is.close();
            return md5;

        } catch (NoSuchAlgorithmException e) {
            Log.e(""MD5"", e.getMessage());
            return null;

        } catch (FileNotFoundException e) {
            Log.e(""No Cache File"", e.getMessage());
            return null;
        } catch (IOException e) {
            Log.e(""Problem reading from file"", e.getMessage());
            return null;
        } 


    }

}
",,1,b4dd2e02f993995ca7c61856c7dc538d250f2cd73178c0655f2bcceae1ae7b84
,"public static String md5(String s) {
    try {
        // Create MD5 Hash
        MessageDigest digest = java.security.MessageDigest
                .getInstance(""MD5"");
        digest.update(s.getBytes());
        byte messageDigest[] = digest.digest();

        // Create Hex String
        StringBuffer hexString = new StringBuffer();
        for (int i = 0; i &lt; messageDigest.length; i++)
            hexString.append(Integer.toHexString(0xFF &amp; messageDigest[i]));
        return hexString.toString();

    } catch (NoSuchAlgorithmException e) {
        e.printStackTrace();
    }
    return """";
}
",,1,edbc773f5deb752c40c4f779648a2d8ed4ee5ef60b01472f5ef098c942db1a08
,"public static final String md5(final String toEncrypt) {
    try {
        final MessageDigest digest = MessageDigest.getInstance(""md5"");
        digest.update(toEncrypt.getBytes());
        final byte[] bytes = digest.digest();
        final StringBuilder sb = new StringBuilder();
        for (int i = 0; i &lt; bytes.length; i++) {
            sb.append(String.format(""%02X"", bytes[i]));
        }
        return sb.toString().toLowerCase();
    } catch (Exception exc) {
        return """"; // Impossibru!
    }
}
",3,0,cf728c09a6ee0464ad39627931df271d18da311dadd36e4d9f1be808d176262e
,"private static final X500Principal DEBUG_DN = new X500Principal(""CN=Android Debug,O=Android,C=US"");
private boolean isDebuggable(Context ctx)
{
    boolean debuggable = false;

    try
    {
        PackageInfo pinfo = ctx.getPackageManager().getPackageInfo(ctx.getPackageName(),PackageManager.GET_SIGNATURES);
        Signature signatures[] = pinfo.signatures;

        CertificateFactory cf = CertificateFactory.getInstance(""X.509"");

        for ( int i = 0; i &lt; signatures.length;i++)
        {   
            ByteArrayInputStream stream = new ByteArrayInputStream(signatures[i].toByteArray());
            X509Certificate cert = (X509Certificate) cf.generateCertificate(stream);       
            debuggable = cert.getSubjectX500Principal().equals(DEBUG_DN);
            if (debuggable)
                break;
        }
    }
    catch (NameNotFoundException e)
    {
        //debuggable variable will remain false
    }
    catch (CertificateException e)
    {
        //debuggable variable will remain false
    }
    return debuggable;
}
",,1,9d2102a3dc746154dc1a330e568c9af624f9fcd3ad041e9e4e094f54fab1bee8
,"ProviderInstaller.installIfNeeded(context);
SSLContext sslContext = SSLContext.getInstance(""TLSv1.2"");
sslContext.init(KeyManager[] km, TrustManager[] tm, SecureRandom rm);
SSLEngine engine = sslContext.createSSLEngine();
AsyncHttpClient.getDefaultInstance().insertMiddleware((AsyncHttpClientMiddleware) engine); 
",2,0,d887d3beedeccfc7c0aedcb053ae0dadbc1edb40f0db3b5867db2e25ab4eda79
,"KeyStore ks = KeyStore.getInstance(""BKS"");
InputStream is = new FileInputStream(""/etc/security/cacerts.bks"");
ks.load(is, ""changeit"".toCharArray());

List&lt;X509Certificate&gt; certs = new ArrayList&lt;X509Certificate&gt;();
Enumeration&lt;String&gt; aliases = ks.aliases();
while (aliases.hasMoreElements()) {
  String alias = aliases.nextElement();
  X509Certificate cert = (X509Certificate) ks.getCertificate(alias);
  certs.add(cert);
}
",,1,229df1615bcecf97df1ae15355e71e91c76ee23255587a44877e717a32712e98
,"TrustManagerFactory tmf = TrustManagerFactory
                    .getInstance(TrustManagerFactory.getDefaultAlgorithm());
tmf.init((KeyStore) null);
X509TrustManager xtm = (X509TrustManager) tmf.getTrustManagers()[0];
for (X509Certificate cert : xtm.getAcceptedIssuers()) {
    String certStr = ""S:"" + cert.getSubjectDN().getName() + ""\nI:""
                        + cert.getIssuerDN().getName();
    Log.d(TAG, certStr);
}
",,1,268f351f1d563a81cdd12c0a849c8ee5fa33db17cda4be8190736bf252c2f613
,"private SSLSocketFactory getSslSocketFactory() {
    try {
        // Load CAs from an InputStream
        // (could be from a resource or ByteArrayInputStream or ...)
        CertificateFactory cf = CertificateFactory.getInstance(""X.509"");
        // From https://www.washington.edu/itconnect/security/ca/load-der.crt
        InputStream caInput = getApplicationContext().getResources().openRawResource(R.raw.loadder);
        Certificate ca = null;
        try {
            ca = cf.generateCertificate(caInput);
            System.out.println(""ca="" + ((X509Certificate) ca).getSubjectDN());
        } catch (CertificateException e) {
            e.printStackTrace();
        } finally {
            caInput.close();
        }

        // Create a KeyStore containing our trusted CAs
        String keyStoreType = KeyStore.getDefaultType();
        KeyStore keyStore = KeyStore.getInstance(keyStoreType);
        keyStore.load(null, null);
        if (ca == null)
            return null;
        keyStore.setCertificateEntry(""ca"", ca);

        // Create a TrustManager that trusts the CAs in our KeyStore
        String tmfAlgorithm = TrustManagerFactory.getDefaultAlgorithm();
        TrustManagerFactory tmf = TrustManagerFactory.getInstance(tmfAlgorithm);
        tmf.init(keyStore);

        // Create an SSLContext that uses our TrustManager
        SSLContext context = SSLContext.getInstance(""TLS"");
        context.init(null, tmf.getTrustManagers(), null);

        return context.getSocketFactory();
    } catch (NoSuchAlgorithmException e) {
        e.printStackTrace();
    } catch (IOException e) {
        e.printStackTrace();
    } catch (KeyStoreException e) {
        e.printStackTrace();
    } catch (KeyManagementException e) {
        e.printStackTrace();
    } catch (Exception e) {
        e.printStackTrace();
    }
    return null;
}
",3,0,ce503da4450268d902ac55f028776f310b34a95072602090b26e729fdf86c075
,"You can also run the following code:
try {
         PackageInfo info = getPackageManager().getPackageInfo(
                           ""yourpackagename"", 
                            PackageManager.GET_SIGNATURES);
         for (Signature signature : info.signatures) {
                    MessageDigest md = MessageDigest.getInstance(""SHA"");
                    md.update(signature.toByteArray());
                        Log.d(""KeyHash:"", Base64.encodeToString(md.digest(), Base64.DEFAULT));
                  }
            } catch (NameNotFoundException e) {

            } catch (NoSuchAlgorithmException e) {

          }enter code here
",3,0,c8fae593647888442ce5b769445a59cb4c13d2000734287d53a20e17aa56f2de
,"final MessageDigest mDigest = MessageDigest.getInstance(""SHA-224"");
byte[] messageDigest = mDigest.digest(toEncrypt.getBytes());
final BigInteger number = new BigInteger(1, messageDigest);
final String sha = number.toString(16);
final int diff = 32 - sha.length();
final StringBuilder finalSHA = new StringBuilder(32);
for (int i=0;i&lt;diff;i++) {
 finalSHA.append(""0"");
}
finalSHA.append(sha);
return finalSHA.toString();
",,1,61c530dd8b89003c8400e81703cb6f1c929ed043f77d591c4e9ab269b5a7e936
,"public String crypto(SecretKey key, String inString, boolean decrypt){
    Cipher cipher = Cipher.getInstance(""AES/ECB/PKCS5Padding"");
    byte[] inputByte = inString.getBytes(""UTF-8"");
    if (decrypt){
        cipher.init(Cipher.DECRYPT_MODE, key);
        return new String (cipher.doFinal(Base64.decode(inputByte, Base64.DEFAULT)));
    } else {
        cipher.init(Cipher.ENCRYPT_MODE, key);
        return new String (Base64.encode(cipher.doFinal(inputByte), Base64.DEFAULT));
    }
}
",4,0,18d633af2a350b4f98486296440949a20eae8b09ab4e19ba3854ea2ff519343f
,"private static final X500Principal DEBUG_DN = new X500Principal(""CN=Android Debug,O=Android,C=US"");
/* ... */
Signature raw = packageManager.getPackageInfo(getPackageName(), PackageManager.GET_SIGNATURES).signatures[0];
CertificateFactory cf = CertificateFactory.getInstance(""X.509"");
X509Certificate cert = (X509Certificate) cf.generateCertificate(new ByteArrayInputStream(raw.toByteArray()));
boolean debug = cert.getSubjectX500Principal().equals(DEBUG_DN);
",,1,5b75e89c13bfd36940542c6c9d7619c8619ecb4fc2ffc1c6c814ca327966ebe1
,"public static PKCS10CertificationRequest generateCSRFile(KeyPair keyPair, KeyUsage keyUsage) throws IOException, OperatorCreationException {
    String principal = ""CN="" + Utils.getCertificateCommonName() + "", O="" + Utils.getCertificateOrganization();
    AsymmetricKeyParameter privateKey = PrivateKeyFactory.createKey(keyPair.getPrivate().getEncoded());
    AlgorithmIdentifier signatureAlgorithm = new DefaultSignatureAlgorithmIdentifierFinder().find(""SHA1WITHRSA"");
    AlgorithmIdentifier digestAlgorithm = new DefaultDigestAlgorithmIdentifierFinder().find(""SHA-1"");
    ContentSigner signer = new BcRSAContentSignerBuilder(signatureAlgorithm, digestAlgorithm).build(privateKey);

    PKCS10CertificationRequestBuilder csrBuilder = new JcaPKCS10CertificationRequestBuilder(new X500Name(principal), keyPair.getPublic());
    ExtensionsGenerator extensionsGenerator = new ExtensionsGenerator();
    extensionsGenerator.addExtension(Extension.basicConstraints, true, new BasicConstraints(true));
    extensionsGenerator.addExtension(Extension.keyUsage, true, keyUsage);
    csrBuilder.addAttribute(PKCSObjectIdentifiers.pkcs_9_at_extensionRequest, extensionsGenerator.generate());
    PKCS10CertificationRequest csr = csrBuilder.build(signer);

    return csr;
}
",,1,cea1d9d93749756f9bc72173b7b099741b342248e79bdd769fb0fdb145b13ecc
,"public static String getMd5OfFile(String filePath)
{
    String returnVal = """";
    try 
    {
        InputStream   input   = new FileInputStream(filePath); 
        byte[]        buffer  = new byte[1024];
        MessageDigest md5Hash = MessageDigest.getInstance(""MD5"");
        int           numRead = 0;
        while (numRead != -1)
        {
            numRead = input.read(buffer);
            if (numRead &gt; 0)
            {
                md5Hash.update(buffer, 0, numRead);
            }
        }
        input.close();

        byte [] md5Bytes = md5Hash.digest();
        for (int i=0; i &lt; md5Bytes.length; i++)
        {
            returnVal += Integer.toString( ( md5Bytes[i] &amp; 0xff ) + 0x100, 16).substring( 1 );
        }
    } 
    catch(Throwable t) {t.printStackTrace();}
    return returnVal.toUpperCase();
}
",3,0,5b73e61334d983beff934ef5e0ca0ed82c55fb1d74f7e3c33464e79e54801047
,"   this.client = new WebSocketClient(new SslContextFactory(true){
        @Override
        public void customize(SSLEngine sslEngine) {
            SSLParameters sslParams = sslEngine.getSSLParameters();
            //sslParams.setEndpointIdentificationAlgorithm(_endpointIdentificationAlgorithm);
            sslEngine.setSSLParameters(sslParams);

            if (getWantClientAuth())
                sslEngine.setWantClientAuth(getWantClientAuth());
            if (getNeedClientAuth())
                sslEngine.setNeedClientAuth(getNeedClientAuth());

            sslEngine.setEnabledCipherSuites(selectCipherSuites(
                    sslEngine.getEnabledCipherSuites(),
                    sslEngine.getSupportedCipherSuites()));

            sslEngine.setEnabledProtocols(selectProtocols(sslEngine.getEnabledProtocols(),sslEngine.getSupportedProtocols()));
        }
    });
",,1,31e5ec6137d128cbc3cfed68c6cd10f591e5c12f2321ecdfb5a84f41aeccd43e
,"client.setHostnameVerifier(new HostnameVerifier() {
            @Override
            public boolean verify(String hostname, SSLSession session) {
                //return true;
                HostnameVerifier hv =
                        HttpsURLConnection.getDefaultHostnameVerifier();
                return hv.verify(""ipage.com"", session);
            }
        });
",3,0,fcafa03e73e1591bf0790a4ec3d9fec9d81e1102464fdde97b37320e68e829d5
,"    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        mTextView = (TextView) findViewById(R.id.textView);
        mHandler = new Handler(Looper.getMainLooper());
        OkHttpClient client = new OkHttpClient();
        client.setHostnameVerifier(new HostnameVerifier() {
            @Override
            public boolean verify(String hostname, SSLSession session) {
                return true;
            }
        });
        Request request = new Request.Builder()
                .url(""https://justedhak.com/Files/users.php"")
                .build();
        client.newCall(request).enqueue(new Callback() {
            @Override
            public void onFailure(Request request, IOException e) {
                // do something...
                Log.e(LOG_TAG, e.toString());
            }

            @Override
            public void onResponse(Response response) throws IOException {
                // do something...
                Log.i(LOG_TAG, response.body().string());
            }
        });
    }
",,1,6d0637e0b51b9973352341ace106e5f9a336c0169ba756b9161bdb6f1e501d8d
,"try {
            PackageInfo info = getPackageManager().getPackageInfo(""com.package.mypackage"",         PackageManager.GET_SIGNATURES);
            for (Signature signature : info.signatures) {
                MessageDigest md = MessageDigest.getInstance(""SHA"");
                md.update(signature.toByteArray());
                String sign=Base64.encodeToString(md.digest(), Base64.DEFAULT);
                Log.e(""MY KEY HASH:"", sign);
                Toast.makeText(getApplicationContext(),sign,         Toast.LENGTH_LONG).show();
            }
} catch (NameNotFoundException e) {
} catch (NoSuchAlgorithmException e) {
}
",3,0,257a3ce7a1554aabac79c20b5beff6cf6f65cc59052146fadc6488026672b517
,"try {
        TrustManager[] victimizedManager = new TrustManager[]{

                new X509TrustManager() {

                    public X509Certificate[] getAcceptedIssuers() {

                        X509Certificate[] myTrustedAnchors = new X509Certificate[0];

                        return myTrustedAnchors;
                    }

                    @Override
                    public void checkClientTrusted(X509Certificate[] certs, String authType) {
                    }

                    @Override
                    public void checkServerTrusted(X509Certificate[] certs, String authType) {
                    }
                }
        };

        SSLContext sc = SSLContext.getInstance(""SSL"");
        sc.init(null, victimizedManager, new SecureRandom());
        HttpsURLConnection.setDefaultSSLSocketFactory(sc.getSocketFactory());
        HttpsURLConnection.setDefaultHostnameVerifier(new HostnameVerifier() {
            @Override
            public boolean verify(String s, SSLSession sslSession) {
                return true;
            }
        });
    } catch (Exception e) {
        e.printStackTrace();
    }
",4,0,a71c663ff595eb0a827661a6260141d840576cefda14a15a278c7cd0a441f09d
,"private void stripHeaders(){

    public_key = public_key.replace(""-----BEGIN PUBLIC KEY-----"", """");
    public_key = public_key.replace(""-----END PUBLIC KEY-----"", """");

}

public byte[] encryptWithPublicKey(String encrypt) throws Exception {
    byte[] message = encrypt.getBytes(""UTF-8"");
    stripHeaders(); 
    PublicKey apiPublicKey= getRSAPublicKeyFromString(); 
    Cipher rsaCipher = Cipher.getInstance(""RSA/None/PKCS1Padding"", ""SC"");
    rsaCipher.init(Cipher.ENCRYPT_MODE, apiPublicKey); 
    return rsaCipher.doFinal(message);
}

private PublicKey getRSAPublicKeyFromString() throws Exception{
    KeyFactory keyFactory = KeyFactory.getInstance(""RSA"", ""SC""); 
    byte[] publicKeyBytes = Base64.decode(public_key.getBytes(""UTF-8""), Base64.DEFAULT); 
    X509EncodedKeySpec x509KeySpec = new X509EncodedKeySpec(publicKeyBytes); 
    return keyFactory.generatePublic(x509KeySpec);
}
",3,0,8a7780bb4911fb6b4abe31004686dc3f2056d248823c798f965119d9ab896ae2
,"KeyPairGenerator keyGen = null;
KeyPair kp = null;

keyGen = KeyPairGenerator.getInstance(""ECDSA"", ""BC"");

ECGenParameterSpec ecSpec = new ECGenParameterSpec(""brainpoolp160r1"");
keyGen.initialize(ecSpec, new SecureRandom());

kp = keyGen.generateKeyPair();
",2,0,8744b3ddb40eaee01f71f82c2ab7edcdb5b0b95707bbe1313dd3700c5fd5dce7
,"static X509TrustManager tm = new X509TrustManager() {

        public void checkClientTrusted(X509Certificate[] xcs, String string) throws CertificateException {
        }

        public void checkServerTrusted(X509Certificate[] xcs, String string) throws CertificateException {
        }

        public X509Certificate[] getAcceptedIssuers() {
        return null;
        }
};

MyConnectionManager(SchemeRegistry scheme){
    super(scheme);
}

public static MyConnectionManager getInstance() {
    if (instance == null){

        SSLContext ctx=null;
        try {
            ctx = SSLContext.getInstance(""TLS"");
            ctx.init(null, new TrustManager[]{tm}, null);
        } catch (NoSuchAlgorithmException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        } catch (KeyManagementException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }                   
        SchemeRegistry schemeRegistry = new SchemeRegistry();
        schemeRegistry.register( new Scheme(""http"", 80,PlainSocketFactory.getSocketFactory()));
        schemeRegistry.register(new Scheme(""https"", 443, SSLSocketFactory.getSocketFactory()));
        instance = new MyConnectionManager(schemeRegistry);
         // Increase max total connection to 200
         instance.setMaxTotal(15);
         // Increase default max connection per route to 20
         instance.setDefaultMaxPerRoute(15);
         // Increase max connections for localhost:80 to 50
         HttpHost localhost = new HttpHost(""picasaweb.google.com"", 443);
         instance.setMaxForRoute(new HttpRoute(localhost), 10);
    }
    return instance;
}
",4,0,03d66e5677725f16e37cca2ed30ab06226b3e9848c9f7588cd0e7443a4ebe63b
,"public class DecryptUtils{
    public static String AES ( byte [] cipherText, String encryptionKey ) 
        {
            String decrypted = null;

            try
            {
                Cipher cipher = Cipher.getInstance ( ""AES"");
                SecretKeySpec key = new SecretKeySpec ( encryptionKey.getBytes ( ""UTF-8"" ), ""AES"" );
                cipher.init ( Cipher.DECRYPT_MODE, key);
                decrypted = new String ( cipher.doFinal ( cipherText ), ""UTF-8"" );a
            }
            catch ( Exception e )
            {
                e.printStackTrace()
            }

            return decrypted;
        }
}
",3,0,ad58be395d88d838ec1782dd5f1435eec5ccfd98998511c062f119a8a95a1628
,"KeyPairGenerator keyGen = KeyPairGenerator.getInstance(""DH"");
keyGen.initialize(new DHParameterSpec(p, g, l));
KeyPair ackp = keyGen.generateKeyPair();
",1,0,32ab9d4d9e37ca8543d48f231f92d10427d4008de6c0563f3b1b192a387e4792
,"AlgorithmParameterGenerator paramGen = AlgorithmParameterGenerator.getInstance(""DH"");
paramGen.init(1024, new SecureRandom());
AlgorithmParameters params = paramGen.generateParameters();
DHParameterSpec dhSpec = (DHParameterSpec)params.getParameterSpec(DHParameterSpec.class);
System.out.println(""p: "" + dhSpec.getP() + ""\ng: "" + dhSpec.getG() + "" \nl: "" + dhSpec.getL());
",2,0,d2bd67e31cf4b7e22b6eef30a34ee8e9b08a5c0b54e85beb0842dc0061aea218
,"InputStream in = new FileInputStream(""CERT.RSA"");
CertificateFactory factory = CertificateFactory.getInstance(""X.509"")
X509Certificate cert = (X509Certificate) factory.generateCertificate(in);
",,1,5d765973f0cdaec3b416a786e2f9b0a94af0683e6f449685c33811ec896d7957
,"FileReader fileReader = new FileReader(""/path/to/cert.pem"");
PEMReader pemReader = new PEMReader(fileReader);
Object obj = pemReader.readObject();
pemReader.close(); // sloppy IO handling, be thorough in production code
X509CertificateObject certObj = (X509CertificateObject) obj;
System.out.println(certObj.getPublicKey());
",,1,bada552b0d62075b62f33e74cc523110f48a7502f6aed71e2b426f9bf204df41
,"Calendar calendarValidityStart = Calendar.getInstance();

Calendar calendarValidityEnd = Calendar.getInstance();
calendarValidityEnd.add(Calendar.YEAR, 99);

KeyPairGeneratorSpec spec = new KeyPairGeneratorSpec.Builder(context)
        .setAlias(""MyKeyAlias"")
        .setSubject(new X500Principal(""CN="" + ""MyKeyAlias""))
        .setSerialNumber(BigInteger.valueOf(1337))
        .setStartDate(calendarValidityStart.getTime())
        .setEndDate(calendarValidityEnd.getTime())
        .build();

KeyPairGenerator kpGenerator = KeyPairGenerator.getInstance(
        ""RSA"",
        ""AndroidKeyStore"");

kpGenerator.initialize(spec);

KeyPair keyPair = kpGenerator.generateKeyPair();
",,1,199ce17499fd51d611f854d63b0396712bef25b7b6353601313d7ded3441d32b
,"KeyStore keyStore = KeyStore.getInstance(""AndroidKeyStore"");
keyStore.load(null);
KeyStore.Entry keyStoreEntry = keyStore.getEntry(alias, null);
",,1,1bf98479499eb76cf0912cc81fdfb76f706f696b4eed57ba518e8459e95eff9e
,"String keyStoreType = KeyStore.getDefaultType();
            KeyStore keyStore = KeyStore.getInstance(keyStoreType);
            keyStore.load(null, null);
            keyStore.setCertificateEntry(""ca"", ca);// my question shows how to get 'ca'
TrustManagerFactory tmf = TrustManagerFactory.getInstance(
    TrustManagerFactory.getDefaultAlgorithm());
// Initialise the TMF as you normally would, for example:
tmf.init(ca); 

TrustManager[] trustManagers = tmf.getTrustManagers();
final X509TrustManager origTrustmanager = (X509TrustManager)trustManagers[0];

TrustManager[] wrappedTrustManagers = new TrustManager[]{
   new X509TrustManager() {
       public java.security.cert.X509Certificate[] getAcceptedIssuers() {
          return origTrustmanager.getAcceptedIssuers();
       }

       public void checkClientTrusted(X509Certificate[] certs, String authType) {
           origTrustmanager.checkClientTrusted(certs, authType);
       }

       public void checkServerTrusted(X509Certificate[] certs, String authType) {
           try {
               origTrustmanager.checkServerTrusted(certs, authType);
           } catch (CertificateExpiredException e) {}
       }
   }
};

SSLContext sc = SSLContext.getInstance(""TLS"");
sc.init(null, wrappedTrustManagers, null);
HttpsURLConnection.setDefaultSSLSocketFactory(sc.getSocketFactory());  
",4,0,2e907f41a093030f7a563eb05d424f9c927a32161307272b0557261f9573bdcf
,"import java.nio.charset.Charset;
import java.security.AlgorithmParameters;
import java.security.SecureRandom;

import javax.crypto.Cipher;
import javax.crypto.KeyGenerator;
import javax.crypto.SecretKey;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;

import org.apache.commons.codec.binary.Base64;


/*
* This software is provided 'as-is', without any express or implied
* warranty.  In no event will Google be held liable for any damages
* arising from the use of this software.
*
* Permission is granted to anyone to use this software for any purpose,
* including commercial applications, and to alter it and redistribute it
* freely, as long as the origin is not misrepresented.
* 
* @author: Ricardo Champa
* 
*/

public class MyCipher {

    private final static String ALGORITHM = ""AES"";
    private String mySecret;

    public MyCipher(String mySecret){
        this.mySecret = mySecret;
    }

    public MyCipherData encryptUTF8(String data){
        try{
            byte[] bytes = data.toString().getBytes(""utf-8"");
            byte[] bytesBase64 = Base64.encodeBase64(bytes);
            return encrypt(bytesBase64);
        }
        catch(Exception e){
            MyLogs.show(e.getMessage());
            return null;
        }

    }

    public String decryptUTF8(byte[] encryptedData, IvParameterSpec iv){
        try {
            byte[] decryptedData = decrypt(encryptedData, iv);
            byte[] decodedBytes = Base64.decodeBase64(decryptedData);
            String restored_data = new String(decodedBytes, Charset.forName(""UTF8""));
            return restored_data;
        } catch (Exception e) {
            MyLogs.show(e.getMessage());;
            return null;
        }
    }

    //AES
    private MyCipherData encrypt(byte[] raw, byte[] clear) throws Exception {
        SecretKeySpec skeySpec = new SecretKeySpec(raw, ALGORITHM);
        Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
        //solved using PRNGFixes class
        cipher.init(Cipher.ENCRYPT_MODE, skeySpec);
        byte[] data = cipher.doFinal(clear);

        AlgorithmParameters params = cipher.getParameters();
        byte[] iv = params.getParameterSpec(IvParameterSpec.class).getIV();
        return new MyCipherData(data, iv);
    }

    private byte[] decrypt(byte[] raw, byte[] encrypted, IvParameterSpec iv) throws Exception {
        SecretKeySpec skeySpec = new SecretKeySpec(raw, ALGORITHM);
        Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
        cipher.init(Cipher.DECRYPT_MODE, skeySpec, iv);
        byte[] decrypted = cipher.doFinal(encrypted);
        return decrypted;
    }

    private byte[] getKey() throws Exception{
        byte[] keyStart = this.mySecret.getBytes(""utf-8"");
        KeyGenerator kgen = KeyGenerator.getInstance(ALGORITHM);

        SecureRandom sr = SecureRandom.getInstance(""SHA1PRNG"", ""Crypto"");
        //      if (android.os.Build.VERSION.SDK_INT &gt;= 17) {
        //          sr = SecureRandom.getInstance(""SHA1PRNG"", ""Crypto"");
        //      } else {
        //          sr = SecureRandom.getInstance(""SHA1PRNG"");
        //      }
        sr.setSeed(keyStart);
        kgen.init(128, sr); // 192 and 256 bits may not be available
        SecretKey skey = kgen.generateKey();
        byte[] key = skey.getEncoded();
        return key;

    }
    ////////////////////////////////////////////////////////////
    private MyCipherData encrypt(byte[] data) throws Exception{
        return encrypt(getKey(),data);
    }
    private byte[] decrypt(byte[] encryptedData, IvParameterSpec iv) throws Exception{
        return decrypt(getKey(),encryptedData, iv);
    }
}
",1,0,1f205a29cf82bbd527ca3e0039cd1220785f0561dc490c21c4d5f6951ed4ff1e
,"public static boolean verify(PublicKey publicKey, String signedData, String signature) {
        Signature sig;
        try {
            sig = Signature.getInstance(SIGNATURE_ALGORITHM);
            sig.initVerify(publicKey);
            sig.update(signedData.getBytes());
            if (!sig.verify(Base64.decode(signature))) {
                Log.e(TAG, ""Signature verification failed."");
                return false;
            }
            return true;
        } catch (...) {
            ...
        }
        return false;
    }
",,1,5030d3c51f0caae84eacb276bf86f4db752795c1742535a6f2de65430b7a203a
,"public static boolean verify(PublicKey publicKey, String signedData, String signature) {
        Signature sig;
        try {
            sig = Signature.getInstance(SIGNATURE_ALGORITHM);
            sig.initVerify(publicKey);
            sig.update(signedData.getBytes());
            Method verify = java.security.SignatureSpi.class.getDeclaredMethod(""engineVerify"", byte[].class);
            verify.setAccessible(true);
            Object returnValue = verify.invoke(sig, Base64.decode(signature));
            if (!(Boolean)returnValue) {
                Log.e(TAG, ""Signature verification failed."");
                return false;
            }
            return true;
        } catch (...) {
            ...
        }
        return false;
    }
",,1,226ebaf64a6c983bb888dba18d168d3d81fbb5f7f8c475350d492c664921d874
,"  String serverAddress = ""https://auth.timeface.cn/aliyun/sts"";
    OkHttpClient httpClient = new OkHttpClient();

    if (serverAddress.contains(""https"")) {
        ConnectionSpec spec = new ConnectionSpec.Builder(ConnectionSpec.MODERN_TLS)
                .tlsVersions(TlsVersion.TLS_1_0)
                .cipherSuites(CipherSuite.TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA)
                .supportsTlsExtensions(true)
                .build();

        httpClient.setConnectionSpecs(Collections.singletonList(spec));
        httpClient.setHostnameVerifier(new HostnameVerifier() {
            @Override
            public boolean verify(String hostname, SSLSession session) {
                return true;
            }
        });
        httpClient.setConnectTimeout(1, TimeUnit.HOURS);
    }

 Request request = new Request.Builder()
        .url(serverAddress)
        .build();

    httpClient.newCall(request).enqueue(new Callback() {
      @Override public void onFailure(Request request, Throwable throwable) {
        throwable.printStackTrace();
      }

      @Override public void onResponse(Response response) throws IOException {
        if (!response.isSuccessful()) throw new IOException(""Unexpected code "" + response);

        String responseStr = response.body().string();
      }
    });
",4,0,be4b83f3ac2fcc170715429acb6ba9884a38e1051e57acda445db966ed790f4c
," final protected static char[] hexArray = ""0123456789ABCDEF"".toCharArray();

 public byte[] md5x16(String text) {
    try {
        MessageDigest digester = MessageDigest.getInstance(""MD5"");
        digester.update(text.getBytes());
        byte[] md5Bytes = digester.digest();
        String md5Text = new String(md5Bytes); // if you need in String format (PS better use byte[])
        return md5Bytes;

    } catch (Exception e) {
        e.printStackTrace();
    }
    return null;
}
",,1,f0288df8c4f8fec3f8cac16354f6aaa4d7de33ee42d8fd7eb1689fb9e88e7eeb
,"public static String md5(String text) {
    try {
        MessageDigest digester = MessageDigest.getInstance(""MD5"");
        digester.update(text.getBytes());
        byte[] md5Bytes = digester.digest();
        String md5Text = null;

        md5Text = bytesToHex(md5Bytes);

        return md5Text;

    } catch (NoSuchAlgorithmException e) {
        e.printStackTrace();
    }
    return """";
}

public static String bytesToHex(byte[] bytes) {
    char[] hexChars = new char[bytes.length * 2];
    for (int j = 0; j &lt; bytes.length; j++) {
        int v = bytes[j] &amp; 0xFF;
        hexChars[j * 2] = hexArray[v &gt;&gt;&gt; 4];
        hexChars[j * 2 + 1] = hexArray[v &amp; 0x0F];
    }
    return new String(hexChars);
}
",,1,48b7675ca9c5081c2c907477933145ebc306974fcac0a4521e8d21f5ed943358
,"public static List&lt;Cookie&gt; cookies;
public DefaultHttpClient getHttpclient() {
        if (!isHTTPSEnabled()) {
            HttpParams httpParameters = new BasicHttpParams();
            HttpConnectionParams.setConnectionTimeout(httpParameters, timeOut);
            HttpConnectionParams.setSoTimeout(httpParameters, timeOut);
            DefaultHttpClient httpclient = new DefaultHttpClient(httpParameters);
            HttpClientParams.setRedirecting(httpclient.getParams(), false);

            if (cookies != null) {
                int size = cookies.size();
                for (int i = 0; i &lt; size; i++) {
                    httpclient.getCookieStore().addCookie(cookies.get(i));
                }
            }
            httpclient.getParams().setParameter(CoreProtocolPNames.USER_AGENT, ""android"");
            return httpclient;
        } else {
            try {
                KeyStore trustStore = KeyStore.getInstance(KeyStore.getDefaultType());
                trustStore.load(null, null);

                SSLSocketFactory sf = new MySSLSocketFactory(trustStore);
                sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);

                HttpParams httpParameters = new BasicHttpParams();
                HttpConnectionParams.setConnectionTimeout(httpParameters, timeOut);
                HttpConnectionParams.setSoTimeout(httpParameters, timeOut);
                HttpProtocolParams.setVersion(httpParameters, HttpVersion.HTTP_1_1);
                HttpProtocolParams.setContentCharset(httpParameters, HTTP.UTF_8);

                SchemeRegistry registry = new SchemeRegistry();
                registry.register(new Scheme(""http"", PlainSocketFactory.getSocketFactory(), 80));
                registry.register(new Scheme(""https"", sf, 443));

                ClientConnectionManager ccm = new ThreadSafeClientConnManager(httpParameters, registry);
                DefaultHttpClient httpclient = new DefaultHttpClient(ccm, httpParameters);
                HttpClientParams.setRedirecting(httpclient.getParams(), false);

                if (cookies != null) {
                    int size = cookies.size();
                    for (int i = 0; i &lt; size; i++) {
                        httpclient.getCookieStore().addCookie(cookies.get(i));
                    }
                }
                httpclient.getParams().setParameter(CoreProtocolPNames.USER_AGENT, ""android"");
                return httpclient;

            } catch (Exception e) {
            }
        }
        return null;

    }
",4,0,53e475c345cf7f21b763974f068c69640b7a8002198e91ab6aa0308ad7e6cb53
," private static OkHttpClient getUnsafeOkHttpClient() {

    // Create a trust manager that does not validate certificate chains
    final TrustManager[] trustAllCerts = new TrustManager[]{
            new X509TrustManager() {
                @Override
                public void checkClientTrusted(java.security.cert.X509Certificate[] chain, String authType) throws CertificateException {
                }

                @Override
                public void checkServerTrusted(java.security.cert.X509Certificate[] chain, String authType) throws CertificateException {
                }

                @Override
                public java.security.cert.X509Certificate[] getAcceptedIssuers() {
                    return new X509Certificate[0];
                }
            }
    };

    // Install the all-trusting trust manager
    SSLContext sslContext = null;
    try {
        sslContext = SSLContext.getInstance(""SSL"");
    } catch (NoSuchAlgorithmException e) {
        e.printStackTrace();
    }
    try {
        sslContext.init(null, trustAllCerts, new java.security.SecureRandom());
    } catch (KeyManagementException e) {
        e.printStackTrace();
    }
    // Create an ssl socket factory with our all-trusting manager
    final SSLSocketFactory sslSocketFactory = sslContext.getSocketFactory();

    OkHttpClient client = new OkHttpClient();

    OkHttpClient.Builder builder = client.newBuilder();
    builder.sslSocketFactory(sslSocketFactory);
    builder.hostnameVerifier(new HostnameVerifier() {
        @Override
        public boolean verify(String hostname, SSLSession session) {
            return true;


        }
    });

    return builder.build();

}
",4,0,79694a07c909ca32e4e15a8f2a9c6143e7b440f48cd6488d79ac6c9a80ae9443
,"private static String hmacSha1(String value, String key)
            throws UnsupportedEncodingException, NoSuchAlgorithmException,
            InvalidKeyException {
        String type = ""HmacSHA1"";
        SecretKeySpec secret = new SecretKeySpec(key.getBytes(), type);
        Mac mac = Mac.getInstance(type);
        mac.init(secret);
        byte[] bytes = mac.doFinal(value.getBytes());
        return bytesToHex(bytes);
    }

    private final static char[] hexArray = ""0123456789abcdef"".toCharArray();

    private static String bytesToHex(byte[] bytes) {
        char[] hexChars = new char[bytes.length * 2];
        int v;
        for (int j = 0; j &lt; bytes.length; j++) {
            v = bytes[j] &amp; 0xFF;
            hexChars[j * 2] = hexArray[v &gt;&gt;&gt; 4];
            hexChars[j * 2 + 1] = hexArray[v &amp; 0x0F];
        }
        return new String(hexChars);
    }
",3,0,e8e63bbaf76d8385436185e731bea5e4026ae34c510112891d75f58f72bbfa41
,"SSLSocketFactory sf = new SSLSocketFactory(
SSLContext.getInstance(""TLS""),
SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
Scheme sch = new Scheme(""https"", 443, sf);
httpclient.getConnectionManager().getSchemeRegistry().register(sch);

HttpGet httpget = new HttpGet(""https://host/"");
",4,0,1f539e78609a5ddb7a509de9a447b58b0a6903f6f4f306f62f3ac88f9abd3849
,"    private void disableSSLCertCheck() throws NoSuchAlgorithmException, KeyManagementException {
    // Create a trust manager that does not validate certificate chains
    TrustManager[] trustAllCerts = new TrustManager[] {new X509TrustManager() {
            public java.security.cert.X509Certificate[] getAcceptedIssuers() {
                return null;
            }
            public void checkClientTrusted(X509Certificate[] certs, String authType) {
            }
            public void checkServerTrusted(X509Certificate[] certs, String authType) {
            }
        }
    };

    // Install the all-trusting trust manager
    SSLContext sc = SSLContext.getInstance(""SSL"");
    sc.init(null, trustAllCerts, new java.security.SecureRandom());
    HttpsURLConnection.setDefaultSSLSocketFactory(sc.getSocketFactory());

    // Create all-trusting host name verifier
    HostnameVerifier allHostsValid = new HostnameVerifier() {
        public boolean verify(String hostname, SSLSession session) {
            return true;
        }
    };

    // Install the all-trusting host verifier
    HttpsURLConnection.setDefaultHostnameVerifier(allHostsValid);
    }
",4,0,ff51e0c42ea7bdd6bc7a8180acf82a8b03792657e24baf1bdfd1cc37d7cc2c36
,"try {
            PackageInfo info = getPackageManager().getPackageInfo(
                    ""com.facebook.scrumptious"", PackageManager.GET_SIGNATURES);
            for (Signature signature : info.signatures) {
                MessageDigest md = MessageDigest.getInstance(""SHA"");
                md.update(signature.toByteArray());
                Log.d(""YOURHASH KEY:"",
                        Base64.encodeToString(md.digest(), Base64.DEFAULT));
            }
        } catch (NameNotFoundException e) {

        } catch (NoSuchAlgorithmException e) {

        }

thanks.
",3,0,d9cab5d8d8052d3247da9e51b81cdbaacf6db90ac77ad323d0253be1840fee6f
,"    try {
    PackageInfo info = getPackageManager().getPackageInfo(
            ""Your.Packet..."", 
            PackageManager.GET_SIGNATURES);
    for (Signature signature : info.signatures) {
        MessageDigest md = MessageDigest.getInstance(""SHA"");
        md.update(signature.toByteArray());
        Log.d(""KeyHash:"", Base64.encodeToString(md.digest(), Base64.DEFAULT));
        }
} catch (NameNotFoundException e) {

} catch (NoSuchAlgorithmException e) {

}
",3,0,eafeb2f103799f6c1f28d4dc111ab1d47addd57c7680c587c2dba8b8b5001a68
,"DESKeySpec keySpec = new DESKeySpec(""Your secret Key phrase"".getBytes(""UTF8""));
SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(""DES"");
SecretKey key = keyFactory.generateSecret(keySpec);
sun.misc.BASE64Encoder base64encoder = new BASE64Encoder();
sun.misc.BASE64Decoder base64decoder = new BASE64Decoder();
.........

// ENCODE plainTextPassword String
byte[] cleartext = plainTextPassword.getBytes(""UTF8"");      

Cipher cipher = Cipher.getInstance(""DES""); // cipher is not thread safe
cipher.init(Cipher.ENCRYPT_MODE, key);
String encryptedPwd = base64encoder.encode(cipher.doFinal(cleartext));
// now you can store it 
......

// DECODE encryptedPwd String
byte[] encrypedPwdBytes = base64decoder.decodeBuffer(encryptedPwd);

Cipher cipher = Cipher.getInstance(""DES"");// cipher is not thread safe
cipher.init(Cipher.DECRYPT_MODE, key);
byte[] plainTextPwdBytes = (cipher.doFinal(encrypedPwdBytes));
",4,0,0ad3392aba75fd60b488a5b0303887c9e2b2d7c67e642d70a2c961097910b93c
,"public static String calculateMD5(File updateFile) {
        MessageDigest digest;
        try {
            digest = MessageDigest.getInstance(""MD5"");
        } catch (NoSuchAlgorithmException e) {
            Log.e(""calculateMD5"", ""Exception while getting Digest"", e);
            return null;
        }

        InputStream is;
        try {
            is = new FileInputStream(updateFile);
        } catch (FileNotFoundException e) {
            Log.e(""calculateMD5"", ""Exception while getting FileInputStream"", e);
            return null;
        }

        byte[] buffer = new byte[8192];
        int read;
        try {
            while ((read = is.read(buffer)) &gt; 0) {
                digest.update(buffer, 0, read);
            }
            byte[] md5sum = digest.digest();
            BigInteger bigInt = new BigInteger(1, md5sum);
            String output = bigInt.toString(16);
            // Fill to 32 chars
            output = String.format(""%32s"", output).replace(' ', '0');
            return output;
        } catch (IOException e) {
            throw new RuntimeException(""Unable to process file for MD5"", e);
        } finally {
            try {
                is.close();
            } catch (IOException e) {
                Log.e(""calculateMD5"", ""Exception on closing MD5 input stream"", e);
            }
        }
    }   
",,1,81ee4f3f0c50d0aa4ed2574011a939fa839440f598484465eb724fb6e7ee98a7
,"public class MySocketFactory implements SocketFactory, LayeredSocketFactory {
private SSLContext mSslContext = null;

{
    try {
        mSslContext = SSLContext.getInstance(""TLS"");

        TrustManager trustManager = new X509TrustManager() {

            @Override
            public X509Certificate[] getAcceptedIssuers() {
                return null;
            }

            @Override
            public void checkServerTrusted(X509Certificate[] chain, String authType)
                    throws CertificateException {
                // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
                // NOTE : This is where we can calculate the certificate's fingerprint,
                // show it to the user and throw an exception in case he doesn't like it
            }

            @Override
            public void checkClientTrusted(X509Certificate[] chain, String authType)
                    throws CertificateException {
            }
        };

        mSslContext.init(null, new TrustManager[]{ trustManager }, new SecureRandom());
    } catch (Exception e) {
        e.printStackTrace();
    }
}

@Override
public Socket connectSocket(Socket socket, String host, int port,
        InetAddress localAddress, int localPort, HttpParams params)
                throws IOException, UnknownHostException, ConnectTimeoutException {

    int connTimeout = HttpConnectionParams.getConnectionTimeout(params);
    int soTimeout = HttpConnectionParams.getSoTimeout(params);

    SocketAddress socketAddress = new InetSocketAddress(localAddress, localPort);
    socket.bind(socketAddress);
    socket.connect(new InetSocketAddress(host, port), connTimeout);
    socket.setSoTimeout(soTimeout);

    return socket;
}

@Override
public Socket createSocket() throws IOException {
    return mSslContext.getSocketFactory().createSocket();
}

@Override
public boolean isSecure(Socket sock) throws IllegalArgumentException {
    return true;
}



@Override
public Socket createSocket(Socket socket, String host, int port,
        boolean autoClose) throws IOException, UnknownHostException {

    return mSslContext.getSocketFactory().createSocket(socket, host, port, autoClose);
}
",4,0,cd7d92e323cf8c96da3332720d385312eaf3d44d2cae13c51ef2424d71ad7469
,"/**
 * Gets a 1-way hashed value of the device's unique ID. This value is
 * encoded using a SHA-256 one way hash and cannot be used to determine what
 * device this data came from.
 * 
 * @param appContext
 *            The context used to access the settings resolver
 * @return An 1-way hashed identifier unique to this device or null if an
 *         ID, or the hashing algorithm is not available.
 */
public static String getGlobalDeviceId(final Context appContext) {
    String systemId = System.getString(appContext.getContentResolver(),
            System.ANDROID_ID);
    if (systemId == null) {
        return null;
    }

    try {
        MessageDigest md = MessageDigest.getInstance(""SHA-256"");
        byte[] digest = md.digest(systemId.getBytes());
        BigInteger hashedNumber = new BigInteger(1, digest);
        return new String(hashedNumber.toString(16));

    } catch (NoSuchAlgorithmException e) {
        return null;
    }
}
",2,0,10d58d3d5dde59060a4f9b4b0bd6a98d89feebefbb3e1d4737e207fce3aa729d
,"void saveCredentials(String username, String password) {
 /* create some random salt bytes - the value doesn't need to be secret (which is
  why we can save it) but it must be unpredictable and unique per-user */
 SecureRandom sr = new SecureRandom();
 byte[] salt = new byte[16];
 sr.nextBytes(salt);

  // hash the (salt + password)
  // hashing algorithms vary, but for now, SHA256 is a reasonable choice
  try {
     MessageDigest hasher = MessageDigest.getInstance(""SHA-256"");
     hasher.update(salt);
     hasher.update(password.getBytes(""UTF-8""));
     byte[] hashedbytes = hasher.digest();

     // we can now save the salt and the hashed bytes to a file,
     //  SharedPreference or any other storage location
     savedata(username, salt, hashedbytes);

  } catch (Exception e) {
     // do something sensible on errors
  }

}
",2,0,49835607725e2707988b7af840f152a6dac521797d3480bcac4a8e8bcd977f79
,"boolean checkPassword(String username, String password) {
  // read the info for the user that we saved in storage
  byte[] salt = readdata(username, ""salt"");
  byte[] correcthash = readdata(username, ""pwdhash"");

  // hash the password we are checking in the same way that we did
  // for the original password
  try {
     MessageDigest hasher = MessageDigest.getInstance(""SHA-256"");
     hasher.update(salt);
     hasher.update(password.getBytes(""UTF-8""));
     byte[] testhash = hasher.digest();

     // if the password is correct, the two hashed values will match
     // - if it's wrong, the hashed values will have one or more
     // bytes that do not match
     for (int i=0; i &lt; testhash.length; i++) {
         if (testhash[i] != correcthash[i])
             return false;  // mismatch - wrong password
     }

     // if we reach here, all the hash bytes match, so the password
     // matches the original
     return true;

  } catch (Exception e) {
     // do something sensible on errors
  }

  return false;
}
",4,0,d7b5250855596006d00da21bfa2396321926335a8ef82f5875d17161f8a3684e
,"public ServiceConnectionSE(Certificate ca, String url) throws IOException
{

    // Create a KeyStore containing our trusted CAs
    String keyStoreType = KeyStore.getDefaultType();
    KeyStore keyStore;
    SSLContext context = null;
    try {
        keyStore = KeyStore.getInstance(keyStoreType);
        keyStore.load(null, null);
        keyStore.setCertificateEntry(""ca"", ca);
        // Create a TrustManager that trusts the CAs in our KeyStore
        String tmfAlgorithm = TrustManagerFactory.getDefaultAlgorithm();
        TrustManagerFactory tmf = TrustManagerFactory.getInstance(tmfAlgorithm);
        tmf.init(keyStore);

        // Create an SSLContext that uses our TrustManager
        context = SSLContext.getInstance(""TLS"");
        context.init(null, tmf.getTrustManagers(), null);


    } catch (KeyStoreException | NoSuchAlgorithmException | CertificateException | KeyManagementException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    }


    // Tell the URLConnection to use a SocketFactory from our SSLContext


    connection = (HttpsURLConnection) new URL(url).openConnection();
    connection.setSSLSocketFactory(context.getSocketFactory());

    connection.setUseCaches(false);
    connection.setDoOutput(true);
    connection.setDoInput(true);
}
",3,0,fb7ca54a37025ea60783b3057949cb53e764dfe3d412b472322a152163b0d286
,"CertificateFactory cf = CertificateFactory.getInstance(""X.509"");
AssetManager assetManager = getAssets();
InputStream caInput = new BufferedInputStream(assetManager.open(""your_cert.cer""));
Certificate ca = cf.generateCertificate(caInput);

AndroidHttpTransport androidHttpTransport = new AndroidHttpTransport(ca, url);
",,1,6c002756c8802eaa28606249e8040a9f7a00a4d4946d1085c62174df04606aee
,"        PackageInfo packageInfo;
        String key = null;
        try {
            //getting application package name, as defined in manifest
            String packageName = context.getApplicationContext().getPackageName();

            //Retriving package info
            packageInfo = context.getPackageManager().getPackageInfo(packageName,
                    PackageManager.GET_SIGNATURES);

            MyLog.e(""Package Name="", context.getApplicationContext().getPackageName());

            for (Signature signature : packageInfo.signatures) {
                MessageDigest md = MessageDigest.getInstance(""SHA"");
                md.update(signature.toByteArray());
                key = new String(Base64.encode(md.digest(), 0));

                // String key = new String(Base64.encodeBytes(md.digest()));
                MyLog.e(""Key Hash="", key);
            }
        } catch (NameNotFoundException e1) {
            MyLog.e(""Name not found"", e1.toString());
        }
        catch (NoSuchAlgorithmException e) {
            MyLog.e(""No such an algorithm"", e.toString());
        } catch (Exception e) {
            MyLog.e(""Exception"", e.toString());
        }
",2,0,bb8bc292d52febaacb9cb6e5b4483d249a9406053a490c631648476e12ef25c5
,"FTPSClient ftpClient = new FTPSClient(""TLS"", false);
try {
    TrustManager[] trustManager = new TrustManager[] { new X509TrustManager() {
        @Override
        public X509Certificate[] getAcceptedIssuers() {
            return null;
        }

        @Override
        public void checkClientTrusted(X509Certificate[] certs, String authType) {
        }

        @Override
        public void checkServerTrusted(X509Certificate[] certs, String authType) {
        }
    } };

    ftpClient.setTrustManager(trustManager[0]);
    KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());
    kmf.init(null, null);
    KeyManager km = kmf.getKeyManagers()[0];
    ftpClient.setKeyManager(km);
    ftpClient.setBufferSize(1024 * 1024);
    ftpClient.setConnectTimeout(100000);
    ftpClient.connect(InetAddress.getByName(""ipaddress""), 990);
    ftpClient.setSoTimeout(100000);

    if (ftpClient.login(""user"", ""password"")) {
        ftpClient.execPBSZ(0);
        ftpClient.execPROT(""P"");
        ftpClient.changeWorkingDirectory(""/"");
        // 250 = directory succesfully changed
        if (ftpClient.getReplyString().contains(""250"")) {
            ftpClient.setFileType(FTP.BINARY_FILE_TYPE);
            ftpClient.enterLocalPassiveMode();
            BufferedInputStream buffIn = null;

            for (File picture : pictures) {
                buffIn = new BufferedInputStream(new FileInputStream(picture.getAbsolutePath()));
                boolean result = ftpClient.storeFile(picture.getName(), buffIn);
                try {
                    buffIn.close();
                } catch (Exception e) {
                }
                if (result)
                    picture.delete();
            }
        }
    }

} catch (SocketException e) {
    Log.e(""APPTAG"", e.getStackTrace().toString());
} catch (UnknownHostException e) {
    Log.e(""APPTAG"", e.getStackTrace().toString());
} catch (IOException e) {
    Log.e(""APPTAG"", e.getStackTrace().toString());
} catch (Exception e) {
    Log.e(""APPTAG"", e.getStackTrace().toString());
} finally {
    try {
        ftpClient.logout();
    } catch (Exception e2) {
    }
    try {
        ftpClient.disconnect();
    } catch (Exception e2) {
    }
}
",4,0,0ad7ab6f632a7a7f42104feb6795c1fa736b00269be4b4714b7620c49f942cd9
,"public class MainClass {
  public static void main(String[] args) {
    String host = args[0];
    int port = Integer.parseInt(args[1]);

    try {
      System.out.println(""Locating socket factory for SSL..."");
      SSLSocketFactory factory = (SSLSocketFactory) SSLSocketFactory.getDefault();

      System.out.println(""Creating secure socket to "" + host + "":"" + port);
      SSLSocket socket = (SSLSocket) factory.createSocket(host, port);

      System.out.println(""Enabling all available cipher suites..."");
      String[] suites = socket.getSupportedCipherSuites();
      socket.setEnabledCipherSuites(suites);

      System.out.println(""Registering a handshake listener..."");
      socket.addHandshakeCompletedListener(new MyHandshakeListener());

      System.out.println(""Starting handshaking..."");
      socket.startHandshake();

      System.out.println(""Just connected to "" + socket.getRemoteSocketAddress());
    } catch (IOException e) {
      e.printStackTrace();
    }
  }
}

class MyHandshakeListener implements HandshakeCompletedListener {
  public void handshakeCompleted(HandshakeCompletedEvent e) {
    System.out.println(""Handshake succesful!"");
    System.out.println(""Using cipher suite: "" + e.getCipherSuite());
  }
}
",3,0,470381635544bc95ae90842bf8e81ca2b1f01285233653bcf0b55cc5484e6f66
,"private boolean ValidateHTTPSCertificate()
    {
        boolean result = false;
        String serverCertPublicSerial = ""abcdefghijklmnopqrstuvwxyz"";

        try
        {
            URL url = new URL( ""https://your-url-goes-here"" );
            HttpsURLConnection con = (HttpsURLConnection) url.openConnection();

            if(con!=null){

                try {
                    con.connect();

                    int respCode =  con.getResponseCode();
                    String pageResult = convertInputStreamToString(con.getInputStream());

                    Certificate[] certs = con.getServerCertificates();
                    for(Certificate cert : certs){

                        X509Certificate x509cert = (X509Certificate)cert;

                        BigInteger serialNum = x509cert.getSerialNumber();

                        String name = x509cert.getIssuerDN().getName();
                        String publicKeySerial = serialNum.toString(16);

                        if (publicKeySerial.toLowerCase().equals(serverCertPublicSerial.toLowerCase()) == true )
                        {
                            result = true;
                            break;
                        }
                    }
                    //con.disconnect();
                } catch (SSLPeerUnverifiedException e) {
                    e.printStackTrace();
                } catch (IOException e){
                    e.printStackTrace();
                }
            }
        }
        catch (Exception ex)
        {
            String  msg = ex.getMessage();
        }

        return result;
    }
",3,0,18356ad8fc6fd44171d31a61fa595ee10327d33e5633c6ccb8d135a8b7420030
,"public class AudioWorker extends Thread
{ 
    private boolean stopped = false;

    private String host;
    private int port;
    private long id=0;
    boolean run=true;
    AudioRecord recorder;

    //ulaw encoder stuff
    private final static String TAG = ""UlawEncoderInputStream"";

    private final static int MAX_ULAW = 8192;
    private final static int SCALE_BITS = 16;

    private InputStream mIn;

    private int mMax = 0;

    private final byte[] mBuf = new byte[1024];
    private int mBufCount = 0; // should be 0 or 1

    private final byte[] mOneByte = new byte[1];
    ////
    /**
     * Give the thread high priority so that it's not canceled unexpectedly, and start it
     */
    public AudioWorker(String host, int port, long id)
    { 
        this.host = host;
        this.port = port;
        this.id = id;
        android.os.Process.setThreadPriority(android.os.Process.THREAD_PRIORITY_URGENT_AUDIO);
//        start();
    }

    @Override
    public void run()
    { 
        Log.i(""AudioWorker"", ""Running AudioWorker Thread"");
        recorder = null;
        AudioTrack track = null;
        short[][]   buffers  = new short[256][160];
        int ix = 0;

        /*
         * Initialize buffer to hold continuously recorded AudioWorker data, start recording, and start
         * playback.
         */
        try
        {
            int N = AudioRecord.getMinBufferSize(8000,AudioFormat.CHANNEL_IN_MONO,AudioFormat.ENCODING_PCM_16BIT);
            recorder = new AudioRecord(AudioSource.MIC, 8000, AudioFormat.CHANNEL_IN_MONO, AudioFormat.ENCODING_PCM_16BIT, N*10);
            track = new AudioTrack(AudioManager.STREAM_MUSIC, 8000, 
                    AudioFormat.CHANNEL_OUT_MONO, AudioFormat.ENCODING_PCM_16BIT, N*10, AudioTrack.MODE_STREAM);
            recorder.startRecording();
            track.play();
            /*
             * Loops until something outside of this thread stops it.
             * Reads the data from the recorder and writes it to the AudioWorker track for playback.
             */


            SSLContext sc = SSLContext.getInstance(""SSL"");
            sc.init(null, trustAllCerts, new java.security.SecureRandom());
            SSLSocketFactory sslFact = sc.getSocketFactory();
            SSLSocket socket = (SSLSocket)sslFact.createSocket(host, port);

            socket.setSoTimeout(10000);
            InputStream inputStream = socket.getInputStream();
            DataInputStream in = new DataInputStream(new BufferedInputStream(inputStream));
            OutputStream outputStream = socket.getOutputStream();
            DataOutputStream os = new DataOutputStream(new BufferedOutputStream(outputStream));
            PrintWriter socketPrinter = new PrintWriter(os);
            BufferedReader br = new BufferedReader(new InputStreamReader(in));

//          socketPrinter.println(""POST /transmitaudio?patient=1333369798370 HTTP/1.0"");
            socketPrinter.println(""POST /transmitaudio?id=""+id+"" HTTP/1.0"");
            socketPrinter.println(""Content-Type: AudioWorker/basic"");
            socketPrinter.println(""Content-Length: 99999"");
            socketPrinter.println(""Connection: Keep-Alive"");
            socketPrinter.println(""Cache-Control: no-cache"");
            socketPrinter.println();
            socketPrinter.flush();


            while(!stopped)
            { 
                Log.i(""Map"", ""Writing new data to buffer"");
                short[] buffer = buffers[ix++ % buffers.length];

                N = recorder.read(buffer,0,buffer.length);
                track.write(buffer, 0, buffer.length);

                byte[] bytes2 = new byte[buffer.length * 2];
                ByteBuffer.wrap(bytes2).order(ByteOrder.LITTLE_ENDIAN).asShortBuffer().put(buffer);

                read(bytes2, 0, bytes2.length);
//              os.write(bytes2,0,bytes2.length);
                os.write(bytes2,0,bytes2.length);

                System.out.println(""bytesRead ""+buffer.length);
                System.out.println(""data ""+Arrays.toString(buffer));
            }
            os.close();
        }
        catch(Throwable x)
        { 
            Log.w(""AudioWorker"", ""Error reading voice AudioWorker"", x);
        }
        /*
         * Frees the thread's resources after the loop completes so that it can be run again
         */
        finally
        { 
            recorder.stop();
            recorder.release();
            track.stop();
            track.release();
        }
    }

    /**
     * Called from outside of the thread in order to stop the recording/playback loop
     */

/**
 * Called from outside of the thread in order to stop the recording/playback loop
 */
public void close()
{ 
     stopped = true;
}
public void resumeThread()
{ 
     stopped = false;
     run();
}

    TrustManager[] trustAllCerts = new TrustManager[]{
            new X509TrustManager() {
                public java.security.cert.X509Certificate[] getAcceptedIssuers() {
                    return null;
                }
                public void checkClientTrusted(
                        java.security.cert.X509Certificate[] certs, String authType) {
                }
                public void checkServerTrusted(
                        java.security.cert.X509Certificate[] chain, String authType) {
                    for (int j=0; j&lt;chain.length; j++)
                    {
                        System.out.println(""Client certificate information:"");
                        System.out.println(""  Subject DN: "" + chain[j].getSubjectDN());
                        System.out.println(""  Issuer DN: "" + chain[j].getIssuerDN());
                        System.out.println(""  Serial number: "" + chain[j].getSerialNumber());
                        System.out.println("""");
                    }
                }
            }
    };


    public static void encode(byte[] pcmBuf, int pcmOffset,
            byte[] ulawBuf, int ulawOffset, int length, int max) {

        // from  'ulaw' in wikipedia
        // +8191 to +8159                          0x80
        // +8158 to +4063 in 16 intervals of 256   0x80 + interval number
        // +4062 to +2015 in 16 intervals of 128   0x90 + interval number
        // +2014 to  +991 in 16 intervals of  64   0xA0 + interval number
        //  +990 to  +479 in 16 intervals of  32   0xB0 + interval number
        //  +478 to  +223 in 16 intervals of  16   0xC0 + interval number
        //  +222 to   +95 in 16 intervals of   8   0xD0 + interval number
        //   +94 to   +31 in 16 intervals of   4   0xE0 + interval number
        //   +30 to    +1 in 15 intervals of   2   0xF0 + interval number
        //     0                                   0xFF

        //    -1                                   0x7F
        //   -31 to    -2 in 15 intervals of   2   0x70 + interval number
        //   -95 to   -32 in 16 intervals of   4   0x60 + interval number
        //  -223 to   -96 in 16 intervals of   8   0x50 + interval number
        //  -479 to  -224 in 16 intervals of  16   0x40 + interval number
        //  -991 to  -480 in 16 intervals of  32   0x30 + interval number
        // -2015 to  -992 in 16 intervals of  64   0x20 + interval number
        // -4063 to -2016 in 16 intervals of 128   0x10 + interval number
        // -8159 to -4064 in 16 intervals of 256   0x00 + interval number
        // -8192 to -8160                          0x00

        // set scale factors
        if (max &lt;= 0) max = MAX_ULAW;

        int coef = MAX_ULAW * (1 &lt;&lt; SCALE_BITS) / max;

        for (int i = 0; i &lt; length; i++) {
            int pcm = (0xff &amp; pcmBuf[pcmOffset++]) + (pcmBuf[pcmOffset++] &lt;&lt; 8);
            pcm = (pcm * coef) &gt;&gt; SCALE_BITS;

            int ulaw;
            if (pcm &gt;= 0) {
                ulaw = pcm &lt;= 0 ? 0xff :
                        pcm &lt;=   30 ? 0xf0 + ((  30 - pcm) &gt;&gt; 1) :
                        pcm &lt;=   94 ? 0xe0 + ((  94 - pcm) &gt;&gt; 2) :
                        pcm &lt;=  222 ? 0xd0 + (( 222 - pcm) &gt;&gt; 3) :
                        pcm &lt;=  478 ? 0xc0 + (( 478 - pcm) &gt;&gt; 4) :
                        pcm &lt;=  990 ? 0xb0 + (( 990 - pcm) &gt;&gt; 5) :
                        pcm &lt;= 2014 ? 0xa0 + ((2014 - pcm) &gt;&gt; 6) :
                        pcm &lt;= 4062 ? 0x90 + ((4062 - pcm) &gt;&gt; 7) :
                        pcm &lt;= 8158 ? 0x80 + ((8158 - pcm) &gt;&gt; 8) :
                        0x80;
            } else {
                ulaw = -1 &lt;= pcm ? 0x7f :
                          -31 &lt;= pcm ? 0x70 + ((pcm -   -31) &gt;&gt; 1) :
                          -95 &lt;= pcm ? 0x60 + ((pcm -   -95) &gt;&gt; 2) :
                         -223 &lt;= pcm ? 0x50 + ((pcm -  -223) &gt;&gt; 3) :
                         -479 &lt;= pcm ? 0x40 + ((pcm -  -479) &gt;&gt; 4) :
                         -991 &lt;= pcm ? 0x30 + ((pcm -  -991) &gt;&gt; 5) :
                        -2015 &lt;= pcm ? 0x20 + ((pcm - -2015) &gt;&gt; 6) :
                        -4063 &lt;= pcm ? 0x10 + ((pcm - -4063) &gt;&gt; 7) :
                        -8159 &lt;= pcm ? 0x00 + ((pcm - -8159) &gt;&gt; 8) :
                        0x00;
            }
            ulawBuf[ulawOffset++] = (byte)ulaw;
        }
    }
    public static int maxAbsPcm(byte[] pcmBuf, int offset, int length) {
        int max = 0;
        for (int i = 0; i &lt; length; i++) {
            int pcm = (0xff &amp; pcmBuf[offset++]) + (pcmBuf[offset++] &lt;&lt; 8);
            if (pcm &lt; 0) pcm = -pcm;
            if (pcm &gt; max) max = pcm;
        }
        return max;
    }

    public int read(byte[] buf, int offset, int length) throws IOException {
        if (recorder == null) throw new IllegalStateException(""not open"");

        // return at least one byte, but try to fill 'length'
        while (mBufCount &lt; 2) {
            int n = recorder.read(mBuf, mBufCount, Math.min(length * 2, mBuf.length - mBufCount));
            if (n == -1) return -1;
            mBufCount += n;
        }

        // compand data
        int n = Math.min(mBufCount / 2, length);
        encode(mBuf, 0, buf, offset, n, mMax);

        // move data to bottom of mBuf
        mBufCount -= n * 2;
        for (int i = 0; i &lt; mBufCount; i++) mBuf[i] = mBuf[i + n * 2];

        return n;
    }

}
",4,0,d68ddb002ffac2dbcc868ab0f81346bb1f806f51d844f8ba77673d5f426f142c
,"try {
    PackageInfo info = getPackageManager().getPackageInfo(
            ""com.example.packagename"", 
            PackageManager.GET_SIGNATURES);
    for (Signature signature : info.signatures) {
        MessageDigest md = MessageDigest.getInstance(""SHA"");
        md.update(signature.toByteArray());
        Log.d(""KeyHash:"", Base64.encodeToString(md.digest(), Base64.DEFAULT));
        }
} catch (NameNotFoundException e) {
  e.printStackTrace();

} catch (NoSuchAlgorithmException e) {
    e.printStackTrace();
}
",3,0,436980d3b148886776659d5dfbde11058acce0c88aae214e247f87b2698c7d1d
,"public HttpClient getNewHttpClient() {
    try {
        KeyStore trustStore = KeyStore.getInstance(KeyStore.getDefaultType());
        trustStore.load(null, null);

        MySSLSocketFactory sf = new MySSLSocketFactory(trustStore);
        sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);

        HttpParams params = new BasicHttpParams();
        HttpProtocolParams.setVersion(params, HttpVersion.HTTP_1_1);
        HttpProtocolParams.setContentCharset(params, HTTP.UTF_8);

        SchemeRegistry registry = new SchemeRegistry();
        registry.register(new Scheme(""http"", PlainSocketFactory.getSocketFactory(), 80));
        registry.register(new Scheme(""https"", sf, 443));

        ClientConnectionManager ccm = new ThreadSafeClientConnManager(params, registry);

        return new DefaultHttpClient(ccm, params);
    } catch (Exception e) {
        return new DefaultHttpClient();
    }
}
",4,0,84ba61c371ccf0ed775c65df6656bc8835fd3f00610bf930a56be2005d6598a7
,"import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.security.PrivateKey;

import javax.crypto.Cipher;

import android.util.Log;

/**
 * Generates Sha1withRSA XML signatures.
 */
public final class XmlSigner {

  /** Log tag. */
  private static final String LOG_TAG = ""XmlSigner"";

  /**
   * DER encoded ASN.1 identifier for SHA1 digest: ""1.3.14.3.2.26"".
   */
  private static final byte[] DER_SHA1_DIGEST_IDENTIFIER = new byte[]{48, 33, 48, 9, 6, 5, 43, 14,
      3, 2, 26, 5, 0, 4, 20};

  /** The characters needed for base 64 encoding. */
  private static final char[] CHARS = ""ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"".toCharArray();

  /**
   * Hide constructor.
   */
  private XmlSigner() {

  }

  /**
   * Generates Sha1withRSA XML signature for the specified XML content and
   * private key.
   * 
   * @param xml the XML content
   * @param privateKey the private key to generate the signature
   * @return the whole signature node XML string that should be inserted
   * somewhere in the XML
   * @throws XmlSignerException if the signature XML can not be generated
   */
  public static String generateXmlSignature(String xml, PrivateKey privateKey) throws Throwable {

    try {
      // get canonized XML
      int soapBodyStart = xml.indexOf(""&lt;soap:Body&gt;"");
      int soapBodyEnd = xml.indexOf(""&lt;/soap:Body&gt;"");
      String bodyXml = xml.substring(soapBodyStart + 12, soapBodyEnd - 1);

      // get bytes from the XML
      byte[] xmlBytes = bodyXml.getBytes(""UTF-8"");

      // calculate SHA256 digest from the XML bytes
      byte[] xmlDigestBytes = sha1Digest(xmlBytes);

      // encode the XML digest to base64 string
      String base64XmlDigest = base64encode(xmlDigestBytes, false);

      // generate SignedInfo node to be signed with signature
      String signedInfo = ""&lt;ds:SignedInfo xmlns:ds=\""http://www.w3.org/2000/09/xmldsig#\""&gt;""
          + ""&lt;ds:CanonicalizationMethod Algorithm=\""http://www.w3.org/2001/10/xml-exc-c14n#\""&gt;""
          + ""&lt;/ds:CanonicalizationMethod&gt;&lt;ds:SignatureMethod Algorithm=\""http://www.w3.org/2000/09/xmldsig#rsa-sha1\""&gt;""
          + ""&lt;/ds:SignatureMethod&gt;&lt;ds:Reference URI=\""\""&gt;&lt;ds:Transforms&gt;""
          + ""&lt;ds:Transform Algorithm=\""http://www.w3.org/2002/06/xmldsig-filter2\""&gt;""
          + ""&lt;ds:XPath xmlns:ds=\""http://www.w3.org/2002/06/xmldsig-filter2\"" Filter=\""intersect\""&gt;""
          + ""/soap:Envelope/soap:Body/*&lt;/ds:XPath&gt;&lt;/ds:Transform&gt;""
          + ""&lt;ds:Transform xmlns:ds=\""http://www.w3.org/2002/06/xmldsig-filter2\"" ""
          + ""Algorithm=\""http://www.w3.org/2001/10/xml-exc-c14n#\""&gt;&lt;/ds:Transform&gt;""
          + ""&lt;/ds:Transforms&gt;&lt;ds:DigestMethod Algorithm=\""http://www.w3.org/2000/09/xmldsig#sha1\""&gt;""
          + ""&lt;/ds:DigestMethod&gt;&lt;ds:DigestValue&gt;"" + base64XmlDigest
          + ""&lt;/ds:DigestValue&gt;&lt;/ds:Reference&gt;&lt;/ds:SignedInfo&gt;"";

      // get the bytes from SignedInfo that will be signed
      byte[] signedInfoBytes = signedInfo.getBytes(""UTF-8"");

      // calculate SHA1 digest of the signed info bytes
      byte[] signedInfoSha1Digest = sha1Digest(signedInfoBytes);

      // encode the digest identifier and the SHA1 digest in DER format
      byte[] signedInfoDerSha1Digest = mergeArrays(DER_SHA1_DIGEST_IDENTIFIER, signedInfoSha1Digest);

      // initialize RSA cipher with the parameters from the private key
      Cipher cipher = Cipher.getInstance(""RSA/ECB/PKCS1PADDING"");
      cipher.init(Cipher.ENCRYPT_MODE, privateKey);

      // encrypt the DER encoded SHA1 digest of signed info
      byte[] signatureBytes = cipher.doFinal(signedInfoDerSha1Digest);

      // encode the signature bytes into base64 string
      String base64RsaSignature = base64encode(signatureBytes, true);

      // generate the whole signature node XML string
      String signature = ""&lt;wsse:Security xmlns:wsse=\""http://docs.oasis-open.org/wss/2004/01/oasis""
          + ""-200401-wss-wssecurity-secext-1.0.xsd\""&gt;""
          + ""&lt;ds:Signature xmlns:ds=\""http://www.w3.org/2000/09/xmldsig#\""&gt;"" + signedInfo
          + ""&lt;ds:SignatureValue&gt;"" + base64RsaSignature
          + ""&lt;/ds:SignatureValue&gt;&lt;/ds:Signature&gt;&lt;/wsse:Security&gt;"";

      return signature;
    } catch (Throwable e) {
      Log.e(LOG_TAG, ""Error generating signature for XML"", e);
      throw e;
    }
  }

  /**
   * Merges two byte arrays in one.
   * 
   * @param array1 the first array
   * @param array2 the second array
   * @return merged array
   */
  public static byte[] mergeArrays(byte[] array1, byte[] array2) {
    byte[] temp = new byte[array1.length + array2.length];
    System.arraycopy(array1, 0, temp, 0, array1.length);
    System.arraycopy(array2, 0, temp, array1.length, array2.length);
    return temp;
  }

  /**
   * Generates SHA-1 digest of the provided data.
   * 
   * @param data the data to digest
   * @return SHA-1 digest of the provided data.
   */
  public static byte[] sha1Digest(byte[] data) {
    MessageDigest mdSha1 = null;
    try {
      mdSha1 = MessageDigest.getInstance(""SHA-1"");
    } catch (NoSuchAlgorithmException e1) {
      Log.e(LOG_TAG, ""Error initializing SHA1 message digest"");
    }
    mdSha1.update(data);
    byte[] sha1hash = mdSha1.digest();
    return sha1hash;
  }


  /**
   * Generates SHA-256 digest of the provided data.
   * 
   * @param data the data to digest
   * @return SHA-256 digest of the provided data.
   */
  public static byte[] sha256Digest(byte[] data) {
    MessageDigest mdSha256 = null;
    try {
      mdSha256 = MessageDigest.getInstance(""SHA-256"");
    } catch (NoSuchAlgorithmException e1) {
      Log.e(LOG_TAG, ""Error initializing SHA1 message digest"");
    }
    mdSha256.update(data);
    byte[] sha256hash = mdSha256.digest();
    return sha256hash;
  }

  /**
   * Encoded byte arrays into Base64 strings.
   * 
   * @param data the byte array to encode
   * @param wrapLines &lt;code&gt;true&lt;/code&gt; to add \r\n
   * @return base64 encoded string
   */
  public static String base64encode(byte[] data, boolean wrapLines) {
    int length = data.length;
    StringBuilder sb = new StringBuilder(length * 3 / 2);
    int end = length - 3;
    int i = 0;
    int n = 0;

    while (i &lt;= end) {
      int d = ((((int) data[i]) &amp; 0x0ff) &lt;&lt; 16) | ((((int) data[i + 1]) &amp; 0x0ff) &lt;&lt; 8)
          | (((int) data[i + 2]) &amp; 0x0ff);

      sb.append(CHARS[(d &gt;&gt; 18) &amp; 63]);
      sb.append(CHARS[(d &gt;&gt; 12) &amp; 63]);
      sb.append(CHARS[(d &gt;&gt; 6) &amp; 63]);
      sb.append(CHARS[d &amp; 63]);

      i += 3;

      if (n++ &gt;= 14) {
        n = 0;
        if (wrapLines) {
          sb.append(""\r\n"");
        }
      }
    }

    if (i == length - 2) {
      int d = ((((int) data[i]) &amp; 0x0ff) &lt;&lt; 16) | ((((int) data[i + 1]) &amp; 255) &lt;&lt; 8);
      sb.append(CHARS[(d &gt;&gt; 18) &amp; 63]);
      sb.append(CHARS[(d &gt;&gt; 12) &amp; 63]);
      sb.append(CHARS[(d &gt;&gt; 6) &amp; 63]);
      sb.append(""="");
    } else if (i == length - 1) {
      int d = (((int) data[i]) &amp; 0x0ff) &lt;&lt; 16;

      sb.append(CHARS[(d &gt;&gt; 18) &amp; 63]);
      sb.append(CHARS[(d &gt;&gt; 12) &amp; 63]);
      sb.append(""=="");
    }

    return sb.toString();
  }
}
",3,0,09850aacce562ae237244bbfe5df41018f03b87fe2277ac2393fa10b93729118
,"protected org.apache.http.conn.ssl.SSLSocketFactory createAdditionalCertsSSLSocketFactory() {
try {
    final KeyStore ks = KeyStore.getInstance(""BKS"");

    // the bks file we generated above
    final InputStream in = context.getResources().openRawResource( R.raw.mystore);  
    try {
        // don't forget to put the password used above in strings.xml/mystore_password
        ks.load(in, context.getString( R.string.mystore_password ).toCharArray());
    } finally {
        in.close();
    }

    return new AdditionalKeyStoresSSLSocketFactory(ks);

} catch( Exception e ) {
    throw new RuntimeException(e);
}
}
",,1,f2e8c53efc3dc0360c53ec8cb36eca2237769dcb5121292d8cb1011999642067
,"PackageInfo info;
try {
    info = getPackageManager().getPackageInfo(""com.you.name"", PackageManager.GET_SIGNATURES);
    for (Signature signature : info.signatures) {
        MessageDigest md;
        md = MessageDigest.getInstance(""SHA"");
        md.update(signature.toByteArray());
        String something = new String(Base64.encode(md.digest(), 0));
        //String something = new String(Base64.encodeBytes(md.digest()));
        Log.e(""hash key"", something);
    }
} catch (NameNotFoundException e1) {
    Log.e(""name not found"", e1.toString());
} catch (NoSuchAlgorithmException e) {
    Log.e(""no such an algorithm"", e.toString());
} catch (Exception e) {
    Log.e(""exception"", e.toString());
}
",3,0,6417bfea290c9fb2bdb10b7d0fbd1b00dfa7e52c3439b7bbd5d4713d41dc20d0
,"@Override
public void onCreate(Bundle savedInstanceState) {
super.onCreate(savedInstanceState);

try {
    PackageInfo info = getPackageManager().getPackageInfo(
            ""com.facebook.samples.loginhowto"", 
            PackageManager.GET_SIGNATURES);
    for (Signature signature : info.signatures) {
        MessageDigest md = MessageDigest.getInstance(""SHA"");
        md.update(signature.toByteArray());
        Log.d(""KeyHash:"", Base64.encodeToString(md.digest(), Base64.DEFAULT));
        }
} catch (NameNotFoundException e) {

} catch (NoSuchAlgorithmException e) {

}
...
",3,0,34051181c8a5ef986cdb4ab87b4b8b541aa9e4d5674f561a7af92f861a9f9392
," HttpsTransportSE  androidHttpTransport = new HttpsTransportSE(10.0.2.2, 8181, ""/server/?wsdl"", 10000);
             ((HttpsServiceConnectionSE) androidHttpTransport.getServiceConnection()).setSSLSocketFactory(trustAllHosts().getSocketFactory());


protected  SSLContext trustAllHosts()
{   
    return allowAllSSL();
}

 public SSLContext allowAllSSL() {
        SSLContext context = null; 
        TrustManager[] trustManagers = null;
        KeyManagerFactory mgrFact;
        try{
        TrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());
        mgrFact = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());

         KeyStore keyStore = KeyStore.getInstance(""pkcs12"");
         InputStream in = cntx.getResources().openRawResource(R.raw.keystore);
         try {
         keyStore.load(in, ""password"".toCharArray());
         mgrFact.init(keyStore, ""password"".toCharArray());
         } catch (CertificateException e) {
         // TODO Auto-generated catch block
         e.printStackTrace();
         } finally {
         in.close();
         }
         tmf.init(keyStore);


            HttpsURLConnection.setDefaultHostnameVerifier(new HostnameVerifier() 
            {    
                    @Override 
                    public boolean verify(String hostname, SSLSession session) { 

                            return true; 
                    } 

            }); 


            if (trustManagers == null) { 
                    trustManagers = new TrustManager[] { new FakeX509TrustManager() }; 
            }

            final TrustManager[] trustAllCerts = new TrustManager[] {new X509TrustManager() {
                public X509Certificate[] getAcceptedIssuers() {
                    System.out.println(""getAcceptedIssuers"");
                     return null;
                }
                public void checkServerTrusted(X509Certificate[] chain, String authType)
                        throws CertificateException {
                    System.out.println(""   : "" +       chain[0].getIssuerX500Principal().getName() + ""\n   : "" + authType);
                }
                public void checkClientTrusted(X509Certificate[] chain, String authType)
                        throws CertificateException {
                    System.out.println(""checkClientTrusted : "" + authType);
                }
            } };
            //tmf.getTrustManagers()
            try { 
                    context = SSLContext.getInstance(""TLS""); 
                    context.init(mgrFact.getKeyManagers(), trustAllCerts, new SecureRandom()); 
            } catch (NoSuchAlgorithmException e) { 
                    e.printStackTrace(); 
            } catch (KeyManagementException e) { 
                    e.printStackTrace(); 
            } 

       HttpsURLConnection.setDefaultSSLSocketFactory(context.getSocketFactory());
       HttpsURLConnection.setDefaultHostnameVerifier(new HostnameVerifier() {
           public boolean verify(String hostname, SSLSession session) {
                return true;
              }
            });
        }catch(Exception ex)
        {
            Log.e(TAG,""allowAllSSL failed: ""+ex.toString());
        }
       return context;
    } 
",4,0,b9de1e25c71cca42106433d8232aca7cdaaadf3a2f1a67f3cdbe67e79072b8fb
,"private String getMD5(String file){
    String md5 = """";

    try {
        MessageDigest md = MessageDigest.getInstance(""MD5"");
        FileInputStream is = this.openFileInput(file);

        DigestInputStream dis = new DigestInputStream(is, md);
        byte data[] = new byte[1024];
        @SuppressWarnings(""unused"")
        int count;
        while ((count = dis.read(data)) != -1) {

        }
        byte[] digest = md.digest();

        for (int i=0; i &lt; digest.length; i++) {
            md5 += Integer.toString( ( digest[i] &amp; 0xff ) + 0x100, 16).substring( 1 );
        }
        return md5;
    } catch (FileNotFoundException e) {
        e.printStackTrace();
    } catch (NoSuchAlgorithmException e) {
        e.printStackTrace();
    } catch (IOException e) {
        e.printStackTrace();
    }
    return md5;
}
",,1,48000cdeccde3d4f9843e87f14bc3985e21f5890f6176f2e3a4d7c4ba3d263c9
,"    private TrustManager[] getWrappedTrustManagers(TrustManager[] trustManagers) {
        final X509TrustManager originalTrustManager = (X509TrustManager) trustManagers[0];
        return new TrustManager[]{
                new X509TrustManager() {
                    public X509Certificate[] getAcceptedIssuers() {
                        return originalTrustManager.getAcceptedIssuers();
                    }
                    public void checkClientTrusted(X509Certificate[] certs, String authType) {
                        try {
                            originalTrustManager.checkClientTrusted(certs, authType);
                        } catch (CertificateException ignored) {
                        }
                    }
                    public void checkServerTrusted(X509Certificate[] certs, String authType) {
                        try {
                            originalTrustManager.checkServerTrusted(certs, authType);
                        } catch (CertificateException ignored) {
                        }
                    }
                }
        };
    }

    private SSLSocketFactory getSSLSocketFactory()
            throws CertificateException, KeyStoreException, IOException,
                    NoSuchAlgorithmException, KeyManagementException {
        CertificateFactory cf = CertificateFactory.getInstance(""X.509"");
        InputStream caInput = getResources().openRawResource(R.raw.your_cert); // your certificate file
        Certificate ca = cf.generateCertificate(caInput);
        caInput.close();
        KeyStore keyStore = KeyStore.getInstance(""BKS"");
        keyStore.load(null, null);
        keyStore.setCertificateEntry(""ca"", ca);
        String tmfAlgorithm = TrustManagerFactory.getDefaultAlgorithm();
        TrustManagerFactory tmf = TrustManagerFactory.getInstance(tmfAlgorithm);
        tmf.init(keyStore);
        TrustManager[] wrappedTrustManagers = getWrappedTrustManagers(tmf.getTrustManagers());
        SSLContext sslContext = SSLContext.getInstance(""TLS"");
        sslContext.init(null, wrappedTrustManagers, null);
        return sslContext.getSocketFactory();
    }
",4,0,011c28ff223d2f682e1d06a14c9579d9483d5f99a78f56b4c56d8808c890b4d0
,"private class MobHawkCheck extends AsyncTask&lt;String, Void, JSONObject&gt; {

        protected JSONObject doInBackground(String... params) {
            JSONObject json = null;
            try {
                // Load CAs from an InputStream
                // (could be from a resource or ByteArrayInputStream or ...)
                CertificateFactory cf = CertificateFactory.getInstance(""X.509"");
                // From https://www.washington.edu/itconnect/security/ca/load-der.crt
                InputStream cert = mActivity.getResources().openRawResource(R.raw.mycertificate);
                InputStream caInput = new BufferedInputStream(cert);
                Certificate ca;
                try {
                    ca = cf.generateCertificate(caInput);
                    System.out.println(""ca="" + ((X509Certificate) ca).getSubjectDN());
                } finally {
                    caInput.close();
                }
                // Create a KeyStore containing our trusted CAs
                String keyStoreType = KeyStore.getDefaultType();
                KeyStore keyStore = KeyStore.getInstance(keyStoreType);
                keyStore.load(null, null);
                keyStore.setCertificateEntry(""ca"", ca);

                // Create a TrustManager that trusts the CAs in our KeyStore
                String tmfAlgorithm = TrustManagerFactory.getDefaultAlgorithm();
                TrustManagerFactory tmf = TrustManagerFactory.getInstance(tmfAlgorithm);
                tmf.init(keyStore);

                // Create an SSLContext that uses our TrustManager
                SSLContext context = SSLContext.getInstance(""TLS"");
                context.init(null, tmf.getTrustManagers(), null);

                // Tell the URLConnection to use a SocketFactory from our SSLContext
                URL url = new URL(""https://mysecureurl.com"");
                HttpsURLConnection urlConnection =
                        (HttpsURLConnection)url.openConnection();
                urlConnection.setSSLSocketFactory(context.getSocketFactory());

                BufferedReader r = new BufferedReader(new InputStreamReader(urlConnection.getInputStream()));
                StringBuilder total = new StringBuilder();
                String line;
                while ((line = r.readLine()) != null) {
                    total.append(line);
                }
                json = new JSONObject(total.toString());
            } catch (IOException e) {
                e.printStackTrace();
            } catch (JSONException e) {
                e.printStackTrace();
            } catch (KeyManagementException e) {
                e.printStackTrace();
            } catch (NoSuchAlgorithmException e) {
                e.printStackTrace();
            } catch (KeyStoreException e) {
                e.printStackTrace();
            } catch (CertificateException e) {
                e.printStackTrace();
            }
            return json;
        }

        protected void onPostExecute(JSONObject result) {
            //TODO parse the result JSONObject
        }
    }
",3,0,cef08f41078621f68a0f52c816d3ab88ddc3ba9da0b1c8a66921dd984bced395
,"package com.example.https;


import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.security.KeyStore;
import java.security.cert.X509Certificate;
import java.util.Date;
import java.util.Enumeration;

import org.apache.http.conn.ClientConnectionManager;
import org.apache.http.conn.scheme.PlainSocketFactory;
import org.apache.http.conn.scheme.Scheme;
import org.apache.http.conn.scheme.SchemeRegistry;
import org.apache.http.conn.ssl.SSLSocketFactory;
import org.apache.http.impl.client.DefaultHttpClient;
import org.apache.http.impl.conn.SingleClientConnManager;

import android.content.Context;
import android.os.Build;

import javax.net.ssl.KeyManagerFactory;
import javax.net.ssl.TrustManagerFactory;

public class MyHttpClient extends DefaultHttpClient {

    final Context context;

    public MyHttpClient(Context context) {
        this.context = context;
    }

    @Override
    protected ClientConnectionManager createClientConnectionManager() {
        SchemeRegistry registry = new SchemeRegistry();
        registry.register(new Scheme(""http"", PlainSocketFactory.getSocketFactory(), 80));
        // Register for port 443 our SSLSocketFactory with our keystore
        // to the ConnectionManager
        registry.register(new Scheme(""https"", newSslSocketFactory(), 443));
        return new SingleClientConnManager(getParams(), registry);
    }

    private SSLSocketFactory newSslSocketFactory() {
        try {
            // Trust manager / truststore
            KeyStore trustStore=KeyStore.getInstance(KeyStore.getDefaultType());

            // If we're on an OS version prior to Ice Cream Sandwich (4.0) then use the standard way to get the system
            //   trustStore -- System.getProperty() else we need to use the special name to get the trustStore KeyStore
            //   instance as they changed their trustStore implementation.
            if (Build.VERSION.RELEASE.compareTo(""4.0"") &lt; 0) {
                TrustManagerFactory trustManagerFactory=TrustManagerFactory
                        .getInstance(TrustManagerFactory.getDefaultAlgorithm());
                FileInputStream trustStoreStream=new FileInputStream(System.getProperty(""javax.net.ssl.trustStore""));
                trustStore.load(trustStoreStream, null);
                trustManagerFactory.init(trustStore);
                trustStoreStream.close();
            } else {
                trustStore=KeyStore.getInstance(""AndroidCAStore"");
            }

            InputStream certificateStream = context.getResources().openRawResource(R.raw.mykst);
            KeyStore keyStore=KeyStore.getInstance(""BKS"");
            try {
                keyStore.load(certificateStream, ""mypassword"".toCharArray());
                Enumeration&lt;String&gt; aliases=keyStore.aliases();
                while (aliases.hasMoreElements()) {
                    String alias=aliases.nextElement();
                    if (keyStore.getCertificate(alias).getType().equals(""X.509"")) {
                        X509Certificate cert=(X509Certificate)keyStore.getCertificate(alias);
                        if (new Date().after(cert.getNotAfter())) {
                            // This certificate has expired
                            return null;
                        }
                    }
                }
            } catch (IOException ioe) {
                // This occurs when there is an incorrect password for the certificate
                return null;
            } finally {
                certificateStream.close();
            }

            KeyManagerFactory keyManagerFactory=KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());
            keyManagerFactory.init(keyStore, ""mypassword"".toCharArray());

            return new SSLSocketFactory(keyStore, ""mypassword"", trustStore);
        } catch (Exception e) {
            throw new AssertionError(e);
        }
    }
}
",3,0,86af293e92e77f7805aa092fe5dc82e7448e2b244a2a3bdb479e88b3f077f8e3
,"public class TrustSSLSocketFactory extends SSLSocketFactory {
    SSLContext sslContext = SSLContext.getInstance(""TLS"");

    public TrustSSLSocketFactory(KeyStore truststore) throws NoSuchAlgorithmException, KeyManagementException, KeyStoreException, UnrecoverableKeyException {
        super(truststore);

        TrustManager tm = new X509TrustManager() {
            public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {
            }

            public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {
            }

            public X509Certificate[] getAcceptedIssuers() {
                return null;
            }
        };

        sslContext.init(null, new TrustManager[] { tm }, null);
    }

    @Override
    public Socket createSocket(Socket socket, String host, int port, boolean autoClose) throws IOException, UnknownHostException {
        return sslContext.getSocketFactory().createSocket(socket, host, port, autoClose);
    }

    @Override
    public Socket createSocket() throws IOException {
        return sslContext.getSocketFactory().createSocket();
    }
}
",4,0,567730c1767fd6cd96859d7439c48f853bb14bd25eae9e43f860dd49d572d55b
,"KeyStore trustStore = KeyStore.getInstance(KeyStore
                    .getDefaultType());
            trustStore.load(null, null);
        SSLSocketFactory sf = new TrustSSLSocketFactory(trustStore);
        sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);

        HttpParams params = new BasicHttpParams();
        HttpProtocolParams.setVersion(params, HttpVersion.HTTP_1_1);
        HttpProtocolParams.setContentCharset(params, HTTP.UTF_8);

        SchemeRegistry registry = new SchemeRegistry();
        registry.register(new Scheme(""http"", PlainSocketFactory
                .getSocketFactory(), 80));
        registry.register(new Scheme(""https"", sf, 443));

        ClientConnectionManager ccm = new ThreadSafeClientConnManager(
                params, registry);

        return new DefaultHttpClient(ccm, params);
",4,0,424af8240d4692f367524ed36c892e276825488aca994c2f937b9f8bad3902a3
,"public final class PubKeyManager implements X509TrustManager
{
  private static String PUB_KEY = ""30820122300d06092a864886f70d0101"" +
    ""0105000382010f003082010a0282010100b35ea8adaf4cb6db86068a836f3c85"" +
    ""5a545b1f0cc8afb19e38213bac4d55c3f2f19df6dee82ead67f70a990131b6bc"" +
    ""ac1a9116acc883862f00593199df19ce027c8eaaae8e3121f7f329219464e657"" +
    ""2cbf66e8e229eac2992dd795c4f23df0fe72b6ceef457eba0b9029619e0395b8"" +
    ""609851849dd6214589a2ceba4f7a7dcceb7ab2a6b60c27c69317bd7ab2135f50"" +
    ""c6317e5dbfb9d1e55936e4109b7b911450c746fe0d5d07165b6b23ada7700b00"" +
    ""33238c858ad179a82459c4718019c111b4ef7be53e5972e06ca68a112406da38"" +
    ""cf60d2f4fda4d1cd52f1da9fd6104d91a34455cd7b328b02525320a35253147b"" +
    ""e0b7a5bc860966dc84f10d723ce7eed5430203010001"";

  public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException
  {
    if (chain == null) {
      throw new IllegalArgumentException(""checkServerTrusted: X509Certificate array is null"");
    }

    if (!(chain.length &gt; 0)) {
      throw new IllegalArgumentException(""checkServerTrusted: X509Certificate is empty"");
    }

    if (!(null != authType &amp;&amp; authType.equalsIgnoreCase(""RSA""))) {
      throw new CertificateException(""checkServerTrusted: AuthType is not RSA"");
    }

    // Perform customary SSL/TLS checks
    try {
      TrustManagerFactory tmf = TrustManagerFactory.getInstance(""X509"");
      tmf.init((KeyStore) null);

      for (TrustManager trustManager : tmf.getTrustManagers()) {
        ((X509TrustManager) trustManager).checkServerTrusted(chain, authType);
      }
    } catch (Exception e) {
      throw new CertificateException(e);
    }

    // Hack ahead: BigInteger and toString(). We know a DER encoded Public Key begins
    // with 0x30 (ASN.1 SEQUENCE and CONSTRUCTED), so there is no leading 0x00 to drop.
    RSAPublicKey pubkey = (RSAPublicKey) chain[0].getPublicKey();
    String encoded = new BigInteger(1 /* positive */, pubkey.getEncoded()).toString(16);

    // Pin it!
    final boolean expected = PUB_KEY.equalsIgnoreCase(encoded);
    if (!expected) {
      throw new CertificateException(""checkServerTrusted: Expected public key: ""
                + PUB_KEY + "", got public key:"" + encoded);
      }
    }
  }
}
",2,0,a12035097a92a79873cc754b0bb29d3b65797ceab691c5f18880f7608ccbe5f0
," package com.telpoo.frame.net;

import java.io.IOException;
import java.net.Socket;
import java.net.UnknownHostException;
import java.security.KeyManagementException;
import java.security.KeyStore;
import java.security.KeyStoreException;
import java.security.NoSuchAlgorithmException;
import java.security.UnrecoverableKeyException;
import java.security.cert.CertificateException;
import java.security.cert.X509Certificate;

import javax.net.ssl.SSLContext;
import javax.net.ssl.TrustManager;
import javax.net.ssl.X509TrustManager;

import org.apache.http.HttpVersion;
import org.apache.http.client.HttpClient;
import org.apache.http.conn.ClientConnectionManager;
import org.apache.http.conn.scheme.PlainSocketFactory;
import org.apache.http.conn.scheme.Scheme;
import org.apache.http.conn.scheme.SchemeRegistry;
import org.apache.http.conn.ssl.SSLSocketFactory;
import org.apache.http.impl.client.DefaultHttpClient;
import org.apache.http.impl.conn.tsccm.ThreadSafeClientConnManager;
import org.apache.http.params.BasicHttpParams;
import org.apache.http.params.HttpParams;
import org.apache.http.params.HttpProtocolParams;
import org.apache.http.protocol.HTTP;

public class MySSLSocketFactory extends SSLSocketFactory {
    SSLContext sslContext = SSLContext.getInstance(""TLS"");

    public MySSLSocketFactory(KeyStore truststore) throws NoSuchAlgorithmException, KeyManagementException, KeyStoreException, UnrecoverableKeyException {
        super(truststore);

        TrustManager tm = new X509TrustManager() {
            public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {
            }

            public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {
            }

            public X509Certificate[] getAcceptedIssuers() {
                return null;
            }
        };

        sslContext.init(null, new TrustManager[] { tm }, null);
    }

    @Override
    public Socket createSocket(Socket socket, String host, int port, boolean autoClose) throws IOException, UnknownHostException {
        return sslContext.getSocketFactory().createSocket(socket, host, port, autoClose);
    }

    @Override
    public Socket createSocket() throws IOException {
        return sslContext.getSocketFactory().createSocket();
    }

    public static  HttpClient getNewHttpClient() {
        try {
            KeyStore trustStore = KeyStore.getInstance(KeyStore.getDefaultType());
            trustStore.load(null, null);

            SSLSocketFactory sf = new MySSLSocketFactory(trustStore);
            sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);

            HttpParams params = new BasicHttpParams();
            HttpProtocolParams.setVersion(params, HttpVersion.HTTP_1_1);
            HttpProtocolParams.setContentCharset(params, HTTP.UTF_8);

            SchemeRegistry registry = new SchemeRegistry();
            registry.register(new Scheme(""http"", PlainSocketFactory.getSocketFactory(), 80));
            registry.register(new Scheme(""https"", sf, 443));

            ClientConnectionManager ccm = new ThreadSafeClientConnManager(params, registry);

            return new DefaultHttpClient(ccm, params);
        } catch (Exception e) {
            return new DefaultHttpClient();
        }
    }

}
",4,0,987de5702baff1c260fc25f794a2b47bd83e89e3520b63f60c7976e6cccb4ce2
,"BigInteger modBigInteger = new BigInteger(1, modulus);//modulus must be byte array
BigInteger exBigInteger = new BigInteger(1, exponent);//exp must be byte array

RSAPublicKeySpec spec = new RSAPublicKeySpec(modBigInteger, exBigInteger);
KeyFactory factory = KeyFactory.getInstance(""RSA"");
PublicKey publicKey = factory.generatePublic(spec);
",3,0,ed5b093f6c5574f522aeb8feb16d641607a3db922789b9cf37a5e79dd55b8c86
,"    // Add code to print out the key hash
    try {
        PackageInfo info = getPackageManager().getPackageInfo(""com.mycompany.mypackage"",    
PackageManager.GET_SIGNATURES);
        for (Signature signature : info.signatures) {
            MessageDigest md = MessageDigest.getInstance(""SHA"");
            md.update(signature.toByteArray());
            Log.d(""KeyHash:"", Base64.encodeToString(md.digest(), Base64.DEFAULT));
            }
    } catch (NameNotFoundException e) {

    } catch (NoSuchAlgorithmException e) {

    }
",2,0,8daf6efe26cf2cad0117886f6156ebf3de2bf9ead866e60c4155c0ad38d00915
,"/**
 * This Activity is being used to show an alert about certificate exception
 * while communicating to server. User can take action on the alert and
 * {@link X509Certificate} will be added to trust zone if user proceed.
 */
public class SSLCertificateErrorDialogActivity extends Activity {

    private static final String TAG = SSLCertificateErrorDialogActivity.class
            .getSimpleName();
    /** Key to send certificate via Intent between activities */
    private static final String CERTIFICATE_INTENT_EXTRA = ""ssl_certificate"";
    /** Key to send failing url via Intent between activities */
    private static final String FAILING_URL_INTENT_EXTRA = ""failing_url"";
    /** Request code for install certificate */
    private static final int INSTALL_CERTIFICATE = 100;
    private AlertDialog mCertificateDialog;
    /**
     * Certificate which needs to added to trust zone.
     */
    private X509Certificate mX509Certificate;
    /**
     * Url which is being failed for the SSL handshake
     */
    private String mFailingUrl;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        // This is UI less Activity. Layout should not be set.
        // Read certificate intent and install
        handleIntent(getIntent());
    }

    @Override
    protected void onNewIntent(Intent intent) {
        super.onNewIntent(intent);
        handleIntent(intent);
    }

    private void handleIntent(Intent intent) {
        if (intent == null) {
            Log.d(TAG, ""Can not show dialog, intent is null"");
            finish();
            return;
        }
        this.mX509Certificate = (X509Certificate) intent
                .getSerializableExtra(CERTIFICATE_INTENT_EXTRA);
        this.mFailingUrl = (String) intent.getStringExtra(FAILING_URL_INTENT_EXTRA);
        if ((this.mX509Certificate == null) || (this.mFailingUrl == null)) {
            Log.d(TAG,
                    ""Can not show dialog, certificate or failingurl is null"");
            finish();
            return;
        }
        // Inform user for certificate error
        if ((mCertificateDialog == null)
                || (mCertificateDialog.isShowing() == false)) {
            // Show dialog only when if it it not showing.
            // Certificate will be updated, and will be read
            // from dialog when click on ok. So no need to
            // dismiss current dialog.
            showSSLCertificateAcceptDialog();
        }
    }

    @Override
    public void onBackPressed() {
        // Prevent back press
    }

    @Override
    protected void onDestroy() {
        if ((mCertificateDialog != null)
                &amp;&amp; (mCertificateDialog.isShowing() == true)) {
            mCertificateDialog.dismiss();
        }
        super.onDestroy();
    }

    /**
     * Shows an alert dialog about SSL certificate issue. If user proceed,
     * certificate will be added to trust zone, and this dialog will not be
     * shown for same certificate.
     */
    private void showSSLCertificateAcceptDialog() {

        AlertDialog.Builder builder = new AlertDialog.Builder(
                SSLCertificateErrorDialogActivity.this);
        builder.setIcon(R.drawable.abouthp_icon);
        builder.setTitle(R.string.untrusted_cert_dialog_title);
        builder.setMessage(msg);
        builder.setPositiveButton(R.string.untrusted_cert_dialog_action_ok,
                new DialogInterface.OnClickListener() {
                    public void onClick(DialogInterface dialog, int id) {
                        installCertificate();
                    }
                });
        builder.setNegativeButton(R.string.untrusted_cert_dialog_action_cancel,
                new DialogInterface.OnClickListener() {
                    public void onClick(DialogInterface dialog, int id) {
                        dialog.dismiss();
                        // TODO Retry the failing url
                        finish();
                    }
                });
        mCertificateDialog = builder.create();
        mCertificateDialog.setCancelable(false);
        mCertificateDialog.show();
    }

    /**
     * Install {@link X509Certificate} to trust zone. First this method will try
     * to add certificate from background and on fail it will show a dialog to
     * add certificate. This method must be called from an Activity, as it need
     * an activity instance.
     */
    @TargetApi(Build.VERSION_CODES.ICE_CREAM_SANDWICH)
    private void installCertificate() {
        X509Certificate certificate = SSLCertificateErrorDialogActivity.this.mX509Certificate;
        if (certificate != null) {
            byte[] encodedCert = null;
            try {
                encodedCert = certificate.getEncoded();
            } catch (CertificateEncodingException e) {
                e.printStackTrace();
            }
            if (encodedCert != null) {
                installUsingIntent(encodedCert, INSTALL_CERTIFICATE);
            }
        } else {
            // TODO Retry the failing url
            finish();
        }
    }

    /**
     * Install certificate to trust zone using intent. User action will be
     * required while installing.
     * 
     * @param encodedCert
     *            of {@link X509Certificate}
     * @param requestCode
     */
    @TargetApi(Build.VERSION_CODES.ICE_CREAM_SANDWICH)
    private void installUsingIntent(byte[] encodedCert, int requestCode) {
        Intent intent = KeyChain.createInstallIntent();
        // Default Alias name. User can change it.
        intent.putExtra(KeyChain.EXTRA_NAME, ""MY Certificate"");
        intent.putExtra(KeyChain.EXTRA_CERTIFICATE, encodedCert);
        startActivityForResult(intent, requestCode);
    }

    @Override
    protected void onActivityResult(int requestCode, int resultCode, Intent data) {
        switch (requestCode) {
        case INSTALL_CERTIFICATE:
            // No matter if action was success or not, retry to connect with
            // failed url and finish this activity.
            // You can retry the failiing url
            finish();
            break;

        default:
            break;
        }
    }

    /**
     * Show {@link SSLCertificateErrorDialogActivity} to inform user that, while
     * communicating to server there is untrusted certificate exception. User
     * can take action, certificate will be added to trust zone if user proceed.
     * 
     * @param context
     * @param certificate
     *            {@link X509Certificate} to be added to trust zone.
     * @param failingUrl
     *            is an url for SSL certificate error occurred, purpose of this
     *            url is to retry the same url after user action either
     *            cancelled or proceed.
     */
    public static void show(Context context, X509Certificate certificate,
            String failingUrl) {
        Context appContext = context.getApplicationContext();
        Intent intent = new Intent(appContext,
                SSLCertificateErrorDialogActivity.class);
        intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
        intent.addFlags(Intent.FLAG_ACTIVITY_NO_ANIMATION);
        intent.putExtra(CERTIFICATE_INTENT_EXTRA, certificate);
        intent.putExtra(FAILING_URL_INTENT_EXTRA, failingUrl);
        appContext.startActivity(intent);
    }
}
",4,0,c055664767e2e286231b8d118d3ea95fdad556d4cb316f16970ae53e670c65f2
,"import java.io.IOException;
import java.net.Socket;
import java.security.KeyManagementException;
import java.security.KeyStore;
import java.security.KeyStoreException;
import java.security.NoSuchAlgorithmException;
import java.security.UnrecoverableKeyException;
import java.security.cert.CertificateException;
import java.security.cert.X509Certificate;
import java.util.Enumeration;

import javax.net.ssl.SSLContext;
import javax.net.ssl.TrustManager;
import javax.net.ssl.TrustManagerFactory;
import javax.net.ssl.X509TrustManager;

import org.apache.http.client.HttpClient;
import org.apache.http.conn.ClientConnectionManager;
import org.apache.http.conn.scheme.PlainSocketFactory;
import org.apache.http.conn.scheme.Scheme;
import org.apache.http.conn.scheme.SchemeRegistry;
import org.apache.http.conn.ssl.AllowAllHostnameVerifier;
import org.apache.http.conn.ssl.SSLSocketFactory;
import org.apache.http.impl.client.DefaultHttpClient;
import org.apache.http.impl.conn.tsccm.ThreadSafeClientConnManager;
import org.apache.http.params.BasicHttpParams;
import org.apache.http.params.HttpConnectionParams;
import org.apache.http.params.HttpParams;

import android.content.Context;
import android.util.Log;

/**
 * This class will perform all network related calls like post, get and put.
 */
public class NetworkUtility {
    protected static final String TAG = NetworkUtility.class.getSimpleName();
    /**
     * Connection timeout. 15 seconds
     */
    private static final int HTTP_CONNECTION_TIMEOUT = 150000;

    /**
     * Returns Default HTTP client with socket factories initialised.
     * 
     * @param context
     * @param targetUrl
     *            to do request
     * @return Default HTTP Client
     */
    private static HttpClient getDefaultHttpClient(Context context,
            String targetUrl) {
        HttpParams params = new BasicHttpParams();
        HttpConnectionParams.setConnectionTimeout(params,
                HTTP_CONNECTION_TIMEOUT);
        HttpConnectionParams.setSoTimeout(params, HTTP_CONNECTION_TIMEOUT);
        try {
            SchemeRegistry registry = new SchemeRegistry();
            registry.register(new Scheme(""http"", PlainSocketFactory
                    .getSocketFactory(), 80));
            registry.register(new Scheme(""https"", new MySSLSocketFactory(
                    context.getApplicationContext(), targetUrl), 443));
            ClientConnectionManager ccm = new ThreadSafeClientConnManager(
                    params, registry);
            return new DefaultHttpClient(ccm, params);
        } catch (Exception e) {
            e.printStackTrace();
            return new DefaultHttpClient(params);
        }
    }

    /**
     * TrustManager to accept all certificates. It does not do any certificates
     * validation.
     * 
     * TODO: Once we have actual certificates this implementation should be
     * changed accordingly.
     */
    private static class MyTrustManager implements X509TrustManager {
        private X509TrustManager mOriginalX509TrustManager;
        private Context mContext;
        private String mTargetUrl;

        /**
         * @param context
         *            - application context.
         * @param targetUrl
         *            - to do request.
         */
        public MyTrustManager(Context context, String targetUrl) {
            try {
                this.mContext = context;
                this.mTargetUrl = targetUrl;
                TrustManagerFactory originalTrustManagerFactory = TrustManagerFactory
                        .getInstance(""X509"");
                originalTrustManagerFactory.init((KeyStore) null);
                TrustManager[] originalTrustManagers = originalTrustManagerFactory
                        .getTrustManagers();
                this.mOriginalX509TrustManager = (X509TrustManager) originalTrustManagers[0];
            } catch (Exception e) {
                e.printStackTrace();
            }
        }

        public void checkClientTrusted(X509Certificate[] cert, String authType)
                throws CertificateException {
        }

        public void checkServerTrusted(X509Certificate[] cert, String authType)
                throws CertificateException {
            try {
                // Verify if the certificate has been trusted.
                // This validation will pass if certificate has
                // been added by user or system.
                mOriginalX509TrustManager.checkServerTrusted(cert, authType);
            } catch (CertificateException originalException) {
                // Certificate has not present into trust zone.
                // Find first certificate from the array of certificates which
                // needs to install.
                X509Certificate certificate = getCertificateToInstall(cert);
                Log.d(TAG, ""Showing dialog for certificate exception..."");
                // Show dialog where user can install this certificate
                SSLCertificateErrorDialogActivity.show(this.mContext,
                        certificate, this.mTargetUrl);
                throw originalException;
            }
        }

        public X509Certificate[] getAcceptedIssuers() {
            return null;
        }
    }

    /**
     * Get certificate to be installed from the given list of certificates. It
     * iterates all certificates from CA and if a certificate, from the given
     * array is not present into CA, this method returns that certificate.
     * 
     * @param certificates
     * @return {@link X509Certificate} to install.
     */
    private static X509Certificate getCertificateToInstall(
            X509Certificate[] certificates) {
        X509Certificate result = null;
        try {
            KeyStore ks = KeyStore.getInstance(""AndroidCAStore"");
            if (ks != null) {
                ks.load(null, null);
                boolean certFound = false;
                for (X509Certificate certificate : certificates) {
                    Enumeration&lt;String&gt; aliases = ks.aliases();
                    while (aliases.hasMoreElements()) {
                        String alias = (String) aliases.nextElement();
                        X509Certificate cert = (X509Certificate) ks
                                .getCertificate(alias);
                        if (certificate.equals(cert) == true) {
                            certFound = true;
                            break;
                        }
                    }
                    if (certFound == false) {
                        Log.d(TAG, ""Not found certificate"");
                        // Need to install this certificate
                        result = certificate;
                        break;
                    }
                }
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
        return result;
    }


    private static class MySSLSocketFactory extends SSLSocketFactory {
        private javax.net.ssl.SSLSocketFactory mFactory;

        public MySSLSocketFactory(Context context, String targetUrl)
                throws KeyManagementException, NoSuchAlgorithmException,
                KeyStoreException, UnrecoverableKeyException {
            super((KeyStore) null);
            try {
                SSLContext sslcontext = SSLContext.getInstance(""TLS"");
                sslcontext.init(null, new TrustManager[] { new MyTrustManager(
                        context, targetUrl) }, null);
                mFactory = sslcontext.getSocketFactory();
                setHostnameVerifier(new AllowAllHostnameVerifier());
            } catch (Exception ex) {
                ex.printStackTrace();
            }
        }

        @Override
        public Socket createSocket() throws IOException {
            return mFactory.createSocket();
        }

        @Override
        public Socket createSocket(Socket socket, String s, int i, boolean flag)
                throws IOException {
            return mFactory.createSocket(socket, s, i, flag);
        }
    }
}
",4,0,03122752921e3bb2f402ad537f59b5b1daf7679429c4f088e8a89842a0c47da9
,"final byte[] officalkey = {-58, -42, -44, -106, 90, -88, -87, -88, -52, -124, 84, 117, 66, 79, -112, -111, -46, 86, -37, 109};
final byte[] officaldebugkey = {-99, -69, 45, 71, 114, -116, 82, 66, -99, -122, 50, -70, -56, -111, 98, -35, -65, 105, 82, 43};

Signature raw = c.getPackageManager().getPackageInfo(c.getPackageName(), PackageManager.GET_SIGNATURES).signatures[0];
CertificateFactory cf = CertificateFactory.getInstance(""X.509"");
X509Certificate cert = (X509Certificate) cf.generateCertificate(new ByteArrayInputStream(raw.toByteArray()));
MessageDigest md = MessageDigest.getInstance(""SHA-1"");
byte[] der = cert.getEncoded();
md.update(der);
byte[] digest = md.digest();


if (Arrays.equals(digest, officalkey))
    apksign = c.getString(R.string.official_build);
else if (Arrays.equals(digest, officaldebugkey))
    apksign = c.getString(R.string.debug_build);
else
    apksign = c.getString(R.string.built_by,cert.getSubjectX500Principal().getName());
",,1,a1a277f72cf4d34bb41adc1fba0fcde2fa1da1ec7d7c196d384ed8a2f314e32d
,"TrustManagerFactory tmf =  TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm()); 
tmf.init((KeyStore) null); 
X509TrustManager xtm = (X509TrustManager) tmf.getTrustManagers()[0]; 
for (X509Certificate cert : xtm.getAcceptedIssuers()) { 
    String certStr = ""S:"" + cert.getSubjectDN().getName() + ""\nI:"" 
                        + cert.getIssuerDN().getName(); 
    Log.d(TAG, certStr); 
} 
",,1,03c2f948fd320563c5e1d4681ddb81056cd29524ee43cd6bef8cf7f2b8d0b296
,"import java.security.Key;
import java.security.KeyPair;
import java.security.KeyPairGenerator;
import java.security.NoSuchAlgorithmException;
import java.security.PrivateKey;
import java.security.PublicKey;
import java.security.SecureRandom;
import javax.crypto.Cipher;

public class Test {

    private static final String RSA_ECB_PKCS1_PADDING = ""RSA/ECB/PKCS1Padding"";

    public static void main(String[] args) {
        String data = ""Hello World"";

        KeyPair kp = generateRSAKeyPair();

        PublicKey publicKey = kp.getPublic();
        PrivateKey privateKey = kp.getPrivate();

        byte[] encryptedValue = encryptRSA(publicKey, data.getBytes());
        byte[] decrytpedValue = decryptRSA(privateKey, encryptedValue);

        String decryptedData = new String(decrytpedValue);

        System.out.println(decryptedData);
    }

    public static KeyPair generateRSAKeyPair() {
        KeyPairGenerator keyGen;
        try {
            keyGen = KeyPairGenerator.getInstance(""RSA"");
            SecureRandom rnd = new SecureRandom();
            keyGen.initialize(2048, rnd);
            KeyPair keyPair = keyGen.genKeyPair();
            return keyPair;
        } catch (NoSuchAlgorithmException e) {
            e.printStackTrace();
            return null;
        }
    }

    public static byte[] encryptRSA(Key key, byte[] data) {
        byte[] cipherText = null;
        try {
            final Cipher cipher = Cipher.getInstance(RSA_ECB_PKCS1_PADDING);
            cipher.init(Cipher.ENCRYPT_MODE, key);
            cipherText = cipher.doFinal(data);
        } catch (Exception e) {
            e.printStackTrace();
        }
        return cipherText;
    }

    public static byte[] decryptRSA(Key key, byte[] data) {
        byte[] decryptedText = null;
        try {
            final Cipher cipher = Cipher.getInstance(RSA_ECB_PKCS1_PADDING);
            cipher.init(Cipher.DECRYPT_MODE, key);
            decryptedText = cipher.doFinal(data);
        } catch (Exception e) {
            e.printStackTrace();
        }
        return decryptedText;
    }

}
",3,0,d57eb860b208f4d362405f76b01d2ce9cddbf6a9332fd36efb99590df4f6975e
,"ByteArrayOutputStream blob = new ByteArrayOutputStream();
DataOutputStream dataBlob = new DataOutputStream(blob);

// Get the salt
SecureRandom random = new SecureRandom();
byte[] salt = new byte[saltLength];
random.nextBytes(salt);

dataBlob.writeShort(saltLength);
dataBlob.write(salt);

// Secret key
SecretKey secretKey = getSecretKey(seed, salt);

// Get Cipher instance for AES with Padding algorithm PKCS5
Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");

// Initialization vector, as CBC requires IV
byte[] iv = new byte[cipher.getBlockSize()];
random.nextBytes(iv);

dataBlob.write(iv.length);
dataBlob.write(iv);

// Algorithm spec for IV
IvParameterSpec ivParams = new IvParameterSpec(iv);

cipher.init(Cipher.ENCRYPT_MODE, secretKey, ivParams);

// Encrypt the text
byte[] encryptedTextInBytes = cipher.doFinal(textToBeEncrypted
        .getBytes(StandardCharsets.UTF_8));

dataBlob.writeInt(encryptedTextInBytes.length);
dataBlob.write(encryptedTextInBytes);


// out of scope: add HMAC protection over current contents of blob here
// (or while writing it to dataBlob, also update a HMAC) 

// Base64Encoder encode;
return Base64Encoder.encode(blob.toByteArray());
",1,0,e4c989e9e003aa429f859be0cca56e830ec1304a8d3d76dc8cd2fdee404b2bcd
,"public class MacOutputStream extends FilterOutputStream {

    private final Mac mac;

    public MacOutputStream(OutputStream out, Mac mac) {
        super(out);
        this.mac = mac;
    }

    @Override
    public void write(byte[] b) throws IOException {
        mac.update(b);
        out.write(b);
    }

    @Override
    public void write(int b) throws IOException {
        mac.update((byte) b);
        out.write(b);
    }

    public byte[] getMac() {
        return mac.doFinal();
    }
}
",,1,925603c204d3b65bdcaf1d254a5b7332dffc8a8015c0cd7136fceb0c30f2a34e
,"final HttpsURLConnection https = (HttpsURLConnection) requestedUrl.openConnection();

try {

    https.setConnectTimeout(timeout);
    https.setReadTimeout(timeout);
    https.setRequestMethod(method);

    if (sslSocketFactory != null) {
        https.setSSLSocketFactory(sslSocketFactory);
    }

    https.setHostnameVerifier(new HostnameVerifier() {
        @Override
        public boolean verify(String hostname, SSLSession session) {
            HostnameVerifier hv = HttpsURLConnection.getDefaultHostnameVerifier();
            return hv.verify(""localhost"", session);
        }
    });
...
",4,0,ebcd052af122d3f38f6108c0f1652fcc5004493017ac6b43894c33915689a57e
,"public static SSLContext loadCertificate(String password)
            throws IOException, KeyStoreException, CertificateException, NoSuchAlgorithmException,
            UnrecoverableKeyException, KeyManagementException {

        final FileInputStream fis = new FileInputStream(new File(CERT_FILE_DIRECTORY, CERT_FILE_NAME));

        final KeyStore keyStore = KeyStore.getInstance(""PKCS12"");
        keyStore.load(fis, password.toCharArray());

        final KeyManagerFactory kmf = KeyManagerFactory.getInstance(""X509"");
        kmf.init(keyStore, null);
        final KeyManager[] keyManagers = kmf.getKeyManagers();
        final SSLContext sslContext = SSLContext.getInstance(""TLS"");
        sslContext.init(keyManagers, new TrustManager[]{new MyTrustManager()}, null);
        return sslContext;
    }
",3,0,6dbefba61b4f44b2f9ba112f5a41067285347881e3d14e1bf9f373fcfae78c89
," import java.io.IOException;
 import java.net.InetAddress;
 import java.net.InetSocketAddress;
 import java.net.Socket;
 import java.net.UnknownHostException;

 import javax.net.ssl.SSLContext;
 import javax.net.ssl.SSLSocket;
 import javax.net.ssl.TrustManager;

 import org.apache.http.conn.ConnectTimeoutException;
 import org.apache.http.conn.scheme.LayeredSocketFactory;
 import org.apache.http.conn.scheme.SocketFactory;
 import org.apache.http.params.HttpConnectionParams;
 import org.apache.http.params.HttpParams;

public class EasySSLSocketFactory implements SocketFactory, LayeredSocketFactory {

private SSLContext sslcontext = null;

private static SSLContext createEasySSLContext() throws IOException {
    try {
        SSLContext context = SSLContext.getInstance(""TLS"");
        context.init(null, new TrustManager[] { new EasyX509TrustManager(null) }, null);
        return context;
    } catch (Exception e) {
        throw new IOException(e.getMessage());
    }
}

private SSLContext getSSLContext() throws IOException {
    if (this.sslcontext == null) {
        this.sslcontext = createEasySSLContext();
    }
    return this.sslcontext;
}

/**
 * @see org.apache.http.conn.scheme.SocketFactory#connectSocket(java.net.Socket, java.lang.String, int,
 *      java.net.InetAddress, int, org.apache.http.params.HttpParams)
 */
public Socket connectSocket(Socket sock, String host, int port, InetAddress localAddress, int localPort,
        HttpParams params) throws IOException, UnknownHostException, ConnectTimeoutException {
    int connTimeout = HttpConnectionParams.getConnectionTimeout(params);
    int soTimeout = HttpConnectionParams.getSoTimeout(params);
    InetSocketAddress remoteAddress = new InetSocketAddress(host, port);
    SSLSocket sslsock = (SSLSocket) ((sock != null) ? sock : createSocket());

    if ((localAddress != null) || (localPort &gt; 0)) {
        // we need to bind explicitly
        if (localPort &lt; 0) {
            localPort = 0; // indicates ""any""
        }
        InetSocketAddress isa = new InetSocketAddress(localAddress, localPort);
        sslsock.bind(isa);
    }

    sslsock.connect(remoteAddress, connTimeout);
    sslsock.setSoTimeout(soTimeout);
    return sslsock;

}

/**
 * @see org.apache.http.conn.scheme.SocketFactory#createSocket()
 */
public Socket createSocket() throws IOException {
    return getSSLContext().getSocketFactory().createSocket();
}

/**
 * @see org.apache.http.conn.scheme.SocketFactory#isSecure(java.net.Socket)
 */
public boolean isSecure(Socket socket) throws IllegalArgumentException {
    return true;
}

/**
 * @see org.apache.http.conn.scheme.LayeredSocketFactory#createSocket(java.net.Socket, java.lang.String, int,
 *      boolean)
 */
public Socket createSocket(Socket socket, String host, int port, boolean autoClose) throws IOException,
        UnknownHostException {
    return getSSLContext().getSocketFactory().createSocket(socket, host, port, autoClose);
}

// -------------------------------------------------------------------
// javadoc in org.apache.http.conn.scheme.SocketFactory says :
// Both Object.equals() and Object.hashCode() must be overridden
// for the correct operation of some connection managers
// -------------------------------------------------------------------

public boolean equals(Object obj) {
    return ((obj != null) &amp;&amp; obj.getClass().equals(EasySSLSocketFactory.class));
}

public int hashCode() {
    return EasySSLSocketFactory.class.hashCode();
}

}
",4,0,3003836f5a975610d83dd1c80ec35c9eda07b9e6ce79379ef9fe9fe94c6ce321
,"import java.security.KeyStore;
import java.security.KeyStoreException;
import java.security.NoSuchAlgorithmException;
import java.security.cert.CertificateException;
import java.security.cert.X509Certificate;

import javax.net.ssl.TrustManager;
import javax.net.ssl.TrustManagerFactory;
import javax.net.ssl.X509TrustManager;

public class EasyX509TrustManager implements X509TrustManager {

private X509TrustManager standardTrustManager = null;

/**
 * Constructor for EasyX509TrustManager.
 */
public EasyX509TrustManager(KeyStore keystore) throws NoSuchAlgorithmException, KeyStoreException {
    super();
    TrustManagerFactory factory = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());
    factory.init(keystore);
    TrustManager[] trustmanagers = factory.getTrustManagers();
    if (trustmanagers.length == 0) {
        throw new NoSuchAlgorithmException(""no trust manager found"");
    }
    this.standardTrustManager = (X509TrustManager) trustmanagers[0];
}

/**
 * @see javax.net.ssl.X509TrustManager#checkClientTrusted(X509Certificate[],String authType)
 */
public void checkClientTrusted(X509Certificate[] certificates, String authType) throws CertificateException {
    standardTrustManager.checkClientTrusted(certificates, authType);
}

/**
 * @see javax.net.ssl.X509TrustManager#checkServerTrusted(X509Certificate[],String authType)
 */
public void checkServerTrusted(X509Certificate[] certificates, String authType) throws CertificateException {
    if ((certificates != null) &amp;&amp; (certificates.length == 1)) {
        certificates[0].checkValidity();
    } else {
        standardTrustManager.checkServerTrusted(certificates, authType);
    }
}

/**
 * @see javax.net.ssl.X509TrustManager#getAcceptedIssuers()
 */
public X509Certificate[] getAcceptedIssuers() {
    return this.standardTrustManager.getAcceptedIssuers();
}

}
",4,0,9f2416882d93dfcd0be9feb62de4da612d47a34c82caf8ab3edc47c033e8b2f7
,"ECGenParameterSpec ecParamSpec = new ECGenParameterSpec(""secp384r1"");
KeyPairGenerator kpg = KeyPairGenerator.getInstance(""ECDH"", ""SC"");
kpg.initialize(ecParamSpec);

KeyPair kpA = kpg.generateKeyPair();

BCECPublicKey publicKey = (BCECPublicKey)kpA.getPublic();
BCECPrivateKey privateKey = (BCECPrivateKey)kpA.getPrivate();

byte[] publicKeyBytes = publicKey.getQ().getEncoded(true);
byte[] privateKeyBytes = privateKey.getD().toByteArray();
",2,0,af04d27b82f123dbead9b53e512fbb7f04106bcb2cfa9bf231186751614cc714
,"public String StringToMD5(String s) {
 try {
     // Create MD5 Hash
     MessageDigest digest = java.security.MessageDigest.getInstance(""MD5"");
     digest.update(s.getBytes());
     byte messageDigest[] = digest.digest();

    // Create Hex String
     StringBuffer hexString = new StringBuffer();
     for (int i=0; i&lt;messageDigest.length; i++)
            M hexString.append(Integer.toHexString(0xFF &amp; messageDigest[i]));
    return hexString.toString();

} catch (NoSuchAlgorithmException e) {
    e.printStackTrace();
}
return """";
}
",,1,cdfb4a0592733763ef7e0053ba5c67a03da2d5e80f7285d155a32ec7b133ac57
," public class PicassoTrustAll {

    private static Picasso mInstance = null;

    private PicassoTrustAll(Context context) {
        OkHttpClient client = new OkHttpClient();
        client.setHostnameVerifier(new HostnameVerifier() {
            @Override
            public boolean verify(String s, SSLSession sslSession) {
                return true;
            }
        });
        TrustManager[] trustAllCerts = new TrustManager[] { new X509TrustManager() {
            @Override
            public void checkClientTrusted(
                    java.security.cert.X509Certificate[] x509Certificates,
                    String s) throws java.security.cert.CertificateException {
            }

            @Override
            public void checkServerTrusted(
                    java.security.cert.X509Certificate[] x509Certificates,
                    String s) throws java.security.cert.CertificateException {
            }

            @Override
            public java.security.cert.X509Certificate[] getAcceptedIssuers() {
                return new java.security.cert.X509Certificate[] {};
            }
        } };
        try {
            SSLContext sc = SSLContext.getInstance(""TLS"");
            sc.init(null, trustAllCerts, new java.security.SecureRandom());
            client.setSslSocketFactory(sc.getSocketFactory());
        } catch (Exception e) {
            e.printStackTrace();
        }

        mInstance = new Picasso.Builder(context)
                .downloader(new OkHttpDownloader(client))
                .listener(new Picasso.Listener() {
                    @Override
                    public void onImageLoadFailed(Picasso picasso, Uri uri, Exception exception) {
                        Log.e(""PICASSO"", exception);
                    }
                }).build();

    }

    public static Picasso getInstance(Context context) {
        if (mInstance == null) {
             new PicassoTrustAll(context);
        }
        return mInstance;
    }
}
",4,0,a00babcc0461bbf3569452303ab7d6c1eed430c24e41c587362a5dc41965438f
,"public static String getAppKeyHash(Context context) {
    // Add code to print out the key hash
    try {
        PackageInfo info = context.getPackageManager().getPackageInfo(
                ""com.example.app"", PackageManager.GET_SIGNATURES);
        String hash = null;
        for (Signature signature : info.signatures) {
            MessageDigest md = MessageDigest.getInstance(""SHA"");
            md.update(signature.toByteArray());
            hash = Base64.encodeToString(md.digest(), Base64.DEFAULT);
            Log.d(""KeyHash:"", hash);
        }
        return hash;
    } catch (NameNotFoundException e) {
        return null;
    } catch (NoSuchAlgorithmException e) {
        return null;
    }
}
",3,0,c8fe578b768115973c9dd883b55cee1ea80a97b71a49e4b8b7b6d7ed683d0934
,"MessageDigest md = MessageDigest.getInstance(""SHA-256"");
String text = ""This is some text"";
md.update(text.getBytes(""UTF-8"")); // Change this to ""UTF-16"" if needed
byte[] digest = md.digest();
",2,0,7da9185f2f2c9b32f2ddba553c96bf53b29ae9e37f3b55e35c154b90aac02cb6
,"public static Picasso getInstance(Context context) {
        if (sPicasso == null) {
            InputStream keyStore = context.getResources().openRawResource(R.raw.my_keystore);
            Picasso.Builder builder = new Picasso.Builder(context);
            OkHttpClient okHttpClient = new OkHttpClient();
            SSLContext sslContext;
            try {
                sslContext = SSLContext.getInstance(""TLS"");
                sslContext.init(null, new TrustManager[]{new SsX509TrustManager(keyStore, password)}, null);
                okHttpClient.setSslSocketFactory(sslContext.getSocketFactory());
                OkHttpDownloader okHttpDownloader = new OkHttpDownloader(okHttpClient);
                builder.downloader(okHttpDownloader);
                sPicasso = builder.build();
            } catch (NoSuchAlgorithmException e) {
                throw new IllegalStateException(""Failure initializing default SSL context"", e);
            } catch (KeyManagementException e) {
                throw new IllegalStateException(""Failure initializing default SSL context"", e);
            } catch (GeneralSecurityException e) {
                e.printStackTrace();
            }
        }

        return sPicasso;
    }
",3,0,849d73dc0fdd41bebc6ca7e58b2c881b3d26719070e9187c29074bf30abf2f4a
,"  TrustManager[] trustAllCerts = new TrustManager[]
   { new X509TrustManager()
      {
        public java.security.cert.X509Certificate[] getAcceptedIssuers()  { return null; }
        public void checkClientTrusted( X509Certificate[] chain, String authType) {}
        public void checkServerTrusted( X509Certificate[] chain, String authType) {}
      }
   };

  try
    {
      SSLContext sc = SSLContext.getInstance( ""SSL""); // ""TLS"" ""SSL""
      sc.init( null, trustAllCerts, null);
      // sc.init( null, trustAllCerts, new java.security.SecureRandom());
      HttpsURLConnection.setDefaultSSLSocketFactory( sc.getSocketFactory());
      HttpsURLConnection.setDefaultHostnameVerifier( 
       new HostnameVerifier() 
        {
          public boolean verify( String hostname, SSLSession session) { return true; }
        } );
    }
   catch (Exception e) {}
",4,0,0d8b310054bbf159f6a7b8c6fc1347f2a5cc376140e3baf39118d0a722872ae5
,"public String md5(String s) {
        try {
            // Create MD5 Hash
            MessageDigest digest = java.security.MessageDigest.getInstance(""MD5"");
            digest.update(s.getBytes());
            byte messageDigest[] = digest.digest();

            // Create Hex String
            StringBuffer hexString = new StringBuffer();
            for (int i=0; i&lt;messageDigest.length; i++)
                hexString.append(Integer.toHexString(0xFF &amp; messageDigest[i]));
            return hexString.toString();

        } catch (NoSuchAlgorithmException e) {
            e.printStackTrace();
        }
        return """";
    }
",,1,e5a6a5c3767dd4d17bca95182697cddb2dccbbb094592dd317166b582a8276dc
,"try {
        PackageInfo info = getPackageManager().getPackageInfo(
                ""com.matainja.facebooklogin"", 
                PackageManager.GET_SIGNATURES);
        for (Signature signature : info.signatures) {
            MessageDigest md = MessageDigest.getInstance(""SHA"");
            md.update(signature.toByteArray());
            Log.d(""KeyHash:"", Base64.encodeToString(md.digest(), Base64.DEFAULT));
            }
    } catch (NameNotFoundException e) {

    } catch (NoSuchAlgorithmExceptio`enter code here`n e) {

    }
",3,0,32d80bbfaa4c166029bdb49db5779c85a4ee2ecaf8a115e40d31fe0f2a92ea58
,"public static String sStringToHMACMD5(String s, String keyString)
    {
        String sEncodedString = null;
        try
        {
            SecretKeySpec key = new SecretKeySpec((keyString).getBytes(""UTF-8""), ""HmacMD5"");
            Mac mac = Mac.getInstance(""HmacMD5"");
            mac.init(key);

            byte[] bytes = mac.doFinal(s.getBytes(""ASCII""));

            StringBuffer hash = new StringBuffer();

            for (int i=0; i&lt;bytes.length; i++) {
                String hex = Integer.toHexString(0xFF &amp;  bytes[i]);
                if (hex.length() == 1) {
                    hash.append('0');
                }
                hash.append(hex);
            }
            sEncodedString = hash.toString();
        }
        catch (UnsupportedEncodingException e) {}
        catch(InvalidKeyException e){}
        catch (NoSuchAlgorithmException e) {}
        return sEncodedString ;
    }
",3,0,e7fd550a236c6ce3b0a3a894109717157959e2a27fd09a1b8c6f0e9a6518056f
,"public final class ProviderUtils {

    private ProviderUtils() {} // not instantiable, it is a utility class

    public static void print(Provider provider) {
        String name = provider.getName();
        // print the name
    }
}
",,1,1544121b40010d1b87f8085c4694f035d82b234dfe27eac524ba26ddaad8b8ce
,"try {
        PackageInfo info = getActivity().getPackageManager().getPackageInfo(
                ""com.yourappname.app"",
                PackageManager.GET_SIGNATURES);
        for (Signature signature : info.signatures) {
            MessageDigest md = MessageDigest.getInstance(""SHA"");
            md.update(signature.toByteArray());
            Log.d(""KeyHash"", ""KeyHash:"" + Base64.encodeToString(md.digest(),
                    Base64.DEFAULT));
            Toast.makeText(getActivity().getApplicationContext(), Base64.encodeToString(md.digest(),
                    Base64.DEFAULT), Toast.LENGTH_LONG).show();
        }
    } catch (PackageManager.NameNotFoundException e) {

    } catch (NoSuchAlgorithmException e) {

    }
",3,0,fa1e1b0eda7bd147a75e73d45b0e87a6bdba6fc4298c5520d668ab5fded8eae3
,"public byte[] RSAEncrypt(final String plain) throws NoSuchAlgorithmException, NoSuchPaddingException,
        InvalidKeyException, IllegalBlockSizeException, BadPaddingException {
    kpg = KeyPairGenerator.getInstance(""RSA"");
    kpg.initialize(1024);
    kp = kpg.genKeyPair();
    publicKey = kp.getPublic();
    privateKey = kp.getPrivate();

    cipher = Cipher.getInstance(""RSA"");
    cipher.init(Cipher.ENCRYPT_MODE, publicKey);
    encryptedBytes = cipher.doFinal(plain.getBytes());
    System.out.println(""EEncrypted?????"" + org.apache.commons.codec.binary.Hex.encodeHexString(encryptedBytes));
    return encryptedBytes;
}

public String RSADecrypt(final byte[] encryptedBytes) throws NoSuchAlgorithmException, NoSuchPaddingException,
        InvalidKeyException, IllegalBlockSizeException, BadPaddingException {

    cipher1 = Cipher.getInstance(""RSA"");
    cipher1.init(Cipher.DECRYPT_MODE, privateKey);
    decryptedBytes = cipher1.doFinal(encryptedBytes);
    decrypted = new String(decryptedBytes);
    System.out.println(""DDecrypted?????"" + decrypted);
    return decrypted;
}
",3,0,68c7a2be5084510d026a943de6a6725eaba70f55b8e533fccafdceb0a70530fc
,"package test;

import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.security.InvalidKeyException;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.Arrays;

import javax.crypto.Cipher;
import javax.crypto.CipherInputStream;
import javax.crypto.CipherOutputStream;
import javax.crypto.NoSuchPaddingException;
import javax.crypto.spec.SecretKeySpec;

public class TestCrypt{

    private static final String salt = ""t784"";
    private static final String cryptPassword = ""873147cbn9x5'2 79'79314"";
    private static final String fileToBeCrypted = ""c:\\Temp\\sampleFile.conf"";
    private static final String fileToBeDecrypted = ""c:\\Temp\\sampleFile.conf.crypt"";
    private static final String fileDecryptedOutput = ""c:\\Temp\\sampleFile.conf.decrypted"";

    public static void main(String[] args) throws Exception
    {
        for (int i=0; i&lt;100; i++)
        {
            encryptfile(fileToBeCrypted, cryptPassword);
            decrypt(fileToBeDecrypted, cryptPassword, fileDecryptedOutput);
            System.out.println(i);
        }
    }

    public static void encryptfile(String path,String password) throws IOException, NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException {
        FileInputStream fis = new FileInputStream(path);
        FileOutputStream fos = new FileOutputStream(path.concat("".crypt""));
        byte[] key = (salt + password).getBytes(""UTF-8"");
        MessageDigest sha = MessageDigest.getInstance(""SHA-1"");
        key = sha.digest(key);
        key = Arrays.copyOf(key,16);
        SecretKeySpec sks = new SecretKeySpec(key, ""AES"");
        Cipher cipher = Cipher.getInstance(""AES"");
        cipher.init(Cipher.ENCRYPT_MODE, sks);
        CipherOutputStream cos = new CipherOutputStream(fos, cipher);
        int b;
        byte[] d = new byte[8];
        while((b = fis.read(d)) != -1) {
            cos.write(d, 0, b);
        }
        cos.flush();
        cos.close();
        fis.close();
    }

    public static void decrypt(String path,String password, String outPath) throws IOException, NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException {
        FileInputStream fis = new FileInputStream(path);
        FileOutputStream fos = new FileOutputStream(outPath);
        byte[] key = (salt + password).getBytes(""UTF-8"");
        MessageDigest sha = MessageDigest.getInstance(""SHA-1"");
        key = sha.digest(key);
        key = Arrays.copyOf(key,16);
        SecretKeySpec sks = new SecretKeySpec(key, ""AES"");
        Cipher cipher = Cipher.getInstance(""AES"");
        cipher.init(Cipher.DECRYPT_MODE, sks);
        CipherInputStream cis = new CipherInputStream(fis, cipher);
        int b;
        byte[] d = new byte[8];
        while((b = cis.read(d)) != -1) {
            fos.write(d, 0, b);
        }
        fos.flush();
        fos.close();
        cis.close();
    }

}
",3,0,772ac0a3f6beeb5216ceb9586443e788ac9c1a0f347522b47b5e686195a4f593
," /**
 * Initialize the HTTP/S connection (if needed)
 *
 * @param  keystoreFile  the full path of the keystore file
 * @param  keystorePass  the password for the keystore file
 */
private void initHttps(String keystoreFile, String keystorePass)
{
    // check if the URL uses HTTP/S
    if (url.toLowerCase().startsWith(HTTPS_PROTOCOL))
    {
        print(""Initializing HTTP/S protocol..."");
        // set the system properties needed for HTTP/S
        System.setProperty(""javax.net.ssl.keyStore"", keystoreFile);
        System.setProperty(""javax.net.ssl.keyStorePassword"", keystorePass);
        System.setProperty(""javax.net.ssl.keyStoreType"", ""JKS"");
        System.setProperty(""javax.net.ssl.trustStore"", keystoreFile);
        System.setProperty(""javax.net.ssl.trustStorePassword"", keystorePass);
        System.setProperty(""javax.protocol.handler.pkgs"",
            ""com.sun.net.ssl.internal.www.protocol"");
        //int addProvider = Security.addProvider(new       com.sun.net.ssl.internal.ssl.Provider());
        HttpsURLConnection.setDefaultHostnameVerifier(new HostnameVerifier()
        {   // fix a HTTP/S handshake issue
            public boolean verify(String hostName, SSLSession session)
            {   // Verify that the host name is acceptable 
                return true;
            }
        });
    }
}
",4,0,445ae21e26c3f30ff1b75cd236f9771ea0c6054d1d9300613d2e19cd175861e6
,"/* generate secretkey */
PBEKeySpec keySpec=new PBEKeySpec(username.toCharArray(),salt.getBytes(),1000,256);
SecretKeyFactory keyFactory=SecretKeyFactory.getInstance(""PBKDF2WithHmacSHA1"");
SecretKey tmp=keyFactory.generateSecret(keySpec);

/*transform key to keySpec*/
SecretKey key=new SecretKeySpec(tmp.getEncoded(),""AES"");
",,1,88ea66083cb192d7a712dea592537a9793d7ac285bef6c6a992ba2fdbcf9664d
,"private String hashString(String s) {
        try {
            // Create SHA-1 Hash
            MessageDigest digest = java.security.MessageDigest.getInstance(""SHA-1"");
            digest.update(s.getBytes(""UTF-8""));
            byte messageDigest[] = digest.digest();

            // Create Hex String
            StringBuffer hexString = new StringBuffer();
            for (int i = 0; i &lt; messageDigest.length; i++)
                hexString.append(Integer.toHexString(0xFF &amp; messageDigest[i]));
            return hexString.toString();

        } catch (NoSuchAlgorithmException e) {
            e.printStackTrace();
        }
        return """";
    }
",3,0,656379ee117fa1d8cef0a0a2411fd75381828759ff2087c363c3dd27e5b2e750
,"protected void ShowHash(android.net.Uri uri) {
    MessageDigest md = null;
    try {
        md = MessageDigest.getInstance(""MD5"");
        BufferedInputStream is = new BufferedInputStream(getContentResolver().openInputStream(uri));
        DigestInputStream dis = new DigestInputStream(is, md);
        byte[] buffer = new byte[1024];
        while(dis.read(buffer, 0, buffer.length) != -1) ;
        Toast.makeText(getApplicationContext(), bytesToHex(md.digest()),
                Toast.LENGTH_LONG).show();
    } catch(Exception e) {
        Toast.makeText(getApplicationContext(), e.toString(),
                Toast.LENGTH_LONG).show();
    }
    return;
}
",,1,ef10a3dfdc220698d4a19974df3dbb39c157ca11a5c2d694e576a16879024d53
,"private static TrustManager[] trustManagers;

public static class _FakeX509TrustManager implements
        javax.net.ssl.X509TrustManager {
    private static final X509Certificate[] _AcceptedIssuers = new X509Certificate[] {};

    public void checkClientTrusted(X509Certificate[] arg0, String arg1)
            throws CertificateException {
    }

    public void checkServerTrusted(X509Certificate[] arg0, String arg1)
            throws CertificateException {
    }

    public boolean isClientTrusted(X509Certificate[] chain) {
        return (true);
    }

    public boolean isServerTrusted(X509Certificate[] chain) {
        return (true);
    }

    public X509Certificate[] getAcceptedIssuers() {
        return (_AcceptedIssuers);
    }
}

public static void allowAllSSL() {

    javax.net.ssl.HttpsURLConnection
            .setDefaultHostnameVerifier(new HostnameVerifier() {
                public boolean verify(String hostname, SSLSession session) {
                    return true;
                }
            });

    javax.net.ssl.SSLContext context = null;

    if (trustManagers == null) {
        trustManagers = new javax.net.ssl.TrustManager[] { new _FakeX509TrustManager() };
    }

    try {
        context = javax.net.ssl.SSLContext.getInstance(""TLS"");
        context.init(null, trustManagers, new SecureRandom());
    } catch (NoSuchAlgorithmException e) {
        Log.e(""allowAllSSL"", e.toString());
    } catch (KeyManagementException e) {
        Log.e(""allowAllSSL"", e.toString());
    }
    javax.net.ssl.HttpsURLConnection.setDefaultSSLSocketFactory(context
            .getSocketFactory());
}
",4,0,89a9354f2722d58c595582a93def2c5f25b7386d341408784fcb227a2db5a135
,"SSLContext ctx = SSLContext.getInstance(""TLS"");
ctx.init(null, new TrustManager[] {
new X509TrustManager() {
     public void checkClientTrusted(X509Certificate[] chain, String authType) {}
     public void checkServerTrusted(X509Certificate[] chain, String authType) {}
     public X509Certificate[] getAcceptedIssuers() { return new X509Certificate[]{}; }
     }
}, null);
HttpsURLConnection.setDefaultSSLSocketFactory(ctx.getSocketFactory());

HttpsURLConnection.setDefaultHostnameVerifier(new HostnameVerifier() {
     public boolean verify(String hostname, SSLSession session) {
          return true;
     }
});
",4,0,938eca455844b79f7397f97d89f2ddd012296ac2bff839670f2075001e16eaae
,"public static String encrypt(final String plainMessage,
        final String symKeyHex) {


    try {

    final byte[] symKeyData = Hex.decodeHex(symKeyHex.toCharArray());

    final byte[] encodedMessage = plainMessage.getBytes(Charset.forName(""UTF-8""));

        final Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
        final int blockSize = cipher.getBlockSize();

        // create the key
        final SecretKeySpec symKey = new SecretKeySpec(symKeyData, ""AES"");

        // generate random IV using block size (possibly create a method for
        // this)
        final byte[] ivData = new byte[blockSize];
        final SecureRandom rnd = SecureRandom.getInstance(""SHA1PRNG"");
        rnd.nextBytes(ivData);
        final IvParameterSpec iv = new IvParameterSpec(ivData);

        cipher.init(Cipher.ENCRYPT_MODE, symKey, iv);

        final byte[] encryptedMessage = cipher.doFinal(encodedMessage);

        // concatenate IV and encrypted message
        final byte[] ivAndEncryptedMessage = new byte[ivData.length
                + encryptedMessage.length];
        System.arraycopy(ivData, 0, ivAndEncryptedMessage, 0, blockSize);
        System.arraycopy(encryptedMessage, 0, ivAndEncryptedMessage,
                blockSize, encryptedMessage.length);

        final String ivAndEncryptedMessageBase64 = Base64.encodeBase64String(ivAndEncryptedMessage);

        return ivAndEncryptedMessageBase64;
    } catch (InvalidKeyException e) {
        throw new IllegalArgumentException(
                ""key argument does not contain a valid AES key"");
    } catch (GeneralSecurityException e) {
        throw new IllegalStateException(
                ""Unexpected exception during encryption"", e);
    } catch (DecoderException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    }
    return """";

}

public static String decrypt(final String ivAndEncryptedMessageBase64,
        final String symKeyHex) {

    try {
        final byte[] symKeyData = Hex.decodeHex(symKeyHex.toCharArray());
        final byte[] ivAndEncryptedMessage = Base64.decodeBase64(ivAndEncryptedMessageBase64);


        final Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
        final int blockSize = cipher.getBlockSize();

        // create the key
        final SecretKeySpec symKey = new SecretKeySpec(symKeyData, ""AES"");

        // retrieve random IV from start of the received message
        final byte[] ivData = new byte[blockSize];
        System.arraycopy(ivAndEncryptedMessage, 0, ivData, 0, blockSize);
        final IvParameterSpec iv = new IvParameterSpec(ivData);

        // retrieve the encrypted message itself
        final byte[] encryptedMessage = new byte[ivAndEncryptedMessage.length
                - blockSize];
        System.arraycopy(ivAndEncryptedMessage, blockSize,
                encryptedMessage, 0, encryptedMessage.length);

        cipher.init(Cipher.DECRYPT_MODE, symKey, iv);

        final byte[] encodedMessage = cipher.doFinal(encryptedMessage);

        // concatenate IV and encrypted message
        final String message = new String(encodedMessage,
                Charset.forName(""UTF-8""));

        return message;
    } catch (InvalidKeyException e) {
        throw new IllegalArgumentException(
                ""key argument does not contain a valid AES key"");
    } catch (BadPaddingException e) {
        // you'd better know about padding oracle attacks
        return null;
    } catch (GeneralSecurityException e) {
        throw new IllegalStateException(
                ""Unexpected exception during decryption"", e);
    } catch (DecoderException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    }
    return """";
}
",1,0,38957bfa19fb6031c00a8ecfe9aaa2385c49b7442541579b2b9ed03454d3bbdf
,"public static String encrypt(final String plainMessage,
                             final String symKeyHex) {


    try {

        final byte[] symKeyData = Hex.decodeHex(symKeyHex.toCharArray());

        final byte[] encodedMessage = plainMessage.getBytes(Charset.forName(""UTF-8""));

        final Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
        final int blockSize = cipher.getBlockSize();

        // create the key
        final SecretKeySpec symKey = new SecretKeySpec(symKeyData, ""AES"");

        // generate random IV using block size (possibly create a method for
        // this)
        final byte[] ivData = new byte[blockSize];
        final SecureRandom rnd = SecureRandom.getInstance(""SHA1PRNG"");
        rnd.nextBytes(ivData);
        final IvParameterSpec iv = new IvParameterSpec(ivData);

        cipher.init(Cipher.ENCRYPT_MODE, symKey, iv);

        final byte[] encryptedMessage = cipher.doFinal(encodedMessage);

        // concatenate IV and encrypted message
        final byte[] ivAndEncryptedMessage = new byte[ivData.length
                + encryptedMessage.length];
        System.arraycopy(ivData, 0, ivAndEncryptedMessage, 0, blockSize);
        System.arraycopy(encryptedMessage, 0, ivAndEncryptedMessage,
                blockSize, encryptedMessage.length);

        //final String ivAndEncryptedMessageBase64 = Base64.encodeBase64String(ivAndEncryptedMessage);
        final String ivAndEncryptedMessageBase64 = Base64.encodeToString(ivAndEncryptedMessage,Base64.DEFAULT);

        return ivAndEncryptedMessageBase64;
    } catch (InvalidKeyException e) {
        throw new IllegalArgumentException(
                ""key argument does not contain a valid AES key"");
    } catch (GeneralSecurityException e) {
        throw new IllegalStateException(
                ""Unexpected exception during encryption"", e);
    } catch (DecoderException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    }
    return """";

}

public static String decrypt(final String ivAndEncryptedMessageBase64,
                             final String symKeyHex) {


    try {

        final byte[] symKeyData = Hex.decodeHex(symKeyHex.toCharArray());
        //final byte[] ivAndEncryptedMessage = Base64.decodeBase64(ivAndEncryptedMessageBase64);
        final byte[] ivAndEncryptedMessage = Base64.decode(ivAndEncryptedMessageBase64,Base64.DEFAULT);

        final Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
        final int blockSize = cipher.getBlockSize();

        // create the key
        final SecretKeySpec symKey = new SecretKeySpec(symKeyData, ""AES"");

        // retrieve random IV from start of the received message
        final byte[] ivData = new byte[blockSize];
        System.arraycopy(ivAndEncryptedMessage, 0, ivData, 0, blockSize);
        final IvParameterSpec iv = new IvParameterSpec(ivData);

        // retrieve the encrypted message itself
        final byte[] encryptedMessage = new byte[ivAndEncryptedMessage.length
                - blockSize];
        System.arraycopy(ivAndEncryptedMessage, blockSize,
                encryptedMessage, 0, encryptedMessage.length);

        cipher.init(Cipher.DECRYPT_MODE, symKey, iv);

        final byte[] encodedMessage = cipher.doFinal(encryptedMessage);

        // concatenate IV and encrypted message
        final String message = new String(encodedMessage,
                Charset.forName(""UTF-8""));

        return message;
    } catch (InvalidKeyException e) {
        throw new IllegalArgumentException(
                ""key argument does not contain a valid AES key"");
    } catch (BadPaddingException e) {
        // you'd better know about padding oracle attacks
        return null;
    } catch (GeneralSecurityException e) {
        throw new IllegalStateException(
                ""Unexpected exception during decryption"", e);
    } catch (DecoderException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    }
    return """";
}
",1,0,6109418194e95e97cb94f7b90f689534a2551334be3250d1df02689649e87bfb
,"public static String md5(String input) throws NoSuchAlgorithmException {
    MessageDigest md = MessageDigest.getInstance(""MD5"");
    byte[] messageDigest = md.digest(input.getBytes());
    BigInteger number = new BigInteger(1, messageDigest);
    return number.toString(16);
}

public String decrypt(String encryptedData, String initialVectorString, String secretKey) {
    String decryptedData = null;
    try {
        SecretKeySpec skeySpec = new SecretKeySpec(md5(secretKey).getBytes(), ""AES"");
        IvParameterSpec initialVector = new IvParameterSpec(initialVectorString.getBytes());
        Cipher cipher = Cipher.getInstance(""AES/CFB8/NoPadding"");
        cipher.init(Cipher.DECRYPT_MODE, skeySpec, initialVector);
        byte[] encryptedByteArray = (new org.apache.commons.codec.binary.Base64()).decode(encryptedData.getBytes());
        byte[] decryptedByteArray = cipher.doFinal(encryptedByteArray);
        decryptedData = new String(decryptedByteArray, ""UTF8"");
    } catch (Exception e) {
        LOGGER.debug(""Problem decrypting the data"", e);
    }
    return decryptedData;
}
",1,0,306c6f9851f57c8f518dc4d4926f52009da16888b938331f2823abab7bee7c05
,"byte[] keyBytes = KeyGenerator.getInstance(""AES"").getEncoded();

...

SecretKeySpec skeySpec = new SecretKeySpec(keyBytes, ""AES"");
Cipher cipher = Cipher.getInstance(""AES"");
cipher.init(Cipher.DECRYPT_MODE, skeySpec);
",3,0,21bf6d721a03093eda9219926125dcfb775ea0b50da40b013572052f8180741c
,"import java.io.IOException;
import java.net.Socket;
import java.net.UnknownHostException;
import java.security.KeyManagementException;
import java.security.KeyStore;
import java.security.KeyStoreException;
import java.security.NoSuchAlgorithmException;
import java.security.UnrecoverableKeyException;
import java.security.cert.CertificateException;
import java.security.cert.X509Certificate;
import javax.net.ssl.SSLContext;
import javax.net.ssl.TrustManager;
import javax.net.ssl.X509TrustManager;
import org.apache.http.conn.ssl.SSLSocketFactory;

public class CustomSSLSocketFactory extends SSLSocketFactory{
      SSLContext sslContext = SSLContext.getInstance(""TLS"");
      /**
       * Generate Certificate for ssl connection
       * @param truststore
       * @throws NoSuchAlgorithmException
       * @throws KeyManagementException
       * @throws KeyStoreException
       * @throws UnrecoverableKeyException
       */
      public CustomSSLSocketFactory(KeyStore truststore)
                  throws NoSuchAlgorithmException, KeyManagementException,
                  KeyStoreException, UnrecoverableKeyException {
            super(truststore);
            TrustManager tm = new X509TrustManager(){
                  @Override
                  public void checkClientTrusted(X509Certificate[] arg0, String arg1)
                              throws CertificateException {
                  }
                  @Override
                  public void checkServerTrusted(X509Certificate[] chain,
                              String authType) throws CertificateException {
                  }
                  @Override
                  public X509Certificate[] getAcceptedIssuers() {
                        return null;
                  }
            };
            sslContext.init(null, new TrustManager[] {tm}, null);
      }

      @Override
      public Socket createSocket(Socket socket, String host, int port,
                  boolean autoClose) throws IOException, UnknownHostException {
            return sslContext.getSocketFactory().createSocket(socket, host, port,
                        autoClose);
      }

      @Override
      public Socket createSocket() throws IOException {
            return sslContext.getSocketFactory().createSocket();
      }
}
",4,0,9a9a8f4c3f9466b6ae9c6f4764d2b5c3461fa41acb2ab08224e94632cc31a0b6
,"import java.security.KeyStore;
import org.apache.http.client.HttpClient;
import org.apache.http.conn.ClientConnectionManager;
import org.apache.http.conn.scheme.Scheme;
import org.apache.http.conn.scheme.SchemeRegistry;
import org.apache.http.conn.ssl.SSLSocketFactory;
import org.apache.http.impl.client.DefaultHttpClient;
import org.apache.http.impl.conn.tsccm.ThreadSafeClientConnManager;
import org.apache.http.params.BasicHttpParams;
import org.apache.http.params.HttpParams;

public class HTTPUtils {
      /**
       * HttpClient
       * @param isHTTPS
       * @return
       */
      public static HttpClient getNewHttpClient(boolean isHTTPS) {
            try {
                  if(!isHTTPS){
                        return getNewHttpClient();
                  }
                  KeyStore trustStore = KeyStore.getInstance(KeyStore.getDefaultType());
                  trustStore.load(null, null);
                  SSLSocketFactory sf = new CustomSSLSocketFactory(trustStore);
                  sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);

                  HttpParams params = new BasicHttpParams();
                  SchemeRegistry registry = new SchemeRegistry();
                  registry.register(new Scheme(""https"", sf, 443));

                  ClientConnectionManager ccm = new ThreadSafeClientConnManager(params, registry);
                  return new DefaultHttpClient(ccm, params);
            } catch (Exception e) {
                  return null;
            }
      }
      /**
       * HttpClient for http request
       * @return
       */
      private static HttpClient getNewHttpClient(){
            HttpParams params = new BasicHttpParams();
            return new DefaultHttpClient(params);
      }
}
",4,0,2650922b0047f1af432a64dfe1505997dc14d8414a10a2c5c76d7f80187324f9
,"try {
    // Taken from: http://blog.alcor.se/index.php/2013/08/09/using-java-to-connect-with-sslsocket-trusting-all-certificates/
    // Create a trust manager that does not validate certificate chains
    TrustManager[] trustAllCerts = new TrustManager[]{new X509TrustManager() {
        @Override
        public void checkClientTrusted(java.security.cert.X509Certificate[]
                                               chain, String authType) throws CertificateException {
        }

        @Override
        public void checkServerTrusted(java.security.cert.X509Certificate[]
                                               chain, String authType) throws CertificateException {
        }

        public java.security.cert.X509Certificate[] getAcceptedIssuers() {
            return null;
        }
    }
    };

    // Install the all-trusting trust manager
    SSLContext sc = SSLContext.getInstance(""SSL"");
    sc.init(null, trustAllCerts, new java.security.SecureRandom());

    SSLSocketFactory sslsocketfactory = sc.getSocketFactory();
    sslsocket = (SSLSocket) sslsocketfactory.createSocket(targetIp, port);
    sslsocket.setKeepAlive(true);
    // Sets this socket's read timeout in milliseconds.
    // sslsocket.setSoTimeout(timeoutSocket);

    Log.d(TAG, ""Sending: "" + xmlAction + xmlValue + XmlConstants.NEW_LINE);
    String line;
    ArrayList&lt;String&gt; receivedLines = new ArrayList&lt;String&gt;();

    DataOutputStream outToServerSSL = new DataOutputStream(sslsocket.getOutputStream());
    BufferedReader inFromServerSSL = new BufferedReader(new InputStreamReader(sslsocket.getInputStream()));
    outToServerSSL.writeBytes(xmlAction + xmlValue + XmlConstants.NEW_LINE + XmlConstants.NEW_LINE);

    while ((line = inFromServerSSL.readLine()) != null) {
        receivedLines.add(line);
        Log.d(TAG, ""Received: "" + line);
    }

    Log.d(TAG, ""Closing tha sizzle"");
    inFromServerSSL.close();
    outToServerSSL.close();

    return ParseXmlForStatusCode(receivedLines);

} catch (NoSuchAlgorithmException e) {
    e.printStackTrace();
} catch (UnknownHostException e) {
    e.printStackTrace();
} catch (KeyManagementException e) {
    e.printStackTrace();
} catch (IOException e) {
    e.printStackTrace();
} finally {
    if (sslsocket != null) {
        try {
            sslsocket.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
",4,0,19f7959867a79ef18453f7356d9d2aec1ccdf0d58238b9890f150461a64e02f9
,"public static SSLContext getSSLContext() throws Exception {
        if (sslContext==null) {
            // loading CA from an InputStream
            InputStream is = AVApplication.getContext().getResources().openRawResource(R.raw.wildcard);
            String certificates = Converter.convertStreamToString(is);
            String certificateArray[] = certificates.split(""-----BEGIN CERTIFICATE-----"");

            // creating a KeyStore containing our trusted CAs
            KeyStore ks = KeyStore.getInstance(""BKS"");
            ks.load(null, null);
            for (int i = 1; i &lt; certificateArray.length; i++) {
                certificateArray[i] = ""-----BEGIN CERTIFICATE-----"" + certificateArray[i];
                //LogAV.d(""cert:"" + certificateArray[i]);

                // generate input stream for certificate factory
                InputStream stream = IOUtils.toInputStream(certificateArray[i]);

                // CertificateFactory
                CertificateFactory cf = CertificateFactory.getInstance(""X.509"");
                // certificate
                Certificate ca;
                try {
                    ca = cf.generateCertificate(stream);
                } finally {
                    is.close();
                }

                ks.setCertificateEntry(""av-ca"" + i, ca);
            }
            // TrustManagerFactory
            String algorithm = TrustManagerFactory.getDefaultAlgorithm();
            TrustManagerFactory tmf = TrustManagerFactory.getInstance(algorithm);
            // Create a TrustManager that trusts the CAs in our KeyStore
            tmf.init(ks);

            // Create a SSLContext with the certificate that uses tmf (TrustManager)
            sslContext = SSLContext.getInstance(""TLS"");
            sslContext.init(null, tmf.getTrustManagers(), new SecureRandom());
        }

        return sslContext;
    }
",3,0,55cb7fc63bca9b08dbc12c52e9ce3f962cf3223ea52e6ce75cd941ce9c8ca8a4
,"byte[] cipherTextBytes = DatatypeConverter.parseBase64Binary(cipherText);
byte[] privateKeyBytes = DatatypeConverter.parseBase64Binary(privateKeyStr);

KeyFactory kf = KeyFactory.getInstance(""RSA"");
PKCS8EncodedKeySpec ks = new PKCS8EncodedKeySpec(privateKeyBytes);
PrivateKey privateKey = kf.generatePrivate(ks);

Cipher c = Cipher.getInstance(""RSA/ECB/OAEPWithSHA-256AndMGF1Padding"");
c.init(Cipher.DECRYPT_MODE, privateKey, new OAEPParameterSpec(""SHA-256"",
        ""MGF1"", MGF1ParameterSpec.SHA256, PSource.PSpecified.DEFAULT));
byte[] plainTextBytes = c.doFinal(cipherTextBytes);
String plainText = new String(plainTextBytes);

System.out.println(plainText);
",2,0,d9ff8fdece59cb121982f2630fc9eb15814b4306436ed2bbd44347cb3014bd72
,"/**
 * Same security, twice the speed.
 */
public static String generateStorngPasswordHashWithSHA256(String password) {
    try {
        char[] chars = password.toCharArray();
        byte[] salt = getSalt();

        PBEKeySpec spec = new PBEKeySpec(chars, salt, 1010101,
                20 * Byte.SIZE);
        SecretKeyFactory skf = SecretKeyFactory
                .getInstance(""PBKDF2WithHmacSHA1"");
        byte[] hash = skf.generateSecret(spec).getEncoded();

        MessageDigest sha256 = MessageDigest.getInstance(""SHA-256"");
        hash = sha256.digest();

        return toHex(salt) + "":"" + toHex(hash);
    } catch (Exception e) {
        System.out.println(""Exception: Error in generating password""
                + e.toString());
    }
    return """";
}
",2,0,d578d40b2ae6264135cbd81827a40e8b43e0d30ccac4c9f65da10058cdd101e0
,"public static byte[] encrypt(byte[] bytes, byte[] key, byte[] iv)
        throws Exception
{
    Cipher cipher = Cipher.getInstance(""AES/CBC/ISO10126Padding"");
    cipher.init(Cipher.ENCRYPT_MODE, new SecretKeySpec(key, ""AES""),
            new IvParameterSpec(iv));
    return cipher.doFinal(bytes);
}
",1,0,1710266a3fe2e614484cf44fe28884e20e6a43b7adf17d6e55f85bb87949ce09
,"KeyStore selfsignedKeys = KeyStore.getInstance(""BKS"");
selfsignedKeys.load(context.getResources().openRawResource(R.raw.selfsignedcertsbks),
""genericPassword"".toCharArray());
TrustManagerFactory trustMgr = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());
trustMgr.init(selfsignedKeys);
SSLContext selfsignedSSLcontext = SSLContext.getInstance(""TLS"");
selfsignedSSLcontext.init(null, trustMgr.getTrustManagers(), new SecureRandom());
HttpsURLConnection.setDefaultSSLSocketFactory(selfsignedSSLcontext.getSocketFactory());
URL serverURL = new URL(""https://server.example.com/endpointTest"");
HttpsURLConnection serverConn = (HttpsURLConnection)serverURL.openConnection();
",3,0,27c73f2f4c6f1aff082a02d3ffd705c58d640c2d1e58d776c915682a5cae0f26
,"SecretKey key = getEncryptionKey(); 
byte[] iv = new byte[] { 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, (byte)144, (byte)233, 122, 100 };
byte[] cipherBytes = readEncryptedFile();
Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
IvParameterSpec ivParams = new IvParameterSpec(iv);
cipher.init(Cipher.DECRYPT_MODE, key, ivParams);
byte[] plaintext = cipher.doFinal(cipherBytes);
",4,0,19fb0440d90c899a964e62e722eb7054e5eb4826666f61816a4a2da228d84389
,"MessageDigest md = MessageDigest.getInstance(""SHA"");
md.update(signatures[0].toByteArray());
String signature = Base64.encodeToString(md.digest(), Base64.DEFAULT);
if (!signature.equals(SIGNATURE_KEY)){
    //do your logic
}
",3,0,66c07743da2f117b8c03cc73225eaa54eb0ae291389f07f08d0ac9bab69ce9e3
,"public class SimpleOTPGenerator {


    protected SimpleOTPGenerator() {
    }

    public static String random(int size) {

        StringBuilder generatedToken = new StringBuilder();
        try {
            SecureRandom number = SecureRandom.getInstance(""SHA1PRNG"");
            // Generate 20 integers 0..20
            for (int i = 0; i &lt; size; i++) {
                generatedToken.append(number.nextInt(9));
            }
        } catch (NoSuchAlgorithmException e) {
            e.printStackTrace();
        }

        return generatedToken.toString();
    }
}
",,1,25b9006e6c0abc842db7e116028687ffbc0db462f97138d4a2841ab82663ea31
,"public class MySSLSocketFactory extends SSLSocketFactory {
    SSLContext sslContext = SSLContext.getInstance(""TLS"");

    public MySSLSocketFactory(KeyStore truststore)
                    throws NoSuchAlgorithmException, KeyManagementException,
                    KeyStoreException, UnrecoverableKeyException {
            super(truststore);

            TrustManager tm = new X509TrustManager() {
                    public void checkClientTrusted(X509Certificate[] chain,
                                    String authType) throws CertificateException {
                    }

                    public void checkServerTrusted(X509Certificate[] chain,
                                    String authType) throws CertificateException {
                    }

                    public X509Certificate[] getAcceptedIssuers() {
                            return null;
                    }
            };

            sslContext.init(null, new TrustManager[] { tm }, null);
    }

    @Override
    public Socket createSocket(Socket socket, String host, int port,
                    boolean autoClose) throws IOException, UnknownHostException {
            return sslContext.getSocketFactory().createSocket(socket, host, port,
                            autoClose);
    }

    @Override
    public Socket createSocket() throws IOException {
            return sslContext.getSocketFactory().createSocket();
    }

}
",4,0,643d1e22f4ab0274b216e791d6c65854bc240f7a9fe61a2ae174bf864f889730
,"public class WebClientDevWrapper {

    public static HttpClient getNewHttpClient() {
         try {
             KeyStore trustStore = KeyStore.getInstance(KeyStore.getDefaultType());
             trustStore.load(null, null);

             SSLSocketFactory sf = new MySSLSocketFactory(trustStore);
             sf.setHostnameVerifier(
                    SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);

             HttpParams params = new BasicHttpParams();
             HttpProtocolParams.setVersion(params, HttpVersion.HTTP_1_1);
             HttpProtocolParams.setContentCharset(params, HTTP.UTF_8);

             SchemeRegistry registry = new SchemeRegistry();
             registry.register(new Scheme(""http"", PlainSocketFactory.getSocketFactory(), 80));
             registry.register(new Scheme(""https"", sf, 443));

             ClientConnectionManager ccm = new ThreadSafeClientConnManager(params, registry);

             return new DefaultHttpClient(ccm, params);
         } catch (Exception e) {
             return new DefaultHttpClient();
         }
     }

}
",4,0,4078788110e89cc108ea8ded9e1a81dea02823314c15b43d0b476e95a9034b72
,"PackageInfo info;
try {
    info = getPackageManager().getPackageInfo(""com.your.project.package"", PackageManager.GET_SIGNATURES);
    for (Signature signature : info.signatures) {
        MessageDigest md;
        md = MessageDigest.getInstance(""SHA"");
        md.update(signature.toByteArray());
        String something = new String(Base64.encode(md.digest(), 0));
        //String something = new String(Base64.encodeBytes(md.digest()));
        Log.e(""hash key"", something);
    }
} catch (PackageManager.NameNotFoundException e1) {
    Log.e(""name not found"", e1.toString());
} catch (NoSuchAlgorithmException e) {
    Log.e(""no such an algorithm"", e.toString());
} catch (Exception e) {
    Log.e(""exception"", e.toString());
}
",3,0,6dd9516a2825265a3598ea1dd4e5d5351476a65562b4a1d9b45a4a591976d406
,"static void encrypt() throws IOException, NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException {
    // Here you read the cleartext.
    FileInputStream fis = new FileInputStream(""data/cleartext"");
    // This stream write the encrypted text. This stream will be wrapped by another stream.
    FileOutputStream fos = new FileOutputStream(""data/encrypted"");

    // Length is 16 byte
    // Careful when taking user input!!! http://stackoverflow.com/a/3452620/1188357
    SecretKeySpec sks = new SecretKeySpec(""MyDifficultPassw"".getBytes(), ""AES"");
    // Create cipher
    Cipher cipher = Cipher.getInstance(""AES"");
    cipher.init(Cipher.ENCRYPT_MODE, sks);
    // Wrap the output stream
    CipherOutputStream cos = new CipherOutputStream(fos, cipher);
    // Write bytes
    int b;
    byte[] d = new byte[8];
    while((b = fis.read(d)) != -1) {
        cos.write(d, 0, b);
    }
    // Flush and close streams.
    cos.flush();
    cos.close();
    fis.close();
}
",,1,138fd9b1cefa546ca1fbe59434465ad3dcaccf0d87908c16e93123e822341d7a
,"private static char[] hexDigits = ""0123456789abcdef"".toCharArray();

public String md5(InputStream is) throws IOException
{
    byte[] bytes = new byte[4096];
    int read = 0;
    MessageDigest digest = MessageDigest.getInstance(""MD5"");
    while ((read = is.read(bytes)) != -1)
    {
        digest.update(bytes, 0, read);
    }

    byte[] messageDigest = digest.digest();

    StringBuilder sb = new StringBuilder(32);

    // Oh yeah, this too.  Integer.toHexString doesn't zero-pad, so
    // (for example) 5 becomes ""5"" rather than ""05"".
    for (byte b : messageDigest)
    {
        sb.append(hexDigits[(b &gt;&gt; 4) &amp; 0x0f]);
        sb.append(hexDigits[b &amp; 0x0f]);
    }

    return sb.toString();
}
",,1,f7b76a49bdec88f22361d44919ea492d42d1b23bc7cd5217323a7017d826976b
,"private void printHashKey()
{
    try
    {
        PackageInfo info = getPackageManager().getPackageInfo(""com.your.package"",
            PackageManager.GET_SIGNATURES);
        for (Signature signature: info.signatures)
        {
            MessageDigest md = MessageDigest.getInstance(""SHA"");
            md.update(signature.toByteArray());
            Log.d(""YOUR HASH KEY:"",
                Base64.encodeToString(md.digest(), Base64.DEFAULT));
        }
    }
    catch (NameNotFoundException e)
    {

    }
    catch (NoSuchAlgorithmException e)
    {

    }
}
",3,0,76b480d56aca0862a02e5867423b9c4c9725284c1718ad5bf14b8f5f068e2613
,"final MessageDigest digest = MessageDigest.getInstance(""SHA-1"");
result = digest.digest(stringToHash.getBytes(""UTF-8"");

// Another way to make HEX, my previous post was only the method like your solution
StringBuilder sb = new StringBuilder();

for (byte b : result) // This is your byte[] result..
{
    sb.append(String.format(""%02X"", b));
}

String messageDigest = sb.toString();
",3,0,f51b8f06327208c7f6d129b1ac46ccd00e054ae2310abe0c6348c6f1ee67a38d
,"try {
        info = getPackageManager().getPackageInfo(getPackageName(), PackageManager.GET_SIGNATURES);
        for (Signature signature : info.signatures) {
            MessageDigest md;

                md = MessageDigest.getInstance(""SHA"");
                md.update(signature.toByteArray());
                String something = new String(Base64.encode(md.digest(), 0));
                Log.e(""hash key"", something);
        } 
    } catch (NameNotFoundException e1) {            
        Log.e(""name not found"", e1.toString());
    } catch (NoSuchAlgorithmException e) {
             Log.e(""no such an algorithm"", e.toString());
     }catch (Exception e){
             Log.e(""exception"", e.toString());
     }
",3,0,54983a8821437c9731542e86f573d0c54f74bac3e565e9cda4455cdcf0aee857
,"public class SecurityUtils {

public static final String KEY_DERIVATION_ALGORITHM = ""PBKDF2WithHmacSHA1"";

private static final String CIPHER_ALGORITHM = ""AES/CBC/PKCS5Padding"";

private static final String DELIMITER = ""]"";

private static final int KEY_LENGTH = 256;

private static final int ITERATION_COUNT = 1000;

private static final int SALT_LENGTH = 8;

private static SecureRandom random = new SecureRandom();

static {
    Security.addProvider(new org.spongycastle.jce.provider.BouncyCastleProvider());
}


public static String encrypt(Context context, String plaintext)
        throws Exception {
    byte[] salt = generateSalt();
    return encrypt(plaintext, getKey(salt, getPassword(context)), salt);
}

private static String encrypt(String plaintext, SecretKey key, byte[] salt)
        throws Exception {
    try {
        Cipher cipher = Cipher.getInstance(CIPHER_ALGORITHM, ""BC"");

        byte[] iv = generateIv(cipher.getBlockSize());
        IvParameterSpec ivParams = new IvParameterSpec(iv);

        cipher.init(Cipher.ENCRYPT_MODE, key, ivParams);
        byte[] cipherText = cipher.doFinal(plaintext.getBytes(""UTF-8""));

        if (salt != null) {
            return String.format(""%s%s%s%s%s"",
                    new String(Base64.encode(salt)), DELIMITER, new String(
                            Base64.encode(iv)), DELIMITER, new String(
                            Base64.encode(cipherText)));
        }

        return String.format(""%s%s%s"", new String(Base64.encode(iv)),
                DELIMITER, new String(Base64.encode(cipherText)));
    } catch (Throwable e) {
        throw new Exception(""Error while encryption"", e);
    }
}

public static String decrypt(Context context, String ciphertext)
        throws Exception {
    return decrypt(ciphertext, getPassword(context));
}

private static String decrypt(String ciphertext, String password)
        throws Exception {
    String[] fields = ciphertext.split(DELIMITER);
    if (fields.length != 3) {
        throw new IllegalArgumentException(""Invalid encypted text format"");
    }
    try {
        byte[] salt = Base64.decode(fields[0]);
        byte[] iv = Base64.decode(fields[1]);
        byte[] cipherBytes = Base64.decode(fields[2]);

        SecretKey key = getKey(salt, password);
        Cipher cipher = Cipher.getInstance(CIPHER_ALGORITHM, ""BC"");
        IvParameterSpec ivParams = new IvParameterSpec(iv);
        cipher.init(Cipher.DECRYPT_MODE, key, ivParams);
        byte[] plaintext = cipher.doFinal(cipherBytes);
        String plainrStr = new String(plaintext, ""UTF-8"");

        return plainrStr;
    } catch (Throwable e) {
        throw new Exception(""Error while decryption"", e);
    }
}

private static String getPassword(Context context) {

    return ""My secret password"";
}

private static SecretKey getKey(byte[] salt, String password)
        throws Exception {
    try {
        KeySpec keySpec = new PBEKeySpec(password.toCharArray(), salt,
                ITERATION_COUNT, KEY_LENGTH);
        SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(
                KEY_DERIVATION_ALGORITHM, ""BC"");
        byte[] keyBytes = keyFactory.generateSecret(keySpec).getEncoded();
        return new SecretKeySpec(keyBytes, ""AES"");
    } catch (Throwable e) {
        throw new Exception(""Error while generating key"", e);
    }
}

private static byte[] generateIv(int length) {
    byte[] b = new byte[length];
    random.nextBytes(b);

    return b;
}

private static byte[] generateSalt() {
    byte[] b = new byte[SALT_LENGTH];
    random.nextBytes(b);

    return b;
}
",4,0,0cba6563f7939f9434168c3719988f630953b27512ec27348fae648fe027984e
,"  private void getHashKey()
   {
           PackageInfo info;
           try {
           info = getPackageManager().getPackageInfo(""Your_Package_Name"", PackageManager.GET_SIGNATURES);
           for (Signature signature : info.signatures) {MessageDigest md;
           md = MessageDigest.getInstance(""SHA"");
           md.update(signature.toByteArray());
                      //String something = new String(Base64.encode(md.digest(), 0));
                        String something = new String(Base64.encode(md.digest(),0));
                      Log.e(""** Hash Key"", something);
           }
           }
           catch (NameNotFoundException e1) {
           Log.e(""name not found"", e1.toString());
           }

           catch (NoSuchAlgorithmException e) {
           Log.e(""no such an algorithm"", e.toString());
           }
           catch (Exception e){
           Log.e(""exception"", e.toString());
           }

   }
",3,0,b74dc0ebe01bc1c483c965c7a02672198f86497e313ef084468272a527c3312f
,"//use to encrypt key
public static byte[] encryptA(byte[] value) throws GeneralSecurityException, IOException
{
    SecretKeySpec sks = getSecretKeySpec(true);
    System.err.println(""encrypt():\t"" + sks.toString());
    Cipher cipher = Cipher.getInstance(""AES"");
    cipher.init(Cipher.ENCRYPT_MODE, sks, cipher.getParameters());
    byte[] encrypted = cipher.doFinal(value);
    return encrypted;
}

//use to encrypt data
public static byte[] encrypt2(byte[] value) throws GeneralSecurityException, IOException
{
    SecretKeySpec key1 = getSecretKeySpec(true);
    System.err.println(""encrypt():\t"" + key1.toString());
    Cipher cipher = Cipher.getInstance(""AES"");
    cipher.init(Cipher.ENCRYPT_MODE, key1, cipher.getParameters());
    byte[] encrypted = cipher.doFinal(value);

    SecretKeySpec key2 = getSecretKeySpec(false);
    System.err.println(""encrypt():\t"" + key2.toString());
    cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
    cipher.init(Cipher.ENCRYPT_MODE, key2, new IvParameterSpec(getIV()));
    byte[] encrypted2 = cipher.doFinal(encrypted);

    return encrypted2;//Base64Coder.encode(encrypted2);
}
//use to decrypt data
public static byte[] decrypt2(byte[] message, boolean A) throws GeneralSecurityException, IOException
{
    SecretKeySpec key1 = getSecretKeySpec(false);
    System.err.println(""decrypt():\t"" + key1.toString());
    Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
    cipher.init(Cipher.DECRYPT_MODE, key1, new IvParameterSpec(getIV()));
    byte[] decrypted = cipher.doFinal(message);

    SecretKeySpec key2 = getSecretKeySpec(true);
    System.err.println(""decrypt():\t"" + key2.toString());
    cipher = Cipher.getInstance(""AES"");
    cipher.init(Cipher.DECRYPT_MODE, key2);
    byte[] decrypted2 = cipher.doFinal(decrypted);

    return decrypted2;
}

    //use to decrypt key
public static byte[] decryptKey(String message, byte[] key) throws GeneralSecurityException
{
    SecretKeySpec sks = new SecretKeySpec(key, ALGORITHM);
    System.err.println(""decryptKey()"");
    Cipher cipher = Cipher.getInstance(""AES"");
    cipher.init(Cipher.DECRYPT_MODE, sks);
    byte[] decrypted = cipher.doFinal(Base64Coder.decode(message));
    return decrypted;
}

//method for fetching keys
private static SecretKeySpec getSecretKeySpec(boolean fromSO) throws NoSuchAlgorithmException, IOException, GeneralSecurityException
{
    return new SecretKeySpec(fromSO ? getKeyBytesFromSO() : getKeyBytesFromAssets(), ""AES"");
}
",1,0,c23f0735a1ea14f8ce27b571891d82466608c8d2d6b873632bfa2f5a7425b3a4
,"KeyStore ks = KeyStore.getInstance(""AndroidCAStore"");
ks.load(null, null);
Enumeration aliases = ks.aliases();
while (aliases.hasMoreElements()) {
    String alias = aliases.nextElement();
    X509Certificate cert = (X509Certificate) 
       ks.getCertificate(alias);
    Log.d(TAG, ""Subject DN: "" + 
       cert.getSubjectDN().getName());
    Log.d(TAG, ""Subject SN: "" + 
       cert.getSerialNumber().toString());
    Log.d(TAG, ""Issuer DN: "" + 
       cert.getIssuerDN().getName());
}
",,1,ce4f77877ae4dfacfdce8a04b3c8e4457bdb25631b41cd401a76d0e759837c39
,"public class MultipartUtility {

    FileUploadListener listener;
    private static final int BUFFER_SIZE = 1024;
    private static final int TIME_OUT = 3 * 60 * 1000;
    private final String boundary;
    private static final String LINE_FEED = ""\r\n"";
    private HttpURLConnection httpConn;
    private String charset;
    private OutputStream outputStream;
    private PrintWriter writer;
    public int statusCode;
    public String mURL;

    public interface FileUploadListener {
        void onUpdateProgress(int percentage, long kb);

        boolean isCanceled();
    }

    /**
     * This constructor initializes a new HTTP POST request with content type
     * is set to multipart/form-data
     *
     * @param requestURL
     * @param charset
     * @throws IOException
     */
    public MultipartUtility(String requestURL, String charset, FileUploadListener listener)
            throws IOException {
        this.charset = charset;
        this.listener = listener;
        mURL = requestURL;
        // creates a unique boundary based on time stamp
        boundary = """" + System.currentTimeMillis() + """";

        URL url = new URL(requestURL);
        httpConn = null;
        if (url.getProtocol().toLowerCase().equals(""https"")) {
            trustAllHosts();
            HttpsURLConnection https = (HttpsURLConnection) url.openConnection();
            https.setHostnameVerifier(new HostnameVerifier() {
                @Override
                public boolean verify(String hostname, SSLSession session) {
                    return true;
                }
            });
            httpConn = https;
        } else {
            httpConn = (HttpURLConnection) url.openConnection();
        }

        // httpConn.setConnectTimeout(TIME_OUT);
        //httpConn.setReadTimeout(TIME_OUT);
        httpConn.setUseCaches(false);
        httpConn.setDoOutput(true); // indicates POST method
        httpConn.setDoInput(true);
        httpConn.setChunkedStreamingMode(BUFFER_SIZE);
        httpConn.setRequestMethod(""POST"");
        httpConn.setRequestProperty(""Content-Type"",
                ""multipart/form-data; boundary="" + boundary);
        httpConn.setRequestProperty(""Connection"", ""Keep-Alive"");
        outputStream = httpConn.getOutputStream();
        writer = new PrintWriter(new OutputStreamWriter(outputStream, charset),
                true);
    }

    private static void trustAllHosts() {
        // Create a trust manager that does not validate certificate chains
        TrustManager[] trustAllCerts = new TrustManager[]{new X509TrustManager() {
            public java.security.cert.X509Certificate[] getAcceptedIssuers() {
                return new java.security.cert.X509Certificate[]{};
            }

            public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {
            }

            public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {
            }
        }};

        // Install the all-trusting trust manager
        try {
            SSLContext sc = SSLContext.getInstance(""TLS"");
            sc.init(null, trustAllCerts, new java.security.SecureRandom());
            HttpsURLConnection.setDefaultSSLSocketFactory(sc.getSocketFactory());
        } catch (Exception e) {
            e.printStackTrace();
        }
    }


    /**
     * Adds a form field to the request
     *
     * @param name  field name
     * @param value field value
     */
    public void addFormField(String name, String value) {
        writer.append(""--"" + boundary).append(LINE_FEED);
        writer.append(""Content-Disposition: form-data; name=\"""" + name + ""\"""")
                .append(LINE_FEED);
        writer.append(""Content-Type: text/plain; charset="" + charset).append(
                LINE_FEED);
        writer.append(LINE_FEED);
        writer.append(value).append(LINE_FEED);
        writer.flush();
    }

    /**
     * Adds a upload file section to the request
     *
     * @param fieldName name attribute in &lt;input type=""file"" name=""..."" /&gt;
     * @param uploadFile a File to be uploaded
     * @throws IOException
     */
    private long lastProgressUpdateTime = 0;

    public void addFilePart(String fieldName, File uploadFile)
            throws IOException {
        String fileName = uploadFile.getName();
        writer.append(""--"" + boundary).append(LINE_FEED);
        writer.append(
                ""Content-Disposition: form-data; name=\"""" + fieldName
                        + ""\""; filename=\"""" + fileName + ""\"""")
                .append(LINE_FEED);
        writer.append(
                ""Content-Type: ""
                        + URLConnection.guessContentTypeFromName(fileName))
                .append(LINE_FEED);
        writer.append(""charset="" + charset).append(
                LINE_FEED);
        writer.append(LINE_FEED);
        writer.flush();

        outputStream.flush();
        byte[] buffer = new byte[BUFFER_SIZE];

        try {
            final FileInputStream inputStream = new FileInputStream(uploadFile);
            long totalRead = 0;
            long totalSize = uploadFile.length();

            int read;
            while ((read = inputStream.read(buffer)) &gt; 0) {
                totalRead += read;
                int percentage = (int) ((totalRead / (float) totalSize) * 100);
                outputStream.write(buffer, 0, read);

                long now = System.currentTimeMillis();
                if (lastProgressUpdateTime == 0 || lastProgressUpdateTime &lt; now - 100) {
                    lastProgressUpdateTime = now;

                    Log.e("""", totalRead + "" "" + "" "" + percentage);

                    if (listener != null)
                        this.listener.onUpdateProgress(percentage, totalRead);
                }
            }
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            outputStream.flush();
        }

        writer.append(LINE_FEED);
        writer.flush();
    }


    /**
     * Adds a header field to the request.
     *
     * @param name  - name of the header field
     * @param value - value of the header field
     */
    public void addHeaderField(String name, String value) {
        writer.append(name + "": "" + value).append(LINE_FEED);
        writer.flush();
    }

    /**
     * Completes the request and receives response from the server.
     *
     * @return a list of Strings as response in case the server returned
     * status OK, otherwise an exception is thrown.
     * @throws IOException
     */
    public String Execute() throws IOException {
        String responses = """";

        writer.append(LINE_FEED).flush();
        writer.append(""--"" + boundary + ""--"").append(LINE_FEED);
        writer.close();
        StringBuilder sb = new StringBuilder();
        try {
            // checks server's status code first
            statusCode = httpConn.getResponseCode();
            if (Constants.IS_DEBUG) {
                Log.v(Constants.TAG, ""Url: "" + mURL);
                Log.e("""", ""response code :"" + statusCode);
            }
            //responses = ;

            sb.append("""" + Utility.convertStreamToString(httpConn.getInputStream()) + ""\n"");

            if (statusCode == HttpURLConnection.HTTP_OK) {
                httpConn.disconnect();
            }
            responses = sb.toString();
            Log.v(Constants.TAG, "" response: "" + responses);
            return responses;
        } catch (Exception e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
            sb = new StringBuilder();

            sb.append("""" + Utility.convertStreamToString(httpConn.getErrorStream()) + ""\n"");

            responses = sb.toString();
            Log.v(Constants.TAG, ""Error response: "" + responses);
        }
        return responses;
    }
}
",4,0,c8adba88ac4501686a81e0268c3bf44ded658aef0221e70a3ed20adbbbf15d90
,"    // Create a trust manager that does not validate certificate chains
    TrustManager[] trustAllCerts = new TrustManager[]{
        new X509TrustManager() {
            public java.security.cert.X509Certificate[] getAcceptedIssuers() {
                return null;
            }
            public void checkClientTrusted(
                java.security.cert.X509Certificate[] certs, String authType) {
            }
            public void checkServerTrusted(
                java.security.cert.X509Certificate[] certs, String authType) {
            }
        }
    };

    // Install the all-trusting trust manager
    // Try ""SSL"" or Replace with ""TLS""
    try {
        SSLContext sc = SSLContext.getInstance(""SSL"");
        sc.init(null, trustAllCerts, new java.security.SecureRandom());
        HttpsURLConnection.setDefaultSSLSocketFactory(sc.getSocketFactory());
    } catch (Exception e) {
    }

    // Now you can access an https URL without having the certificate in the truststore 
           // Your Code Goes Here
",4,0,2343646c9360b91cd30de4ef60ed9673229c71bb597f7cf55eb0800116b72bb7
,"public void generateHashKeyForFacebook(Context context) throws Exception {
        try {   
            PackageInfo info = context.getPackageManager().getPackageInfo(""com.yourPackageName"", PackageManager.GET_SIGNATURES);
            for (Signature signature : info.signatures) {
                MessageDigest md = MessageDigest.getInstance(""SHA"");
                md.update(signature.toByteArray());
                Log.d(""FBKeyHash &gt;&gt;&gt; "", Base64.encodeToString(md.digest(), Base64.DEFAULT));
            }
        } catch (PackageManager.NameNotFoundException e) {
            e.printStackTrace();
        } catch (NoSuchAlgorithmException e) {
            e.printStackTrace();
        }
    }
",3,0,6e660c811299f8cd3a14ebdd57acc4137ef3a92f0392e0b63a6e944aed1abef3
,"public class MySSLSocketFactory extends SSLSocketFactory {
        SSLContext sslContext = SSLContext.getInstance(""TLS"");

        ...

        @Override
        public Socket createSocket(Socket socket, String host, int port, boolean autoClose) throws IOException, UnknownHostException {
            final SSLSocket sslSocket = (SSLSocket) sslContext.getSocketFactory().createSocket(socket, host, port, autoClose);
            sslSocket.setEnabledCipherSuites(sslSocket.getSupportedCipherSuites());
            return sslSocket;
        }

        @Override
        public Socket createSocket() throws IOException {
            final SSLSocket sslSocket = (SSLSocket) sslContext.getSocketFactory().createSocket();
            sslSocket.setEnabledCipherSuites(sslSocket.getSupportedCipherSuites());
            return sslSocket;
        }
}
",3,0,e51e4d7a72c196f6e15e78609f29598c5f32b76dcbb9d475b9833f0f7f101bfa
,"    public class SimpleSSLSocketFactory extends
    org.apache.http.conn.ssl.SSLSocketFactory {
private javax.net.ssl.SSLSocketFactory sslFactory = HttpsURLConnection
        .getDefaultSSLSocketFactory();

public SimpleSSLSocketFactory(KeyStore truststore)
        throws NoSuchAlgorithmException, KeyManagementException,
        KeyStoreException, UnrecoverableKeyException {
    super(null);
    try {
        SSLContext context = SSLContext.getInstance(""TLS"");
        TrustManager[] trustAllCerts = new TrustManager[] { new  

                 X509TrustManager() {
            public java.security.cert.X509Certificate[] getAcceptedIssuers() {
                return new java.security.cert.X509Certificate[] {};
            }
            public void checkClientTrusted(X509Certificate[] chain,
                    String authType) throws CertificateException {
            }

            public void checkServerTrusted(X509Certificate[] chain,
                    String authType) throws CertificateException {
            }
        } };

        // Initialize the socket factory
        context.init(null, trustAllCerts, new SecureRandom());
        sslFactory = context.getSocketFactory();
    } catch (Exception e) {
        e.printStackTrace();
    }
}

@Override
public Socket createSocket(Socket socket, String host, int port,
        boolean autoClose) throws IOException, UnknownHostException {
    return sslFactory.createSocket(socket, host, port, autoClose);
}

@Override
public Socket createSocket() throws IOException {
    return sslFactory.createSocket();
}
",4,0,39724a83322d2eeea665de1fd54df9924936190fba25fa0f5b77bb0989126244
,"public class DataLoader {
DefaultHttpClient sslClient;
private boolean silent;

public class CustomX509TrustManager implements X509TrustManager {

    @Override
    public void checkClientTrusted(X509Certificate[] chain, String authType)
            throws CertificateException {
    }

    @Override
    public void checkServerTrusted(
            java.security.cert.X509Certificate[] certs, String authType)
            throws CertificateException {
    }

    public X509Certificate[] getAcceptedIssuers() {
        return null;
    }
}

public class CustomSSLSocketFactory extends SSLSocketFactory {
    SSLContext sslContext = SSLContext.getInstance(""TLS"");

    public CustomSSLSocketFactory(KeyStore truststore)
            throws NoSuchAlgorithmException, KeyManagementException,
            KeyStoreException, UnrecoverableKeyException {
        super(truststore);
        TrustManager tm = new CustomX509TrustManager();
        sslContext.init(null, new TrustManager[] { tm }, null);
    }

    public CustomSSLSocketFactory(SSLContext context)
            throws KeyManagementException, NoSuchAlgorithmException,
            KeyStoreException, UnrecoverableKeyException {
        super(null);
        sslContext = context;
    }

    @Override
    public Socket createSocket(Socket socket, String host, int port,
            boolean autoClose) throws IOException, UnknownHostException {
        return sslContext.getSocketFactory().createSocket(socket, host,
                port, autoClose);
    }

    @Override
    public Socket createSocket() throws IOException {
        return sslContext.getSocketFactory().createSocket();
    }
}

public HttpResponse execute(HttpUriRequest request) {
    if (!(silent)) {
        Log.i(""Performing request"", ""Performing request"");
        for (Header header : request.getAllHeaders())
            Log.i(""Performing request"",
                    ""Performing request ""
                            + new StringBuilder()
                                    .append(""Request header: "")
                                    .append(header.getName()).append("" - "")
                                    .append(header.getValue()).toString());
    }
    HttpResponse response = null;
    try {
        SSLContext ctx = SSLContext.getInstance(""TLS"");
        ctx.init(null, new TrustManager[] { new CustomX509TrustManager() },
                new SecureRandom());
        HttpClient client = new DefaultHttpClient();
        SSLSocketFactory ssf = new CustomSSLSocketFactory(ctx);
        ssf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
        ClientConnectionManager ccm = client.getConnectionManager();
        SchemeRegistry sr = ccm.getSchemeRegistry();
        sr.register(new Scheme(""https"", ssf, 443));
        sslClient = new DefaultHttpClient(ccm, client.getParams());
        response = sslClient.execute(request);
    } catch (IOException e) {
        e.printStackTrace();
    } catch (Exception e) {
        e.printStackTrace();
    }
    return response;
}
",4,0,9d13e86c6085d4ee400c23598ff06eb52b12b985454ba93189e20d2e28f364f3
,"private PackageInfo INFO = null; //global declaration
    public void generateHashKeyForFacebook(Context context) throws Exception {
            try {
                INFO = context.getPackageManager().getPackageInfo(""com.bito1.Shoplu"", PackageManager.GET_SIGNATURES);
                if (INFO == null) {
                    Toast.makeText(context.getApplicationContext(), ""Invalid Package Name / Package not found"", Toast.LENGTH_LONG).show();
                    return;
                }
                for (Signature signature : INFO.signatures) {
                    MessageDigest _md = MessageDigest.getInstance(""SHA"");
                    _md.update(signature.toByteArray());
                    Log.d(""KeyHash: =&gt;"", Base64.encodeToString(_md.digest(), Base64.DEFAULT));
                }
            } catch (PackageManager.NameNotFoundException e) {
                e.printStackTrace();
            } catch (NoSuchAlgorithmException e) {
                e.printStackTrace();
            }
        }
",3,0,3986e1b9e8e6e444ce930d4892c1668ddabf5ac6ba69b101acdfb7543b3c904d
,"/**
 * Parses an Android public RSA key like stored under .android/adbkey.pub and returns a Java public RSA key.
 * @param inputKey The Android public key.
 * @return the public RSA key.
 * @throws Exception
 */
public static PublicKey parseAndroidPubKey(String inputKey) {
    BufferedReader bufferedReader = new BufferedReader(new StringReader(inputKey));
    String line = null;
    try {
        line = bufferedReader.readLine();
    } catch (IOException e) {
        throw new RuntimeException(e);
    }
    line = line.replaceAll("" .*@.*"", """");
    byte[] raw = Base64.getDecoder().decode(line);
    ByteBuffer bb = ByteBuffer.wrap(raw);
    bb.order(ByteOrder.LITTLE_ENDIAN);
    IntBuffer intBuffer = bb.asIntBuffer();
    int len = intBuffer.get();
    BigInteger n0Inv = BigInteger.valueOf(intBuffer.get());
    ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(len*4);
    int[] dst = new int[len];
    intBuffer.get(dst);
    ArrayUtils.reverse(dst);
    for (int i = 0; i &lt; len; i++) {
        int value = dst[i];
        byte[] convertedBytes = ByteBuffer.allocate(4).order(ByteOrder.BIG_ENDIAN).putInt(value).array();
        byteArrayOutputStream.write(convertedBytes, 0, convertedBytes.length);
    }
    byte[] n = byteArrayOutputStream.toByteArray();
    byteArrayOutputStream.reset();
    dst = new int[len];
    intBuffer.get(dst);
    ArrayUtils.reverse(dst);
    for (int i = 0; i &lt; len; i++) {
        int value = dst[i];
        byte[] convertedBytes = ByteBuffer.allocate(4).order(ByteOrder.BIG_ENDIAN).putInt(value).array();
        byteArrayOutputStream.write(convertedBytes, 0, convertedBytes.length);
    }
    int e = intBuffer.get();

    RSAPublicKey publicKey;
    try {
        publicKey = (RSAPublicKey) KeyFactory.getInstance(""RSA"").generatePublic(new RSAPublicKeySpec(new BigInteger(1, n), BigInteger.valueOf(e)));
    } catch (Exception ex) {
        throw new RuntimeException(ex);
    }
    return publicKey;
}
",,1,7db5769f45a564137b08a8cee2ecd5025ff63a2f2ee38c794036edea00678518
,"public HttpClient getNewHttpClient() throws SocketException, UnknownHostException {
    try {
        KeyStore trustStore = KeyStore.getInstance(KeyStore.getDefaultType());
        trustStore.load(null, null);

        SSLSocketFactory sf = new MySSLSocketFactory(trustStore);
        sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);

        HttpParams params = new BasicHttpParams();
        HttpProtocolParams.setVersion(params, HttpVersion.HTTP_1_1);
        HttpProtocolParams.setContentCharset(params, HTTP.UTF_8);

        SchemeRegistry registry = new SchemeRegistry();
        registry.register(new Scheme(""http"", PlainSocketFactory.getSocketFactory(), 80));
        registry.register(new Scheme(""https"", sf, 443));

        ClientConnectionManager ccm = new ThreadSafeClientConnManager(params, registry);
        return new DefaultHttpClient(ccm, params);
    } catch (Exception e) {
        return new DefaultHttpClient();
    }
}
",4,0,f19749beb748136c22c0725f912575aceb3de2a3ae4314f642622ecbab76fd6a
,"public static String decrypt(String seed, String encrypted) throws Exception {
  byte[] keyb = seed.getBytes(""UTF-8"");
  MessageDigest md = MessageDigest.getInstance(""MD5"");
  byte[] thedigest = md.digest(keyb);
  SecretKeySpec skey = new SecretKeySpec(thedigest, ""AES/ECB/PKCS7Padding"");
  Cipher dcipher = Cipher.getInstance(""AES/ECB/PKCS7Padding"");
  dcipher.init(Cipher.DECRYPT_MODE, skey);

  byte[] clearbyte = dcipher.doFinal(toByte(encrypted));
  return new String(clearbyte);
}

public static byte[] toByte(String hexString) {
  int len = hexString.length()/2;
  byte[] result = new byte[len];
  for (int i = 0; i &lt; len; i++)
    result[i] = Integer.valueOf(hexString.substring(2*i, 2*i+2), 16).byteValue();
  return result;
}
",4,0,db0a16c177d830516859485d9bf6854d7ccac545981759a50dd2b3d74a402f30
,"// aesKey is 128, 196 or 256-bit key (8, 12 or 16 byte array)
SecretKeySpec key = new SecretKeySpec(aesKey, ""AES"");

// initialization vector
IvParameterSpec ivSpec = new IvParameterSpec(iv);

// create and initialize cipher object
Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5PADDING"");
cipher.init(Cipher.DECRYPT_MODE, key, ivSpec);
",1,0,99d98789b3e3feaafc111efa6b33a6cc36fa79868c2ebc09cd1ae622b14e8dd0
,"// Algorithm, mode and padding must match encryption.
// Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5PADDING"");

// If you have Bouncycastle library installed, you can use
// Rijndael/CBC/PKCS7PADDING directly.
Cipher cipher = Cipher.getInstance(""Rijndael/CBC/PKCS7PADDING"");

// convertedSecureString and initVector must be byte[] with correct length
cipher.init(Cipher.DECRYPT_MODE, new SecretKeySpec(convertedSecureString, ""AES""),
    new IvParameterSpec(initVector));

CipherInputStream cryptoStream = new CipherInputStream(inputStream, cipher);
byte[] buffer = new byte[1024];
int len = cryptoStream.read(buffer, 0, buffer.length);
while (len &gt; 0) {
    outputStream.write(buffer, 0, len);
    len = cryptoStream.read(buffer, 0, buffer.length);
}

outputStream.flush();
cryptoStream.close();
// no need to close inputStream here, as cryptoStream will close it
",1,0,af43ec75a802e5fd68da5a38add3a772bbdd57b26296c65af9d19813921821d8
,"public static String getMd5Hash(String input) {
    try {
        MessageDigest md = MessageDigest.getInstance(""MD5"");
        byte[] messageDigest = md.digest(input.getBytes());
        BigInteger number = new BigInteger(1, messageDigest);
        String md5 = number.toString(16);
        while (md5.length() &lt; 32)
           md5 = ""0"" + md5;
        return md5;
        } catch (NoSuchAlgorithmException e) {
         Log.e(""MD5"", e.getLocalizedMessage());
      return null;
    }
    }
",,1,a0777e60f02ca03b3638a6dcbe10edaaa8d24d9d9e97a6b37c0999e5bfda0638
,"private static byte[] key = ""12345678"".getBytes();// 64 bit 
private static byte[] iv = ""12345678"".getBytes();

public static String encrypt(String in) {
    String cypert = in;
    try {
        IvParameterSpec ivSpec = new IvParameterSpec(iv);
        SecretKeySpec k = new SecretKeySpec(key, ""DES"");
        Cipher c = Cipher.getInstance(""DES/CBC/PKCS7Padding"");
        c.init(Cipher.ENCRYPT_MODE, k, ivSpec);
        byte[] encryptedData = c.doFinal(in.getBytes());
        cypert = Base64.encodeLines(encryptedData);
    } catch (Exception e) {
        Debugger.error(e);
    }
    return cypert;
}


public static String decrypt(String in) throws Exception {
    String plain=in;
    try {
        IvParameterSpec ivSpec = new IvParameterSpec(iv);
        SecretKeySpec keys = new SecretKeySpec(key, ""DES"");
        Cipher cipher = Cipher.getInstance(""DES/CBC/PKCS7Padding"");
        cipher.init(Cipher.DECRYPT_MODE, keys, ivSpec);
        // decryption pass
        byte[] cipherText = Base64.decodeLines(in);
        int ctLength = cipherText.length;
        byte[] plainText = new byte[cipher.getOutputSize(ctLength)];
        ByteArrayOutputStream bos = new ByteArrayOutputStream();
        bos.write(cipher.doFinal(cipherText));
        plainText = bos.toByteArray();
        bos.close();
        plain = new String(plainText, ""UTF8"");
    } catch (Exception e) {
        Debugger.error(e);
    }
    return plain;
}
",4,0,d319c1b05cc936e992c28204d0d2b48342fb05aad2c1253a07aa07bb7459c4fb
,"public void generateKeys(){
        try {
     SharedPreferences SP;
     SharedPreferences.Editor SPE;
     KeyPairGenerator generator;
                generator = KeyPairGenerator.getInstance(""RSA"", ""BC"");
                generator.initialize(256, new SecureRandom());
                KeyPair pair = generator.generateKeyPair();
                pubKey = pair.getPublic();
                privKey = pair.getPrivate();            
                byte[] publicKeyBytes = pubKey.getEncoded();
                String pubKeyStr = new String(Base64.encode(publicKeyBytes));
                byte[] privKeyBytes = privKey.getEncoded();
                String privKeyStr = new String(Base64.encode(privKeyBytes));            
                SPE = SP.edit();
                SPE.putString(""PublicKey"", pubKeyStr);
                SPE.putString(""PrivateKey"", privKeyStr);           
                SPE.commit();

  } catch (NoSuchAlgorithmException e) {
            e.printStackTrace();
        } catch (NoSuchProviderException e) {
            e.printStackTrace();
        }           
    }

public PublicKey getPublicKey(){
        String pubKeyStr = SP.getString(""PublicKey"", """");       
        byte[] sigBytes = Base64.decode(pubKeyStr);
        X509EncodedKeySpec x509KeySpec = new X509EncodedKeySpec(sigBytes);
        KeyFactory keyFact = null;
        try {
            keyFact = KeyFactory.getInstance(""RSA"", ""BC"");
        } catch (NoSuchAlgorithmException e) {
            e.printStackTrace();
        } catch (NoSuchProviderException e) {
            e.printStackTrace();
        }
        try {
            return  keyFact.generatePublic(x509KeySpec);
        } catch (InvalidKeySpecException e) {
            e.printStackTrace();
        }
        return null;
    }
    public String getPublicKeyAsString(){
        return SP.getString(""PublicKey"", """");       
    }
    public PrivateKey getPrivateKey(){
        String privKeyStr = SP.getString(""PrivateKey"", """");
        byte[] sigBytes = Base64.decode(privKeyStr);
        X509EncodedKeySpec x509KeySpec = new X509EncodedKeySpec(sigBytes);
        KeyFactory keyFact = null;
        try {
            keyFact = KeyFactory.getInstance(""RSA"", ""BC"");
        } catch (NoSuchAlgorithmException e) {
            e.printStackTrace();
        } catch (NoSuchProviderException e) {
            e.printStackTrace();
        }
        try {
            return  keyFact.generatePrivate(x509KeySpec);
        } catch (InvalidKeySpecException e) {
            e.printStackTrace();
        }
        return null;
    }
    public String getPrivateKeyAsString(){
        return SP.getString(""PrivateKey"", """");      
    }
",4,0,84865a7e9473fec1271e2c8f3645b4a56b22a8a435a88ad787e1ee49ccdb2b3f
,"Security.addProvider(new BouncyCastleProvider());
    SSLContext sslContext = SSLContext.getInstance(""TLS"");
    TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());
    trustManagerFactory.init((KeyStore)null); //this is where you would add the truststore
    KeyManagerFactory keyManagerFactory = KeyManagerFactory.getInstance(""SunX509"");
    KeyStore keyStore = KeyStore.getInstance(""PKCS12""); //spongyCastle library
    keyStore.load(new FileInputStream(""D:\\Documents\\VISA Direct Api\\cabcentralcert.p12""), ""cabcentral"".toCharArray()); //inputStream to PKCS12
    keyManagerFactory.init(keyStore, ""cabcentral"".toCharArray());
    //TrustManager[] trustManagers = trustManagerFactory.getTrustManagers();
    TrustManager[] trustAllCertManagers = { new X509TrustManager() { // this is vulnerable to MITM attack
        @Override
        public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {
        }

        @Override
        public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {
        }

        @Override
        public X509Certificate[] getAcceptedIssuers() {
            return new X509Certificate[0];
        }
    }};

    sslContext.init(keyManagerFactory.getKeyManagers(), trustAllCertManagers, new SecureRandom());
    URL url = new URL(strUrl);
    HttpsURLConnection httpsUrlConnection = (HttpsURLConnection) url.openConnection();
    httpsUrlConnection.setSSLSocketFactory(sslContext.getSocketFactory());

    System.out.println(""Response Code : "" + httpsUrlConnection.getResponseCode());
    System.out.println(""Cipher Suite : "" + httpsUrlConnection.getCipherSuite());
",4,0,077d7b0e55090bf27a4c33a6745afb4e8b7eb140b02ac2ee4f4e0f6d7b3b99c4
,"        HttpsURLConnection.setDefaultHostnameVerifier(new HostnameVerifier(){
            public boolean verify(String hostname, SSLSession session) {
                return true;
            }});
    SSLContext context = SSLContext.getInstance(""TLS"");
    context.init(null, new X509TrustManager[]{new X509TrustManager(){
        public void checkClientTrusted(X509Certificate[] chain,
                String authType) throws CertificateException {}
        public void checkServerTrusted(X509Certificate[] chain,
                String authType) throws CertificateException {}
        public X509Certificate[] getAcceptedIssuers() {
            return new X509Certificate[0];
        }}}, new SecureRandom());
    HttpsURLConnection.setDefaultSSLSocketFactory(
            context.getSocketFactory());
",4,0,edd7d6d83d63cd7dd4b8d10e0da25510d83edbc8cbadd4107c6412c3c483dd53
,"/**
 * @param input
 * @return decoded string
 */
public static String decode(String input) {
    // Receiving side
    String text = """";
    try {
        byte[] data = Decoder.decode(input);
        text = new String(data, ""UTF-8"");
        return text;
    } catch (UnsupportedEncodingException e) {
        e.printStackTrace();
    }
    return ""Error"";
}
",,1,2fd473875837aa48f3ffa5ffe0d36fd83519720df6dc627417b72330e31a0616
,"try {
   PackageInfo info = getPackageManager().getPackageInfo(""com.yourcompany.client"", PackageManager.GET_SIGNATURES);
   for (Signature signature : info.signatures) {
        MessageDigest md = MessageDigest.getInstance(""SHA"");
        md.update(signature.toByteArray());
        Log.d(""Hash Key:"", Base64.encode(md.digest()));
   }
} catch (NameNotFoundException e) {

} catch (NoSuchAlgorithmException e) {

}
",3,0,d9bbebcaa1b31cc176ccc2ef4bd2d73b0befdf4e7e565dfea07d22d063a0e8ff
,"public String md5(String toConvert) {

    String retVal = """";

    MessageDigest algorithm;
    try {
        algorithm = MessageDigest.getInstance(""MD5"");
        algorithm.reset();
        algorithm.update(toConvert.getBytes());
        byte messageDigest[] = algorithm.digest();
        StringBuffer hexString = new StringBuffer();
        for (int i = 0; i &lt; messageDigest.length; i++) {
            hexString.append(Integer.toHexString(0xFF &amp; messageDigest[i]));
        }
        retVal = hexString + """";
    } catch (NoSuchAlgorithmException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    }
    return retVal;
}
",,1,6a42bff12c5c117a6ddcbb463b2fca955a27863a1846073157018c76a4eef0fa
,"/**
 * The server has a SSL certificate. This method add SSL certificate to HTTP
 * Request
 */
public static void addSLLCertificateToHttpRequest() {
    // Code to use verifier which return true.
    try {
        SSLContext sslctx = null;
        try {
            sslctx = SSLContext.getInstance(""TLS"");
            sslctx.init(null, new TrustManager[] { new X509TrustManager() {
                public void checkClientTrusted(X509Certificate[] chain, String authType)
                {
                }

                public void checkServerTrusted(X509Certificate[] chain, String authType)
                {
                }

                public X509Certificate[] getAcceptedIssuers() {
                    return new X509Certificate[] {};
                }
            } }, null);
        } catch (NoSuchAlgorithmException e) {
            e.printStackTrace();
        } catch (Exception e) {
            e.printStackTrace();
        }
        HttpsURLConnection.setDefaultSSLSocketFactory(sslctx.getSocketFactory());
        HttpsURLConnection.setDefaultHostnameVerifier(new HostnameVerifier() {
            public boolean verify(String hostname, SSLSession session) {
                return true;
            }
        });
    } catch (Exception e) {
        e.printStackTrace();
    }

}
",4,0,56674580ee3d574fff829e9d2f17419d0df09f4f15e73dd2fc5c21f9036ac231
,"import java.io.UnsupportedEncodingException;
import java.security.InvalidAlgorithmParameterException;
import java.security.InvalidKeyException;
import java.security.NoSuchAlgorithmException;
import java.security.spec.AlgorithmParameterSpec;
import java.security.spec.InvalidKeySpecException;
import java.security.spec.KeySpec;
import javax.crypto.BadPaddingException;
import javax.crypto.Cipher;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.NoSuchPaddingException;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.PBEKeySpec;
import javax.crypto.spec.PBEParameterSpec;

public class StringEncrypter {

Cipher ecipher;
Cipher dcipher;

StringEncrypter(String password) {

    // 8-bytes Salt
    byte[] salt = {
        (byte)0xA9, (byte)0x9B, (byte)0xC8, (byte)0x32,
        (byte)0x56, (byte)0x34, (byte)0xE3, (byte)0x03
    };

    // Iteration count
    int iterationCount = 19;

    try {

        KeySpec keySpec = new PBEKeySpec(password.toCharArray(), salt, iterationCount);
        SecretKey key = SecretKeyFactory.getInstance(""PBEWithMD5AndDES"").generateSecret(keySpec);

        ecipher = Cipher.getInstance(key.getAlgorithm());
        dcipher = Cipher.getInstance(key.getAlgorithm());

        // Prepare the parameters to the cipthers
        AlgorithmParameterSpec paramSpec = new PBEParameterSpec(salt, iterationCount);

        ecipher.init(Cipher.ENCRYPT_MODE, key, paramSpec);
        dcipher.init(Cipher.DECRYPT_MODE, key, paramSpec);

    } catch (InvalidAlgorithmParameterException e) {
        System.out.println(""EXCEPTION: InvalidAlgorithmParameterException"");
    } catch (InvalidKeySpecException e) {
        System.out.println(""EXCEPTION: InvalidKeySpecException"");
    } catch (NoSuchPaddingException e) {
        System.out.println(""EXCEPTION: NoSuchPaddingException"");
    } catch (NoSuchAlgorithmException e) {
        System.out.println(""EXCEPTION: NoSuchAlgorithmException"");
    } catch (InvalidKeyException e) {
        System.out.println(""EXCEPTION: InvalidKeyException"");
    }
}


/**
 * Takes a single String as an argument and returns an Encrypted version
 * of that String.
 * @param str String to be encrypted
 * @return &lt;code&gt;String&lt;/code&gt; Encrypted version of the provided String
 */
public byte[] encrypt(String str) {
    try {
        // Encode the string into bytes using utf-8
        byte[] utf8 = str.getBytes(""UTF8"");

        // Encrypt
        byte[] enc = ecipher.doFinal(utf8);

        // Encode bytes to base64 to get a string
        //return new sun.misc.BASE64Encoder().encode(enc);
        return enc;

    } catch (BadPaddingException e) {
    } catch (IllegalBlockSizeException e) {
    } catch (UnsupportedEncodingException e) {
    }
    return null;
}


/**
 * Takes a encrypted String as an argument, decrypts and returns the
 * decrypted String.
 * @param str Encrypted String to be decrypted
 * @return &lt;code&gt;String&lt;/code&gt; Decrypted version of the provided String
 */
public String decrypt(byte[] dec) {

    try {

        // Decode base64 to get bytes
        //byte[] dec = new sun.misc.BASE64Decoder().decodeBuffer(str);
        //byte[] dec = Base64Coder.decode(str);

        // Decrypt
        byte[] utf8 = dcipher.doFinal(dec);

        // Decode using utf-8
        return new String(utf8, ""UTF8"");

    } catch (BadPaddingException e) {
    } catch (IllegalBlockSizeException e) {
    } catch (UnsupportedEncodingException e) {
    }
    return null;
}
",4,0,b20ffbe734d5b299b5050b922df1526cdf8d5892564a4aeae32e78c44ad375c6
,"PackageInfo info;
try {

    info = getPackageManager().getPackageInfo(
        ""com.example.worldmission"", PackageManager.GET_SIGNATURES);

    for (Signature signature : info.signatures) {
        MessageDigest md;
        md = MessageDigest.getInstance(""SHA"");
        md.update(signature.toByteArray());
        String something = new String(Base64.encode(md.digest(), 0));
        Log.e(""Hash key"", something);
        System.out.println(""Hash key"" + something);
    }

} catch (NameNotFoundException e1) {
    Log.e(""name not found"", e1.toString());
} catch (NoSuchAlgorithmException e) {
    Log.e(""no such an algorithm"", e.toString());
} catch (Exception e) {
    Log.e(""exception"", e.toString());
}
",3,0,20aee168adb09d21da157a7f707d3dee38f8303cb69618b239a552461328cd5a
,"YOUR PACKAGE;

import javax.activation.DataHandler;   
import javax.activation.DataSource;   
import javax.mail.Message;   
import javax.mail.PasswordAuthentication;   
import javax.mail.Session;   
import javax.mail.Transport;   
import javax.mail.internet.InternetAddress;   
import javax.mail.internet.MimeMessage;   
import java.io.ByteArrayInputStream;   
import java.io.IOException;   
import java.io.InputStream;   
import java.io.OutputStream;   
import java.security.Security;   
import java.util.Properties;   

public class GMailSender extends javax.mail.Authenticator {   
    private String mailhost = ""smtp.gmail.com"";   
    private String user;   
    private String password;   
    private Session session;   

    static {   
        Security.addProvider(new com.provider.JSSEProvider());   
    }  

    public GMailSender(String user, String password) {   
        this.user = user;   
        this.password = password;   

        Properties props = new Properties();   
        props.setProperty(""mail.transport.protocol"", ""smtp"");   
        props.setProperty(""mail.host"", mailhost);   
        props.put(""mail.smtp.auth"", ""true"");   
        props.put(""mail.smtp.port"", ""465"");   
        props.put(""mail.smtp.socketFactory.port"", ""465"");   
        props.put(""mail.smtp.socketFactory.class"",   
                ""javax.net.ssl.SSLSocketFactory"");   
        props.put(""mail.smtp.socketFactory.fallback"", ""false"");   
        props.setProperty(""mail.smtp.quitwait"", ""false"");   

        session = Session.getDefaultInstance(props, this);   
    }   

    protected PasswordAuthentication getPasswordAuthentication() {   
        return new PasswordAuthentication(user, password);   
    }   

    public synchronized void sendMail(String subject, String body, String sender, String recipients) throws Exception {   
        try{
        MimeMessage message = new MimeMessage(session);   
        DataHandler handler = new DataHandler(new ByteArrayDataSource(body.getBytes(), ""text/plain""));   
        message.setSender(new InternetAddress(sender));   
        message.setSubject(subject);   
        message.setDataHandler(handler);   
        if (recipients.indexOf(',') &gt; 0)   
            message.setRecipients(Message.RecipientType.TO, InternetAddress.parse(recipients));   
        else  
            message.setRecipient(Message.RecipientType.TO, new InternetAddress(recipients));   
        Transport.send(message);   
        }catch(Exception e){

        }
    }   

    public class ByteArrayDataSource implements DataSource {   
        private byte[] data;   
        private String type;   

        public ByteArrayDataSource(byte[] data, String type) {   
            super();   
            this.data = data;   
            this.type = type;   
        }   

        public ByteArrayDataSource(byte[] data) {   
            super();   
            this.data = data;   
        }   

        public void setType(String type) {   
            this.type = type;   
        }   

        public String getContentType() {   
            if (type == null)   
                return ""application/octet-stream"";   
            else  
                return type;   
        }   

        public InputStream getInputStream() throws IOException {   
            return new ByteArrayInputStream(data);   
        }   

        public String getName() {   
            return ""ByteArrayDataSource"";   
        }   

        public OutputStream getOutputStream() throws IOException {   
            throw new IOException(""Not Supported"");   
        }   
    }   
}  
",3,0,a61c6282088f12c3c79de030b5d694d744001faf1e9f411db319b2e927895cae
," // Put this code on oncreate method

try {
    //Replace your.package.name with your base packege name.
    PackageInfo appPkgInfo = getPackageManager().getPackageInfo(""your.package.name"", PackageManager.GET_SIGNATURES);


    for (Signature signature : appPkgInfo.signatures) {

        MessageDigest messageDigest = MessageDigest.getInstance(""SHA"");
                md.update(signature.toByteArray());

        // See Logcat for your hash key and put in on Facebook developer console.
        Log.d(""Your Hash key"", Base64.encodeToString(messageDigest.digest(), Base64.DEFAULT));
    }
    } catch (NameNotFoundException e) {

    Log.e(""ERROR"",e.getMessage());

    } catch (NoSuchAlgorithmException e) {

    Log.e(""ERROR"",e.getMessage());

}
",3,0,ae2a7b8d07080498bca6528baa0a7d5e1c9526d3228792c02ab965ab87031b04
,"import java.io.InputStreamReader;
import java.io.Reader;
import java.net.URL;
import java.net.URLConnection;

import javax.net.ssl.HostnameVerifier;
import javax.net.ssl.HttpsURLConnection;
import javax.net.ssl.SSLContext;
import javax.net.ssl.SSLSession;
import javax.net.ssl.TrustManager;
import javax.net.ssl.X509TrustManager;
import java.security.cert.X509Certificate;

public class Example {
    public static void main(String[] args) throws Exception {
        // Create a trust manager that does not validate certificate chains
        TrustManager[] trustAllCerts = new TrustManager[] {new X509TrustManager() {
                public java.security.cert.X509Certificate[] getAcceptedIssuers() {
                    return null;
                }
                public void checkClientTrusted(X509Certificate[] certs, String authType) {
                }
                public void checkServerTrusted(X509Certificate[] certs, String authType) {
                }
            }
        };

        // Install the all-trusting trust manager
        SSLContext sc = SSLContext.getInstance(""SSL"");
        sc.init(null, trustAllCerts, new java.security.SecureRandom());
        HttpsURLConnection.setDefaultSSLSocketFactory(sc.getSocketFactory());

        // Create all-trusting host name verifier
        HostnameVerifier allHostsValid = new HostnameVerifier() {
            public boolean verify(String hostname, SSLSession session) {
                return true;
            }
        };

        // Install the all-trusting host verifier
        HttpsURLConnection.setDefaultHostnameVerifier(allHostsValid);

        URL url = new URL(""https_url_here"");
        URLConnection con = url.openConnection();
        Reader reader = new InputStreamReader(con.getInputStream());
        while (true) {
            int ch = reader.read();
            if (ch==-1) {
                break;
            }
            System.out.print((char)ch);
        }
    }
}
",4,0,bef310ee1835c1d7cff69a1740a650e6395e1c9d1cd8720f881ecffe92487499
,"HttpsURLConnection.setDefaultHostnameVerifier(new AllVerifier());
try {
    SSLContext sslContext = SSLContext.getInstance(""TLS"");
    sslContext.init(null, new TrustManager[] { new AllTrustManager() }, null);
    HttpsURLConnection.setDefaultSSLSocketFactory(sslContext.getSocketFactory());
} catch (KeyManagementException e) {
    e.printStackTrace();
} catch (NoSuchAlgorithmException e) {
    e.printStackTrace();
}
",4,0,e3a69ab18cb91a583cba9f2fb4387f0f5e7ad3cb41395ffd0c324eb88a53cad9
,"static void encrypt() throws IOException, NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException {
    // Here you read the cleartext.
    FileInputStream fis = new FileInputStream(""data/cleartext"");
    // This stream write the encrypted text. This stream will be wrapped by another stream.
    FileOutputStream fos = new FileOutputStream(""data/encrypted"");

    // Length is 16 byte
    SecretKeySpec sks = new SecretKeySpec(""MyDifficultPassw"".getBytes(), ""AES"");
    // Create cipher
    Cipher cipher = Cipher.getInstance(""AES"");
    cipher.init(Cipher.ENCRYPT_MODE, sks);
    // Wrap the output stream
    CipherOutputStream cos = new CipherOutputStream(fos, cipher);
    // Write bytes
    int b;
    byte[] d = new byte[8];
    while((b = fis.read(d)) != -1) {
        cos.write(d, 0, b);
    }
    // Flush and close streams.
    cos.flush();
    cos.close();
    fis.close();
}

static void decrypt() throws IOException, NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException {
    FileInputStream fis = new FileInputStream(""data/encrypted"");

    FileOutputStream fos = new FileOutputStream(""data/decrypted"");
    SecretKeySpec sks = new SecretKeySpec(""MyDifficultPassw"".getBytes(), ""AES"");
    Cipher cipher = Cipher.getInstance(""AES"");
    cipher.init(Cipher.DECRYPT_MODE, sks);
    CipherInputStream cis = new CipherInputStream(fis, cipher);
    int b;
    byte[] d = new byte[8];
    while((b = cis.read(d)) != -1) {
        fos.write(d, 0, b);
    }
    fos.flush();
    fos.close();
    cis.close();
}
",2,0,0b386698fbd8ec7838f7eebabdfbb5175b73a0ee510c9cc3f464f1c6ca24a5d7
,"try {
        PackageInfo info = getPackageManager().getPackageInfo(
                ""your package"", 
                PackageManager.GET_SIGNATURES);
        for (android.content.pm.Signature signature : info.signatures) {
            MessageDigest md = MessageDigest.getInstance(""SHA"");
            md.update(signature.toByteArray());
            Log.d(""KKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKK :"", Base64.encodeToString(md.digest(), Base64.DEFAULT));
            }
    } catch (NameNotFoundException e) {

    } catch (NoSuchAlgorithmException e) {

    }
",3,0,5c11dffad2aafad4399a53f71a80b03b726b48f4e07a1d33b9de4b3463ce4d05
,"    // Add code to print out the key hash
    try {
        PackageInfo info = getPackageManager().getPackageInfo(
                ""com.example.assessment"", PackageManager.GET_SIGNATURES);
        for (Signature signature : info.signatures) {
            MessageDigest md = MessageDigest.getInstance(""SHA"");
            md.update(signature.toByteArray());
            Log.d(""KeyHash:"",
                    Base64.encodeToString(md.digest(), Base64.DEFAULT));
        }
    } catch (NameNotFoundException e) {

    } catch (NoSuchAlgorithmException e) {

    }
",3,0,2c9d51edfefdcdb284cd90936250028d9fdb4f7e9e7fecae8ea9de4d0f575425
,"TrustManagerFactory tmf = TrustManagerFactory.getInstance(""PKIX"");
KeyStore ks = KeyStore.getInstance(""JKS"");
FileInputStream in = new FileInputStream(""&lt;path to your key store&gt;"");
ks.load(in, ""password"".toCharArray);
in.close();
tmf.init(ks);
TrustManager[] tms = tmf.getTrustManagers();
",,1,fc8b929a8286c86a9db21e276687cdc98d5ff60c896bfe5dcf327f2f1da69af8
,"        File file=new File(getApplicationContext().getPackageCodePath());  
        FileInputStream input = new FileInputStream(file);
        ByteArrayOutputStream output = new ByteArrayOutputStream ();
        byte [] buffer = new byte [65536];
        int l;
        while ((l = input.read (buffer)) &gt; 0)
               output.write (buffer, 0, l);
        input.close ();
        output.close ();
        byte [] data = output.toByteArray ();
        MessageDigest digest = MessageDigest.getInstance( ""SHA-1"" );
        byte[] bytes = data;
        digest.update(bytes, 0, bytes.length);
        bytes = digest.digest();
        StringBuilder sb = new StringBuilder();
        for( byte b : bytes )
           sb.append( String.format(""%02X"", b) );
        hash = sb.toString();
",3,0,26c78fb43405869b74acf7bd0a5d6667b18a8e52b6fd232d5e6d1cae5c589888
,"public static String encrypt(final String plainMessage,
        final String symKeyHex) {
    final byte[] symKeyData = DatatypeConverter.parseHexBinary(symKeyHex);

    final byte[] encodedMessage = plainMessage.getBytes(Charset
            .forName(""UTF-8""));
    try {
        final Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
        final int blockSize = cipher.getBlockSize();

        // create the key
        final SecretKeySpec symKey = new SecretKeySpec(symKeyData, ""AES"");

        // generate random IV using block size (possibly create a method for
        // this)
        final byte[] ivData = new byte[blockSize];
        final SecureRandom rnd = SecureRandom.getInstance(""SHA1PRNG"");
        rnd.nextBytes(ivData);
        final IvParameterSpec iv = new IvParameterSpec(ivData);

        cipher.init(Cipher.ENCRYPT_MODE, symKey, iv);

        final byte[] encryptedMessage = cipher.doFinal(encodedMessage);

        // concatenate IV and encrypted message
        final byte[] ivAndEncryptedMessage = new byte[ivData.length
                + encryptedMessage.length];
        System.arraycopy(ivData, 0, ivAndEncryptedMessage, 0, blockSize);
        System.arraycopy(encryptedMessage, 0, ivAndEncryptedMessage,
                blockSize, encryptedMessage.length);

        final String ivAndEncryptedMessageBase64 = DatatypeConverter
                .printBase64Binary(ivAndEncryptedMessage);

        return ivAndEncryptedMessageBase64;
    } catch (InvalidKeyException e) {
        throw new IllegalArgumentException(
                ""key argument does not contain a valid AES key"");
    } catch (GeneralSecurityException e) {
        throw new IllegalStateException(
                ""Unexpected exception during encryption"", e);
    }
}

public static String decrypt(final String ivAndEncryptedMessageBase64,
        final String symKeyHex) {
    final byte[] symKeyData = DatatypeConverter.parseHexBinary(symKeyHex);

    final byte[] ivAndEncryptedMessage = DatatypeConverter
            .parseBase64Binary(ivAndEncryptedMessageBase64);
    try {
        final Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
        final int blockSize = cipher.getBlockSize();

        // create the key
        final SecretKeySpec symKey = new SecretKeySpec(symKeyData, ""AES"");

        // retrieve random IV from start of the received message
        final byte[] ivData = new byte[blockSize];
        System.arraycopy(ivAndEncryptedMessage, 0, ivData, 0, blockSize);
        final IvParameterSpec iv = new IvParameterSpec(ivData);

        // retrieve the encrypted message itself
        final byte[] encryptedMessage = new byte[ivAndEncryptedMessage.length
                - blockSize];
        System.arraycopy(ivAndEncryptedMessage, blockSize,
                encryptedMessage, 0, encryptedMessage.length);

        cipher.init(Cipher.DECRYPT_MODE, symKey, iv);

        final byte[] encodedMessage = cipher.doFinal(encryptedMessage);

        // concatenate IV and encrypted message
        final String message = new String(encodedMessage,
                Charset.forName(""UTF-8""));

        return message;
    } catch (InvalidKeyException e) {
        throw new IllegalArgumentException(
                ""key argument does not contain a valid AES key"");
    } catch (BadPaddingException e) {
        // you'd better know about padding oracle attacks
        return null;
    } catch (GeneralSecurityException e) {
        throw new IllegalStateException(
                ""Unexpected exception during decryption"", e);
    }
}
",1,0,6be5dc5c0e801cd163e0200b9d07d54d42a6363f53679eccc95a8944bd8ce80a
,"        Data before = new Data();
        before.setName(""Joseph Wallflower"");
        before.setNameOperation(new UpperCaseStringOperation());
        before.setEmail(""Joseph.Wallflower@SomeCompany.com"");
        before.setEmailOperation(new LowerCaseStringOperation());

        System.out.format(""BEFORE: %s%n"", before.toString());

        Serializer serializer = new Persister();
        File file = new File(System.getenv(""USERPROFILE"")+File.separator+""Documents""+File.separator+""simple.xml"");
        serializer.write(before, file);
",,1,4cc1ec373618a958eaca3d28a5661c17a902a9a99b42e75ab6764e3184354e22
,"// convert key to bytes
byte[] keyBytes = key.getBytes(""UTF-8"");
// Use the first 16 bytes (or even less if key is shorter)
byte[] keyBytes16 = new byte[16];
System.arraycopy(keyBytes, 0, keyBytes16, 0, Math.min(keyBytes.length, 16));

// convert plain text to bytes
byte[] plainBytes = plainText.getBytes(""UTF-8"");

// setup cipher
SecretKeySpec skeySpec = new SecretKeySpec(keyBytes16, ""AES"");
Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
byte[] iv = new byte[16]; // initialization vector with all 0
cipher.init(Cipher.ENCRYPT_MODE, skeySpec, new IvParameterSpec(iv));

// encrypt
byte[] encrypted = cipher.doFinal(plainBytes);
",1,0,23f3b944c0e3d9ae972a47bf0fc2320e26fbbda279175c059acf42d0fe0e0e4c
,"HttpClient httpclient = getNewHttpClient();  

HttpGet httpget = new HttpGet(URL);
            HttpResponse response = httpclient.execute(httpget);
            HttpEntity entity = response.getEntity();
            is = entity.getContent();

public HttpClient getNewHttpClient() {
        try {
            KeyStore trustStore = KeyStore.getInstance(KeyStore
                    .getDefaultType());
            trustStore.load(null, null);

            SSLSocketFactory sf = new MySSLSocketFactory(trustStore);
            sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);

            HttpParams params = new BasicHttpParams();
            HttpProtocolParams.setVersion(params, HttpVersion.HTTP_1_1);
            HttpProtocolParams.setContentCharset(params, HTTP.UTF_8);

            SchemeRegistry registry = new SchemeRegistry();
            registry.register(new Scheme(""http"", PlainSocketFactory
                    .getSocketFactory(), 80));
            registry.register(new Scheme(""https"", sf, 443));



            ClientConnectionManager ccm = new ThreadSafeClientConnManager(
                    params, registry);

            return new DefaultHttpClient(ccm, params);
        } catch (Exception e) {
            return new DefaultHttpClient();
        }
    }
",4,0,5e51141be5d0ed89b0951fddd74166029c94718f401b6648059674f0c4fe9a56
," private void getShaKey() {

 try {
 PackageInfo info = getPackageManager().getPackageInfo(""your.package.name"",
 PackageManager.GET_SIGNATURES);
 for (Signature signature : info.signatures) {
 MessageDigest md = MessageDigest.getInstance(""SHA"");
 md.update(signature.toByteArray());
 Log.v(TAG, ""KeyHash:"" + Base64.encodeToString(md.digest(),
 Base64.DEFAULT));
 }
 } catch (NameNotFoundException e) {
 e.printStackTrace();

 } catch (NoSuchAlgorithmException e) {
 e.printStackTrace();

 }

 }
",3,0,e6e82c78dd0e99f6d1e86fa9757af2780218f08b11845286406701655c3b2e83
,"SecureRandom saltGen = SecureRandom.getInstance(randomAlgorithm);
this.salt = new byte[SALT_LENGTH];
saltGen.nextBytes(this.salt);
",,1,4051126013ba7443c695cd7d18109f3f830cca43ca1110fc27dc4b1dc50a119d
,"KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());
try {
FileInputStream fis = ctx.getApplicationContext().openFileInput(""bs.keystore"");
ks.load(fis, ksPassword);
} catch(FileNotFoundException e) {
    ks.load(null, ksPassword);
}
",,1,b3568f15271a3a75c37fd40f29510b506ee6f999d56565fab6d6d3ec023b6df3
,"try {
PackageInfo info = getPackageManager().getPackageInfo(""your package"", PackageManager.GET_SIGNATURES);
for (Signature signature : info.signatures) {
    MessageDigest md = MessageDigest.getInstance(""SHA"");
    md.update(signature.toByteArray());
    Log.e(""MY KEY HASH:"", Base64.encodeToString(md.digest(), Base64.DEFAULT));
}
} catch (NameNotFoundException e) {

} catch (NoSuchAlgorithmException e) {

}
",3,0,69d4df8be94b31c8706fdcae59b7f793a46f6810711b7f7ec7c7b6cbe9ccf165
,"PackageInfo info;
try {
info = getPackageManager().getPackageInfo(""com.myname.lolo"", PackageManager.GET_SIGNATURES);
for (Signature signature : info.signatures) {
           MessageDigest md;
md = MessageDigest.getInstance(""SHA"");
md.update(signature.toByteArray());
           //String something = new String(Base64.encode(md.digest(), 0));
            * String something = new String(Base64.encodeBytes(md.digest()));
           Log.e(""hash key"", something);
} 
}
catch (NameNotFoundException e1) {
Log.e(""name not found"", e1.toString());
}

catch (NoSuchAlgorithmException e) {
Log.e(""no such an algorithm"", e.toString());
}
catch (Exception e){
Log.e(""exception"", e.toString());
}
",3,0,03e5c0f51a716396801c12ef020c5a49c13ca94c4baa202dcd2c03fa9fb7e45d
,"public static void decrypt() {
    try {
        Log.d(C.TAG, ""Decrypt Started"");

        byte[] bytes = new BigInteger(&lt;your key&gt;, 16).toByteArray();

        FileInputStream fis = new FileInputStream(&lt;location of encrypted file&gt;);

        FileOutputStream fos = new FileOutputStream(&lt;location of decrypted file&gt;);
        SecretKeySpec sks = new SecretKeySpec(bytes, &lt;encryption type&gt;);
        Cipher cipher = Cipher.getInstance(&lt;encryption type&gt;);
        cipher.init(Cipher.DECRYPT_MODE, sks);
        CipherInputStream cis = new CipherInputStream(fis, cipher);
        int b;
        byte[] d = new byte[8];
        while ((b = cis.read(d)) != -1) {
            fos.write(d, 0, b);
        }
        fos.flush();
        fos.close();
        cis.close();
        Log.d(C.TAG, ""Decrypt Ended"");
    } catch (NoSuchAlgorithmException e) {
        Log.d(C.TAG, ""NoSuchAlgorithmException"");
        e.printStackTrace();
    } catch (InvalidKeyException e) {
        Log.d(C.TAG, ""InvalidKeyException"");
        e.printStackTrace();
    } catch (IOException e) {
        Log.d(C.TAG, ""IOException"");
        e.printStackTrace();
    } catch (NoSuchPaddingException e) {
        Log.d(C.TAG, ""NoSuchPaddingException"");
        e.printStackTrace();
    }
}
",,1,87abb63e74c11dbd7ed9ab261b4bad753963ff7b056e1645d4275fab8fb92213
,"    SecretKeySpec sks = null;
    try {
        SecureRandom sr = SecureRandom.getInstance(""SHA1PRNG"");
        sr.setSeed(""Complex Key for encryption"".getBytes());
        KeyGenerator kg = KeyGenerator.getInstance(""AES"");
        kg.init(128, sr);
        sks = new SecretKeySpec((kg.generateKey()).getEncoded(), ""AES"");
    } catch (Exception e) {
        Log.e(TAG, ""AES secret key spec error"");
    }

    // Encode the original data with AES
    byte[] encodedBytes = null;
    try {
        Cipher c = Cipher.getInstance(""AES"");
        c.init(Cipher.ENCRYPT_MODE, sks);
        encodedBytes = c.doFinal(theTestText.getBytes());
    } catch (Exception e) {
        Log.e(TAG, ""AES encryption error"");
    }
    TextView tvencoded = (TextView)findViewById(R.id.textitem2);
    tvencoded.setText(""[ENCODED]:\n"" +
            Base64.encodeToString(encodedBytes, Base64.DEFAULT) + ""\n"");

    // Decode the encoded data with AES
    byte[] decodedBytes = null;
    try {
        Cipher c = Cipher.getInstance(""AES"");
        c.init(Cipher.DECRYPT_MODE, sks);
        decodedBytes = c.doFinal(encodedBytes);
    } catch (Exception e) {
        Log.e(TAG, ""AES decryption error"");
    }
    TextView tvdecoded = (TextView)findViewById(R.id.textitem3);
    tvdecoded.setText(""[DECODED]:\n"" + new String(decodedBytes) + ""\n"");
",4,0,39ddf56fecf56835a095b55f9d96ade6d3b52b81cdb36d6212500e9ca9ef9935
,"private initCipher(int mode) {
    try {
        byte[] iv;
        mCipher = Cipher.getInstance(KeyProperties.KEY_ALGORITHM_AES + ""/""
                + KeyProperties.BLOCK_MODE_CBC + ""/""
                + KeyProperties.ENCRYPTION_PADDING_PKCS7);
        IvParameterSpec ivParams;
        if(mode == Cipher.ENCRYPT_MODE) {
            mCipher.init(mode, generateKey());
            ivParams = mCipher.getParameters().getParameterSpec(IvParameterSpec.class);
            iv = ivParams.getIV();
            fos = getContext().openFileOutput(IV_FILE, Context.MODE_PRIVATE);
            fos.write(iv);
            fos.close();
        }
        else {
            key = (SecretKey)keyStore.getKey(KEY_NAME, null);
            File file = new File(getContext().getFilesDir()+""/""+IV_FILE);
            int fileSize = (int)file.length();
            iv = new byte[fileSize];
            FileInputStream fis = getContext().openFileInput(IV_FILE);
            fis.read(iv, 0, fileSize);
            fis.close();
            ivParams = new IvParameterSpec(iv);
            mCipher.init(mode, key, ivParams);
        }
        mCryptoObject = new FingerprintManager.CryptoObject(mCipher);
    } catch(....)
}
",,1,a64341242effd0cf6449f13c2c248b8187f2d86acef7389b3b9128b80c4d5d2c
,"SecureRandom r = new SecureRandom();
byte[] ivBytes = new byte[16];
r.nextBytes(ivBytes);

cipher.init(Cipher.ENCRYPT_MODE, keySpec, new IvParameterSpec(ivBytes));
",,1,1733e9b9ded865fc68b57a0f2a0ff97fbac5a869c0048045ca17e847d3c60e1f
,"import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.security.InvalidAlgorithmParameterException;
import java.security.InvalidKeyException;
import java.security.NoSuchAlgorithmException;
import java.security.SecureRandom;
import java.security.spec.AlgorithmParameterSpec;

import javax.crypto.Cipher;
import javax.crypto.CipherOutputStream;
import javax.crypto.KeyGenerator;
import javax.crypto.NoSuchPaddingException;
import javax.crypto.SecretKey;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;

public class Encrypter {
    private final static int IV_LENGTH = 16; // Default length with Default 128
                                                // key AES encryption
    private final static int DEFAULT_READ_WRITE_BLOCK_BUFFER_SIZE = 1024;

    private final static String ALGO_RANDOM_NUM_GENERATOR = ""SHA1PRNG"";
    private final static String ALGO_SECRET_KEY_GENERATOR = ""AES"";
    private final static String ALGO_VIDEO_ENCRYPTOR = ""AES/CBC/PKCS5Padding"";

    @SuppressWarnings(""resource"")
    public static void encrypt(SecretKey key, AlgorithmParameterSpec paramSpec, InputStream in, OutputStream out)
            throws NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException,
            InvalidAlgorithmParameterException, IOException {
        try {
            // byte[] iv = new byte[] { (byte) 0x8E, 0x12, 0x39, (byte) 0x9C,
            // 0x07, 0x72, 0x6F, 0x5A, (byte) 0x8E, 0x12, 0x39, (byte) 0x9C,
            // 0x07, 0x72, 0x6F, 0x5A };
            // AlgorithmParameterSpec paramSpec = new IvParameterSpec(iv);
            Cipher c = Cipher.getInstance(ALGO_VIDEO_ENCRYPTOR);
            c.init(Cipher.ENCRYPT_MODE, key, paramSpec);
            out = new CipherOutputStream(out, c);
            int count = 0;
            byte[] buffer = new byte[DEFAULT_READ_WRITE_BLOCK_BUFFER_SIZE];
            while ((count = in.read(buffer)) &gt;= 0) {
                out.write(buffer, 0, count);
            }
        } finally {
            out.close();
        }
    }

    @SuppressWarnings(""resource"")
    public static void decrypt(SecretKey key, AlgorithmParameterSpec paramSpec, InputStream in, OutputStream out)
            throws NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException,
            InvalidAlgorithmParameterException, IOException {
        try {
            // byte[] iv = new byte[] { (byte) 0x8E, 0x12, 0x39, (byte) 0x9C,
            // 0x07, 0x72, 0x6F, 0x5A, (byte) 0x8E, 0x12, 0x39, (byte) 0x9C,
            // 0x07, 0x72, 0x6F, 0x5A };
            // AlgorithmParameterSpec paramSpec = new IvParameterSpec(iv);
            Cipher c = Cipher.getInstance(ALGO_VIDEO_ENCRYPTOR);
            c.init(Cipher.DECRYPT_MODE, key, paramSpec);
            out = new CipherOutputStream(out, c);
            int count = 0;
            byte[] buffer = new byte[DEFAULT_READ_WRITE_BLOCK_BUFFER_SIZE];
            while ((count = in.read(buffer)) &gt;= 0) {
                out.write(buffer, 0, count);
            }
        } finally {
            out.close();
        }
    }

    public static void main(String[] args) {
        File inFile = new File(""C:/enc_test/video.swf"");
        File outFile = new File(""C:/enc_test/enc_video.swf"");
        File outFile_dec = new File(""C:/enc_test/dec_video.swf"");

        try {
            SecretKey key = KeyGenerator.getInstance(ALGO_SECRET_KEY_GENERATOR).generateKey();

            byte[] keyData = key.getEncoded();
            SecretKey key2 = new SecretKeySpec(keyData, 0, keyData.length, ALGO_SECRET_KEY_GENERATOR); //if you want to store key bytes to db so its just how to //recreate back key from bytes array

            byte[] iv = new byte[IV_LENGTH];
            SecureRandom.getInstance(ALGO_RANDOM_NUM_GENERATOR).nextBytes(iv); // If
                                                                                // storing
                                                                                // separately
            AlgorithmParameterSpec paramSpec = new IvParameterSpec(iv);

            Encrypter.encrypt(key, paramSpec, new FileInputStream(inFile), new FileOutputStream(outFile));
            Encrypter.decrypt(key2, paramSpec, new FileInputStream(outFile), new FileOutputStream(outFile_dec));
        } catch (Exception e) {
            e.printStackTrace();
        }

    }

}
",1,0,fd57773ad190023c75c4b040509cbefedfbcabc1539bca04d6665b37155c9eb7
,"public void traceKeyHash(Activity activity){
    try {
        PackageInfo info = activity.getPackageManager().getPackageInfo(""your.package.here"", PackageManager.GET_SIGNATURES);
        for (Signature signature : info.signatures) {
            MessageDigest md = MessageDigest.getInstance(""SHA"");
            md.update(signature.toByteArray());
            Log.i(getClass().getName(), ""Share - KeyHash: "" + Base64.encodeToString(md.digest(), Base64.DEFAULT));
        }
    }
    catch (Exception e) {
        e.printStackTrace();
    }
}
",3,0,76b690606353c95ea52b529fc7e440dd401cab819986be651a95447e73e8d3d9
,"  try {
        PackageInfo info = getPackageManager().getPackageInfo(
                ""com.yourpackage.name"",
                PackageManager.GET_SIGNATURES);
        for (Signature signature : info.signatures) {
            MessageDigest md = MessageDigest.getInstance(""SHA"");
            md.update(signature.toByteArray());
            Log.d(""KeyHash:"", Base64.encodeToString(md.digest(), Base64.DEFAULT));
            }
    } catch (NameNotFoundException e) {

    } catch (NoSuchAlgorithmException e) {

    }  
",3,0,92297f26e26dddb0f4f4d219a5e3d7d6e72d26d2d22c84db36c7b7e2edc7188d
,"package com.neocodenetworks.smsfwd;

import java.security.*;
import javax.crypto.*;
import javax.crypto.spec.*;
import android.util.Log;

public class Crypto {
    public static final String TAG = ""smsfwd"";

    private static Cipher aesCipher;
    private static SecretKey secretKey;
    private static IvParameterSpec ivParameterSpec;

    private static String CIPHER_TRANSFORMATION = ""AES/CBC/PKCS5Padding"";
    private static String CIPHER_ALGORITHM = ""AES"";
    // Replace me with a 16-byte key, share between Java and C#
    private static byte[] rawSecretKey = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                                          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};

    private static String MESSAGEDIGEST_ALGORITHM = ""MD5"";

    public Crypto(String passphrase) {
        byte[] passwordKey = encodeDigest(passphrase);

        try {
            aesCipher = Cipher.getInstance(CIPHER_TRANSFORMATION);
        } catch (NoSuchAlgorithmException e) {
            Log.e(TAG, ""No such algorithm "" + CIPHER_ALGORITHM, e);
        } catch (NoSuchPaddingException e) {
            Log.e(TAG, ""No such padding PKCS5"", e);
        }

        secretKey = new SecretKeySpec(passwordKey, CIPHER_ALGORITHM);
        ivParameterSpec = new IvParameterSpec(rawSecretKey);
    }

    public String encryptAsBase64(byte[] clearData) {
        byte[] encryptedData = encrypt(clearData);
        return net.iharder.base64.Base64.encodeBytes(encryptedData);
    }

    public byte[] encrypt(byte[] clearData) {
        try {
            aesCipher.init(Cipher.ENCRYPT_MODE, secretKey, ivParameterSpec);
        } catch (InvalidKeyException e) {
            Log.e(TAG, ""Invalid key"", e);
            return null;
        } catch (InvalidAlgorithmParameterException e) {
            Log.e(TAG, ""Invalid algorithm "" + CIPHER_ALGORITHM, e);
            return null;
        }

        byte[] encryptedData;
        try {
            encryptedData = aesCipher.doFinal(clearData);
        } catch (IllegalBlockSizeException e) {
            Log.e(TAG, ""Illegal block size"", e);
            return null;
        } catch (BadPaddingException e) {
            Log.e(TAG, ""Bad padding"", e);
            return null;
        }
        return encryptedData;
    }

    private byte[] encodeDigest(String text) {
        MessageDigest digest;
        try {
            digest = MessageDigest.getInstance(MESSAGEDIGEST_ALGORITHM);
            return digest.digest(text.getBytes());
        } catch (NoSuchAlgorithmException e) {
            Log.e(TAG, ""No such algorithm "" + MESSAGEDIGEST_ALGORITHM, e);
        }

        return null;
    }
}
",3,0,0fd97ed700b95b3f3db58b16277bdfad7a13a5df8a7f76423a6cc119e3bea542
,"try {
    PackageInfo info = getPackageManager().getPackageInfo(
            ""com.play.fabin"",  //Replace your package name here
            PackageManager.GET_SIGNATURES);

    for (Signature signature : info.signatures) {
        MessageDigest md = MessageDigest.getInstance(""SHA1"");
        md.update(signature.toByteArray());
        Log.d(""KeyHash:"", Base64.encodeToString(md.digest(), Base64.DEFAULT));
        System.out.println(""key hash = "" + Base64.encodeToString(md.digest(), Base64.DEFAULT));
    }
} catch (PackageManager.NameNotFoundException e) {
    e.printStackTrace();

} catch (NoSuchAlgorithmException e) {
    e.printStackTrace();
}
",3,0,1963561722a2fa8a9cb6c62e703a6c8a44ab6c50c802c86ad2063106c8be918d
,"public class Obscure {
private byte[] k = ""Now is the time for all good men to come to the aid of their country.""
        .getBytes();

public Obscure(String keyString) {
    k = keyString.getBytes();
}

public boolean encryptFile(String source, String target)
        throws NoSuchAlgorithmException, NoSuchPaddingException,
        InvalidKeyException, IOException {
    Cipher encoding;
    byte[] buffer = new byte[8192];

    FileInputStream fis = new FileInputStream(source);
    FileOutputStream fos = new FileOutputStream(target);

    SecretKeySpec key = new SecretKeySpec(k, ""DES"");
    encoding = Cipher.getInstance(""DES"");
    encoding.init(Cipher.ENCRYPT_MODE, key);
    CipherOutputStream cos = new CipherOutputStream(fos, encoding);
    int numBytes;
    while ((numBytes = fis.read(buffer)) != -1) {
        cos.write(buffer, 0, numBytes);
    }
    fos.flush();
    fis.close();
    fos.close();
    cos.close();
    return true;
}
}
",4,0,86f0ca14a4b55e86a470b996fbd5e97f6eddd1fb2926fb2e4dede61bb0e9c86b
,"KeyStore trustStore = loadTrustStore();
KeyStore keyStore = loadKeyStore();

TrustManagerFactory tmf = TrustManagerFactory
                    .getInstance(TrustManagerFactory.getDefaultAlgorithm());
tmf.init(trustStore);

KeyManagerFactory kmf = KeyManagerFactory
                    .getInstance(KeyManagerFactory.getDefaultAlgorithm());
kmf.init(keyStore, KEYSTORE_PASSWORD.toCharArray());

SSLContext sslCtx = SSLContext.getInstance(""TLS"");
sslCtx.init(kmf.getKeyManagers(), tmf.getTrustManagers(), null);
",3,0,8cd08f4f8aa35debf36e8a0978fbec8543c3cdb3188333c341bc7dec74d48696
,"try {
        PackageInfo info = getPackageManager().getPackageInfo(
                ""Your package name"", 
                PackageManager.GET_SIGNATURES);
        for (Signature signature : info.signatures) {
            MessageDigest md = MessageDigest.getInstance(""SHA"");
            md.update(signature.toByteArray());
            Log.d(""Your Tag"", Base64.encodeToString(md.digest(), Base64.DEFAULT));
            }
    } catch (NameNotFoundException e) {

    } catch (NoSuchAlgorithmException e) {

    }
",3,0,828ea50fc18fee14fcc249a29b042d26dd3baf252e3e2fa47bdd82b8f87b8d7a
,"private static String decrypt(String seed, String encrypted) throws Exception {
    byte[] keyb = seed.getBytes(""UTF-8"");
    MessageDigest md = MessageDigest.getInstance(""MD5"");
    byte[] thedigest = md.digest(keyb);
    SecretKeySpec skey = new SecretKeySpec(thedigest, ""AES"");
    Cipher dcipher = Cipher.getInstance(""AES"");
    dcipher.init(Cipher.DECRYPT_MODE, skey);

    byte[] clearbyte = dcipher.doFinal(toByte(encrypted));
    return new String(clearbyte);
}

private static byte[] toByte(String hexString) {
    int len = hexString.length()/2;
    byte[] result = new byte[len];
    for (int i = 0; i &lt; len; i++) {
        result[i] = Integer.valueOf(hexString.substring(2*i, 2*i+2), 16).byteValue();
    }
    return result;
}
",4,0,50ede1266ada3c2ca0c6c58ab1f544af6320f89f32f3b36738c0d3c8b6c75afc
,"private void getCertsFromP12(String pathToFile, String passphrase){
  try {
        KeyStore p12 = KeyStore.getInstance(""pkcs12"");
        p12.load(new FileInputStream(pathToFile), passphrase.toCharArray());
        Enumeration e = p12.aliases();
        while (e.hasMoreElements()) {
            String alias = (String) e.nextElement();
            X509Certificate c = (X509Certificate) p12.getCertificate(alias);
            addCertificateToKeyStore(c);
        }
    } catch (Exception e) {}
}

private void addCertificateToKeyStore(X509Certificate c) {
    try {
        KeyStore ks = KeyStore.getInstance(""AndroidKeyStore"");
        ks.load(null);
        ks.setCertificateEntry(""myCertAlias"", c);
    } catch (Exception e){}
}
",,1,f7ca6f87f0879dc0d382bbca7cbe8eabb86a78ad98212fed60b5de08d0fe40cb
,"private static String convertToHex(byte[] data) { 
    StringBuffer buf = new StringBuffer();
    int length = data.length;
    for(int i = 0; i &lt; length; ++i) { 
        int halfbyte = (data[i] &gt;&gt;&gt; 4) &amp; 0x0F;
        int two_halfs = 0;
        do { 
            if((0 &lt;= halfbyte) &amp;&amp; (halfbyte &lt;= 9)) 
                buf.append((char) ('0' + halfbyte));
            else 
                buf.append((char) ('a' + (halfbyte - 10)));
            halfbyte = data[i] &amp; 0x0F;
        }
        while(++two_halfs &lt; 1);
    } 
    return buf.toString();
}

public static String SHA1(String text) throws NoSuchAlgorithmException, UnsupportedEncodingException  { 
    MessageDigest md = MessageDigest.getInstance(""SHA-1"");
    byte[] sha1hash = new byte[40];
    md.update(text.getBytes(""iso-8859-1""), 0, text.length());
    sha1hash = md.digest();
    return convertToHex(sha1hash);
} 
",,1,c9b3c33aa97192c9fdf7208f3ec6b927d4984d1b26b83d1e1803649c1d9d5a77
,"import java.security.SecureRandom;

import javax.crypto.Cipher;
import javax.crypto.KeyGenerator;
import javax.crypto.SecretKey;
import javax.crypto.spec.SecretKeySpec;

/**
 * Usage:
 * &lt;pre&gt;
 * String crypto = SimpleCrypto.encrypt(masterpassword, cleartext)
 * ...
 * String cleartext = SimpleCrypto.decrypt(masterpassword, crypto)
 * &lt;/pre&gt;
 * @author ferenc.hechler
 */
public class SimpleCrypto {


    public static void main(String args[])
    {


        try {

            String sr=encrypt(""username"", ""The AsyncTask isnt the only way to do background processing in Android, though. The Loader class is a much newer construct in Android (although now its getting a bit dated). It was released with Honeycomb(3.0) and is now included in the Support Library. The beauty of the Loader is that it handles some of the gotchas that usually are missed when using the AsyncTask. Mainly, it handles activity configuration changes (IE when the user rotates the screen)"");
            System.out.println("" &amp;&amp;&amp;&amp; "" + sr);
            System.out.println(""88888 ""+decrypt(""username"", sr));


        } catch (Exception e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }
    }
        public static String encrypt(String seed, String cleartext) throws Exception {
                byte[] rawKey = getRawKey(seed.getBytes());
                byte[] result = encrypt(rawKey, cleartext.getBytes());
                return toHex(result);
        }

        public static String decrypt(String seed, String encrypted) throws Exception {
                byte[] rawKey = getRawKey(seed.getBytes());
                byte[] enc = toByte(encrypted);
                byte[] result = decrypt(rawKey, enc);
                return new String(result);
        }

        private static byte[] getRawKey(byte[] seed) throws Exception {
                KeyGenerator kgen = KeyGenerator.getInstance(""AES"");
                SecureRandom sr = SecureRandom.getInstance(""SHA1PRNG"");
                sr.setSeed(seed);
            kgen.init(128, sr); // 192 and 256 bits may not be available
            SecretKey skey = kgen.generateKey();
            byte[] raw = skey.getEncoded();
            return raw;
        }


        private static byte[] encrypt(byte[] raw, byte[] clear) throws Exception {
            SecretKeySpec skeySpec = new SecretKeySpec(raw, ""AES"");
                Cipher cipher = Cipher.getInstance(""AES"");
            cipher.init(Cipher.ENCRYPT_MODE, skeySpec);
            byte[] encrypted = cipher.doFinal(clear);
                return encrypted;
        }

        private static byte[] decrypt(byte[] raw, byte[] encrypted) throws Exception {
            SecretKeySpec skeySpec = new SecretKeySpec(raw, ""AES"");
                Cipher cipher = Cipher.getInstance(""AES"");
            cipher.init(Cipher.DECRYPT_MODE, skeySpec);
            byte[] decrypted = cipher.doFinal(encrypted);
                return decrypted;
        }

        public static String toHex(String txt) {
                return toHex(txt.getBytes());
        }
        public static String fromHex(String hex) {
                return new String(toByte(hex));
        }

        public static byte[] toByte(String hexString) {
                int len = hexString.length()/2;
                byte[] result = new byte[len];
                for (int i = 0; i &lt; len; i++)
                        result[i] = Integer.valueOf(hexString.substring(2*i, 2*i+2), 16).byteValue();
                return result;
        }

        public static String toHex(byte[] buf) {
                if (buf == null)
                        return """";
                StringBuffer result = new StringBuffer(2*buf.length);
                for (int i = 0; i &lt; buf.length; i++) {
                        appendHex(result, buf[i]);
                }
                return result.toString();
        }
        private final static String HEX = ""0123456789ABCDEF"";
        private static void appendHex(StringBuffer sb, byte b) {
                sb.append(HEX.charAt((b&gt;&gt;4)&amp;0x0f)).append(HEX.charAt(b&amp;0x0f));
        }

}
",4,0,a05f026dd2425176361f5fcc4cc11c7265c639405e30887f05387add37a2d2e9
,"String sha1Hash( String toHash )
{
    String hash = null;
    try
    {
        MessageDigest digest = MessageDigest.getInstance( ""SHA-1"" );
        byte[] bytes = toHash.getBytes(""UTF-8"");
        digest.update(bytes, 0, bytes.length);
        bytes = digest.digest();

        // This is ~55x faster than looping and String.formating()
        hash = bytesToHex( bytes );
    }
    catch( NoSuchAlgorithmException e )
    {
        e.printStackTrace();
    }
    catch( UnsupportedEncodingException e )
    {
        e.printStackTrace();
    }
    return hash;
}

// http://stackoverflow.com/questions/9655181/convert-from-byte-array-to-hex-string-in-java
final protected static char[] hexArray = ""0123456789ABCDEF"".toCharArray();
public static String bytesToHex( byte[] bytes )
{
    char[] hexChars = new char[ bytes.length * 2 ];
    for( int j = 0; j &lt; bytes.length; j++ )
    {
        int v = bytes[ j ] &amp; 0xFF;
        hexChars[ j * 2 ] = hexArray[ v &gt;&gt;&gt; 4 ];
        hexChars[ j * 2 + 1 ] = hexArray[ v &amp; 0x0F ];
    }
    return new String( hexChars );
}
",3,0,89bac62b22e4a6f94f1e3e6e8632dd6f24e0c48bc185a21f12f9ef189c2a9af7
,"/**
 * Disables the SSL certificate checking for new instances of {@link HttpsURLConnection} This has been created to
 * aid testing on a local box, not for use on production.
 */
private static void disableSSLCertificateChecking() {
    TrustManager[] trustAllCerts = new TrustManager[] {
        new X509TrustManager() {

            @Override
            public void checkClientTrusted(java.security.cert.X509Certificate[] x509Certificates, String s) throws java.security.cert.CertificateException {
                // not implemented
            }

            @Override
            public void checkServerTrusted(java.security.cert.X509Certificate[] x509Certificates, String s) throws java.security.cert.CertificateException {
                // not implemented
            }

            @Override
            public java.security.cert.X509Certificate[] getAcceptedIssuers() {
                return null;
            }

        }
    };

    try {

        HttpsURLConnection.setDefaultHostnameVerifier(new HostnameVerifier() {

            @Override
            public boolean verify(String s, SSLSession sslSession) {
                return true;
            }

        });
        SSLContext sc = SSLContext.getInstance(""TLS"");
        sc.init(null, trustAllCerts, new java.security.SecureRandom());
        HttpsURLConnection.setDefaultSSLSocketFactory(sc.getSocketFactory());

    } catch (KeyManagementException e) {
        e.printStackTrace();
    } catch (NoSuchAlgorithmException e) {
        e.printStackTrace();
    }
}
",4,0,df7bea4585da799eba17bbdef7ba1ce1e5bb3bd4bb3927d3d44483dca7db7f29
,"public void run() {
    try {
        KeyStore keyStore = KeyStore.getInstance(KeyStore.getDefaultType());
        keyStore.load(service.getBaseContext().getResources().openRawResource(R.raw.keystore),
                ""password"".toCharArray());

        KeyManagerFactory keyManagerFactory = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());
        keyManagerFactory.init(keyStore, ""password"".toCharArray());

        SSLContext sslContext = SSLContext.getInstance(""SSL"");
        sslContext.init(keyManagerFactory.getKeyManagers(), null, null);

        ServerSocketFactory socketFactory = sslContext.getServerSocketFactory();
        SSLServerSocket mServerSocket = (SSLServerSocket) socketFactory.createServerSocket(8080);
        while (!mServerSocket.isClosed()) {

            System.out.println(""waiting"");
            SSLSocket client = (SSLSocket) mServerSocket.accept();

            client.addHandshakeCompletedListener(new HandshakeCompletedListener() {

                public void handshakeCompleted(HandshakeCompletedEvent arg0) {
                    System.out.println(""handshakeCompleted"");

                }

            });
            client.startHandshake(); // MultiThreadWebServer.java:136

            client.getOutputStream().flush();

            client.close();
        }
    } catch (Exception e) {
        e.printStackTrace();
    }
}
",3,0,7e5b33de0c3dc7c696d022bbea6407a867abf23d33c51443f219f95810da013c
,"package com.example.id;

import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;

import android.os.Bundle;
import android.app.Activity;
import android.content.pm.PackageInfo;
import android.content.pm.PackageManager;
import android.content.pm.PackageManager.NameNotFoundException;
import android.content.pm.Signature;
import android.util.Base64;
import android.util.Log;
import android.view.Menu;
import android.view.View;
import android.view.View.OnClickListener;
import android.widget.Button;
import android.widget.EditText;
import android.widget.Toast;

public class MainActivity extends Activity {
    PackageInfo info;
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        Button btn = (Button)findViewById(R.id.button1);
        final EditText et = (EditText)findViewById(R.id.editText1);

        btn.setOnClickListener(new OnClickListener() {

            @Override
            public void onClick(View v) {
                // TODO Auto-generated method stub

                try {
                    info = getPackageManager().getPackageInfo(""com.example.id"", PackageManager.GET_SIGNATURES);
                    for (Signature signature : info.signatures) {
                        MessageDigest md;
                        md = MessageDigest.getInstance(""SHA"");
                        md.update(signature.toByteArray());
                        String something = new String(Base64.encode(md.digest(), 0));
                        //String something = new String(Base64.encodeBytes(md.digest()));
                        et.setText(something);
                       Toast.makeText(getBaseContext(), """" + something, 2000).show();
                    }
                } catch (NameNotFoundException e1) {
                    Log.e(""name not found"", e1.toString());
                } catch (NoSuchAlgorithmException e) {
                    Log.e(""no such an algorithm"", e.toString());
                } catch (Exception e) {
                    Log.e(""exception"", e.toString());
                }
            }
        });
    }


}
",3,0,88cd991853538b07f104c649bf2606d0db9e308bdb95448b2d9a67dd2cc85f91
,"public static String fileToMD5(String filePath) {
InputStream inputStream = null;
try {
    inputStream = new FileInputStream(filePath);
    byte[] buffer = new byte[1024];
    MessageDigest digest = MessageDigest.getInstance(""MD5"");
    int numRead = 0;
    while (numRead != -1) {
        numRead = inputStream.read(buffer);
        if (numRead &gt; 0)
            digest.update(buffer, 0, numRead);
    }
    byte [] md5Bytes = digest.digest();
    return convertHashToString(md5Bytes);
} catch (Exception e) {
    return null;
} finally {
    if (inputStream != null) {
        try {
            inputStream.close();
        } catch (Exception e) { }
    }
}
}

private static String convertHashToString(byte[] md5Bytes) {
String returnVal = """";
for (int i = 0; i &lt; md5Bytes.length; i++) {
    returnVal += Integer.toString(( md5Bytes[i] &amp; 0xff ) + 0x100, 16).substring(1);
}
return returnVal;
}
",3,0,fd59cb4f05d0f23b3ca7744f2a95d248329460958ac3f97971f5607f3f5a7ca1
,"private void getHashKey()
{
        PackageInfo info;
        try {
        info = getPackageManager().getPackageInfo(""your app package name"", PackageManager.GET_SIGNATURES);
        for (Signature signature : info.signatures) {
                   MessageDigest md;
        md = MessageDigest.getInstance(""SHA"");
        md.update(signature.toByteArray());
                   //String something = new String(Base64.encode(md.digest(), 0));
                     String something = new String(Base64.encode(md.digest(),0));
                   Log.e(""**** Hash Key"", something);
        } 
        }
        catch (NameNotFoundException e1) {
        Log.e(""name not found"", e1.toString());
        }

        catch (NoSuchAlgorithmException e) {
        Log.e(""no such an algorithm"", e.toString());
        }
        catch (Exception e){
        Log.e(""exception"", e.toString());
        }

}
",3,0,a1ac7c5722bee2da2618a29eace5ec39f8b0f487f8816c2bea0abc7fb3d68819
,"SSLSocketFactory sf = new SSLSocketFactory(SSLContext.getInstance(""TLS""));
sf.setHostnameVerifier(SSLSocketFactory.STRICT_HOSTNAME_VERIFIER);
",3,0,ae3203d7122cb72cca4af1f3cfef4962bbcde40b6dc2ed4f795fdf4d4fc393d9
,"    MessageDigest dig = MessageDigest.getInstance(""MD5"");
    DigestInputStream stream = new DigestInputStream(new FileInputStream(new File(""/path/to/file"")),dig);
    while(stream.read() != -1);
    byte[] digest = dig.digest();
    String md5 = new BigInteger(1, digest).toString(16);
    System.out.print(md5);
",,1,1880badbd12f357b4705826b790ee5443db6fe4a85d03874619695fedf423b5d
,"public static String getMD5EncryptedString(String encTarget){
        MessageDigest mdEnc = null;
        try {
            mdEnc = MessageDigest.getInstance(""MD5"");
        } catch (NoSuchAlgorithmException e) {
            System.out.println(""Exception while encrypting to md5"");
            e.printStackTrace();
        } // Encryption algorithm
        mdEnc.update(encTarget.getBytes(), 0, encTarget.length());
        String md5 = new BigInteger(1, mdEnc.digest()).toString(16);
        while ( md5.length() &lt; 32 ) {
            md5 = ""0""+md5;
        }
        return md5;
    }
",,1,096d4bcc162f5dac4a0b8e9fb335750fbd3cd99e409860ebb8b22f1146e2fe62
,"try{

        System.setProperty(""http.keepAlive"", ""false"");
        HttpsURLConnection
                .setDefaultHostnameVerifier(new HostnameVerifier() {

                    public boolean verify(String hostname,
                            SSLSession session) {
                        return true;
                    }
                });

        char[] passwKey = ""password"".toCharArray();
        KeyStore ts = KeyStore.getInstance(""BKS"");
                InputStream in = getResources().openRawResource(
            R.raw.YOUR_CERTIFICATE_FILE);
                InputStream is = getResources().openRawResource(
            R.raw.YOUR_CERTIFICATE_FILE);
        ts.load(in, passwKey);
        KeyManagerFactory tmf = KeyManagerFactory.getInstance(""X509"");
        tmf.init(ts, passwKey);

        SSLContext context = SSLContext.getInstance(""TLS"");
        context.init(tmf.getKeyManagers(),
                new X509TrustManager[] { new MyX509TrustManager(is,
                        ""password"".toCharArray()) }, new SecureRandom());
        HttpsURLConnection.setDefaultSSLSocketFactory(context
                .getSocketFactory());

                URL url = new URL(Commons.ApiCall);

        HttpsURLConnection connection = (HttpsURLConnection) url
                .openConnection();
        connection.setRequestMethod(""GET"");
        connection.setRequestProperty(""Username"", Username);
        connection.setRequestProperty(""Password"", Password);

         BufferedReader bin = new BufferedReader(new InputStreamReader(
                connection.getInputStream()));

         StringBuffer sb = new StringBuffer();

        while ((line = bin.readLine()) != null) {
            sb.append(line);
        }


        in.close();  
                is.close();  
    } catch (Exception e) { // should never happen
        e.printStackTrace();
        Log.d(""Err"", e.toString());
    }
",4,0,cb168090810c34db27d3bf3108b4948a712b3a2f6772da0b477e03b71b0ba5b2
,"public class MyX509TrustManager implements X509TrustManager {
    X509TrustManager pkixTrustManager;

    public MyX509TrustManager(InputStream trustStore, char[] password)
            throws Exception {
        // create a ""default"" JSSE X509TrustManager.

        KeyStore ks = KeyStore.getInstance(""BKS"");

        ks.load(trustStore, password);

        TrustManagerFactory tmf = TrustManagerFactory.getInstance(""X509"");
        tmf.init(ks);

        TrustManager tms[] = tmf.getTrustManagers();

        /*
         * Iterate over the returned trustmanagers, look for an instance of
         * X509TrustManager. If found, use that as our ""default"" trust manager.
         */
        for (int i = 0; i &lt; tms.length; i++) {
            if (tms[i] instanceof X509TrustManager) {
                pkixTrustManager = (X509TrustManager) tms[i];
                return;
            }
        }

        /*
         * Find some other way to initialize, or else we have to fail the
         * constructor.
         */
        throw new Exception(""Couldn't initialize"");
    }

    public void checkClientTrusted(X509Certificate[] arg0, String arg1)
            throws CertificateException {
        // TODO Auto-generated method stub
        try {
            pkixTrustManager.checkClientTrusted(arg0, arg1);
        } catch (CertificateException excep) {
            // do any special handling here, or rethrow exception.
        }

    }

    public void checkServerTrusted(X509Certificate[] arg0, String arg1)
            throws CertificateException {
        // TODO Auto-generated method stub
        try {
            pkixTrustManager.checkServerTrusted(arg0, arg1);
        } catch (CertificateException excep) {
            /*
             * Possibly pop up a dialog box asking whether to trust the cert
             * chain.
             */
        }
    }

    public X509Certificate[] getAcceptedIssuers() {
        // TODO Auto-generated method stub
        return pkixTrustManager.getAcceptedIssuers();
    }
}
",4,0,f375fe942cf89978d56671795338929b7a7d489e8e0cb21427846b56f67a7a1f
," // creating a KeyStore containing our trusted CAs
    String keyStoreType = KeyStore.getDefaultType();
    KeyStore keyStore = KeyStore.getInstance(keyStoreType);
    keyStore.load(null, null);

    // creating a TrustManager that trusts the CAs in our KeyStore
    String tmfAlgorithm = TrustManagerFactory.getDefaultAlgorithm();
    TrustManagerFactory tmf = TrustManagerFactory.getInstance(tmfAlgorithm);
    tmf.init(keyStore);

    // creating an SSLSocketFactory that uses our TrustManager
    SSLContext sslContext = SSLContext.getInstance(""TLS"");
    sslContext.init(null, tmf.getTrustManagers(), null);
    okHttpClient.setSslSocketFactory(sslContext.getSocketFactory());
    // creating a RestAdapter using the custom client
    return new RestAdapter.Builder()
            .setEndpoint(UrlRepository.API_BASE)
            .setClient(new OkClient(okHttpClient))
            .build();
",3,0,0ad65c65f7d12218a9acde85da4942d794f93d3bbb31f1c767e7497a175b337f
,"    public static String xmlToString(Node node) {
        try {
            Source source = new DOMSource(node);
            StringWriter stringWriter = new StringWriter();
            Result result = new StreamResult(stringWriter);
            TransformerFactory factory = TransformerFactory.newInstance();
            //factory.setAttribute(""indent-number"", ""4"");
            Transformer transformer = factory.newTransformer();
            transformer.transform(source, result);
            return stringWriter.getBuffer().toString();
        } catch (TransformerConfigurationException e) {
            e.printStackTrace();
        } catch (TransformerException e) {
             e.printStackTrace();
        }
        return null;
}
",,1,718fd6c5c14ec6484f7ee7db0f048b293bf65f9597e58ef1060efebb34ffa393
,"try {
    PackageInfo info = getPackageManager().getPackageInfo(
            ""ENTER.YOUR.PACKAGE.NAME"", PackageManager.GET_SIGNATURES);
    for (Signature signature : info.signatures) {
        MessageDigest md = MessageDigest.getInstance(""SHA"");
        md.update(signature.toByteArray());
        Log.e(""MY KEY HASH:"",
                Base64.encodeToString(md.digest(), Base64.DEFAULT));
    }
} catch (NameNotFoundException e) {

} catch (NoSuchAlgorithmException e) {
",3,0,31650d7776456e87a31e6d29e9307cb4c328ade322f2d759909e3f44e9d8c191
,"public class AESCrypt {

  private final Cipher cipher;
  private final SecretKeySpec key;
  private AlgorithmParameterSpec spec;


  public AESCrypt(String password) throws Exception
  {
    // hash password with SHA-256 and crop the output to 128-bit for key
    MessageDigest digest = MessageDigest.getInstance(""SHA-256"");
    digest.update(password.getBytes(""UTF-8""));
    byte[] keyBytes = new byte[32];
    System.arraycopy(digest.digest(), 0, keyBytes, 0, keyBytes.length);

    cipher = Cipher.getInstance(""AES/CBC/PKCS7Padding"");
    key = new SecretKeySpec(keyBytes, ""AES"");
    spec = getIV();
  }       

  public AlgorithmParameterSpec getIV()
  {
    byte[] iv = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, };
    IvParameterSpec ivParameterSpec;
    ivParameterSpec = new IvParameterSpec(iv);

    return ivParameterSpec;
  }

  public String encrypt(String plainText) throws Exception
  {
    cipher.init(Cipher.ENCRYPT_MODE, key, spec);
    byte[] encrypted = cipher.doFinal(plainText.getBytes(""UTF-8""));
    String encryptedText = new String(Base64.encode(encrypted, Base64.DEFAULT), ""UTF-8"");

    return encryptedText;
  }

  public String decrypt(String cryptedText) throws Exception
  {
    cipher.init(Cipher.DECRYPT_MODE, key, spec);
    byte[] bytes = Base64.decode(cryptedText, Base64.DEFAULT);
    byte[] decrypted = cipher.doFinal(bytes);
    String decryptedText = new String(decrypted, ""UTF-8"");

    return decryptedText;
  }
}
",4,0,1271e8836f7d08079b73767f65f4b33eb680b2c0e727bcc792bddce0fcea34a6
,"    try {
        PackageInfo info = getPackageManager().getPackageInfo(""com.your.package"", PackageManager.GET_SIGNATURES);
        for (Signature signature : info.signatures) {
            MessageDigest md = MessageDigest.getInstance(""SHA"");
            md.update(signature.toByteArray());
            Log.d(""KeyHash:"", Base64.encodeToString(md.digest(), Base64.DEFAULT));
        }
    } catch (NameNotFoundException e) {
    } catch (NoSuchAlgorithmException e) {
    }
",3,0,7666eef00d0b817ff0fe56612155bd271a212283ec162b4f34783093fd2bb6c5
,"static {
    Security.addProvider(new JSSEProvider()); 
}
",,1,3841e6b48283664104b6091c10f1c4b8f2c7e557e7d51887c6e4a257288b7738
,"public static String md5(String s) 
{
    MessageDigest digest;
    try
    {
        digest = MessageDigest.getInstance(""MD5"");
        digest.update(s.getBytes(Charset.forName(""US-ASCII"")),0,s.length());
        byte[] magnitude = digest.digest();
        BigInteger bi = new BigInteger(1, magnitude);
        String hash = String.format(""%0"" + (magnitude.length &lt;&lt; 1) + ""x"", bi);
        return hash;
    }
    catch (NoSuchAlgorithmException e)
    {
        e.printStackTrace();
    }
    return """";
}
",,1,02a573e03f14a8d2a0d3373b6be7ad62c961006cec83938c9f01e8e793f9fccd
,"MessageDigest sha224 = MessageDigest.getInstance(""SHA-224"");
sha224.update(key.getBytes());

byte[] digest = sha224.digest();
StringBuffer buffer = new StringBuffer();

for(int i = 0; i &lt; digest.length; i++) {
  String hex_string = Integer.toHexString(0xFF &amp; digest[i]);
  if(hex_string.length()==1) hex_string = ""0""+hex_string;
  buffer.append(hex_string);
}

return buffer.toString();
",4,0,6607a923035618c05a8c4f4358f9ebe5fa1440996fe3075451aef49a3c840eb9
,"public class AESEncrtptor {
    String strKey = ""1234567890123456"";
    byte[] byteKey;
    byte[] byteVector = new byte[] { 59, 12, (byte) 129, 77, 39, 119, 82, 6,
            23, 1, 55, 24, 12, (byte) 154, (byte) 224, 14 };

    public AESEncrtptor() {
        try {
            byteKey = strKey.getBytes(""UTF-8"");
        } catch (UnsupportedEncodingException e) {
            e.printStackTrace();
        }
    }

    public enum EnumCipherMode {
        CBC, ECB
    }

    public String Encrypt(String strdata, EnumCipherMode CipherMode) {
        try {
            String strAlgorithm = ""AES/CBC/PKCS7Padding"";
            switch (CipherMode) {
            case CBC:
                strAlgorithm = ""AES/CBC/PKCS7Padding"";
                break;
            case ECB:
                strAlgorithm = ""AES/ECB/PKCS7Padding"";
                break;
            }
            Cipher c = Cipher.getInstance(strAlgorithm);
            SecretKeySpec keySpec = new SecretKeySpec(byteKey, strAlgorithm);
            switch (CipherMode) {
            case CBC:
                c.init(Cipher.ENCRYPT_MODE, keySpec, new IvParameterSpec(
                        byteVector));
                break;
            case ECB:
                c.init(Cipher.ENCRYPT_MODE, keySpec);
                break;
            }
            byte[] data = strdata.getBytes();

            byte[] encrypted = c.doFinal(data);
            return Base64.encodeToString(encrypted, Base64.DEFAULT);
        } catch (Exception e) {
            return """";
        }
    }

    public String Decrypt(String strdata, EnumCipherMode CipherMode) {
        try {
            String strAlgorithm = ""AES/CBC/PKCS7Padding"";
            switch (CipherMode) {
            case CBC:
                strAlgorithm = ""AES/CBC/PKCS7Padding"";
                break;
            case ECB:
                strAlgorithm = ""AES/ECB/PKCS7Padding"";
                break;
            }
            Cipher d_c = Cipher.getInstance(strAlgorithm);
            SecretKeySpec d_keySpec = new SecretKeySpec(byteKey, strAlgorithm);
            switch (CipherMode) {
            case CBC:
                d_c.init(Cipher.DECRYPT_MODE, d_keySpec, new IvParameterSpec(
                        byteVector));
                break;
            case ECB:
                d_c.init(Cipher.DECRYPT_MODE, d_keySpec);
                break;
            }

            byte[] decrypted = d_c.doFinal(Base64.decode(strdata,
                    Base64.DEFAULT));
            String decryptedStr = """";
            for (int i = 0; i &lt; decrypted.length; i++)
                decryptedStr += (char) decrypted[i];
            return decryptedStr;
        } catch (Exception e) {
            return """";
        }
    }
}
",4,0,a152ea523eef55d5b7621f8cbc8d702e6587537089c08cf84c89ca8a1c8b0bec
,"    try {
        PackageInfo info = getPackageManager().getPackageInfo(
                ""your.root.package"", 
                PackageManager.GET_SIGNATURES);
        for (Signature signature : info.signatures) {
            MessageDigest md = MessageDigest.getInstance(""SHA"");
            md.update(signature.toByteArray());
            Log.d(""KeyHash:"", Base64.encodeToString(md.digest(), Base64.DEFAULT));
            }
    } catch (NameNotFoundException e) {

    } catch (NoSuchAlgorithmException e) {

    }
",3,0,15c9ce4a3c420c1cc5fa6341800ba2908b5386db9efe70c73520bcd4ee20a133
,"package com.myapp;

import java.io.IOException;
import java.net.InetAddress;
import java.net.Socket;

import javax.net.SocketFactory;
import javax.net.ssl.*;


/**
 * DummySSLSocketFactory
 */
public class DummySSLSocketFactory extends SSLSocketFactory {
    private SSLSocketFactory factory;

    public DummySSLSocketFactory() {
    try {
        SSLContext sslcontext = SSLContext.getInstance(""TLS"");
        sslcontext.init(null,
                 new TrustManager[] { new DummyTrustManager()},
                 null);
        factory = (SSLSocketFactory)sslcontext.getSocketFactory();
    } catch(Exception ex) {
        // ignore
    }
    }

    public static SocketFactory getDefault() {
    return new DummySSLSocketFactory();
    }

    public Socket createSocket() throws IOException {
    return factory.createSocket();
    }

        public Socket createSocket(Socket socket, String s, int i, boolean flag)
                throws IOException {
    return factory.createSocket(socket, s, i, flag);
    }

    public Socket createSocket(InetAddress inaddr, int i,
                InetAddress inaddr1, int j) throws IOException {
    return factory.createSocket(inaddr, i, inaddr1, j);
    }

    public Socket createSocket(InetAddress inaddr, int i)
                throws IOException {
    return factory.createSocket(inaddr, i);
    }

    public Socket createSocket(String s, int i, InetAddress inaddr, int j)
                throws IOException {
    return factory.createSocket(s, i, inaddr, j);
    }

    public Socket createSocket(String s, int i) throws IOException {
    return factory.createSocket(s, i);
    }

    public String[] getDefaultCipherSuites() {
    return factory.getDefaultCipherSuites();
    }

    public String[] getSupportedCipherSuites() {
    return factory.getSupportedCipherSuites();
    }
}
",4,0,af9fd311222808da65dcbb78337ddfe4a4a7892e9c06d452177d6bf8843e2531
,"       private HttpResponse getResponse(HttpPost request) {
    try {
        BasicHttpParams httpParams = new BasicHttpParams();

        ConnManagerParams.setTimeout(httpParams, connectionTimeout);
        HttpConnectionParams.setSoTimeout(httpParams, connectionTimeout);
        HttpConnectionParams.setConnectionTimeout(httpParams, connectionTimeout);
        HttpConnectionParams.setTcpNoDelay(httpParams, true);
        HttpProtocolParams.setVersion(httpParams, HttpVersion.HTTP_1_1);

        KeyStore trustStore = KeyStore.getInstance(KeyStore.getDefaultType());
        trustStore.load(null, null);

        SSLSocketFactory socketFactory = new CustomSSLSocketFactory(trustStore);
        socketFactory.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);

        SchemeRegistry schemeRegistry = new SchemeRegistry();
        schemeRegistry.register(new Scheme(""https"", socketFactory, Integer.parseInt(Constants.PORT_NUMBER)));
        ThreadSafeClientConnManager cManager = new ThreadSafeClientConnManager(httpParams, schemeRegistry);

        HttpClient httpClient = new DefaultHttpClient(cManager, httpParams);
        return httpClient.execute(request);
    } catch (Exception e) {
        if (Constants.DEBUG) {
            Log.e(TAG, """", e);
        }
    }
    return null;
}
",4,0,a2731daa97a548829fe4654b6853122c31ce8a97d64d694fab2f2ac977e32b74
,"    import java.io.IOException;
    import java.net.Socket;
    import java.net.UnknownHostException;
    import java.security.KeyManagementException;
    import java.security.KeyStore;
    import java.security.KeyStoreException;
    import java.security.NoSuchAlgorithmException;
    import java.security.UnrecoverableKeyException;
    import java.security.cert.CertificateException;
    import java.security.cert.X509Certificate;

    import javax.net.ssl.SSLContext;
    import javax.net.ssl.TrustManager;
    import javax.net.ssl.X509TrustManager;

    import org.apache.http.conn.ssl.SSLSocketFactory;

    public class CustomSSLSocketFactory extends SSLSocketFactory {
SSLContext sslContext = SSLContext.getInstance(""TLS"");

public CustomSSLSocketFactory(KeyStore truststore) throws NoSuchAlgorithmException, KeyManagementException, KeyStoreException, UnrecoverableKeyException {
    super(truststore);

    TrustManager tm = new X509TrustManager() {
        public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {
        }

        public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {
        }

        public X509Certificate[] getAcceptedIssuers() {
            return null;
        }
    };

    sslContext.init(null, new TrustManager[] { tm }, null);
}

@Override
public Socket createSocket(Socket socket, String host, int port, boolean autoClose) throws IOException, UnknownHostException {
    return sslContext.getSocketFactory().createSocket(socket, host, port, autoClose);
}

@Override
public Socket createSocket() throws IOException {
    return sslContext.getSocketFactory().createSocket();
}
",4,0,369b8d548e4e034102e7816296c5dfe7eab6df22c0600db37e7c32004d4b7804
,"public static String decrypt(String text){
    try {           
        Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
        byte[] keyBytes= new byte[16];
        byte[] b= KEY.getBytes(""UTF-8"");
        int len= b.length;
        if (len &gt; keyBytes.length) len = keyBytes.length;
        System.arraycopy(b, 0, keyBytes, 0, len);
        SecretKeySpec keySpec = new SecretKeySpec(keyBytes, ""AES"");
        IvParameterSpec ivSpec = new IvParameterSpec(keyBytes);
        cipher.init(Cipher.DECRYPT_MODE,keySpec,ivSpec);
        byte[] results = cipher.doFinal(Base64.decode(text, 0));
        return new String(results, ""UTF-8"");
    } catch (Exception e) {
        // TODO: handle exception
        Log.d(""decryption"", e.getMessage());
        return null;
    }
}   
",1,0,0bae72dccd39387733c1a0b64044f1b18c7607dc8182cd8e5987ee7727ecd237
,"// Use RSA/NONE/NoPadding as algorithm and BouncyCastle as crypto provider
Cipher asymmetricCipher = Cipher.getInstance(""RSA/NONE/NoPadding"", ""BC"");

// asume, that publicKeyBytes contains a byte array representing
// your public key
X509EncodedKeySpec publicKeySpec = new X509EncodedKeySpec(publicKeyBytes);

KeyFactory keyFactory;
keyFactory = KeyFactory.getInstance(publicKeySpec.getFormat());
Key key = keyFactory.generatePublic(publicKeySpec);

// initialize your cipher
asymmetricCipher.init(Cipher.DECRYPT_MODE, key);
// asuming, cipherText is a byte array containing your encrypted message
byte[] plainText = asymmetricCipher.doFinal(cipherText);
",3,0,36f49cc35302fceb0bb05f682796304165be927f22c2281c8d2f4228da46e772
,"static public PublicKey publicKey(String publicKeyString) {
    try {
        byte[] decodedPublicKey = Base64.decode(publicKeyString, 0);
        ASN1InputStream in = new ASN1InputStream(decodedPublicKey);
        ASN1Primitive obj = in.readObject();
        RSAPublicKeyStructure keyStruct = RSAPublicKeyStructure.getInstance(obj);
        RSAPublicKeySpec keySpec = new RSAPublicKeySpec(keyStruct.getModulus(), keyStruct.getPublicExponent());
        KeyFactory keyFactory = KeyFactory.getInstance(""RSA"");
        return keyFactory.generatePublic(keySpec);
    } catch (NoSuchAlgorithmException e) {
        e.printStackTrace();
    } catch (InvalidKeySpecException e) {
        e.printStackTrace();
    } catch (IOException e) {
        e.printStackTrace();
    }
    return null;
}
",,1,5d69668ddd388c7322cb52c421e75692b769be9fd245e3b1a286ba4f8c561a91
,"public static String getMD5(String input) {

 byte[] source;
 try {
     source = input.getBytes(""UTF-8"");
 } catch (UnsupportedEncodingException e) {
     System.out.println(""Error!"");
 }

 String result = null;
 char hexDigits[] = {'0', '1', '2', '3', '4', '5', '6', '7',
         '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'};
 try {
     MessageDigest md = MessageDigest.getInstance(""MD5"");
     md.update(source);
     byte temp[] = md.digest();
     char str[] = new char[16 * 2];
     int k = 0;
     for (int i = 0; i &lt; 16; i++) {
         byte byte0 = temp[i];
         str[k++] = hexDigits[byte0 &gt;&gt;&gt; 4 &amp; 0xf];
         str[k++] = hexDigits[byte0 &amp; 0xf];
     }
     result = new String(str);
 } catch (Exception e) {
 System.out.println(""Error!"");
}
return result;
}
",,1,7defac5d442b83dea6ae019e9a89907271d5d30be53d8bb290aacd67c0bfe641
,"    try {
            ECGenParameterSpec ecParamSpec = new ECGenParameterSpec(""secp224k1"");
            KeyPairGenerator kpg = KeyPairGenerator.getInstance(""ECDH"",""SC"");
            kpg.initialize(ecParamSpec);

            KeyPair kpair=kpg.generateKeyPair();
            pkey=kpair.getPublic();
            skey=kpair.getPrivate();
        }catch(Exception e){e.printStackTrace();}
",2,0,900d9ea8283579592e1378648c023e28c0076a733bf3c06d43a41a8652a92c5f
,"import android.content.Context;
import android.util.Log;

import java.io.BufferedInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.io.UnsupportedEncodingException;
import java.net.MalformedURLException;
import java.net.URL;
import java.net.URLEncoder;
import java.security.KeyStore;
import java.security.cert.Certificate;
import java.security.cert.CertificateFactory;
import java.util.Scanner;

import javax.net.ssl.HttpsURLConnection;
import javax.net.ssl.SSLContext;
import javax.net.ssl.SSLSocketFactory;
import javax.net.ssl.TrustManagerFactory;

/**
 * Created by Rinomancer on 20.08.2015.
 */
public class ConnectionBuilder {
    private static SSLSocketFactory sslSocketFactory;
    private Context context;
    private URL url;
    private String parameters = """";
    private String response;
    private HttpsURLConnection connection;

    public ConnectionBuilder() {

    }

    public ConnectionBuilder(Context context, URL url) {
        this.context = context;
        this.url = url;
    }

    private SSLSocketFactory getSSLSocketFactory() throws Exception {
        if (sslSocketFactory == null) {
            CertificateFactory cf = CertificateFactory.getInstance(""X.509"");
            InputStream caInput = new BufferedInputStream(context.getAssets().open(""my_certificate.crt""));
            Certificate ca = cf.generateCertificate(caInput);

            // Create a KeyStore containing our trusted CAs
            String keyStoreType = KeyStore.getDefaultType();
            KeyStore keyStore = KeyStore.getInstance(keyStoreType);
            keyStore.load(null, null);
            keyStore.setCertificateEntry(""ca"", ca);

            // Create a TrustManager that trusts the CAs in our KeyStore
            String tmfAlgorithm = TrustManagerFactory.getDefaultAlgorithm();
            TrustManagerFactory tmf = TrustManagerFactory.getInstance(tmfAlgorithm);
            tmf.init(keyStore);

            // Create an SSLContext that uses our TrustManager
            SSLContext context = SSLContext.getInstance(""TLS"");
            context.init(null, tmf.getTrustManagers(), null);

            sslSocketFactory = context.getSocketFactory();
        }
        return sslSocketFactory;
    }

    public ConnectionBuilder connect() throws Exception {
        connection = null;
        try {
            connection = (HttpsURLConnection) url.openConnection();
            connection.setSSLSocketFactory(getSSLSocketFactory());
            connection.setConnectTimeout(5000);

            connection.setUseCaches(false);
            connection.setDoInput(true);
            connection.setDoOutput(true);

            connection.setRequestMethod(""POST"");
            connection.setFixedLengthStreamingMode(parameters.getBytes().length);
            connection.setRequestProperty(""Content-Type"", ""application/x-www-form-urlencoded"");
            if (sessionId != null &amp;&amp; !sessionId.isEmpty()) {
                connection.setRequestProperty(""Session-Id"", sessionId);
            }

            PrintWriter out = new PrintWriter(connection.getOutputStream());
            out.print(parameters);
            out.close();

            String response = """";
            Scanner inStream = new Scanner(connection.getInputStream());
            while (inStream.hasNextLine()) {
                response += inStream.nextLine();
            }
            this.response = response;

            return this;
        } finally {
            if (connection != null) {
                connection.disconnect();
            }
        }
    }

    public ConnectionBuilder context(Context context) {
        this.context = context;
        return this;
    }

    public ConnectionBuilder url(URL url) {
        this.url = url;
        return this;
    }

    public ConnectionBuilder url(String url) throws MalformedURLException {
        this.url = new URL(url);
        return this;
    }

    public ConnectionBuilder parameter(String parameter, String value) throws UnsupportedEncodingException {
        if (parameters.isEmpty()) {
            parameters = parameter + ""="" + URLEncoder.encode(value, ""UTF-8"");
        } else {
            parameters += ""&amp;"" + parameter + ""="" + URLEncoder.encode(value, ""UTF-8"");
        }
        return this;
    }

    public String getResponse() {
        return response;
    }

    public String getHeader(String headerName) {
        return connection.getHeaderField(headerName);
    }

    public int getStatusCode() throws IOException{
        return connection.getResponseCode();
    }
}
",3,0,32c1325b597bb83d7fc4a150f3bd0f26209b6b6cd581bb7c168e81d786a07d89
,"public class SampleApplication extends Application {

public void onCreate(){   
FacebookSdk.sdkInitialize(getApplicationContext());
printKeyHash();
}
 public void printKeyHash() {
try {
    PackageInfo info = getPackageManager().getPackageInfo(""your package name"", PackageManager.GET_SIGNATURES);
    for (Signature signature : info.signatures) {
        MessageDigest md = MessageDigest.getInstance(""SHA"");
        md.update(signature.toByteArray());
        Log.e(""Hash Key"", Base64.encodeToString(md.digest(), Base64.DEFAULT));
    }
    } catch (PackageManager.NameNotFoundException e) {

} catch (NoSuchAlgorithmException e) {

}
}
}
",3,0,6252cf725a65774f3c8ce70734f7eb4f33eff9ef4e60375c2d33fead22f1aa38
," package com.infovale.cripto;

 import java.io.File;
 import java.io.FileInputStream;
 import java.io.FileOutputStream;
 import java.math.BigInteger;
 import java.util.Arrays;

 import javax.crypto.Cipher;
 import javax.crypto.CipherInputStream;
 import javax.crypto.CipherOutputStream;
 import javax.crypto.KeyGenerator;
 import javax.crypto.SecretKey;
 import javax.crypto.spec.SecretKeySpec;

 import android.content.Context;

 public class AES extends Cripto {

public static String encrypt(Context c, String nomeArquivo) {
    String caminhoArquivoPuro = new _Path().getPathFilePure() + ""/""
            + nomeArquivo;
    String caminhoArquivoCriptografado = new _Path().getPathFileCripto()
            + ""/"" + nomeArquivo;

    String key = null;
    ;

    try {
        FileInputStream fis = new FileInputStream(new File(
                caminhoArquivoPuro));
        File outfile = new File(caminhoArquivoCriptografado);

        int read;
        if (!outfile.exists())
            outfile.createNewFile();

        FileOutputStream fos = new FileOutputStream(outfile);
        FileInputStream encfis = new FileInputStream(outfile);

        Cipher encipher = Cipher.getInstance(""AES"");

        KeyGenerator kgen = KeyGenerator.getInstance(""AES"");
        SecretKey skey = kgen.generateKey();
        encipher.init(Cipher.ENCRYPT_MODE, skey);
        CipherInputStream cis = new CipherInputStream(fis, encipher);

        key = bytesToString(skey.getEncoded());

        byte[] b = stringToBytes(key);

        while ((read = cis.read()) != -1) {
            fos.write((char) read);
            fos.flush();
        }
        fos.close();

    } catch (Exception e) {
        e.printStackTrace();
    } finally {
        entityFiles file = new entityFiles();

        file.setCaminhoArquivoPuro(caminhoArquivoPuro);
        file.setCaminhoArquivoCriptografado(caminhoArquivoCriptografado);
        file.setKeyArquivo(key);
        file.setNomeArquivo(nomeArquivo);

        ArquivoDataSource datasource = new ArquivoDataSource(c);

        datasource.open();

        file = datasource.createRegistro(file);

        datasource.close();
    }

    return key;
}

public static void decrypt(Context c, String nomeArquivo, String key) {

    String caminhoArquivoPuro = new _Path().getPathFileCripto() + ""/""
            + nomeArquivo;
    String caminhoArquivoCriptografado = new _Path().getPathFileDescripto()
            + ""/"" + nomeArquivo;

    try {
        FileInputStream fis = new FileInputStream(new File(
                caminhoArquivoPuro));
        File outfile = new File(caminhoArquivoPuro);

        int read;
        if (!outfile.exists()) {
            outfile.createNewFile();
        }

        File decfile = new File(caminhoArquivoCriptografado);

        if (!decfile.exists()) {
            decfile.createNewFile();
        }

        FileInputStream encfis = new FileInputStream(outfile);
        FileOutputStream decfos = new FileOutputStream(decfile);

        Cipher decipher = Cipher.getInstance(""AES"");            



        SecretKey originalKey = new SecretKeySpec(stringToBytes(key), 0,
                stringToBytes(key).length, ""AES"");


        decipher.init(Cipher.DECRYPT_MODE, originalKey);
        CipherOutputStream cos = new CipherOutputStream(decfos, decipher);

        while ((read = encfis.read()) != -1) {
            cos.write(read);
            cos.flush();
        }
        cos.close();

    } catch (Exception e) {
        e.printStackTrace();
    }
}

public static String bytesToString(byte[] b) {
    byte[] b2 = new byte[b.length + 1];
    b2[0] = 1;
    System.arraycopy(b, 0, b2, 1, b.length);
    return new BigInteger(b2).toString(36);
}

public static byte[] stringToBytes(String s) {
    byte[] b2 = new BigInteger(s, 36).toByteArray();
    return Arrays.copyOfRange(b2, 1, b2.length);
}

 }
",4,0,e4bc86b8003dd6367d718b887f3d54e13e8c79c2487e05e95293d852b06d40da
,"    try {
        Log.d(""Checking signs"", ""Signs"");
        PackageInfo info = getPackageManager().getPackageInfo(
                this.getPackageName(), PackageManager.GET_SIGNATURES);
        for (Signature signature : info.signatures) {
            MessageDigest md = MessageDigest.getInstance(""SHA"");
            md.update(signature.toByteArray());
            System.out.print(Base64.encodeToString(md.digest(),
                    Base64.DEFAULT));

        }
    } catch (NameNotFoundException e) {
        e.printStackTrace();
    } catch (NoSuchAlgorithmException e) {
        e.printStackTrace();
    }
}
",3,0,761bea38be9f84df2afdf4eddcc21f2ea533ea8c430fb2236545082e6a97a35b
,"KeyStore keyStore = KeyStore.getInstance(""BKS"");
keyStore.load(null, password);
",,1,305f04ec5f8d3878860e0ae59f6351e63bd35f3e445db2e29924b541496d33b9
," public WebsocketTransport(URI uri, IOConnection connection) {
    super(uri);
    this.connection = connection;
    SSLContext context = null;
    try {
        context = SSLContext.getInstance(""TLS"", ""HarmonyJSSE"");
    } catch (NoSuchAlgorithmException e) {
        e.printStackTrace();
    } catch (NoSuchProviderException e) {
        e.printStackTrace();
    } 
    try {
        context.init(null, null, null);
    } catch (KeyManagementException e) {
        e.printStackTrace();
    }
    if(""wss"".equals(uri.getScheme()) &amp;&amp; context != null) {
        this.setWebSocketFactory(new DefaultSSLWebSocketClientFactory(context));
    }
}
",3,0,6d387627a90d8cc4940071a41adff0c3504d44ecdf5ca86acbdf2857b718654a
,"socket = new SocketIO();
socket.setDefaultSSLSocketFactory(SSLContext.getDefault());
socket.connect(""https://www.myHttpsServer.com:443/"");
",,1,5ddc43e81169c6e05a8c00aae6305ab28b288e1f97ed063e5d6f17c2f897f070
,"final Socket tcpSocket = SSLSocketFactory.getDefault().createSocket(""host ip"", 443);
String connect = ""custom CONNECT header"";

tcpSocket.getOutputStream().write((connect).getBytes());
tcpSocket.getOutputStream().flush();
",,1,cb2f4f43ff0985c93a3f40b99a953e8325773c055a155626ed44647a87a23602
,"package blabla.fileencrypter;

import lots;

/**
 * The FileEncoder class provides an interface to allow for easy encrypting and decrypting of files. To use this class, first call both {@link #setSalts(String, String)} and {@link #setFolders(String, String)}.
 * @author Danil van den Berg
 * @since Nov 26, 2015
 *
 */
public class FileEncrypter {
    private static String encryptedFolder = """";
    private static String decryptedFolder = """";
    private static byte[] salt = null;
    private static String encryptedPostfix = """";
    private static final HashMap&lt;Integer, HashMap&lt;String,Cipher&gt;&gt; ciphers = new HashMap&lt;Integer, HashMap&lt;String, Cipher&gt;&gt;();

    /**
     * Sets the folders the documents have to be placed in.
     * @param encryptedFolder The folder encrypted files have to be placed in.
     * @param decryptedFolder The folder decrypted files have to be placed in.
     */
    public static void setFolders(String encryptedFolder, String decryptedFolder){
        FileEncrypter.encryptedFolder = encryptedFolder;
        FileEncrypter.decryptedFolder = decryptedFolder;
    }

    /**
     * A postfix to give to encrypted files. Can be """" for no postfix.
     * @param extension The postfix to append to encrypted files.
     */
    public static void setEncryptedPostfix(String extension){
        if (extension != null){
            FileEncrypter.encryptedPostfix = extension;
        }else{
            FileEncrypter.encryptedPostfix = """";
        }
    }

    /**
     * The salts to use when encrypting/decrypting files.
     * @param salt The salt to use.
     * @param ivParameterSpec The buffer with the IV.
     * @throws FileEncryptingException When the ivParameterSpec is smaller than 16 bytes.
     */
    public static void setSalts(String salt) throws FileEncryptingException{
        FileEncrypter.salt = salt.getBytes();
    }

    /**
     * Encode the given inputFile with the given key.
     * @param inputFile The file to encrypt.
     * @param key The key to use for encrypting the file.
     * @return The encrypted file.
     * @throws FileEncryptingException
     * @throws NoSuchAlgorithmException
     * @throws NoSuchPaddingException
     * @throws InvalidKeyException
     * @throws IOException
     * @throws InvalidKeySpecException
     * @throws InvalidAlgorithmParameterException
     */
    public static File encrypt(File inputFile, String key) throws FileEncryptingException, NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, IOException, InvalidKeySpecException, InvalidAlgorithmParameterException{
        if (isEncrypted(inputFile)){
            throw new FileEncryptingException(""File not decrypted: ""+inputFile.getAbsolutePath());
        }

        FileInputStream inputStream = new FileInputStream(inputFile);
        BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream);

        File outputFile = new File(inputFile.getAbsolutePath().replace(decryptedFolder,encryptedFolder) + encryptedPostfix);
        outputFile.getParentFile().mkdirs();
        FileOutputStream outputStream = new FileOutputStream(outputFile);
        BufferedOutputStream bufferedOutputStream = new BufferedOutputStream(outputStream);
        processStream(Cipher.ENCRYPT_MODE,key,bufferedInputStream,bufferedOutputStream);
        inputStream.close();
        outputStream.close();
        bufferedInputStream.close();
        bufferedOutputStream.close();
        return outputFile;
    }

    /**
     * Decrypt the given inputFile with the given key.
     * @param inputFile The file to decrypt.
     * @param key The key to use for decrypting the file.
     * @return The decrypted file.
     * @throws FileEncryptingException
     * @throws IOException
     * @throws NoSuchAlgorithmException
     * @throws NoSuchPaddingException
     * @throws InvalidKeyException
     * @throws InvalidKeySpecException
     * @throws InvalidAlgorithmParameterException
     */
    public static File decrypt(File inputFile, String key) throws FileEncryptingException, IOException, NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, InvalidKeySpecException, InvalidAlgorithmParameterException{
        if (!isEncrypted(inputFile)){
            throw new FileEncryptingException(""File not encrypted: ""+inputFile.getAbsolutePath());
        }

        if (!inputFile.exists() &amp;&amp; !inputFile.getAbsolutePath().contains(encryptedPostfix)){
            inputFile = new File(inputFile.getAbsolutePath()+encryptedPostfix);
        }

        FileInputStream inputStream = new FileInputStream(inputFile);
        BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream);

        File outputFile = new File(inputFile.getAbsolutePath().replace(encryptedPostfix, """").replace(encryptedFolder,decryptedFolder));
        outputFile.getParentFile().mkdirs();
        FileOutputStream outputStream = new FileOutputStream(outputFile);
        BufferedOutputStream bufferedOutputStream = new BufferedOutputStream(outputStream);
        processStream(Cipher.DECRYPT_MODE,key,bufferedInputStream,bufferedOutputStream);
        inputStream.close();
        outputStream.close();
        bufferedInputStream.close();
        bufferedOutputStream.close();
        return outputFile;
    }

    /**
     * Used for generating a cipher.
     * @param cipherMode The cipher mode to use. Either &lt;code&gt;Cipher.DECRYPT_MODE&lt;/code&gt; or &lt;code&gt;Cipher.ENCRYPT_MODE&lt;/code&gt;
     * @param key The key to generate the cipher with.
     * @return The generated cipher.
     * @throws NoSuchAlgorithmException
     * @throws InvalidKeySpecException
     * @throws NoSuchPaddingException
     * @throws InvalidKeyException
     * @throws InvalidAlgorithmParameterException
     */
    private static Cipher getCipher(int cipherMode, String key) throws NoSuchAlgorithmException, InvalidKeySpecException, NoSuchPaddingException, InvalidKeyException, InvalidAlgorithmParameterException {
        if (!ciphers.containsKey(cipherMode)){
            synchronized (ciphers){
                if (!ciphers.containsKey(cipherMode)){
                    ciphers.put(cipherMode, new HashMap&lt;String,Cipher&gt;());
                }
            }
        }
        HashMap&lt;String, Cipher&gt; hashMap = ciphers.get(cipherMode);
        if (!hashMap.containsKey(key)){
            synchronized (hashMap) {
                if (!hashMap.containsKey(key)){
                    SecretKeyFactory factory = SecretKeyFactory.getInstance(""PBKDF2WithHmacSHA1"");
                    KeySpec spec = new PBEKeySpec(key.toCharArray(), salt, 65536, 128);
                    SecretKey tmp = factory.generateSecret(spec);
                    SecretKey secret = new SecretKeySpec(tmp.getEncoded(), ""RC4"");

                    Cipher c = Cipher.getInstance(""RC4"");
                    c.init(cipherMode, secret);
                    hashMap.put(key, c);
                }
            }
        }
        return hashMap.get(key);
    }

    /**
     * Process a stream. This will encrypt or decrypt the stream, depending on the given cipherMode. The output will be available in the given {@link OutputStream}.
     * @param cipherMode The cipher mode to use. Either &lt;code&gt;Cipher.DECRYPT_MODE&lt;/code&gt; or &lt;code&gt;Cipher.ENCRYPT_MODE&lt;/code&gt;
     * @param key The key to use for decryption/encryption.
     * @param inputStream The stream to read from.
     * @param outputStream The stream to write the encrypted/decrypted result to.
     * @throws InvalidKeyException
     * @throws NoSuchAlgorithmException
     * @throws InvalidKeySpecException
     * @throws NoSuchPaddingException
     * @throws InvalidAlgorithmParameterException
     * @throws IOException
     */
    public static void processStream(int cipherMode, String key, InputStream inputStream, OutputStream outputStream) throws InvalidKeyException, NoSuchAlgorithmException, InvalidKeySpecException, NoSuchPaddingException, InvalidAlgorithmParameterException, IOException{
        Cipher c = getCipher(cipherMode,key);
        CipherOutputStream cipherOutputStream = new CipherOutputStream(outputStream, c);
        int b = 0;
        while ((b = inputStream.read()) !=-1){
            cipherOutputStream.write(b);
        }
        cipherOutputStream.close();
    }

    /**
     * Returns a file, no matter whether it's encrypted or not. See {@link #isEncrypted(File)} to detect if the file is encrypted.
     * @param filenameDecrypted The filename the decrypted file would have.
     * @return The file that corresponds with the given filename.
     */
    public static File getFile(String filenameDecrypted){
        if (!filenameDecrypted.contains(decryptedFolder) &amp;&amp; !filenameDecrypted.contains(encryptedFolder)){
            filenameDecrypted = decryptedFolder + filenameDecrypted;
        }
        File file = new File(filenameDecrypted);
        if (!file.exists()){
            file = new File(filenameDecrypted.replace(decryptedFolder, encryptedFolder)+encryptedPostfix);
        }
        return file;
    }

    /**
     * Checks if the file is encrypted or not.
     * @param file The file to check.
     * @return True if the file is encrypted, false otherwise.
     */
    public static boolean isEncrypted(File file){
        return file.getAbsolutePath().contains(encryptedFolder) || (!encryptedPostfix.isEmpty() &amp;&amp; file.getAbsolutePath().contains(encryptedPostfix));
    }
}
",4,0,393640ac8f848cf324c91eff0f44a486d3fdf388bb7ee4104c2a7806d067e5a4
,"RSAPublicKeySpec rsaPublicKeySpec = new RSAPublicKeySpec(mod,exp);
KeyFactory keyFactory = KeyFactory.getInstance(""RSA"",""BS"");
PublicKey publicKey = keyFactory.generatePublic(rsaPublicKeySpec);
Cipher cipher = Cipher.getInstance(""RSA/None/PKCS1Padding"", ""BS"");
cipher.init(Cipher.ENCRYPT_MODE, publicKey);
byte[] encryptedBytes = cipher.doFinal(plainText.getBytes(""UTF-8""));//
byte[] coded = Base64.encodeBase64(encryptedBytes);  //used library encode decode
String encryptedData = new String(encodedBytes);
",3,0,d14fde1ae037ecde76c7dc4dadb8b2041dcce7fdbaf81991e63a89079f6afc41
,"package il.co.falk;

import javax.crypto.*;
import javax.crypto.spec.PBEKeySpec;
import javax.crypto.spec.SecretKeySpec;
import java.security.*;
import java.security.spec.KeySpec;
import java.security.spec.PKCS8EncodedKeySpec;

public class SecureFile {
private PublicKey publicKey;
private byte[] privateKeyArray;
private byte[] salt = {1,2,3,4,5,6,7,8};


public static void main(String[] args) {
    String password = ""PASSWORD"";
    SecureFile secureFile = new SecureFile(password);
    secureFile.test();
}


public void test() {
    String password = ""PASSWORD"";
    String imageFile = ""348756348975634897562398479623896"";

    ImageAndKey imageAndKey = encryptImage(imageFile.getBytes());
    byte[] decryptedImage = decryptImage(imageAndKey, password);

    System.out.println(new String(imageFile));
    System.out.println(new String(decryptedImage));
}

public SecureFile(String password) {
    try {
        generateRSAKeys(password);
    } catch (Exception e) {
        e.printStackTrace();
    }
}



public ImageAndKey encryptImage(byte[] imageBytes) {
    try {
        byte[] secretKeyBytes = generateAESKey();
        byte[] encryptedFile = aesEncrypt(imageBytes, secretKeyBytes);
        byte[] encryptedKey = rsaEncrypt(secretKeyBytes);

        return new ImageAndKey(encryptedFile, encryptedKey);
    } catch (Exception e) {
        e.printStackTrace();
        return null;
    }

}

public byte[] decryptImage(ImageAndKey imageAndKey, String password) {
    try {
        byte[] secretKeyBytes = generateAESKey(password);
        byte[] decryptedPrivateKey = aesDecrypt(privateKeyArray, secretKeyBytes);
        byte[] decryptedKey = rsaDecrypt(imageAndKey.aesKey, decryptedPrivateKey);

        SecretKey secretKey = new SecretKeySpec(decryptedKey, ""AES"");
        secretKeyBytes = secretKey.getEncoded();

        byte[] decryptedBytes = aesDecrypt(imageAndKey.imageBytes, secretKeyBytes);

        return  decryptedBytes;
    } catch (Exception e) {
        e.printStackTrace();
    }
    return null;
}



// RSA
private void generateRSAKeys(String password) throws Exception {
    final KeyPairGenerator keyGen = KeyPairGenerator.getInstance(""RSA"");
    keyGen.initialize(512); // TODO: make this 2048 at least
    final KeyPair keyPair = keyGen.generateKeyPair();
    publicKey = keyPair.getPublic();
    PrivateKey privateKey = keyPair.getPrivate();

    byte[] secretKeyBytes = generateAESKey(password);
    byte[] privateKeyBytes = privateKey.getEncoded();
    privateKeyArray = aesEncrypt(privateKeyBytes, secretKeyBytes);
}

public byte[] rsaEncrypt(byte[] plainText) throws Exception {
    final Cipher cipher = Cipher.getInstance(""RSA"");
    cipher.init(Cipher.ENCRYPT_MODE, publicKey);
    byte[] cipherText = cipher.doFinal(plainText);
    return cipherText;
}

public byte[] rsaDecrypt(byte[] cipherText, byte[] decryptedPrivateKeyArray) throws Exception {
    PrivateKey privateKey = KeyFactory.getInstance(""RSA"").generatePrivate(new PKCS8EncodedKeySpec(decryptedPrivateKeyArray));

    final Cipher cipher = Cipher.getInstance(""RSA"");
    cipher.init(Cipher.DECRYPT_MODE, privateKey);
    byte[]  plainText = cipher.doFinal(cipherText);
    return plainText;
}

// AES
private byte[] aesEncrypt(byte[] plainText, byte[] secretKeyBytes) throws Exception {
    Cipher cipher = Cipher.getInstance(""AES/ECB/PKCS5Padding"");
    cipher.init(Cipher.ENCRYPT_MODE, getSecretKey(secretKeyBytes));
    byte[] cipherText = cipher.doFinal(plainText);
    return cipherText;
}

public byte[] aesDecrypt(byte[] cipherText, byte[] secretKeyBytes) throws Exception {
    Cipher cipher = Cipher.getInstance(""AES/ECB/PKCS5Padding"");
    cipher.init(Cipher.DECRYPT_MODE, getSecretKey(secretKeyBytes));
    byte[] plainText = cipher.doFinal(cipherText);
    return plainText;
}

private byte[] generateAESKey() throws Exception {
    KeyGenerator keyGen = KeyGenerator.getInstance(""AES"");
    keyGen.init(256);
    SecretKey secretKey = keyGen.generateKey();
    return secretKey.getEncoded();
}

private byte[] generateAESKey(String password) throws Exception {
    SecretKeyFactory factory = SecretKeyFactory.getInstance(""PBKDF2WithHmacSHA1"");
    KeySpec spec = new PBEKeySpec(password.toCharArray(), salt, 65536, 256);
    SecretKey tmp = factory.generateSecret(spec);
    SecretKey secret = new SecretKeySpec(tmp.getEncoded(), ""AES"");
    return secret.getEncoded();
}

private SecretKey getSecretKey(byte[] secretKeyBytes) throws Exception {
    SecretKey secretKey = new SecretKeySpec(secretKeyBytes, ""AES"");
    return secretKey;
}



// Classes
class ImageAndKey {
    public byte[] imageBytes;
    public byte[] aesKey;

    public ImageAndKey(byte[] imageBytes, byte[] aesKey) {
        this.imageBytes = imageBytes;
        this.aesKey = aesKey;
    }
}
",4,0,6eb2201277f9294eed542964df2370a50d68727891d518d485310a532f4ba85c
,"X509TrustManager trustManager = new X509TrustManager() {
                @Override
                public void checkClientTrusted(X509Certificate[] chain,
                        String authType) throws CertificateException {
                    for (TrustManager tm : managers) {
                        if (tm instanceof X509TrustManager) {
                            ((X509TrustManager) tm).checkClientTrusted(
                                    chain, authType);
                        }
                    }
                }

                @Override
                public void checkServerTrusted(X509Certificate[] chain,
                        String authType) throws CertificateException {
                    for (X509Certificate cert : chain) {
                        // cert gives the server Certificate Information.
                        if (cert.getIssuerX500Principal().equals(
                                trustedRoot.getIssuerX500Principal())) {
                            return;
                        }
                    }
                    for (TrustManager tm : managers) {
                        if (tm instanceof X509TrustManager) {
                            ((X509TrustManager) tm).checkServerTrusted(
                                    chain, authType);
                        }
                    }
                }

                @Override
                public X509Certificate[] getAcceptedIssuers() {
                    ArrayList&lt;X509Certificate&gt; issuers = new ArrayList&lt;&gt;();
                    for (TrustManager tm : managers) {
                        if (tm instanceof X509TrustManager) {
                            issuers.addAll(Arrays
                                    .asList(((X509TrustManager) tm)
                                            .getAcceptedIssuers()));
                        }
                    }
                    return issuers.toArray(new X509Certificate[issuers
                            .size()]);
                }

            };
",4,0,7594d9c7cf448d727ee0c61bc8db80b6f4d8d7e8269e700bf27de82f4ba14e6e
,"public byte[] digest(String value) throws NoSuchAlgorithmException {
    MessageDigest digester = MessageDigest.getInstance(""SHA-256"");

    byte[] stringBytes = value.getBytes();

    digester.update(stringBytes, 0, stringBytes.length);

    return digester.digest();
}
",2,0,793cdfe01ae46e8908699f4bc450a8d71508c5947088d08ea97795c82646fa50
,"public String convert(String str){
        String a=null;
         char hexDigits[] = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 
                  'a', 'b', 'c', 'd', 'e', 'f' }; 
        try {
            a=new   String(str.getBytes(""ISO8859_1""),""UTF-8"");
            byte[] strTemp = str.getBytes(); 
            MessageDigest mdTemp = MessageDigest.getInstance(""MD5""); 
               mdTemp.update(strTemp); 
               byte[] md = mdTemp.digest(); 
               int j = md.length; 
               char str1[] = new char[j * 2]; 
               int k = 0; 
               for (int i = 0; i &lt; j; i++) { 
                byte b = md[i]; 
                //System.out.println((int)b);  
                str1[k++] = hexDigits[b &gt;&gt; 4 &amp; 0xf]; 
                str1[k++] = hexDigits[b &amp; 0xf]; 
               } 


        } catch (Exception e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
 return new String(str1); 

}
",,1,95f3442b75533bbd36f12c18b66a01982165e75d43d95980f1197182f40bf2b0
,"KeyStore ks = KeyStore.getInstance(""AndroidCAStore"");
ks.load(null, null);
Enumeration aliases = ks.aliases();
while (aliases.hasMoreElements()) {
    String alias = aliases.nextElement();
    X09Certificate cert = (X509Certificate) 
       ks.getCertificate(alias);
    Log.d(TAG, ""Subject DN: "" + 
       cert.getSubjectDN().getName());
    Log.d(TAG, ""Issuer DN: "" + 
       cert.getIssuerDN().getName());
}
",,1,81ee39678c32fefe603568686fcf3cecc50cfe012e9525f2581945d70530f07b
,"public static String makeCheck(String url)
{
    URL u=new URL(url);
    MessageDigest md = MessageDigest.getInstance(""MD5"");
    u.getQuery();
    md.update(u.getQuery().getBytes());
    BigInteger bn = new BigInteger(1,md.digest(""A_SECRET_WORD"".getBytes()));
    return bn.toString(16);
}
",,1,1c81e8a29d1498b5bb7a10ec1f46bbdb3856c972e61d2240c07a8a662283d612
,"byte temp[];
Base64 b = new Base64();
String jsonString = clientHash.getJSONObject(""client_auth_hash"").toString();
temp = b.decode(jsonString.getBytes());
",,1,57d334654f5d671d2848c6c66c763cc84e648e7646acbd367693b6ed28bdfdd9
,"public void sslCheck() {

        int PLAY_SERVICES_RESOLUTION_REQUEST=9000;
        int resultCode = GooglePlayServicesUtil.isGooglePlayServicesAvailable(this);
        //Log.i(""log_tag2"", String.valueOf(resultCode));
        if (resultCode != ConnectionResult.SUCCESS) {
            if (GooglePlayServicesUtil.isUserRecoverableError(resultCode)) {
                Log.i(""log_tag2"",""Not good!"");
                if (MyAppActivity.instance != null) {
                    Log.i(""log_tag2"",""but can fix"");
                    GooglePlayServicesUtil.getErrorDialog(
                            resultCode,
                            MyAppActivity.instance,
                            PLAY_SERVICES_RESOLUTION_REQUEST).show();
                }
            }
        }
        else {
            Log.i(""log_tag2"",""Already good!"");
            try {
                ProviderInstaller.installIfNeeded(this);
                Log.i(""log_tag"", ""1"");
            } catch (GooglePlayServicesRepairableException e) {
                e.printStackTrace();
            } catch (GooglePlayServicesNotAvailableException e) {
                e.printStackTrace();
            }
            SSLContext helper=null;
            try {
                helper = SSLContext.getInstance(""TLSv1.2"");
                Log.i(""log_tag"",""2"");
            } catch (NoSuchAlgorithmException e) {
                e.printStackTrace();
            }
            try {
                helper.init(null,null,null);
                Log.i(""log_tag"", ""3"");
            } catch (KeyManagementException e) {
                e.printStackTrace();
            }
            SSLEngine engine = helper.createSSLEngine();
        }
    }
",2,0,cd45083ea9a338e1d4663628eedf654a15c26399ba20ec41814b0b0389c9cf7a
,"// 16 characters for 128-bit AES
private final static String PASSPHRASE=""myappspassphrase""

SecretKeySpec key = new SecretKeySpec(PASSPHRASE.getBytes(""UTF-8""), ""AES"");

...

// Initialise the cipher
Cipher encryptCipher = Cipher.getInstance(""AES"");
encryptCipher.init(Cipher.ENCRYPT_MODE, key);
",4,0,a598548aa8d1b0576922b5b8dfbc2efb3aa9966950e1394dc857470d4f3d539a
,"/**
 * Warning, this gives a false sense of security.  If an attacker has enough access to
 * acquire your password store, then he almost certainly has enough access to acquire your
 * source binary and figure out your encryption key.  However, it will prevent casual
 * investigators from acquiring passwords, and thereby may prevent undesired negative
 * publicity.
 */
public class ObscuredSharedPreferences implements SharedPreferences {
    protected static final String UTF8 = ""utf-8"";
    private static final char[] SEKRIT = ... ; // INSERT A RANDOM PASSWORD HERE.
                                               // Don't use anything you wouldn't want to
                                               // get out there if someone decompiled
                                               // your app.


    protected SharedPreferences delegate;
    protected Context context;

    public ObscuredSharedPreferences(Context context, SharedPreferences delegate) {
        this.delegate = delegate;
        this.context = context;
    }

    public class Editor implements SharedPreferences.Editor {
        protected SharedPreferences.Editor delegate;

        public Editor() {
            this.delegate = ObscuredSharedPreferences.this.delegate.edit();                    
        }

        @Override
        public Editor putBoolean(String key, boolean value) {
            delegate.putString(key, encrypt(Boolean.toString(value)));
            return this;
        }

        @Override
        public Editor putFloat(String key, float value) {
            delegate.putString(key, encrypt(Float.toString(value)));
            return this;
        }

        @Override
        public Editor putInt(String key, int value) {
            delegate.putString(key, encrypt(Integer.toString(value)));
            return this;
        }

        @Override
        public Editor putLong(String key, long value) {
            delegate.putString(key, encrypt(Long.toString(value)));
            return this;
        }

        @Override
        public Editor putString(String key, String value) {
            delegate.putString(key, encrypt(value));
            return this;
        }

        @Override
        public void apply() {
            delegate.apply();
        }

        @Override
        public Editor clear() {
            delegate.clear();
            return this;
        }

        @Override
        public boolean commit() {
            return delegate.commit();
        }

        @Override
        public Editor remove(String s) {
            delegate.remove(s);
            return this;
        }
    }

    public Editor edit() {
        return new Editor();
    }


    @Override
    public Map&lt;String, ?&gt; getAll() {
        throw new UnsupportedOperationException(); // left as an exercise to the reader
    }

    @Override
    public boolean getBoolean(String key, boolean defValue) {
        final String v = delegate.getString(key, null);
        return v!=null ? Boolean.parseBoolean(decrypt(v)) : defValue;
    }

    @Override
    public float getFloat(String key, float defValue) {
        final String v = delegate.getString(key, null);
        return v!=null ? Float.parseFloat(decrypt(v)) : defValue;
    }

    @Override
    public int getInt(String key, int defValue) {
        final String v = delegate.getString(key, null);
        return v!=null ? Integer.parseInt(decrypt(v)) : defValue;
    }

    @Override
    public long getLong(String key, long defValue) {
        final String v = delegate.getString(key, null);
        return v!=null ? Long.parseLong(decrypt(v)) : defValue;
    }

    @Override
    public String getString(String key, String defValue) {
        final String v = delegate.getString(key, null);
        return v != null ? decrypt(v) : defValue;
    }

    @Override
    public boolean contains(String s) {
        return delegate.contains(s);
    }

    @Override
    public void registerOnSharedPreferenceChangeListener(OnSharedPreferenceChangeListener onSharedPreferenceChangeListener) {
        delegate.registerOnSharedPreferenceChangeListener(onSharedPreferenceChangeListener);
    }

    @Override
    public void unregisterOnSharedPreferenceChangeListener(OnSharedPreferenceChangeListener onSharedPreferenceChangeListener) {
        delegate.unregisterOnSharedPreferenceChangeListener(onSharedPreferenceChangeListener);
    }




    protected String encrypt( String value ) {

        try {
            final byte[] bytes = value!=null ? value.getBytes(UTF8) : new byte[0];
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(""PBEWithMD5AndDES"");
            SecretKey key = keyFactory.generateSecret(new PBEKeySpec(SEKRIT));
            Cipher pbeCipher = Cipher.getInstance(""PBEWithMD5AndDES"");
            pbeCipher.init(Cipher.ENCRYPT_MODE, key, new PBEParameterSpec(Settings.Secure.getString(context.getContentResolver(),Settings.System.ANDROID_ID).getBytes(UTF8), 20));
            return new String(Base64.encode(pbeCipher.doFinal(bytes), Base64.NO_WRAP),UTF8);

        } catch( Exception e ) {
            throw new RuntimeException(e);
        }

    }

    protected String decrypt(String value){
        try {
            final byte[] bytes = value!=null ? Base64.decode(value,Base64.DEFAULT) : new byte[0];
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(""PBEWithMD5AndDES"");
            SecretKey key = keyFactory.generateSecret(new PBEKeySpec(SEKRIT));
            Cipher pbeCipher = Cipher.getInstance(""PBEWithMD5AndDES"");
            pbeCipher.init(Cipher.DECRYPT_MODE, key, new PBEParameterSpec(Settings.Secure.getString(context.getContentResolver(),Settings.System.ANDROID_ID).getBytes(UTF8), 20));
            return new String(pbeCipher.doFinal(bytes),UTF8);

        } catch( Exception e) {
            throw new RuntimeException(e);
        }
    }

}
",4,0,60d6eae0b6507534bb606befacf3bb120b869b3a8c382e8e91e541aa592b9b49
,"private class UploadFileToServer extends AsyncTask&lt;Void, Integer, String&gt; {
    JSONObject jsonObject = null;

    @Override
    protected void onPreExecute() {

        upload_image_progress.setProgress(0);

         int totalSize = 0
        super.onPreExecute();
    }

    @Override
    protected void onProgressUpdate(Integer... progress) {
        // Making progress bar visible
        upload_image_progress.setVisibility(View.VISIBLE);
        // mHandler.sendEmptyMessageDelayed(progress[0], 100);
        // updating progress bar value
        upload_image_progress.setProgress(progress[0]);

        // updating percentage value
        // txtPercentage.setText(String.valueOf(progress[0]) + ""%"");
    }

    @Override
    protected String doInBackground(Void... params) {
        return uploadFile();
    }

    private String uploadFile() {

        String responseString = null;
        try {

            HostnameVerifier hostnameVerifier = org.apache.http.conn.ssl.SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER;

            HttpClient client = new DefaultHttpClient();

            SchemeRegistry registry = new SchemeRegistry();
            SSLSocketFactory socketFactory = SSLSocketFactory
                    .getSocketFactory();
            socketFactory
                    .setHostnameVerifier((X509HostnameVerifier) hostnameVerifier);

            registry.register(new Scheme(""http"", socketFactory, 443));
            SingleClientConnManager mgr = new SingleClientConnManager(
                    client.getParams(), registry);
            DefaultHttpClient httpClient = new DefaultHttpClient(mgr,
                    client.getParams());

            // Set verifier
            HttpsURLConnection.setDefaultHostnameVerifier(hostnameVerifier);


            HttpPost httpPost = new HttpPost(""your url"");


            AndroidMultiPartEntity entity = new AndroidMultiPartEntity(
                    new ProgressListener() {

                        @Override
                        public void transferred(long num) {
                            publishProgress((int) ((num * 100) / totalSize));

                        }
                    });

            File sourceFile = new File(""image path"");
            long fileSizeInBytes = sourceFile.length();

            // Convert the bytes to Kilobytes (1 KB = 1024 Bytes)
            long fileSizeInKB = fileSizeInBytes / 1024;

            // Convert the KB to MegaBytes (1 MB = 1024 KBytes)
            long fileSizeInMB = fileSizeInKB / 1024;
            // Log.e(""file length in MB"", """" + fileSizeInMB);
            if (fileSizeInMB &gt; 2) {

                BitmapFactory.Options options = new BitmapFactory.Options();
                options.inSampleSize = 8;

                Bitmap bmp = BitmapFactory.decodeFile(image_uri, options);

                ByteArrayOutputStream bos = new ByteArrayOutputStream();
                bmp.compress(CompressFormat.JPEG, 70, bos);
                InputStream in = new ByteArrayInputStream(bos.toByteArray());

                ContentBody foto = new InputStreamBody(in, ""image/jpeg"",
                        image_uri);

                Log.e(""size"", """" + bos.size());

                entity.addPart(""image_file"", foto);


                totalSize = bos.size();
                Log.e(""file length"", """" + sourceFile.length());

                // Adding file data to http body
            } else {
                entity.addPart(""image_file"", new FileBody(sourceFile));
                totalSize = entity.getContentLength();

            }

            httpPost.setEntity(entity);

            HttpResponse response = client.execute(httpPost);

            // Making server call

            HttpEntity r_entity = response.getEntity();

            int statusCode = response.getStatusLine().getStatusCode();
            if (statusCode == 200) {
                // Server response
                responseString = EntityUtils.toString(r_entity);
                jsonObject = new JSONObject(responseString);
            } else {

                responseString = ""Error occurred! Http Status Code: ""
                        + statusCode;
            }

        } catch (ClientProtocolException e) {
            responseString = e.toString();
            e.printStackTrace();

        } catch (IOException e) {
            e.printStackTrace();
            responseString = e.toString();

        } catch (Exception e) {
            e.printStackTrace();

        }

        return responseString;

    }

    @Override
    protected void onPostExecute(String result) {
        try {

            if (jsonObject != null) {
                //get response here
                }
        super.onPostExecute(result);
    }

}
",4,0,15d84233f5e0b8d314518634298afa18d8073d56493dc1a422f47ca0ac2555ad
,"                KeyPairGenerator keyGen = KeyPairGenerator.getInstance(""RSA"");
    keyGen.initialize(1024);
    KeyPair keyPair = keyGen.generateKeyPair();
    RSAPrivateKey privateKey = (RSAPrivateKey) keyPair.getPrivate();
    RSAPublicKey publicKey = (RSAPublicKey) keyPair.getPublic();
    BigInteger mod_Int = publicKey.getModulus();
    BigInteger exp_Int = publicKey.getPublicExponent();
    byte[] mod_Bytes_Extra = mod_Int.toByteArray();
    byte[] mod_Bytes = new byte[128];
    System.arraycopy(mod_Bytes_Extra, 1, mod_Bytes, 0, 128);
    byte[] exp_Bytes = exp_Int.toByteArray();
    String modulus = Base64.encodeToString(mod_Bytes, Base64.DEFAULT);
    String exponent = Base64.encodeToString(exp_Bytes, Base64.DEFAULT);
    System.out.println(modulus);
    System.out.println(exponent);
    String public_Xml = ""&lt;BitStrength&gt;0124&lt;/BitStrength&gt;&lt;RSAKeyValue&gt;&lt;Modulus&gt;""+modulus+""&lt;/Modulus&gt;&lt;Exponent&gt;""+exponent+""&lt;/Exponent&gt;&lt;/RSAKeyValue&gt;"";
",4,0,891f9ca05ee7a882bb5fc5e18988c28deca3282f56ede74bdea430da30a51d99
,"public HttpClient getNewHttpClient() {
        try {
            KeyStore trustStore = KeyStore.getInstance(KeyStore
                    .getDefaultType());
            trustStore.load(null, null);

            SSLSocketFactory sf = new MySSLSocketFactory(trustStore);
            sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);

            HttpParams params = new BasicHttpParams();
            HttpProtocolParams.setVersion(params, HttpVersion.HTTP_1_1);
            HttpProtocolParams.setContentCharset(params, HTTP.UTF_8);

            SchemeRegistry registry = new SchemeRegistry();
            registry.register(new Scheme(""http"", PlainSocketFactory
                    .getSocketFactory(), 80));
            registry.register(new Scheme(""https"", sf, 443));

            ClientConnectionManager ccm = new ThreadSafeClientConnManager(
                    params, registry);

            return new DefaultHttpClient(ccm, params);
        } catch (Exception e) {
            return new DefaultHttpClient();
        }
    }



public class MySSLSocketFactory extends SSLSocketFactory {
    SSLContext sslContext = SSLContext.getInstance(""TLS"");

    public MySSLSocketFactory(KeyStore truststore) throws NoSuchAlgorithmException, KeyManagementException, KeyStoreException, UnrecoverableKeyException {
        super(truststore);

        TrustManager tm = new X509TrustManager() {
            public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {
            }

            public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {
            }

            public X509Certificate[] getAcceptedIssuers() {
                return null;
            }
        };

        sslContext.init(null, new TrustManager[] { tm }, null);
    }

    @Override
    public Socket createSocket(Socket socket, String host, int port, boolean autoClose) throws IOException, UnknownHostException {
        return sslContext.getSocketFactory().createSocket(socket, host, port, autoClose);
    }

    @Override
    public Socket createSocket() throws IOException {
        return sslContext.getSocketFactory().createSocket();
    }
}
",4,0,c6ac3d96c7a213b983760065af61417bcc05a9fcb5bd2ca9f3879a71596368bd
,"public void printHashKey() {

   // Add code to print out the key hash
    try {
        PackageInfo info = getPackageManager().getPackageInfo(""com.facebook.samples.hellofacebook"", 
                PackageManager.GET_SIGNATURES);

        for (Signature signature : info.signatures) {
            MessageDigest md = MessageDigest.getInstance(""SHA"");
            md.update(signature.toByteArray());
            Log.d(""KeyHash:"", Base64.encodeToString(md.digest(), Base64.DEFAULT));
        }
    } catch (NameNotFoundException e) {

    } catch (NoSuchAlgorithmException e) {
}
",3,0,9a74e4dcb8ddc3509ab4c44514d902535e308cca85ea3d756c1629557f38b9ac
,"public String encrypt(String unencryptedString, byte[] ivBytes, byte[] keyBytes){

 String encryptedString = null;

   try {

        AlgorithmParameterSpec ivSpec = new IvParameterSpec(ivBytes);
        SecretKeySpec Key = new SecretKeySpec(keyBytes, ""AES"");
        Cipher cipher = null;
        cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
        cipher.init(Cipher.ENCRYPT_MODE, key);
        byte[] plainText = unencryptedString.getBytes(UNICODE_FORMAT);
        byte[] encryptedText = cipher.doFinal(plainText);
        encryptedString = new String(Base64.encodeBase64(encryptedText));

                } catch (Exception e) {
                    e.printStackTrace();
                }
                return encryptedString;
            }
",1,0,9dfcebcaaf6fef10eb9659bf2918dfac648c6d1e749a9cb351639e2f96c2095c
,"// Create the OkHttp client        
OkHttpClient okHttpClient = new OkHttpClient();
SSLContext sslContext;
try {
    sslContext = SSLContext.getInstance(""TLS"");
    sslContext.init(null, null, null);
} catch (GeneralSecurityException e) {
    throw new AssertionError(); // The system has no TLS. Just give up.
}
Client client = okHttpClient.setSslSocketFactory(sslContext.getSocketFactory());

// Create the Retrofit RestAdapter
RestAdapter.LogLevel logLevel = BuildConfig.DEBUG ? RestAdapter.LogLevel.FULL : RestAdapter.LogLevel.NONE;
return new RestAdapter.Builder()
        .setEndpoint(BuildConfig.API_URL)
        .setClient(client)
        .setConverter(new GsonConverter(getGson()))
        .setRequestInterceptor(new RetrofitAuthenticationInterceptor())
        .setLogLevel(logLevel)
        .build()
        .create(ApiServiceV1.class);
",3,0,735c7b10736d5171c65a56fe01d26d9b149bff0e11450cc1415be68687efeb3b
,"public static class _FakeX509TrustManager implements X509TrustManager {

    private static TrustManager[] trustManagers;
    private static final X509Certificate[] _AcceptedIssuers = new X509Certificate[] {};

    @Override
    public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {
    }

    @Override
    public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {
    }

    public boolean isClientTrusted(X509Certificate[] chain) {
            return true;
    }

    public boolean isServerTrusted(X509Certificate[] chain) {
            return true;
    }

    @Override
    public X509Certificate[] getAcceptedIssuers() {
            return _AcceptedIssuers;
    }

    public static void allowAllSSL() {
        HttpsURLConnection.setDefaultHostnameVerifier(new 
                HostnameVerifier(){
                @Override
                public boolean verify(String hostname, SSLSession session) {
                        return true;
                }

        });

        SSLContext context = null;
        if (trustManagers == null) {
                trustManagers = new TrustManager[] { new _FakeX509TrustManager() };
        }

        try {
                context = SSLContext.getInstance(""TLS"");
                context.init(null, trustManagers, new SecureRandom());
        } catch (NoSuchAlgorithmException e) {
                e.printStackTrace();
        } catch (KeyManagementException e) {
                e.printStackTrace();
        }


        HttpsURLConnection.setDefaultSSLSocketFactory(context.getSocketFactory());
}
",4,0,ab6f5ca1793c94c91e094a3903f8ab9090ef69a848e505e27078334eb7267bae
,"static public byte[] decrypt(Cipher cipher, SecretKey key, byte[]... bytes)
        throws GeneralSecurityException, IOException {
    cipher.init(Cipher.DECRYPT_MODE, key);
    ByteArrayOutputStream bos = new ByteArrayOutputStream();
    for (int i = 0; i &lt; bytes.length; i++) {
        bos.write(cipher.update(bytes[i]));
    }
    bos.write(cipher.doFinal());
    return bos.toByteArray();
}
",2,0,88e2302848b586ffe21b134d1046cba826afc3a9f01afd585dafc895e0416786
,"String android_id = Settings.Secure.getString(
            this.getContentResolver(), Settings.Secure.ANDROID_ID);
String deviceId = md5(android_id).toUpperCase();


public static final String md5(final String s) {
    try {
        // Create MD5 Hash
        MessageDigest digest = java.security.MessageDigest
                .getInstance(""MD5"");
        digest.update(s.getBytes());
        byte messageDigest[] = digest.digest();

        // Create Hex String
        StringBuffer hexString = new StringBuffer();
        for (int i = 0; i &lt; messageDigest.length; i++) {
            String h = Integer.toHexString(0xFF &amp; messageDigest[i]);
            while (h.length() &lt; 2)
                h = ""0"" + h;
            hexString.append(h);
        }
        return hexString.toString();

    } catch (NoSuchAlgorithmException e) {
        e.printStackTrace();
    }
    return """";
}
",,1,17fc35858a4b1d0509d6ad3b22dd8c499f863d0bd657df6259736a9b1a10549f
,"Security.addProvider(new BouncyCastleProvider());

final char[] password = ""pass"".toCharArray();
final int saltLength = 8;
final String saltedPrefix = ""Salted__"";

String[] files = { ""file0.txt.enc"", ""file0.txt.enc.nosalt"" };
for (String file : files) {
    byte[] encrypted = Files.readAllBytes(Paths.get(""testData"", ""openssl"", file));

    byte[] salt = new byte[0];
    int offset = 0;
    if (new String(encrypted, 0, saltLength, ""ASCII"").equals(saltedPrefix)) {
        salt = new byte[saltLength];
        System.arraycopy(encrypted, saltedPrefix.length(), salt, 0, saltLength);
        offset = saltedPrefix.length() + saltLength;
    }

    SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(""PBEWITHMD5AND256BITAES-CBC-OPENSSL"", ""BC"");
    PBEKeySpec keySpec = new PBEKeySpec(password);
    PBEParameterSpec paramSpec = new PBEParameterSpec(salt, 0);
    Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"", ""BC"");
    cipher.init(Cipher.DECRYPT_MODE, keyFactory.generateSecret(keySpec), paramSpec);

    byte[] data = cipher.doFinal(encrypted, offset, encrypted.length- offset);
    System.out.println(new String(data));
}
",4,0,7936ab6831980ab5a470594caed179a43ec7a82b1645af8bb424d2768e4b5cde
,"try {
            String secret = ""secret"";
            String message = ""Message"";

            Mac sha_HMAC = Mac.getInstance(""HmacSHA512"");

            SecretKeySpec secret_key = new SecretKeySpec(secret.getBytes(), ""HmacSHA512"");
            sha_HMAC.init(secret_key);

            String hash = Base64.encodeToString(sha_HMAC.doFinal(message.getBytes()), Base64.DEFAULT);
            System.out.println(hash);
            Log.e(""string is "",hash);

        }
        catch (Exception e){
            System.out.println(""Error"");
        }
",2,0,2ec36566838f914a7e758c8c946fcbf8cbff1c00eff4f54406099225d1c72918
,"private static byte[] Rfc2898DeriveBytes(String password, byte[] salt, int iterations) throws GeneralSecurityException {

    SecretKeyFactory factory = SecretKeyFactory.getInstance(""PBKDF2WithHmacSHA1"");
    PBEKeySpec pbeKeySpec = new PBEKeySpec(password.toCharArray(), salt, Iterations, 256);
    Key secretKey = factory.generateSecret(pbeKeySpec);
    byte[] rawKeyData = secretKey.getEncoded();
    return rawKeyData;
}
",3,0,ab7fad82021e0781bcb7e214f86a1ed0e7706fe7eae736944c592384e04814fe
,"public static byte[] generateKey(String password) throws Exception
{
    byte[] keyStart = password.getBytes(""UTF-8"");

    KeyGenerator kgen = KeyGenerator.getInstance(""AES"");
    SecureRandom sr = SecureRandom.getInstance(""SHA1PRNG"", ""Crypto"");
    sr.setSeed(keyStart);
    kgen.init(128, sr);
    SecretKey skey = kgen.generateKey();
    return skey.getEncoded();
}

    public static byte[] encodeFile(byte[] key, byte[] fileData) throws Exception
    {

        SecretKeySpec skeySpec = new SecretKeySpec(key, ""AES"");
        Cipher cipher = Cipher.getInstance(""AES"");
        cipher.init(Cipher.ENCRYPT_MODE, skeySpec);

        byte[] encrypted = cipher.doFinal(fileData);

        return encrypted;
    }

    public static byte[] decodeFile(byte[] key, byte[] fileData) throws Exception
    {
        SecretKeySpec skeySpec = new SecretKeySpec(key, ""AES"");
        Cipher cipher = Cipher.getInstance(""AES"");
        cipher.init(Cipher.DECRYPT_MODE, skeySpec);

        byte[] decrypted = cipher.doFinal(fileData);

        return decrypted;
    }
",3,0,b2cea52e04b15d2c96fb4efe9b87df2127ad42af2814bf2eb9173edec8f7ae83
,"public static String decrypt(InputStream stream, String encrypted) throws IOException, NoSuchAlgorithmException, InvalidKeySpecException,
        NoSuchPaddingException, InvalidKeyException, IllegalBlockSizeException, BadPaddingException {

    byte[] encodedKey = new byte[stream.available()];
    stream.read(encodedKey);
    X509EncodedKeySpec publicKeySpec = new X509EncodedKeySpec(encodedKey);
    KeyFactory kf = KeyFactory.getInstance(""RSA"");
    PublicKey pkPublic = kf.generatePublic(publicKeySpec);

    Cipher pkCipher = Cipher.getInstance(""RSA/ECB/PKCS1PADDING"");
    pkCipher.init(Cipher.DECRYPT_MODE, pkPublic);

    byte[] decoded = Base64Coder.decode(encrypted);
    byte[] decryptedInByte = pkCipher.doFinal(decoded);
    return new String(decryptedInByte);
}
",3,0,4109aeea116e02ba558c349af4f942ca131aa244cb1bc5256401d162e0e0f03a
,"private static String seed;

/**
 * Encrypts the text. 
 * @param clearText The text you want to encrypt
 * @return Encrypted data if successful, or null if unsucessful
 */
protected String encrypt(String clearText) {
    byte[] encryptedText = null;
    try {
        byte[] keyData = seed.getBytes();
        SecretKey ks = new SecretKeySpec(keyData, ""AES"");
        Cipher c = Cipher.getInstance(""AES"");
        c.init(Cipher.ENCRYPT_MODE, ks);
        encryptedText = c.doFinal(clearText.getBytes(""UTF-8""));
        return Base64.encodeToString(encryptedText, Base64.DEFAULT);
    } catch (Exception e) {
        return null;
    }
}

/**
 * Decrypts the text
 * @param encryptedText The text you want to encrypt
 * @return Decrypted data if successful, or null if unsucessful
 */
protected String decrypt (String encryptedText) {
    byte[] clearText = null;
    try {
        byte[] keyData = seed.getBytes();
        SecretKey ks = new SecretKeySpec(keyData, ""AES"");
        Cipher c = Cipher.getInstance(""AES"");
        c.init(Cipher.DECRYPT_MODE, ks);
        clearText = c.doFinal(Base64.decode(encryptedText, Base64.DEFAULT));
        return new String(clearText, ""UTF-8"");
    } catch (Exception e) {
        return null;
    }
}   
",4,0,6e70cd46a00129f5457e29b444d28160697164a150c1ffea1c64dc3cae000c5f
,"public static String getApkFileDigest(Context context) {
        String apkPath = context.getPackageCodePath();
        try {
            byte[] hashed= getDigest(new FileInputStream(apkPath), ""SHA-256"");
            return Base64.encodeToString(hashed, Base64.DEFAULT);
        } catch (Throwable throwable) {
            throwable.printStackTrace();
        }
        return null;
    }

    public static final int BUFFER_SIZE = 2048;

    public static byte[] getDigest(InputStream in, String algorithm) throws Throwable {
        MessageDigest md = MessageDigest.getInstance(algorithm);
        try {
            DigestInputStream dis = new DigestInputStream(in, md);
            byte[] buffer = new byte[BUFFER_SIZE];
            while (dis.read(buffer) != -1) {
            }
            dis.close();
        } finally {
            in.close();
        }
        return md.digest();
    }
",2,0,d664e3c4a4528553cdbed55e49e4845cf16fd8fc669e8a10772ef3b57c138d02
,"String stringKey = ""60380131061660211660380426804995"";
String message = ""This is a secret message"";
try {
    SecretKeySpec sks = new SecretKeySpec(stringKey.getBytes(),""AES"");
    Cipher c = Cipher.getInstance(""AES/ECB/ZeroBytePadding""); // Change to CBC and use appropriate IV
    c.init(Cipher.ENCRYPT_MODE, sks);
    c.update(message.getBytes());
    byte[] ciphertext = c.doFinal();
    Log.i(""CE"", new String(ciphertext));

    } catch (NoSuchAlgorithmException e) {
        Log.e(""CE"",e.getMessage());
    } catch (NoSuchPaddingException e) {
        Log.e(""CE"",e.getMessage());
    } catch (InvalidKeyException e) {
        Log.e(""CE"",e.getMessage());
    } catch (IllegalBlockSizeException e) {
        Log.e(""CE"",e.getMessage());
    } catch (BadPaddingException e) {
        Log.e(""CE"",e.getMessage());
}
",4,0,e41ecdb5f30eeca386b4443bd7cfc53abbc8366e7b15660e6430228a3685349e
,"  private KeyStore loadPEMKeystoreStore(File certificateFile, String password) throws Exception {
        InputStream caInput = new BufferedInputStream(new FileInputStream(certificateFile));


        KeyStore keystore = KeyStore.getInstance(CLIENT_CERTIFICATE_KEYSTORE_TYPE);


        CertificateFactory certificateFactory = CertificateFactory
                .getInstance(X509);
        X509Certificate cert = (X509Certificate) certificateFactory
                .generateCertificate(caInput);


        keystore.load(null);
        keystore.setCertificateEntry(""cert-alias"", cert);
        keystore.setKeyEntry(""key-alias"", privateKey, password.toCharArray(),
                new Certificate[]{cert});
        FileOutputStream out = new FileOutputStream(file);
        keystore.store(out, password.toCharArray());

        return keyStore ;
    }
",,1,cf1b63e748f67c03169dec7682e6c081a911c7e29f1a93712507435b4a55060f
,"// Add code to print out the key hash
try {
    PackageInfo info = getPackageManager().getPackageInfo(
            ""com.facebook.samples.hellofacebook"", //your unique package name here
            PackageManager.GET_SIGNATURES);
    for (Signature signature : info.signatures) {
        MessageDigest md = MessageDigest.getInstance(""SHA"");
        md.update(signature.toByteArray());
        Log.d(""KeyHash:"", Base64.encodeToString(md.digest(), Base64.DEFAULT));// this line  gives your keyhash
        }
} catch (NameNotFoundException e) {

} catch (NoSuchAlgorithmException e) {

}
",3,0,a4d2543fbca6c1ad1408ad6ca1c0cbf588c5210ebfba14a9632c9f4345271305
,"import com.loopj.android.http.AsyncHttpClient;
import com.loopj.android.http.AsyncHttpResponseHandler;
import com.loopj.android.http.RequestParams;

import java.io.IOException;
import java.net.Socket;
import java.net.UnknownHostException;
import java.security.KeyManagementException;
import java.security.KeyStore;
import java.security.KeyStoreException;
import java.security.NoSuchAlgorithmException;
import java.security.UnrecoverableKeyException;
import java.security.cert.CertificateException;
import java.security.cert.X509Certificate;

import javax.net.ssl.SSLContext;
import javax.net.ssl.TrustManager;
import javax.net.ssl.X509TrustManager;

import org.apache.http.conn.ssl.SSLSocketFactory;

public class RestClient {

private static final String BASE_URL = ""https://YOUR_DOMAIN.COM/"";

private static AsyncHttpClient client = new AsyncHttpClient();

public static void get(String url, RequestParams params,
        AsyncHttpResponseHandler responseHandler) {
    client.setSSLSocketFactory(getSSLSocketFactory());
    client.get(getAbsoluteUrl(url), params, responseHandler);
}

public static void post(String url, RequestParams params,
        AsyncHttpResponseHandler responseHandler) {
    client.setSSLSocketFactory(getSSLSocketFactory());
    client.post(getAbsoluteUrl(url), params, responseHandler);
}

public static void put(String url, RequestParams params,
        AsyncHttpResponseHandler responseHandler) {
    client.setSSLSocketFactory(getSSLSocketFactory());
    client.put(getAbsoluteUrl(url), params, responseHandler);
}

private static String getAbsoluteUrl(String relativeUrl) {
    return BASE_URL + relativeUrl;
}

public static class VoipemSSLSocketFactory extends SSLSocketFactory {
    SSLContext sslContext = SSLContext.getInstance(""TLS"");

    public VoipemSSLSocketFactory(KeyStore truststore)
            throws NoSuchAlgorithmException, KeyManagementException,
            KeyStoreException, UnrecoverableKeyException {
        super(truststore);

        TrustManager tm = new X509TrustManager() {
            public void checkClientTrusted(X509Certificate[] chain,
                    String authType) throws CertificateException {
            }

            public void checkServerTrusted(X509Certificate[] chain,
                    String authType) throws CertificateException {
            }

            public X509Certificate[] getAcceptedIssuers() {
                return null;
            }
        };

        sslContext.init(null, new TrustManager[] { tm }, null);
    }

    @Override
    public Socket createSocket(Socket socket, String host, int port,
            boolean autoClose) throws IOException, UnknownHostException {
        return sslContext.getSocketFactory().createSocket(socket, host,
                port, autoClose);
    }

    @Override
    public Socket createSocket() throws IOException {
        return sslContext.getSocketFactory().createSocket();
    }
}

private static SSLSocketFactory getSSLSocketFactory() {
    KeyStore trustStore;
    SSLSocketFactory sslSocketFactory = null;
    try {
        trustStore = KeyStore.getInstance(KeyStore.getDefaultType());
        trustStore.load(null, null);

        sslSocketFactory = new VoipemSSLSocketFactory(trustStore);
        sslSocketFactory
                .setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER); 
    } catch (KeyStoreException e) {
        e.printStackTrace();
    } catch (NoSuchAlgorithmException e) {
        e.printStackTrace();
    } catch (CertificateException e) {
        e.printStackTrace();
    } catch (IOException e) {
        e.printStackTrace();
    } catch (KeyManagementException e) {
        e.printStackTrace();
    } catch (UnrecoverableKeyException e) { 
    }
    return sslSocketFactory;
}
}
",4,0,935f0015b668544a541293e4740c91e3a2b6f2944969990910b87c1d090b26da
,"public class PromptUserTrustManager implements X509TrustManager
{
    private AcceptUserSelectedCertsTrustManager(ValidateCertificateCallback callback) throws NoSuchAlgorithmException, KeyStoreException
    {
        KeyStore keyStore = null;
        TrustManagerFactory factory = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());
        factory.init(keyStore);
        TrustManager [] trustmanagers = factory.getTrustManagers();
        m_standardTrustManager = (X509TrustManager) trustmanagers[0];
    }

    @Override
    public void checkClientTrusted(X509Certificate[] arg0, String arg1) throws CertificateException
    {
    }

    // This is where you check the server cert and make the determination
    @Override
    public void checkServerTrusted(X509Certificate[] certChain, String authType)throws CertificateException
    {
        try
        {
            m_standardTrustManager.checkServerTrusted(certChain,authType);
        }
        catch(CertificateException e)
        {
            // Cert isn't trusted - popup the error here. You'll need to 
            // make sure you switch to the UI thread since here you're on a network thread
            if(!userAcceptsCert(certChain))
            {
                throw e;
            }
        }
    }
}
",3,0,1b49279616cc9c6a8c769cd3fbfc8416275b04ba8dfd308cfdf928526a517731
,"    public void computeSHAHash(String path)// path to your file
    {
            String SHAHash = null;
    try 
    {
        MessageDigest md = MessageDigest.getInstance(""SHA1"");
        InputStream in = new FileInputStream(path);
        byte[] buf = new byte[8192];
        int len = -1;
        while((len = in.read(buf)) &gt; 0) 
        {
            md.update(buf, 0, len);
        }
        in.close();
        byte[] data = md.digest();
        try 
        {
           SHAHash = convertToHex(data);
        } 
        catch (IOException e) 
        {
           // TODO Auto-generated catch block
           e.printStackTrace();
        }
    } catch (NoSuchAlgorithmException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    } catch (FileNotFoundException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    } catch (IOException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    }
      Toast.makeToast(getApplicationContext(),""Generated Hash =""+SHAHash,Toast.LENGTH_SHORT).show();  

   }
 private static String convertToHex(byte[] data) throws java.io.IOException
{
    StringBuffer sb = new StringBuffer();
    String hex = null;

    hex = Base64.encodeToString(data, 0, data.length, NO_OPTIONS);

    sb.append(hex);

    return sb.toString();
}
",3,0,2b568b1a99dd925d8123dfe6ff46e63809ae51365c68f8559f032905e7d91426
,"KeyStore ks = KeyStore.getInstance(""JKS"");
ks.load(new FileInputStream(""keystoreFile""), ""keystorePassword"".toCharArray());

KeyManagerFactory kmf = KeyManagerFactory.getInstance(""X509"");
kmf.init(ks, ""keystorePassword"".toCharArray());

TrustManagerFactory tmf = TrustManagerFactory.getInstance(""X509""); 
tmf.init(ks);

SSLContext sc = SSLContext.getInstance(""TLS""); 
TrustManager[] trustManagers = tmf.getTrustManagers(); 
sc.init(kmf.getKeyManagers(), trustManagers, null); 

SSLServerSocketFactory ssf = sc.getServerSocketFactory(); 
SSLServerSocket s = (SSLServerSocket) ssf.createServerSocket(serverport);
SSLSocket c = (SSLSocket) s.accept();
",3,0,43c756dc3ff17f721ea0fe22295078def4a1bb65a2fdc510aa56b49e42e8db08
,"SSLSocketFactory ssf = sc.getSocketFactory(); 
SSLSocket s = (SSLSocket) ssf.createSocket(serverip, serverport);
s.startHandshake();
",,1,fdeef0418b53cf50f4f8d24825e7f3aa4dc2bcc97009b58c733bcd1179b83b6d
,"/**
 * Encryption of a given text using the provided secretKey
 * 
 * @param text
 * @param secretKey
 * @return the encoded string
 * @throws SignatureException
 */
public static String hashMac(String text, String secretKey)
  throws SignatureException {

 try {
  Key sk = new SecretKeySpec(secretKey.getBytes(), HASH_ALGORITHM);
  Mac mac = Mac.getInstance(sk.getAlgorithm());
  mac.init(sk);
  final byte[] hmac = mac.doFinal(text.getBytes());
  return toHexString(hmac);
 } catch (NoSuchAlgorithmException e1) {
  // throw an exception or pick a different encryption method
  throw new SignatureException(
    ""error building signature, no such algorithm in device ""
      + HASH_ALGORITHM);
 } catch (InvalidKeyException e) {
  throw new SignatureException(
    ""error building signature, invalid key "" + HASH_ALGORITHM);
 }
}
",,1,d2adf15675748ea7dbb7d69c8fe5164bce468f3bf74a941fa1c694a47b31bb74
,"public static byte[] decryptRSA(Context mContext, byte[] message) throws Exception { 

    // reads the public key stored in a file
    InputStream is = mContext.getResources().openRawResource(R.raw.sm_public);
    BufferedReader br = new BufferedReader(new InputStreamReader(is));
    List&lt;String&gt; lines = new ArrayList&lt;String&gt;();
    String line = null;
    while ((line = br.readLine()) != null)
        lines.add(line);

    // removes the first and last lines of the file (comments)
    if (lines.size() &gt; 1 &amp;&amp; lines.get(0).startsWith(""-----"") &amp;&amp; lines.get(lines.size()-1).startsWith(""-----"")) {
        lines.remove(0);
        lines.remove(lines.size()-1);
    }

    // concats the remaining lines to a single String
    StringBuilder sb = new StringBuilder();
    for (String aLine: lines)
        sb.append(aLine);
    String keyString = sb.toString();
    Log.d(""log"", ""keyString:""+keyString);

    // converts the String to a PublicKey instance
    byte[] keyBytes = Base64.decodeBase64(keyString.getBytes(""utf-8""));
    X509EncodedKeySpec spec = new X509EncodedKeySpec(keyBytes);
    KeyFactory keyFactory = KeyFactory.getInstance(""RSA"");
    PublicKey key = keyFactory.generatePublic(spec);

    // decrypts the message
    byte[] dectyptedText = null;
    Cipher cipher = Cipher.getInstance(""RSA"");
    cipher.init(Cipher.DECRYPT_MODE, key);
    dectyptedText = cipher.doFinal(Base64.decodeBase64(message));
    return dectyptedText;
}
",3,0,ebd15109755a3dbd77a16523dc495256c6241695836c12bc282f8f5f76a3ea10
,"   public static String generateKeyPair() {
        try {
            KeyPairGenerator kpg = KeyPairGenerator.getInstance(""RSA"", ""BC"");

            kpg.initialize(2048, new SecureRandom());
            KeyPair pair = kpg.generateKeyPair();

            PKCS8EncodedKeySpec keyspec = new PKCS8EncodedKeySpec(pair.getPrivate().getEncoded());
            StringBuilder sb = new StringBuilder();
            sb.append(""-----BEGIN PRIVATE KEY-----"");
            sb.append(new String(Base64.encode(keyspec.getEncoded())));
            sb.append(""-----END PRIVATE KEY-----"");

            return new String(Base64.encode(sb.toString().getBytes()));
        } catch (NoSuchAlgorithmException e) {
            e.printStackTrace();
        } catch (NoSuchProviderException e) {
            e.printStackTrace();
        }

        return null;
    }
",3,0,021c2220d0e7e3b031ccde23081f02dcf1781d3ce726f51278c5b54f6b79f742
,"    package com.kushal.utils;

    import java.security.spec.KeySpec;
    import javax.crypto.Cipher;
    import javax.crypto.SecretKey;
    import javax.crypto.SecretKeyFactory;
    import javax.crypto.spec.DESedeKeySpec;
    import sun.misc.BASE64Decoder;
    import sun.misc.BASE64Encoder;

    public class DESedeEncryption {

        private static final String UNICODE_FORMAT = ""UTF8"";
        public static final String DESEDE_ENCRYPTION_SCHEME = ""DESede"";
        private KeySpec myKeySpec;
        private SecretKeyFactory mySecretKeyFactory;
        private Cipher cipher;
        byte[] keyAsBytes;
        private String myEncryptionKey;
        private String myEncryptionScheme;
        SecretKey key;

        public DESedeEncryption() throws Exception
        {
            myEncryptionKey = ""ThisIsSecretEncryptionKey"";
            myEncryptionScheme = DESEDE_ENCRYPTION_SCHEME;
            keyAsBytes = myEncryptionKey.getBytes(UNICODE_FORMAT);
            myKeySpec = new DESedeKeySpec(keyAsBytes);
            mySecretKeyFactory = SecretKeyFactory.getInstance(myEncryptionScheme);
            cipher = Cipher.getInstance(myEncryptionScheme);
            key = mySecretKeyFactory.generateSecret(myKeySpec);
        }

        /**
         * Method To Encrypt The String
         */
        public String encrypt(String unencryptedString) {
            String encryptedString = null;
            try {
                cipher.init(Cipher.ENCRYPT_MODE, key);
                byte[] plainText = unencryptedString.getBytes(UNICODE_FORMAT);
                byte[] encryptedText = cipher.doFinal(plainText);
                BASE64Encoder base64encoder = new BASE64Encoder();
                encryptedString = base64encoder.encode(encryptedText);
            } catch (Exception e) {
                e.printStackTrace();
            }
            return encryptedString;
        }
        /**
         * Method To Decrypt An Ecrypted String
         */
        public String decrypt(String encryptedString) {
            String decryptedText=null;
            try {
                cipher.init(Cipher.DECRYPT_MODE, key);
                BASE64Decoder base64decoder = new BASE64Decoder();
                byte[] encryptedText = base64decoder.decodeBuffer(encryptedString);
                byte[] plainText = cipher.doFinal(encryptedText);
                decryptedText= bytes2String(plainText);
            } catch (Exception e) {
                e.printStackTrace();
            }
            return decryptedText;
        }
        /**
         * Returns String From An Array Of Bytes
         */
        private static String bytes2String(byte[] bytes) {
            StringBuffer stringBuffer = new StringBuffer();
            for (int i = 0; i &amp;amp;lt; bytes.length; i++) {
                stringBuffer.append((char) bytes[i]);
            }
            return stringBuffer.toString();
        }

        /**
         * Testing The DESede Encryption And Decryption Technique
         */
        public static void main(String args []) throws Exception
        {
            DESedeEncryption myEncryptor= new DESedeEncryption();

            String stringToEncrypt=&amp;quot;Sanjaal.com&amp;quot;;
            String encrypted=myEncryptor.encrypt(stringToEncrypt);
            String decrypted=myEncryptor.decrypt(encrypted);

            System.out.println(""String To Encrypt: ""+stringToEncrypt);
            System.out.println(""Encrypted Value :"" + encrypted);
            System.out.println(""Decrypted Value :""+decrypted);

        }

    }

output:
String To Encrypt: Sanjaal.com
Encrypted Value :aArhqI25Y1SkYrdv9gxYDQ==
Decrypted Value :Sanjaal.com

http://sanjaal.com/java/189/java-encryption/tutorial-encryption-and-decryption-using-desede-triple-des-in-java/
",4,0,e73bd8ad49a1b1c9a2453332165ea36370ab0079ece1d80f63de7e863c9d42a4
,"KeyFactory kf1 = KeyFactory.getInstance(""RSA"");
PublicKey pkPublic1 = kf1.generatePublic(publicKeySpec1);

Cipher pkCipher1 = Cipher.getInstance(""RSA/ECB/PKCS1PADDING"");
pkCipher1.init(Cipher.DECRYPT_MODE, pkPublic1)
",3,0,584a1ae9b63bbd5941639346ec43c9163856bdc00a5250a6e7315169156b7e3d
,"    private void getAppKeyHash() {
    try {
        PackageInfo info = getPackageManager().getPackageInfo(
                getPackageName(), PackageManager.GET_SIGNATURES);
        for (Signature signature : info.signatures) {
            MessageDigest md;

            md = MessageDigest.getInstance(""SHA"");
            md.update(signature.toByteArray());
            String something = new String(Base64.encode(md.digest(), 0));
            System.out.println(""HASH  "" + something);
            showSignedHashKey(something);

        }
    } catch (NameNotFoundException e1) {
        // TODO Auto-generated catch block
        Log.e(""name not found"", e1.toString());
    } catch (NoSuchAlgorithmException e) {

        Log.e(""no such an algorithm"", e.toString());
    } catch (Exception e) {
        Log.e(""exception"", e.toString());
    }
}
public void showSignedHashKey(String hashKey) {

    AlertDialog.Builder adb = new AlertDialog.Builder(this);
    adb.setTitle(""Note Signed Hash Key"");
    adb.setMessage(hashKey);
    adb.setPositiveButton(""OK"", new DialogInterface.OnClickListener() {
        public void onClick(DialogInterface dialog, int which) {

        }
    });

    adb.show();
}
",3,0,1d2df9f77132c1f5a65ed62a2fcaa29e929f636054075bfd6b90ba4272e1804f
,"import java.security.NoSuchAlgorithmException;

import javax.crypto.Cipher;
import javax.crypto.NoSuchPaddingException;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;
public class MCrypt {

    private String iv = ""fedcba9876543210"";//Dummy iv (CHANGE IT!)
    private IvParameterSpec ivspec;
    private SecretKeySpec keyspec;
    private Cipher cipher;
    private String SecretKey = ""0123456789abcdef"";//Dummy secretKey (CHANGE IT!)

    public MCrypt() {
        ivspec = new IvParameterSpec(iv.getBytes());

        keyspec = new SecretKeySpec(SecretKey.getBytes(), ""AES"");

        try {
            cipher = Cipher.getInstance(""AES/CBC/NoPadding"");
        } catch (NoSuchAlgorithmException e) {
            e.printStackTrace();
        } catch (NoSuchPaddingException e) {
            e.printStackTrace();
        }
    }

    public byte[] encrypt(String text) throws Exception {
        if (text == null || text.length() == 0) throw new Exception(""Empty string"");

        byte[] encrypted = null;

        cipher.init(Cipher.ENCRYPT_MODE, keyspec, ivspec);

        encrypted = cipher.doFinal(padString(text).getBytes());
        try { //  for OS version 2.2+
            encrypted = android.util.Base64.encode(encrypted, android.util.Base64.NO_PADDING);
        } catch (NoClassDefFoundError e) {
            encrypted = org.apache.commons.codec.binary.Base64.encodeBase64(encrypted);
        }

        return encrypted;
    }

    public byte[] decrypt(String code) throws Exception {
        if (code == null || code.length() == 0) throw new Exception(""Empty string"");

        byte[] decrypted = null;

        cipher.init(Cipher.DECRYPT_MODE, keyspec, ivspec);

        try { // for OS version 2.2+
            decrypted = cipher.doFinal(android.util.Base64.decode(code, android.util.Base64.NO_PADDING));
        } catch (NoClassDefFoundError e) {
            decrypted = cipher.doFinal(org.apache.commons.codec.binary.Base64.decodeBase64(code.getBytes(""UTF-8"")));
        }
        return decrypted;
    }



    private static String padString(String source) {
        char paddingChar = ' ';
        int size = 16;
        int x = source.length() % size;
        int padLength = size - x;

        for (int i = 0; i &lt; padLength; i++) {
            source += paddingChar;
        }

        return source;
    }
}
",4,0,d8ab1dd0863c34c96aba2d3ce745be47bd5589959a8e5a78264c1bd167c7b9a3
," public String makeSHA1Hash(String input)
        throws NoSuchAlgorithmException, UnsupportedEncodingException
    {
        MessageDigest md = MessageDigest.getInstance(""SHA1"");
        md.reset();
        byte[] buffer = input.getBytes(""UTF-8"");
        md.update(buffer);
        byte[] digest = md.digest();

        String hexStr = """";
        for (int i = 0; i &lt; digest.length; i++) {
            hexStr +=  Integer.toString( ( digest[i] &amp; 0xff ) + 0x100, 16).substring( 1 );
        }
        return hexStr;
    }
",3,0,ef8f8b31211bacf7ac795ddf7f3e872ea20b1d23a998e82c9afce360062e03db
,"    int iterationCount = 1000;
    int saltLength = 8; // bytes; 64 bits
    int keyLength = 256;
    SecureRandom random = new SecureRandom();
    byte[] salt = new byte[saltLength];
    random.nextBytes(salt);
    KeySpec keySpec = new PBEKeySpec(seed.toCharArray(), salt,
            iterationCount, keyLength);
    SecretKeyFactory keyFactory = SecretKeyFactory
            .getInstance(""PBKDF2WithHmacSHA1"");
    byte[] raw = keyFactory.generateSecret(keySpec).getEncoded();
",3,0,2cf209f8be43fb58a3bb38f6c2bc20933611b4d9287c458d5a793e5ae2929805
,"          private CharSequence getHash(String sourceDir)  {
          // TODO Auto-generated method stub

          File file = new File(packageInfo.applicationInfo.sourceDir);
         String outputTxt= """";
           String hashcode = null;

        try {

        FileInputStream input = new FileInputStream(file);

        ByteArrayOutputStream output = new ByteArrayOutputStream ();
        byte [] buffer = new byte [65536];
        int l;


              while ((l = input.read (buffer)) &gt; 0)
                  output.write (buffer, 0, l);

                  input.close ();
              output.close ();

                byte [] data = output.toByteArray ();

                MessageDigest digest = MessageDigest.getInstance( ""SHA-1"" ); 

            byte[] bytes = data;

            digest.update(bytes, 0, bytes.length);
            bytes = digest.digest();

            StringBuilder sb = new StringBuilder();

            for( byte b : bytes )
            {
                sb.append( String.format(""%02X"", b) );
            }

            hashcode = sb.toString();


         } catch (FileNotFoundException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
         } catch (IOException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
         } catch (NoSuchAlgorithmException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
       }



          return hashcode;
         }
",,1,40b27e0d41b90a2eff814ec99c426c09c86a9762a3ef13fc0f718e3cbd03caf0
,"  //URL to get JSON Array
  private static String url = ""https://demo.vtiger.com/webservice.php?operation=getchallenge&amp;username=admin"";

  //JSON Node Names
  private static final String TAG_RESULT = ""result"";
  private static final String TAG_TOKEN = ""token"";

  // contacts JSONArray
  JSONArray contacts = null;

  String token = null;
  String sessionId;

@Override
public void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.login);

    if (android.os.Build.VERSION.SDK_INT &gt; 9) {
        StrictMode.ThreadPolicy policy = new StrictMode.ThreadPolicy.Builder().permitAll().build();
        StrictMode.setThreadPolicy(policy);
    }


    new AsyncTask&lt;Void, Void, Void&gt;() {

        private ProgressDialog dialog = new ProgressDialog(Login.this);
        protected void onPreExecute() {
               dialog.setMessage(""Loging In... Please wait..."");
               dialog.show();
              }
@SuppressWarnings(""unused"")
            JSONObject result;

            @Override
            protected Void doInBackground(Void... params) {

                // Creating new JSON Parser
                JSONParser jParser = new JSONParser();

                // Getting JSON from URL
                JSONObject json = jParser.getJSONFromUrl(url);

                try {
                    // Getting JSON Array
                    result = json.getJSONObject(TAG_RESULT);
                      JSONObject json_result = json.getJSONObject(TAG_RESULT);

                    // Storing  JSON item in a Variable
                    token = json_result.getString(TAG_TOKEN);

                    //Importing TextView

                } catch (JSONException e) {
                    e.printStackTrace();
                }

                String username=""admin"";
                String accesskeyvalue = ""w9OweWKUS4a5sSL"";
                String accessKey=md5(token + accesskeyvalue);

                //For debugging purpose only
                //System.out.println(accesskeyvalue);
                //System.out.println(token);
                //System.out.println(accessKey);

        String data = null;

            try {
                data = URLEncoder.encode(""username"", ""UTF-8"")
                        + ""="" + URLEncoder.encode(username, ""UTF-8"");
                data += ""&amp;"" + URLEncoder.encode(""accessKey"", ""UTF-8"") + ""=""
                        + URLEncoder.encode(accessKey, ""UTF-8"");
            } catch (UnsupportedEncodingException e) {
                // TODO Auto-generated catch block
                e.printStackTrace();
            } 
        String text = """";
        BufferedReader reader=null;
        //System.out.println(data);

        // Send data
        try
        {

            // Defined URL  where to send data
            URL url = new URL(""https://demo.vtiger.com/webservice.php?operation=login"");

         // Send POST data request
          URLConnection conn = url.openConnection();
          conn.setDoOutput(true);
          OutputStreamWriter wr = new OutputStreamWriter(conn.getOutputStream());
          wr.write( data );
          wr.flush();    

        // Get the server response    
        reader = new BufferedReader(new InputStreamReader(conn.getInputStream()));
        StringBuilder sb = new StringBuilder();
        String line = null;

        // Read Server Response
        while((line = reader.readLine()) != null)
            {
                   // Append server response in string
                   sb.append(line + ""\n"");
            }


            text = sb.toString();
        }
        catch(Exception ex)
        {

        }
        finally
        {
            try
            {

                reader.close();
            }

            catch(Exception ex) {}
        }

        // Show response
        System.out.println(text);
        sessionId = text.substring(41, 62);
        //System.out.println(""doInBackground()""+sessionId);



    return null;    
    }
            @Override
            protected void onPostExecute(Void aVoid) {
                super.onPostExecute(aVoid);    
                dialog.dismiss();
               }

         }.execute();

    } 

    public String md5(String s) 
    {
    MessageDigest digest;
        try 
            {
                digest = MessageDigest.getInstance(""MD5"");
                digest.update(s.getBytes(),0,s.length());
                String hash = new BigInteger(1, digest.digest()).toString(16);
                return hash;
            } 
        catch (NoSuchAlgorithmException e) 
            {
                e.printStackTrace();
            }
        return """";
    }
",,1,c734d45762f9a1965f790d530653607e131e34303ce4b47936952b54901f97e8
,"package using_net;

import android.content.Context;
import android.os.AsyncTask;

import org.apache.http.Header;
import org.apache.http.HttpResponse;
import org.apache.http.NameValuePair;
import org.apache.http.client.HttpClient;
import org.apache.http.client.entity.UrlEncodedFormEntity;
import org.apache.http.client.methods.HttpPost;
import org.apache.http.conn.scheme.Scheme;
import org.apache.http.conn.scheme.SchemeRegistry;
import org.apache.http.conn.ssl.SSLSocketFactory;
import org.apache.http.conn.ssl.X509HostnameVerifier;
import org.apache.http.impl.client.DefaultHttpClient;
import org.apache.http.impl.conn.SingleClientConnManager;
import org.apache.http.message.BasicNameValuePair;
import org.apache.http.protocol.HTTP;

import java.io.BufferedReader;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.net.URL;
import java.net.URLConnection;
import java.util.ArrayList;
import java.util.List;
import java.util.zip.GZIPInputStream;

import javax.net.ssl.HostnameVerifier;
import javax.net.ssl.HttpsURLConnection;

import logger.AndroidLogger;
import other.GetException;
import other.PostException;

/**
 * Created by ehog on 2013.12.11..
 */
public class BaseAsyncTask&lt;Paramets, Progress,Result&gt; extends AsyncTask&lt;Paramets,Progress,Result&gt;
{
    protected Context _context;

    public BaseAsyncTask(Context context)
    {
        _context = context;
    }

    protected String Get(String url) throws GetException
    {
        try
        {
            AndroidLogger.PushDebugMessage(""Web access: ""+url);
            URL realUrl = new URL(url);
            URLConnection connection = realUrl.openConnection();
            BufferedReader reader = new BufferedReader(new InputStreamReader(connection.getInputStream()));
            StringBuilder builder = new StringBuilder();
            for(String line = null; (line = reader.readLine()) != null;) {
                builder.append(line);
            }
            return builder.toString();
        }
        catch (Exception e) {
            throw new GetException(e);
        }
    }

    protected String Post(String url, String message_json) throws PostException
    {
        HostnameVerifier hostnameVerifier = org.apache.http.conn.ssl.SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER;

        DefaultHttpClient client = new DefaultHttpClient();
        SchemeRegistry registry = new SchemeRegistry();
        SSLSocketFactory socketFactory = SSLSocketFactory.getSocketFactory();
        socketFactory.setHostnameVerifier((X509HostnameVerifier) hostnameVerifier);
        registry.register(new Scheme(""https"", socketFactory, 443));
        SingleClientConnManager mgr = new SingleClientConnManager(client.getParams(), registry);
        HttpClient httpclient = new DefaultHttpClient(mgr, client.getParams());
        HttpsURLConnection.setDefaultHostnameVerifier(hostnameVerifier);

        HttpPost httpost = new HttpPost(url);
        try
        {
            List&lt;NameValuePair&gt; nvp = new ArrayList&lt;NameValuePair&gt;(1);
            nvp.add(new BasicNameValuePair(""json_data"",message_json));
            httpost.setHeader(""User-Agent"", ""Your.browser.header"");
            httpost.setEntity(new UrlEncodedFormEntity(nvp, HTTP.UTF_8));
            httpost.addHeader(""Accept-Encoding"", ""gzip"");
            HttpResponse response = httpclient.execute(httpost);

            int code = response.getStatusLine().getStatusCode();

            if(code &lt; 200 || code &gt;= 300) {
                networkError(code);
                return null;
            }
            InputStream instream = response.getEntity().getContent();
            Header contentEncoding = response.getFirstHeader(""Content-Encoding"");
            if (contentEncoding != null &amp;&amp; contentEncoding.getValue().equalsIgnoreCase(""gzip""))
            {
                instream = new GZIPInputStream(instream);
            }
            BufferedReader reader = new BufferedReader(new InputStreamReader(instream, ""UTF-8""));
            StringBuilder builder = new StringBuilder();
            for(String line = null; (line = reader.readLine()) != null;) {
                builder.append(line).append(""\n"");
            }
            return builder.toString();
        } catch (Exception x) {
            throw new PostException(x);
        }
    }

    protected void networkError(int code) {

    }

    protected void process(Result result) {

    }

    protected void error() {

    }

    @Override
    protected Result doInBackground(Paramets... params) {
        return null;
    }

    @Override
    protected void onPostExecute(Result result) {
        if(result == null) error();
        else process(result);
    }
}
",4,0,f3670a0974433a408780f44078dea33f44b101d86996e63ef4be92791b0a59cb
,"private void generateKeyHash() {
    // TODO Auto-generated method stub
    try {
        PackageInfo info = getPackageManager().getPackageInfo(
                ""Your Package name"", PackageManager.GET_SIGNATURES);
        for (Signature signature : info.signatures) {
            MessageDigest md = MessageDigest.getInstance(""SHA"");
            md.update(signature.toByteArray());
            Log.d(""KeyHash:"",
                    Base64.encodeToString(md.digest(), Base64.DEFAULT));
        }
    } catch (Exception e) {
        e.printStackTrace();
    }
}
",3,0,9edc2325a36965b98553b92475a45094868bb2816aa93d934c55395344cdb297
,"package com.trustit.trustme;
import java.security.KeyStore;
import java.security.KeyStoreException;
import java.security.NoSuchAlgorithmException;
import java.security.cert.CertificateException;
import java.security.cert.X509Certificate;
import java.util.Date;
import javax.net.ssl.TrustManager;
import javax.net.ssl.TrustManagerFactory;
import javax.net.ssl.X509TrustManager;

public class EasyX509TrustManager implements X509TrustManager 
{  
    private X509TrustManager standardTrustManager = null;  

    /** 
     * Constructor for EasyX509TrustManager. 
     */  
    public EasyX509TrustManager(KeyStore keystore) throws NoSuchAlgorithmException, KeyStoreException 
    {  
      super();  
      TrustManagerFactory factory = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());  
      factory.init(keystore);  
      TrustManager[] trustmanagers = factory.getTrustManagers();  
      if (trustmanagers.length == 0) 
      {  
        throw new NoSuchAlgorithmException(""no trust manager found"");  
      }  
      this.standardTrustManager = (X509TrustManager) trustmanagers[0];  
    }  

    /** 
     * @see javax.net.ssl.X509TrustManager#checkClientTrusted(X509Certificate[],String authType) 
     */  
    public void checkClientTrusted(X509Certificate[] certificates, String authType) throws CertificateException 
    {  
      standardTrustManager.checkClientTrusted(certificates, authType);  
    }  

    /** 
     * @see javax.net.ssl.X509TrustManager#checkServerTrusted(X509Certificate[],String authType) 
     */  
    public void checkServerTrusted(X509Certificate[] certificates, String authType) throws CertificateException 
    {  
    // Clean up the certificates chain and build a new one.
        // Theoretically, we shouldn't have to do this, but various web servers
        // in practice are mis-configured to have out-of-order certificates or
        // expired self-issued root certificate.
        int chainLength = certificates.length;
        if (certificates.length &gt; 1) 
        {
          // 1. we clean the received certificates chain.
          // We start from the end-entity certificate, tracing down by matching
          // the ""issuer"" field and ""subject"" field until we can't continue.
          // This helps when the certificates are out of order or
          // some certificates are not related to the site.
          int currIndex;
          for (currIndex = 0; currIndex &lt; certificates.length; ++currIndex) 
          {
            boolean foundNext = false;
            for (int nextIndex = currIndex + 1;
                           nextIndex &lt; certificates.length;
                           ++nextIndex) 
            {
              if (certificates[currIndex].getIssuerDN().equals(
                            certificates[nextIndex].getSubjectDN())) 
              {
                foundNext = true;
                // Exchange certificates so that 0 through currIndex + 1 are in proper order
                if (nextIndex != currIndex + 1) 
                {
                  X509Certificate tempCertificate = certificates[nextIndex];
                  certificates[nextIndex] = certificates[currIndex + 1];
                  certificates[currIndex + 1] = tempCertificate;
                }
                break;
            }
            }
            if (!foundNext) break;
      }

          // 2. we exam if the last traced certificate is self issued and it is expired.
          // If so, we drop it and pass the rest to checkServerTrusted(), hoping we might
          // have a similar but unexpired trusted root.
          chainLength = currIndex + 1;
          X509Certificate lastCertificate = certificates[chainLength - 1];
          Date now = new Date();
          if (lastCertificate.getSubjectDN().equals(lastCertificate.getIssuerDN())
                  &amp;&amp; now.after(lastCertificate.getNotAfter())) 
          {
            --chainLength;
          }
      } 

    standardTrustManager.checkServerTrusted(certificates, authType);    
    }  

    /** 
     * @see javax.net.ssl.X509TrustManager#getAcceptedIssuers() 
     */  
    public X509Certificate[] getAcceptedIssuers() 
    {  
      return this.standardTrustManager.getAcceptedIssuers();  
    }    
}  
",4,0,5e65cea6ff2ffc0df8d8bd8e7af964a5384eaf96f24584a07e5f165f2c6acffb
,"package com.trustit.trustme;

import java.io.IOException;  
import java.net.InetAddress;  
import java.net.InetSocketAddress;  
import java.net.Socket;  
import java.net.UnknownHostException;  

import javax.net.ssl.SSLContext;  
import javax.net.ssl.SSLSocket;  
import javax.net.ssl.TrustManager;  

import org.apache.http.conn.ConnectTimeoutException;  
import org.apache.http.conn.scheme.LayeredSocketFactory;  
import org.apache.http.conn.scheme.SocketFactory;  
import org.apache.http.params.HttpConnectionParams;  
import org.apache.http.params.HttpParams;  

public class EasySSLSocketFactory implements SocketFactory, LayeredSocketFactory 
{  
    private SSLContext sslcontext = null;  

    private static SSLContext createEasySSLContext() throws IOException 
    {  
      try
      {  
        SSLContext context = SSLContext.getInstance(""TLS"");  
        context.init(null, new TrustManager[] { new EasyX509TrustManager(null) }, null);  
        return context;  
      }
      catch (Exception e) 
      {  
        throw new IOException(e.getMessage());  
      }  
    }  

    private SSLContext getSSLContext() throws IOException 
    {  
      if (this.sslcontext == null) 
      {  
        this.sslcontext = createEasySSLContext();  
      }  
      return this.sslcontext;  
    }  

    /** 
     * @see org.apache.http.conn.scheme.SocketFactory#connectSocket(java.net.Socket, java.lang.String, int, 
     *      java.net.InetAddress, int, org.apache.http.params.HttpParams) 
     */  
    public Socket connectSocket(Socket sock,
                                    String host,
                                    int port, 
                                    InetAddress localAddress,
                                    int localPort,
                                    HttpParams params) 

                throws IOException, UnknownHostException, ConnectTimeoutException 
    {  
      int connTimeout = HttpConnectionParams.getConnectionTimeout(params);  
      int soTimeout = HttpConnectionParams.getSoTimeout(params);  
      InetSocketAddress remoteAddress = new InetSocketAddress(host, port);  
      SSLSocket sslsock = (SSLSocket) ((sock != null) ? sock : createSocket());  

      if ((localAddress != null) || (localPort &gt; 0)) 
      {  
        // we need to bind explicitly  
        if (localPort &lt; 0) 
        {  
          localPort = 0; // indicates ""any""  
        }  
        InetSocketAddress isa = new InetSocketAddress(localAddress, localPort);  
        sslsock.bind(isa);  
      }  

      sslsock.connect(remoteAddress, connTimeout);  
      sslsock.setSoTimeout(soTimeout);  
      return sslsock;    
    }  

    /** 
     * @see org.apache.http.conn.scheme.SocketFactory#createSocket() 
     */  
    public Socket createSocket() throws IOException {  
        return getSSLContext().getSocketFactory().createSocket();  
    }  

    /** 
     * @see org.apache.http.conn.scheme.SocketFactory#isSecure(java.net.Socket) 
     */  
    public boolean isSecure(Socket socket) throws IllegalArgumentException {  
        return true;  
    }  

    /** 
     * @see org.apache.http.conn.scheme.LayeredSocketFactory#createSocket(java.net.Socket, java.lang.String, int, 
     *      boolean) 
     */  
    public Socket createSocket(Socket socket,
                                   String host, 
                                   int port,
                                   boolean autoClose) throws IOException,  
                                                             UnknownHostException 
    {  
      return getSSLContext().getSocketFactory().createSocket(socket, host, port, autoClose);  
    }  

    // -------------------------------------------------------------------  
    // javadoc in org.apache.http.conn.scheme.SocketFactory says :  
    // Both Object.equals() and Object.hashCode() must be overridden  
    // for the correct operation of some connection managers  
    // -------------------------------------------------------------------  

    public boolean equals(Object obj) {  
        return ((obj != null) &amp;&amp; obj.getClass().equals(EasySSLSocketFactory.class));  
    }  

    public int hashCode() {  
        return EasySSLSocketFactory.class.hashCode();  
    }  
}
",,1,5a1ba8f227d3d44cbed827835ca2e04145337c02c10451bedbd2c1e4634763a9
,"import java.io.IOException;

    import java.net.Socket;
    import java.security.KeyManagementException;
    import java.security.KeyStoreException;
    import java.security.NoSuchAlgorithmException;
    import java.security.UnrecoverableKeyException;
    import java.security.cert.CertificateException;
    import java.security.cert.X509Certificate;

    import javax.net.ssl.SSLContext;
    import javax.net.ssl.TrustManager;
    import javax.net.ssl.X509TrustManager;

    import org.apache.http.client.ClientProtocolException;
    import org.apache.http.client.HttpClient;
    import org.apache.http.client.methods.HttpPost;
    import org.apache.http.conn.scheme.PlainSocketFactory;
    import org.apache.http.conn.scheme.Scheme;
    import org.apache.http.conn.scheme.SchemeRegistry;
    import org.apache.http.conn.ssl.SSLSocketFactory;
    import org.apache.http.conn.ssl.X509HostnameVerifier;
    import org.apache.http.impl.client.DefaultHttpClient;
    import org.apache.http.impl.conn.tsccm.ThreadSafeClientConnManager;
    import org.apache.http.params.BasicHttpParams;
import org.apache.http.params.HttpConnectionParams;
import org.apache.http.params.HttpParams;

    public class HttpsClientBuilder {
        public static DefaultHttpClient getBelieverHttpsClient() {

            DefaultHttpClient client = null;

            SchemeRegistry Current_Scheme = new SchemeRegistry();
            Current_Scheme.register(new Scheme(""http"", PlainSocketFactory.getSocketFactory(), 80));
            try {
                Current_Scheme.register(new Scheme(""https"", new Naive_SSLSocketFactory(), 8443));
            } catch (KeyManagementException e) {
                // TODO Auto-generated catch block
                e.printStackTrace();
            } catch (UnrecoverableKeyException e) {
                // TODO Auto-generated catch block
                e.printStackTrace();
            } catch (NoSuchAlgorithmException e) {
                // TODO Auto-generated catch block
                e.printStackTrace();
            } catch (KeyStoreException e) {
                // TODO Auto-generated catch block
                e.printStackTrace();
            }
            HttpParams Current_Params = new BasicHttpParams();
            int timeoutConnection = 8000;
            HttpConnectionParams.setConnectionTimeout(Current_Params, timeoutConnection);
            int timeoutSocket = 10000;
            HttpConnectionParams.setSoTimeout(Current_Params, timeoutSocket);
            ThreadSafeClientConnManager Current_Manager = new ThreadSafeClientConnManager(Current_Params, Current_Scheme);
            client = new DefaultHttpClient(Current_Manager, Current_Params);
            //HttpPost httpPost = new HttpPost(url);
            //client.execute(httpPost);

         return client;
         }

    public static class Naive_SSLSocketFactory extends SSLSocketFactory
    {
        protected SSLContext Cur_SSL_Context = SSLContext.getInstance(""TLS"");

        public Naive_SSLSocketFactory ()
                throws NoSuchAlgorithmException, KeyManagementException,
                KeyStoreException, UnrecoverableKeyException
        {
            super(null, null, null, null, null, (X509HostnameVerifier)null);
            Cur_SSL_Context.init(null, new TrustManager[] { new X509_Trust_Manager() }, null);
        }

        @Override
        public Socket createSocket(Socket socket, String host, int port,
                boolean autoClose) throws IOException
        {
            return Cur_SSL_Context.getSocketFactory().createSocket(socket, host, port, autoClose);
        }

        @Override
        public Socket createSocket() throws IOException
        {
            return Cur_SSL_Context.getSocketFactory().createSocket();
        }
    }

    private static class X509_Trust_Manager implements X509TrustManager
    {

        public void checkClientTrusted(X509Certificate[] chain, String authType)
                throws CertificateException {
            // TODO Auto-generated method stub

        }

        public void checkServerTrusted(X509Certificate[] chain, String authType)
                throws CertificateException {
            // TODO Auto-generated method stub

        }

        public X509Certificate[] getAcceptedIssuers() {
            // TODO Auto-generated method stub
            return null;
        }

    };
}
",4,0,a9a4a9b40011e44c930fd78eefe161200d29ec3703a1a9392346de75a794ab78
,"public static String md5Hash(File file) {
    try {
        MessageDigest md = MessageDigest.getInstance(""MD5"");
        InputStream is = new FileInputStream(file);
        byte[] buffer = new byte[1024];

        try {
            is = new DigestInputStream(is, md);

            while (is.read(buffer) != -1) { }
        } finally {
            is.close();
        }

        byte[] digest = md.digest();

        BigInteger bigInt = new BigInteger(1, digest);
        String output = bigInt.toString(16);
        while (output.length() &lt; 32) {
            output = ""0"" + output;
        }

        return output;
    } catch (NoSuchAlgorithmException e) {
        e.printStackTrace();
    } catch (FileNotFoundException e) {
        e.printStackTrace();
    } catch (IOException e) {
        e.printStackTrace();
    }

    return null;
}
",3,0,a9822b4f3efafa9ccf7f2420faeb8c5e5444a2309be0115b6958401ff3e3aad1
," /**
   * Will cause HttpsURLConnection to accept even self-signed certificates.
   * @param conn
   */
  private static void trustEveryone(HttpsURLConnection conn) {
    try {
      conn.setHostnameVerifier(new HostnameVerifier() {
        public boolean verify(String hostname, SSLSession session) {
          return true;
        }
      });
      SSLContext context = SSLContext.getInstance(""TLS"");
      context.init(null, new X509TrustManager[] { new X509TrustManager() {

        @Override
        public void checkClientTrusted(
            java.security.cert.X509Certificate[] aChain, String aAuthType)
            throws java.security.cert.CertificateException {
        }

        @Override
        public void checkServerTrusted(
            java.security.cert.X509Certificate[] aChain, String aAuthType)
            throws java.security.cert.CertificateException {
        }

        @Override
        public java.security.cert.X509Certificate[] getAcceptedIssuers() {
          // TODO Auto-generated method stub
          return new java.security.cert.X509Certificate[0];
        }
      } }, new SecureRandom());
      conn.setSSLSocketFactory(context.getSocketFactory());
    } catch (Exception e) { //handle accordingly
      e.printStackTrace();
    }
  }
",4,0,3d946c7e7cbf8d49c1cc45195364b6c31637cd08930013a7433a5b175d3ede5e
,"    //here i am downloading file from server and writing

    String download_link = ""some server location""; 
                URL url = new URL(download_link);
                 HttpsURLConnection c = null;
                if (url.getProtocol().toLowerCase().equals(""https"")) {
                     trustAllHosts();
                     c = (HttpsURLConnection) url.openConnection();
                     c.setHostnameVerifier(DO_NOT_VERIFY);
                }
                c.setRequestMethod(""GET"");
                c.setDoOutput(true);
                c.connect();
                String PATH = Environment.getExternalStorageDirectory() + ""/download/"";
                File file = new File(PATH);
                file.mkdirs();
                File outputFile = new File(file, ""Mobi.apk"");
                if(outputFile.exists()){
                    outputFile.delete();
                }
                FileOutputStream fos = new FileOutputStream(outputFile);
                InputStream is = c.getInputStream();
                byte[] buffer = new byte[1024];
                int len1 = 0;
                while ((len1 = is.read(buffer)) != -1) {
                    fos.write(buffer, 0, len1);
                }
                fos.close();
                is.close();

you need to add permission in manifest file:    

uses-permission android:name=""android.permission.INTERNET""&gt;&lt;/uses-permission&gt;
    &lt;uses-permission android:name=""android.permission.WRITE_EXTERNAL_STORAGE""&gt;&lt;/uses-permission&gt;
    &lt;uses-permission android:name=""android.permission.ACCESS_NETWORK_STATE""&gt;&lt;/uses-permission&gt;
    &lt;uses-permission android:name=""android.permission.READ_PHONE_STATE""&gt;&lt;/uses-permission&gt;
",4,0,09c3ee9170f9a9c0b0a6ea417709d32cfd5fac623f4142e8a0fcf1ee7dc60d86
,"import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.security.SecureRandom;

import javax.crypto.Cipher;
import javax.crypto.KeyGenerator;
import javax.crypto.SecretKey;
import javax.crypto.spec.SecretKeySpec;


public class AESEncrypter {
    public static void encryptToBinaryFile(String password, byte[] bytes, File file) throws EncrypterException {
        try {
            final byte[] rawKey = getRawKey(password.getBytes());
            final FileOutputStream ostream = new FileOutputStream(file, false);

            ostream.write(encrypt(rawKey, bytes));
            ostream.flush();
            ostream.close();

        } catch (IOException e) {
            throw new EncrypterException(e);
        }
    }

public static byte[] decryptFromBinaryFile(String password, File file) throws EncrypterException {
    try {
        final byte[] rawKey = getRawKey(password.getBytes());
        final FileInputStream istream = new FileInputStream(file);
        final byte[] buffer = new byte[(int)file.length()];

        istream.read(buffer);

        return decrypt(rawKey, buffer);

    } catch (IOException e) {
        throw new EncrypterException(e);
    }
}

private static byte[] getRawKey(byte[] seed) throws EncrypterException {
    try {
        final KeyGenerator kgen = KeyGenerator.getInstance(""AES"");
        final SecureRandom sr = SecureRandom.getInstance(""SHA1PRNG"");

        sr.setSeed(seed);
        kgen.init(128, sr); // 192 and 256 bits may not be available

        final SecretKey skey = kgen.generateKey();

        return skey.getEncoded();

    } catch (Exception e) {
        throw new EncrypterException(e);
    }
}

private static byte[] encrypt(byte[] raw, byte[] clear) throws EncrypterException {
    try {
        final SecretKeySpec skeySpec = new SecretKeySpec(raw, ""AES"");
        final Cipher cipher = Cipher.getInstance(""AES"");
        cipher.init(Cipher.ENCRYPT_MODE, skeySpec);

        return cipher.doFinal(clear);

    } catch (Exception e) {
        throw new EncrypterException(e);
    }
}

private static byte[] decrypt(byte[] raw, byte[] encrypted) throws EncrypterException {
    SecretKeySpec skeySpec = new SecretKeySpec(raw, ""AES"");
    try {
        final Cipher cipher = Cipher.getInstance(""AES"");
        cipher.init(Cipher.DECRYPT_MODE, skeySpec);

        return cipher.doFinal(encrypted);

    } catch (Exception e) {
        throw new EncrypterException(e);
    }
}
",4,0,231c8bccacf77497853f8dd9287284ff11958550868d738047f8edef3a26b7e8
," private void connect(){
            String alias = getAliasForClientCertificate();

            final X509Certificate[] certificates =getCertificateChain(alias);
            final PrivateKey pk = getPrivateKey(alias);



            KeyStore trustStore = KeyStore.getInstance(KeyStore
                    .getDefaultType());


            X509ExtendedKeyManager keyManager = new X509ExtendedKeyManager() {

                @Override
                public String chooseClientAlias(String[] strings, Principal[] principals, Socket socket) {
                    return alias;
                }

                @Override
                public String chooseServerAlias(String s, Principal[] principals, Socket socket) {
                    return alias;
                }

                @Override
                public X509Certificate[] getCertificateChain(String s) {
                    return certificates;
                }

                @Override
                public String[] getClientAliases(String s, Principal[] principals) {
                    return new String[]{alias};
                }

                @Override
                public String[] getServerAliases(String s, Principal[] principals) {
                    return new String[]{alias};
                }

                @Override
                public PrivateKey getPrivateKey(String s) {
                    return pk;
                }
            };

            TrustManagerFactory trustFactory = TrustManagerFactory
                    .getInstance(TrustManagerFactory.getDefaultAlgorithm());

            trustFactory.init(trustStore);

            TrustManager[] trustManagers = trustFactory.getTrustManagers();



            X509TrustManager[] tm = new X509TrustManager[] { new X509TrustManager() {
                public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {
                }

                public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {
                }

                //            public X509Certificate[] getAcceptedIssuers() {
                //                return certificates;
                //            }

                public X509Certificate[] getAcceptedIssuers() {
                    return certificates;
                }

                public boolean isClientTrusted(X509Certificate[] arg0) {
                    return true;
                }
            public boolean isServerTrusted(X509Certificate[] arg0) {
                return true; 
            }


        } };
        SSLContext sslContext = SSLContext.getInstance(""TLS"");
        sslContext.init(new KeyManager[] {keyManager}, tm, null);
        SSLContext.setDefault(sslContext);

        URL url = new URL(""url.."");
        HttpsURLConnection urlConnection = (HttpsURLConnection) url
                .openConnection();
        urlConnection.setSSLSocketFactory(sslContext.getSocketFactory());

        HostnameVerifier hv = new HostnameVerifier() {

            @Override
            public boolean verify(String hostname, SSLSession session) {
                return true;
            }
        };
        urlConnection.setHostnameVerifier(hv);


        urlConnection.setInstanceFollowRedirects(false);
        urlConnection.connect();
        int responseCode = urlConnection.getResponseCode();

}

private X509Certificate[] getCertificateChain(String alias) {
        try {
            return KeyChain.getCertificateChain(this, alias);
        } catch (KeyChainException e) {
            e.printStackTrace();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        return null;
}
",4,0,405964d8a8782efbc02bb97e1e8dbc9d6cc7c6d8789713c72b5dfa80c1d73cc2
,"    static public String getPackageFingerPrint( Context ctx ) {
        PackageManager pm = ctx.getPackageManager();
        String packageName = ctx.getPackageName();
        int flags = PackageManager.GET_SIGNATURES;

        PackageInfo packageInfo = null;

        try {
                packageInfo = pm.getPackageInfo(packageName, flags);
        } catch (NameNotFoundException e) {
                return """";
        }
        Signature[] signatures = packageInfo.signatures;

        byte[] cert = signatures[0].toByteArray();

        InputStream input = new ByteArrayInputStream(cert);

        CertificateFactory cf = null;
        try {
                cf = CertificateFactory.getInstance(""X509"");


        } catch (CertificateException e) {
                return """";
        }
        X509Certificate c = null;
        try {
                c = (X509Certificate) cf.generateCertificate(input);
        } catch (CertificateException e) {
                return """";
        }


        try {
            MessageDigest md = MessageDigest.getInstance(""SHA1"");
            byte[] publicKey = md.digest(c.getPublicKey().getEncoded());


            StringBuffer hexString = new StringBuffer();
            for (int i=0;i&lt;publicKey.length;i++) {
                String appendString = Integer.toHexString(0xFF &amp; publicKey[i]);
                if(appendString.length()==1)hexString.append(""0"");
                hexString.append(appendString);
                }


            return hexString.toString();

        } catch (NoSuchAlgorithmException e1) {
            return """";
        } 
    }
",,1,097421d6a7f53a4cc499148a814d2701feccf8ff990540e1e4a572a07349e8ac
,"@Override
public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
    if (Build.VERSION.RELEASE.equals(""5.0""))
    {
        Security.removeProvider(""SC"");
    }
    return super.onCreateView(inflater, container, savedInstanceState);
}

@Override
public void onDestroyView() {
    if (Build.VERSION.RELEASE.equals(""5.0""))
    {
        Security.addProvider(new org.spongycastle.jce.provider.BouncyCastleProvider());
    }
    super.onDestroyView();
}
",,1,c85d03ec13305875f4ab68f2378ab0406df55e27507681c0c6dfa42211849745
,"SecretKeyFactory f = SecretKeyFactory.getInstance(""PBKDF2WithHmacSHA1"");
// note, the third argument should be set to a value as high as possible
// 10K is about the minimum nowadays
KeySpec ks = new PBEKeySpec(password, salt, 1024, 128);
SecretKey s = f.generateSecret(ks);
Key k = new SecretKeySpec(s.getEncoded(),""AES"");
",3,0,59482ba2261748efff5e1c1c0e29f8c063a4c2c6f3caa8b994c0bf53f8d6571e
,"// Loading the certificate in asserts
CertificateFactory cf = CertificateFactory.getInstance(""X.509"");
AssetManager assManager = context.getAssets();
caInput = assManager.open(""certif.crt"");
Certificate ca = cf.generateCertificate(caInput);
// Create a KeyStore containing different CAs
String keyStoreType = KeyStore.getDefaultType();
KeyStore keyStore = KeyStore.getInstance(keyStoreType);
keyStore.load(null, null);
keyStore.setCertificateEntry(""ca"", ca);

// Create a TrustManager to store certificates
String tmfAlgorithm = TrustManagerFactory.getDefaultAlgorithm();
TrustManagerFactory tmf = TrustManagerFactory.getInstance(tmfAlgorithm);
tmf.init(keyStore);

// Creates a context for use ssl certificate
SSLContext context = SSLContext.getInstance(""TLS"");
context.init(null, tmf.getTrustManagers(), null);
",3,0,f8cb3019bb50d5b378dbb4f1b03267e86c73c3de7d8baf8ac6a779e772d3b0de
,"public class MySSLSocketFactory extends SSLSocketFactory {
           SSLContext sslContext = SSLContext.getInstance(""TLS"");


           public MySSLSocketFactory() throws UnrecoverableKeyException, NoSuchAlgorithmException, KeyStoreException, KeyManagementException {
                super(null, null, null, null, null, null);

                final TrustManagerFactory trustMgrFactory = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());
                trustMgrFactory.init((KeyStore) null);

                sslContext.init(null, trustMgrFactory.getTrustManagers(), new SecureRandom());
            }

            @Override
            public Socket createSocket(Socket socket, String host, int port, boolean autoClose) throws IOException, UnknownHostException {
                final SSLSocket sslSocket = (SSLSocket) sslContext.getSocketFactory().createSocket(socket, host, port, autoClose);
                sslSocket.setEnabledCipherSuites(sslSocket.getSupportedCipherSuites());
                return sslSocket;
            }

            @Override
            public Socket createSocket() throws IOException {
                final SSLSocket sslSocket = (SSLSocket) sslContext.getSocketFactory().createSocket();
                sslSocket.setEnabledCipherSuites(sslSocket.getSupportedCipherSuites());
                return sslSocket;
            }
    }
",3,0,1cf496a829f8cfa8734ca8565fc19b51c3f3f462dd2edd9be00486de80d09d33
,"md = MessageDigest.getInstance(""SHA-256"");
        md.update(text.getBytes(""iso-8859-1""), 0, text.length());
        sha1hash = md.digest();
",2,0,dba2dd6755647ebef5634cc2ee44cecc1015557bd9ce647e4ab7b7144a4b9f08
,"import javax.net.ssl.SSLSocketFactory;

// Create a socket without connecting
SSLSocketFactory socketFactory = SSLSocketFactory.getDefault();
Socket socket = socketFactory.createSocket();

// Connect, with an explicit timeout value
socket.connect(new InetSocketAddress(endpoint.mServer,
endpoint.mPort), CONNECT_TIMEOUT);
",3,0,8407f5ccb11c84b0fc9d95f38e6ad1657f2e66b3eda5aa7168fe17dd2f19957a
,"private getSSLContext()
{
    /* Load the keyStore that includes self-signed cert as a ""trusted"" entry. */
    KeyStore keyStore = ...  //optional
    TrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm()); //optional
    tmf.init(keyStore); //optional

    //This is the important line, specifying the cipher to use and cipher provider
    SSLContext sslContext = SSLContext.getInstance(""TLSv1"",""AndroidOpenSSL"");
    ctx.init(null, tmf.getTrustManagers(), null); //if trustmanager not used pass null as the second parameter    
    return sslContext;
}
",4,0,bcc701df36b69d114f59cd78f6bbb3db3064896c7025db7669160813ec05ee7d
,"private Session.StatusCallback statusCallback = new SessionStatusCallback();

private class SessionStatusCallback implements Session.StatusCallback {
    @Override
    public void call(final Session session, SessionState state,
            Exception exception) {

        try {
            new_session = session;
            if (state.equals(SessionState.OPENING)) {

            }

            if (state.equals(SessionState.OPENED)) {


            }

            if (state.equals(SessionState.CLOSED_LOGIN_FAILED)) {
                try {
                    PackageInfo info = context.getPackageManager()
                            .getPackageInfo(""your package name"",
                                    PackageManager.GET_SIGNATURES);
                    for (Signature signature : info.signatures) {
                        MessageDigest md = MessageDigest.getInstance(""SHA"");
                        md.update(signature.toByteArray());
                        Log.d(""KeyHash:"", Base64.encodeToString(
                                md.digest(), Base64.DEFAULT));
                    }
                    Session.openActiveSession((Activity) context, true,
                            statusCallback);
                } catch (NameNotFoundException e) {

                } catch (NoSuchAlgorithmException e) {

                }
            }

            if (state.equals(SessionState.OPENED_TOKEN_UPDATED)) {



            }

    }
    catch(Exception e){}
  }
}

//if session is closed
Session.openActiveSession((Activity) context, true,
                    statusCallback);
",3,0,1f412275d108b01f6a6a819fd9f5a8c2afecd2f3e15ce2cf987bb11687ecb776
,"PackageInfo info;
try {

    info = getPackageManager().getPackageInfo( ""com.you.name"",PackageManager.GET_SIGNATURES);

    for (Signature signature : info.signatures)
    {
        MessageDigest md;
        md = MessageDigest.getInstance(""SHA"");
        md.update(signature.toByteArray());
        String something = new String(Base64.encode(md.digest(), 0));
        //String something = new String(Base64.encodeBytes(md.digest()));
        Log.e(""Hash key"", something);
    }

} catch (NameNotFoundException e1) {
Log.e(""name not found"", e1.toString());
} catch (NoSuchAlgorithmException e) {
Log.e(""no such an algorithm"", e.toString());
} catch (Exception e) {
Log.e(""exception"", e.toString());
}
",3,0,071a3697497801399a6d29e56773608d08fd9e688550b13eea8829c7c6472d0a
,"package nl.owlstead.stackoverflow;

import java.io.IOException;
import java.io.StringReader;
import java.security.KeyFactory;
import java.security.NoSuchAlgorithmException;
import java.security.interfaces.RSAPublicKey;
import java.security.spec.InvalidKeySpecException;
import java.security.spec.RSAPublicKeySpec;

import org.bouncycastle.util.io.pem.PemObject;
import org.bouncycastle.util.io.pem.PemReader;

public final class RSAPublicKeyFromOpenSSL_PKCS1_PEM {
    private static final String PEM = ""-----BEGIN RSA PUBLIC KEY-----\r\n""
            + ""MIGJAoGBAKks62Itns2uU/dVZJ4kCkMinHgyeh/rdMD53a4Zu2a76OIJvdSZ8q4c\r\n""
            + ""YTWvPj0giefVtMc7tV4c6AAw04jyIfmCTvcQUlHI+sspHxXDlQTagNoxCuA29b5L\r\n""
            + ""9MKO6Ok0LwF9rGgTywC1heNEulZz9ISn9FQDazJT+Bd9cnNOrJRdAgMBAAE=\r\n""
            + ""-----END RSA PUBLIC KEY-----\r\n"";

    public static RSAPublicKey parsePEM(final String pem)
            throws IllegalArgumentException {

        // --- read PEM object
        final PemObject readPemObject;
        try (final PemReader reader = new PemReader(new StringReader(PEM))) {
            readPemObject = reader.readPemObject();
        } catch (final IOException e) {
            throw new IllegalArgumentException(""Not a PEM object"", e);
        }
        if (!readPemObject.getType().equalsIgnoreCase(""RSA PUBLIC KEY"")) {
            throw new IllegalArgumentException(""Not a public key"");
        }
        final byte[] pemContent = readPemObject.getContent();

        // --- create Bouncy Castle PKCS#1 public key
        final org.bouncycastle.asn1.pkcs.RSAPublicKey pkcs1PublicKey;
        try {
            pkcs1PublicKey = org.bouncycastle.asn1.pkcs.RSAPublicKey
                    .getInstance(pemContent);
        } catch (final Exception e) {
            throw new IllegalArgumentException(
                    ""Could not parse BER PKCS#1 public key structure"", e);
        }

        // --- convert to JCE RSAPublicKey
        final RSAPublicKeySpec spec = new RSAPublicKeySpec(
                pkcs1PublicKey.getModulus(), pkcs1PublicKey.getPublicExponent());
        final KeyFactory rsaKeyFact;
        try {
            rsaKeyFact = KeyFactory.getInstance(""RSA"");
        } catch (final NoSuchAlgorithmException e) {
            throw new IllegalStateException(""RSA KeyFactory should be available"", e);
        }
        try {
            return (RSAPublicKey) rsaKeyFact.generatePublic(spec);
        } catch (InvalidKeySpecException e) {
            throw new IllegalArgumentException(
                    ""Invalid RSA public key, modulus and/or exponent invalid"", e);
        }
    }

    public static void main(final String ... args) throws Exception {
        final RSAPublicKey publicKey = parsePEM(PEM);
        System.out.println(publicKey);
    }
}
",,1,8b665006315adaa2f2e403613dac912b432f2660e76792cabf58e19dccfa637b
,"package com.test;

import java.io.IOException;
import java.io.UnsupportedEncodingException;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.GregorianCalendar;
import java.util.HashMap;
import java.util.Map;

import org.apache.harmony.javax.security.auth.callback.CallbackHandler;
import org.jivesoftware.smack.SASLAuthentication;
import org.jivesoftware.smack.XMPPException;
import org.jivesoftware.smack.sasl.SASLMechanism;
import org.jivesoftware.smack.util.Base64;

import de.measite.smack.Sasl;

public class FacebookConnectSASLMechanism  extends SASLMechanism
{

    private String sessionKey = """";
    private String sessionSecret = """";
    private String apiKey = """";

    public FacebookConnectSASLMechanism(SASLAuthentication saslAuthentication) {
            super(saslAuthentication);
    }

    // protected void authenticate() throws IOException, XMPPException {
    // String[] mechanisms = { getName() };
    // Map&lt;String, String&gt; props = new HashMap&lt;String, String&gt;();
    // sc = Sasl.createSaslClient(mechanisms, null, ""xmpp"", hostname, props,
    // this);
    //
    // super.authenticate();
    // }

    protected void authenticate() throws IOException, XMPPException {
            StringBuilder stanza = new StringBuilder();
            stanza.append(""&lt;auth mechanism=\"""").append(getName());
            stanza.append(""\"" xmlns=\""urn:ietf:params:xml:ns:xmpp-sasl\""&gt;"");
            stanza.append(""&lt;/auth&gt;"");

            // Send the authentication to the server
            //getSASLAuthentication().send(stanza.toString());
    }

    public void authenticate(String apiKeyAndSessionKey, String host, String sessionSecret)
                    throws IOException, XMPPException {

            if(apiKeyAndSessionKey==null || sessionSecret==null)
                    throw new IllegalStateException(""Invalid parameters!"");

            String[] keyArray = apiKeyAndSessionKey.split(""\\|"");

            if(keyArray==null || keyArray.length != 2)
                    throw new IllegalStateException(""Api key or session key is not present!"");

            this.apiKey = keyArray[0];
            this.sessionKey = keyArray[1];
            this.sessionSecret = sessionSecret;

            this.authenticationId = sessionKey;
            this.password = sessionSecret;
            this.hostname = host;

            String[] mechanisms = { ""DIGEST-MD5"" };
            Map&lt;String, String&gt; props = new HashMap&lt;String, String&gt;();
            sc = Sasl.createSaslClient(mechanisms, null, ""xmpp"", host, props, this);
            authenticate();
    }

    public void authenticate(String username, String host, CallbackHandler cbh)
                    throws IOException, XMPPException {
            String[] mechanisms = { ""DIGEST-MD5"" };
            Map&lt;String, String&gt; props = new HashMap&lt;String, String&gt;();
            sc = Sasl.createSaslClient(mechanisms, null, ""xmpp"", host, props, cbh);
            authenticate();
    }

    protected String getName() {
            return ""X-FACEBOOK-PLATFORM"";
    }

    public void challengeReceived(String challenge) throws IOException {
            // Build the challenge response stanza encoding the response text
            StringBuilder stanza = new StringBuilder();

            byte response[] = null;
            if (challenge != null) {
                    String decodedResponse = new String(Base64.decode(challenge));
                    Map&lt;String, String&gt; parameters = getQueryMap(decodedResponse);

                    String version = ""1.0"";
                    String nonce = parameters.get(""nonce"");
                    String method = parameters.get(""method"");

                    Long callId = new GregorianCalendar().getTimeInMillis()/1000;

                    String sig = ""api_key=""+apiKey
                                                    +""call_id=""+callId
                                                    +""method=""+method
                                                    +""nonce=""+nonce
                                                    +""session_key=""+sessionKey
                                                    +""v=""+version
                                                    +sessionSecret;

                    try {
                            sig = MD5(sig);
                    } catch (NoSuchAlgorithmException e) {
                            throw new IllegalStateException(e);
                    }

                    String composedResponse = ""api_key=""+apiKey+""&amp;""
                                                                            +""call_id=""+callId+""&amp;""
                                                                            +""method=""+method+""&amp;""
                                                                            +""nonce=""+nonce+""&amp;""
                                                                            +""session_key=""+sessionKey+""&amp;""
                                                                            +""v=""+version+""&amp;""
                                                                            +""sig=""+sig;

                    response = composedResponse.getBytes();
            }

            String authenticationText="""";

            if (response != null) {
                    authenticationText = Base64.encodeBytes(response, Base64.DONT_BREAK_LINES);
            }

            stanza.append(""&lt;response xmlns=\""urn:ietf:params:xml:ns:xmpp-sasl\""&gt;"");
            stanza.append(authenticationText);
            stanza.append(""&lt;/response&gt;"");

            // Send the authentication to the server
            //getSASLAuthentication().send(stanza);
    }

    private Map&lt;String, String&gt; getQueryMap(String query) {
            String[] params = query.split(""&amp;"");
            Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();
            for (String param : params) {
                    String name = param.split(""="")[0];
                    String value = param.split(""="")[1];
                    map.put(name, value);
            }
            return map;
    }

private String convertToHex(byte[] data) {
    StringBuffer buf = new StringBuffer();
    for (int i = 0; i &lt; data.length; i++) {
        int halfbyte = (data[i] &gt;&gt;&gt; 4) &amp; 0x0F;
        int two_halfs = 0;
        do {
            if ((0 &lt;= halfbyte) &amp;&amp; (halfbyte &lt;= 9))
                buf.append((char) ('0' + halfbyte));
            else
                buf.append((char) ('a' + (halfbyte - 10)));
            halfbyte = data[i] &amp; 0x0F;
        } while(two_halfs++ &lt; 1);
    }
    return buf.toString();
}

public String MD5(String text) throws NoSuchAlgorithmException, UnsupportedEncodingException  {
    MessageDigest md;
    md = MessageDigest.getInstance(""MD5"");
    byte[] md5hash = new byte[32];
    md.update(text.getBytes(""iso-8859-1""), 0, text.length());
    md5hash = md.digest();
    return convertToHex(md5hash);
}
}
",3,0,55e0329d3c86c133701d93f43a5a1feba440cce6947a58536a8be1d6081f51a1
,"try {
        PackageInfo info = context.getPackageManager().getPackageInfo(
                packageName, PackageManager.GET_SIGNATURES);
        for (Signature signature : info.signatures) {
            MessageDigest md = MessageDigest.getInstance(""SHA"");
            md.update(signature.toByteArray());

            // writtenToFile(""FB_KEY_HASH.txt"",
            // Base64.encodeToString(md.digest(),
            // Base64.DEFAULT).toString(), false);

            if (AppUtills.showLogs)
                Log.v(pageName,
                        ""KeyHash:""
                                + Base64.encodeToString(md.digest(),
                                        Base64.DEFAULT));
        }
    } catch (Exception e) {
        e.printStackTrace();
    }
",3,0,5e289e3ae1c0fdb47d77e21c7f34bdff8d11c7e25e5ffbfb2d039eefe8257a90
,"try
{
    //paste Your package name at the first parameter
    PackageInfo info = getPackageManager().getPackageInfo(""PUT_YOUR_PACKAGE_NAME_HERE"",
            PackageManager.GET_SIGNATURES);
    for (android.content.pm.Signature signature : info.signatures)
    {
        MessageDigest md = MessageDigest.getInstance(""SHA"");
        md.update(signature.toByteArray());
        String sign = Base64.encodeToString(md.digest(), Base64.DEFAULT);
        Log.e(""MY KEY HASH:"", sign);
        Toast.makeText(getApplicationContext(),sign,     Toast.LENGTH_LONG).show();
    }
}
catch (PackageManager.NameNotFoundException e)
{
}
catch (NoSuchAlgorithmException e)
{
}
",3,0,3dddf3da319d3ad402305fd809381651eff5e068fa47c8f0a971b6758512bb33
,"    try {
        PackageInfo info = getPackageManager().getPackageInfo(""my.package.name"", PackageManager.GET_SIGNATURES);
        for (Signature signature : info.signatures) {
            MessageDigest md;
            md = MessageDigest.getInstance(""SHA"");
            md.update(signature.toByteArray());
            Log.e(""hash key"", Base64.encodeToString(md.digest(), Base64.DEFAULT));
        }
    } catch (NameNotFoundException e1) {
        Log.e(""name not found"", e1.toString());
    } catch (NoSuchAlgorithmException e) {
        Log.e(""no such an algorithm"", e.toString());
    } catch (Exception e) {
        Log.e(""exception"", e.toString());
    }
",3,0,487240c51caa38e569a2d624dfc2b78c8dd49193c92b563a3feb160b0e5c3ba8
," KeyGenerator keyGenerator = KeyGenerator.getInstance(
         KeyProperties.KEY_ALGORITHM_AES, ""AndroidKeyStore"");
 keyGenerator.initialize(
         new KeyGenParameterSpec.Builder(""key2"",
                 KeyProperties.PURPOSE_ENCRYPT | KeyProperties.PURPOSE_DECRYPT)
                 .setBlockModes(KeyProperties.BLOCK_MODE_GCM)
                 .setEncryptionPaddings(KeyProperties.ENCRYPTION_PADDING_NONE)
                 .build());
 SecretKey key = keyGenerator.generateKey();

 Cipher cipher = Cipher.getInstance(""AES/GCM/NoPadding"");
 cipher.init(Cipher.ENCRYPT_MODE, key);
 ...

 // The key can also be obtained from the Android Keystore any time as follows:
 KeyStore keyStore = KeyStore.getInstance(""AndroidKeyStore"");
 keyStore.load(null);
 key = (SecretKey) keyStore.getKey(""key2"", null);
",1,0,021c54db62260ace74886443eafdce894c2122c93f48d6115bac20b1df004f76
,"public String encryptText(String cipherText) throws Exception {

    String plainKey = ""key12345"";
    String plainIV = ""1234567890ABCDEF"";

    KeySpec ks = new  DESKeySpec(plainKey.getBytes(encodingType));
    SecretKey key = SecretKeyFactory.getInstance(keyDes).generateSecret(ks);

    IvParameterSpec iv = new IvParameterSpec(
            org.apache.commons.codec.binary.Hex.decodeHex(plainIV.toCharArray()));

    Cipher cipher = Cipher.getInstance(encryptAlgo);
    cipher.init(Cipher.ENCRYPT_MODE, key, iv);

    byte[] decoded = cipher.doFinal(cipherText.getBytes(encodingType));

    return new Base64().encodeToString(decoded);
}
",4,0,94c5e2fd7e40c781614d3a8851011e184efb39ae2e163a7f4e48ebe1e453dbcf
,"        OkHttpClient client = new OkHttpClient();

    try {
        KeyStore keyStore = readKeyStore(this);
        SSLContext sslContext = SSLContext.getInstance(""SSL"");
        TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());
        trustManagerFactory.init(keyStore);
        KeyManagerFactory keyManagerFactory = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());
        keyManagerFactory.init(keyStore, ""keystore_pass"".toCharArray());
        sslContext.init(keyManagerFactory.getKeyManagers(),trustManagerFactory.getTrustManagers(), new SecureRandom());
        client.setSslSocketFactory(sslContext.getSocketFactory());

    } catch (Exception e) {
        e.printStackTrace();
    }
",3,0,b0c5c584e91f0ae137c6d41f88da449db9722176ee811d62e116814dbe332ec5
,"public static String getSha1Hex(String clearString)
{
    try
    {
        MessageDigest messageDigest = MessageDigest.getInstance(""SHA-1"");
        messageDigest.update(clearString.getBytes(""UTF-8""));
        byte[] bytes = messageDigest.digest();
        StringBuilder buffer = new StringBuilder();
        for (byte b : bytes)
        {
            buffer.append(Integer.toString((b &amp; 0xff) + 0x100, 16).substring(1));
        }
        return buffer.toString();
    }
    catch (Exception ignored)
    {
        ignored.printStackTrace();
        return null;
    }
}
",3,0,5f766a162b77791fd624fe4e32031edac60f5cc8771098d7bc4cf1f832d00f1e
,"public void encrypt(InputStream fin, OutputStream fout, String password) {
    try {
        PKCS12ParametersGenerator pGen = new PKCS12ParametersGenerator(new SHA256Digest());
        char[] passwordChars = password.toCharArray();
        final byte[] pkcs12PasswordBytes = PBEParametersGenerator.PKCS12PasswordToBytes(passwordChars);
        pGen.init(pkcs12PasswordBytes, salt.getBytes(), iterationCount);
        CBCBlockCipher aesCBC = new CBCBlockCipher(new AESEngine());
        ParametersWithIV aesCBCParams = (ParametersWithIV) pGen.generateDerivedParameters(256, 128);
        aesCBC.init(true, aesCBCParams);
        PaddedBufferedBlockCipher aesCipher = new PaddedBufferedBlockCipher(aesCBC, new PKCS7Padding());
        aesCipher.init(true, aesCBCParams);

        // Read in the decrypted bytes and write the cleartext to out
        int numRead = 0;
        while ((numRead = fin.read(buf)) &gt;= 0) {
            if (numRead == 1024) {
                byte[] plainTemp = new byte[aesCipher.getUpdateOutputSize(numRead)];
                int offset = aesCipher.processBytes(buf, 0, numRead, plainTemp, 0);
                final byte[] plain = new byte[offset];
                System.arraycopy(plainTemp, 0, plain, 0, plain.length);
                fout.write(plain, 0, plain.length);
            } else {
                byte[] plainTemp = new byte[aesCipher.getOutputSize(numRead)];
                int offset = aesCipher.processBytes(buf, 0, numRead, plainTemp, 0);
                int last = aesCipher.doFinal(plainTemp, offset);
                final byte[] plain = new byte[offset + last];
                System.arraycopy(plainTemp, 0, plain, 0, plain.length);
                fout.write(plain, 0, plain.length);
            }
        }
        fout.close();
        fin.close();
    } catch (Exception e) {
        e.printStackTrace();
    }

}

public void decrypt(InputStream fin, OutputStream fout, String password) {
    try {
        PKCS12ParametersGenerator pGen = new PKCS12ParametersGenerator(new SHA256Digest());
        char[] passwordChars = password.toCharArray();
        final byte[] pkcs12PasswordBytes = PBEParametersGenerator.PKCS12PasswordToBytes(passwordChars);
        pGen.init(pkcs12PasswordBytes, salt.getBytes(), iterationCount);
        CBCBlockCipher aesCBC = new CBCBlockCipher(new AESEngine());
        ParametersWithIV aesCBCParams = (ParametersWithIV) pGen.generateDerivedParameters(256, 128);
        aesCBC.init(false, aesCBCParams);
        PaddedBufferedBlockCipher aesCipher = new PaddedBufferedBlockCipher(aesCBC, new PKCS7Padding());
        aesCipher.init(false, aesCBCParams);

        // Read in the decrypted bytes and write the cleartext to out
        int numRead = 0;
        while ((numRead = fin.read(buf)) &gt;= 0) {
            if (numRead == 1024) {
                byte[] plainTemp = new byte[aesCipher.getUpdateOutputSize(numRead)];
                int offset = aesCipher.processBytes(buf, 0, numRead, plainTemp, 0);
                // int last = aesCipher.doFinal(plainTemp, offset);
                final byte[] plain = new byte[offset];
                System.arraycopy(plainTemp, 0, plain, 0, plain.length);
                fout.write(plain, 0, plain.length);
            } else {
                byte[] plainTemp = new byte[aesCipher.getOutputSize(numRead)];
                int offset = aesCipher.processBytes(buf, 0, numRead, plainTemp, 0);
                int last = aesCipher.doFinal(plainTemp, offset);
                final byte[] plain = new byte[offset + last];
                System.arraycopy(plainTemp, 0, plain, 0, plain.length);
                fout.write(plain, 0, plain.length);
            }
        }
        fout.close();
        fin.close();
    } catch (Exception e) {
        e.printStackTrace();
    }
}
",1,0,83ec85995a71fd2bde88cc806ff8d0ed1d04dc59411f8cb6e6cade3b0fc13990
,"package com.nweave.utils;

import java.io.IOException;
import java.lang.ref.WeakReference;
import java.net.URI;
import java.net.URISyntaxException;
import java.security.KeyStore;

import org.apache.http.HttpResponse;
import org.apache.http.HttpVersion;
import org.apache.http.client.ClientProtocolException;
import org.apache.http.client.HttpClient;
import org.apache.http.client.methods.HttpGet;
import org.apache.http.conn.ClientConnectionManager;
import org.apache.http.conn.scheme.PlainSocketFactory;
import org.apache.http.conn.scheme.Scheme;
import org.apache.http.conn.scheme.SchemeRegistry;
import org.apache.http.conn.ssl.SSLSocketFactory;
import org.apache.http.impl.client.DefaultHttpClient;
import org.apache.http.impl.conn.tsccm.ThreadSafeClientConnManager;
import org.apache.http.params.BasicHttpParams;
import org.apache.http.params.HttpParams;
import org.apache.http.params.HttpProtocolParams;
import org.apache.http.protocol.HTTP;

import android.graphics.Bitmap;
import android.graphics.BitmapFactory;
import android.graphics.drawable.ColorDrawable;
import android.graphics.drawable.Drawable;
import android.os.AsyncTask;
import android.util.Log;
import android.view.View;
import android.widget.ImageView;
import android.widget.ProgressBar;

import com.nweave.view.ProductArrayAdapter;

public class ImageDownloader {
    private ProductArrayAdapter productArrayAdapter;

    public ImageDownloader(ProductArrayAdapter productArrayAdapter) {
        this.productArrayAdapter = productArrayAdapter;
    }

    public void download(String name, String url, ImageView imageView,
            ProgressBar progressBar) {
        if (cancelPotentialDownload(url, imageView)) {
            BitmapDownloaderTask bitmapDownloaderTask = new BitmapDownloaderTask(
                    name, imageView, progressBar);
            DownloadedDrawable downloadedDrawable = new DownloadedDrawable(
                    bitmapDownloaderTask);
            imageView.setImageDrawable(downloadedDrawable);
            bitmapDownloaderTask.execute(url);
        }
    }

    private class BitmapDownloaderTask extends AsyncTask&lt;String, Void, Bitmap&gt; {
        String url;
        private final WeakReference&lt;ImageView&gt; imageViewReference;
        private final String productName;
        private final ProgressBar progressbar;

        public BitmapDownloaderTask(String name, ImageView imageView,
                ProgressBar progressBar) {
            imageViewReference = new WeakReference&lt;ImageView&gt;(imageView);
            productName = name;
            progressbar = progressBar;
        }

        @Override
        protected Bitmap doInBackground(String... params) {
            HttpResponse response = null;
            HttpClient httpsClient = getHttpsClient();
            HttpGet httpGet = new HttpGet();
            try {
                httpGet.setURI(new URI(params[0]));

                response = httpsClient.execute(httpGet);
                Bitmap currentBitMap = BitmapFactory.decodeStream(response
                        .getEntity().getContent());
                productArrayAdapter.cacheImages.saveImages(productName,
                        currentBitMap);
                return currentBitMap;
            } catch (URISyntaxException e) {
                Log.e(ImageDownloader.class.getSimpleName() + "":doInBackground"",
                        e.getMessage());
            } catch (ClientProtocolException e) {
                Log.e(ImageDownloader.class.getSimpleName() + "":doInBackground"",
                        e.getMessage());
            } catch (IOException e) {
                Log.e(ImageDownloader.class.getSimpleName() + "":doInBackground"",
                        e.getMessage());
            }
            return null;
        }

        @Override
        protected void onPostExecute(Bitmap result) {
            if (isCancelled()) {
                result = null;
            }
            if (imageViewReference != null) {
                ImageView imageView = imageViewReference.get();
                BitmapDownloaderTask bitmapDownloaderTask = ImageDownloader
                        .getBitmapDownloaderTask(imageView);
                if (this == bitmapDownloaderTask) {
                    imageView.setImageBitmap(result);
                    imageView.setVisibility(View.VISIBLE);
                    progressbar.setVisibility(View.INVISIBLE);
                }
            }
        }
    }

    private static class DownloadedDrawable extends ColorDrawable {
        private final WeakReference&lt;BitmapDownloaderTask&gt; bitmapDownloaderTaskReference;

        public DownloadedDrawable(BitmapDownloaderTask bitmapDownloaderTask) {
            bitmapDownloaderTaskReference = new WeakReference&lt;BitmapDownloaderTask&gt;(
                    bitmapDownloaderTask);
        }

        public BitmapDownloaderTask getBitmapDownloaderTask() {
            return bitmapDownloaderTaskReference.get();
        }
    }

    private static boolean cancelPotentialDownload(String url,
            ImageView imageView) {
        BitmapDownloaderTask bitmapDownloaderTask = getBitmapDownloaderTask(imageView);
        if (bitmapDownloaderTask != null) {
            String bitmapUrl = bitmapDownloaderTask.url;
            if ((bitmapUrl == null) || (!bitmapUrl.equals(url))) {
                bitmapDownloaderTask.cancel(true);
            } else {
                return false;
            }
        }
        return true;
    }

    private static BitmapDownloaderTask getBitmapDownloaderTask(
            ImageView imageView) {
        if (imageView != null) {
            Drawable drawable = imageView.getDrawable();
            if (drawable instanceof DownloadedDrawable) {
                DownloadedDrawable downloadedDrawable = (DownloadedDrawable) drawable;
                return downloadedDrawable.getBitmapDownloaderTask();
            }
        }
        return null;
    }

    private static HttpClient getHttpsClient() {
        try {
            KeyStore trustStore = KeyStore.getInstance(KeyStore
                    .getDefaultType());
            trustStore.load(null, null);
            SSLSocketFactory sslSocketFactory = new MySSLSocketFactory(
                    trustStore);
            sslSocketFactory
                    .setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
            HttpParams params = new BasicHttpParams();
            HttpProtocolParams.setVersion(params, HttpVersion.HTTP_1_1);
            HttpProtocolParams.setContentCharset(params, HTTP.UTF_8);
            SchemeRegistry registry = new SchemeRegistry();
            registry.register(new Scheme(""http"", PlainSocketFactory
                    .getSocketFactory(), 80));
            registry.register(new Scheme(""https"", sslSocketFactory, 443));
            ClientConnectionManager ccm = new ThreadSafeClientConnManager(
                    params, registry);
            return new DefaultHttpClient(ccm, params);
        } catch (Exception e) {
            Log.e(ImageDownloader.class.getSimpleName() + "":getHttpsClient"",
                    e.getMessage());
            return new DefaultHttpClient();
        }
    }
}
",4,0,8ded274ffe7db91d463307075d872b6e9285c5a2728d9088a10b128bdb94cf64
,"Provider[] providers = Security.getProviders();
for (Provider p : providers) {
  String providerStr = String.format(""%s/%s/%f\n"", p.getName(),
                    p.getInfo(), p.getVersion());
  Set&lt;Service&gt; services = p.getServices();
  for (Service s : services) {
    if (""MessageDigest"".equals(s.getType())) {
       System.out.printf(""\t%s/%s/%s"", s.getType(),
                            s.getAlgorithm(), s.getClassName());
    }
  }
}
",,1,af1a8940019e3e74201e95d0d718f7fa51e67d49d1e9396b390f1697589d89d1
," public static String encrytData(String text) throws Exception {

    Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS7Padding"");
    byte[] static_key = Constants.AES_KEY.getBytes();

    SecretKeySpec keySpec = new SecretKeySpec(static_key, ""AES"");
    IvParameterSpec ivSpec = new IvParameterSpec(Constants.IV_VECTOR);
    cipher.init(Cipher.ENCRYPT_MODE, keySpec, ivSpec);

    byte[] results = cipher.doFinal(text.getBytes());

    String result = Base64.encodeToString(results, Base64.NO_WRAP|Base64.DEFAULT);
    return result;

}


public static String decryptData(String text)throws Exception{

    byte[] encryted_bytes = Base64.decode(text, Base64.DEFAULT);

    Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS7Padding"");
    byte[] static_key = Constants.AES_KEY.getBytes();

    SecretKeySpec keySpec = new SecretKeySpec(static_key, ""AES"");
    IvParameterSpec ivSpec = new IvParameterSpec(Constants.IV_VECTOR);
    cipher.init(Cipher.DECRYPT_MODE, keySpec, ivSpec);

    byte[] decrypted = cipher.doFinal(encryted_bytes);
    String result = new String(decrypted);

    return result;
}
",1,0,4af0e87d438c8994e0454a9738e2c71daf11220f967d3e14dd74aa9916682560
,"String filename =title.replace("" "","""")+j+"".nomedia"";
File destination = new File(MyApplication.getPhotoStorage() ,filename);


URL url = new URL (url_image);

OutputStream os = new FileOutputStream(destination);

MessageDigest md = MessageDigest.getInstance(""MD5"");
try (InputStream is = url.openStream()) {
    DigestInputStream dis = new DigestInputStream(is, md);
    byte[] b = new byte[2048];
    int length;

    while ((length = dis.read(b)) != -1) {
        os.write(b, 0, length);
    }
}

byte[] digest = md.digest();

os.close();
localPhotosUrl.add(destination.getAbsolutePath());
",,1,547e9cae8fc3643f8b3fb3837dee99769720c37959ed6fbe8bc026689101fd31
,"private static byte[] filesize = new byte[8];
private static byte[] ivBytes = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };

public static void decrypt(String inputFile, String outputFile, String password) throws IOException, NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, InvalidAlgorithmParameterException {
    FileInputStream fis = new FileInputStream(inputFile);
    FileOutputStream fos = new FileOutputStream(outputFile);
    fis.read(filesize, 0, 8);
    System.out.println(new String(filesize));
    fis.mark(9);
    fis.read(ivBytes, 0, 16);
    System.out.println(new String(ivBytes));
    fis.mark(25);
    IvParameterSpec iv = new IvParameterSpec(ivBytes);
    SecretKeySpec sks = new SecretKeySpec(password.getBytes(), ""AES"");
    Cipher cipher = Cipher.getInstance(""AES/CBC/NoPadding"");
    cipher.init(Cipher.DECRYPT_MODE, sks, iv);
    File file = new File(inputFile);
    int byteLength = (int) file.length() - 24;
    System.out.println(Integer.toString(byteLength));
    byte[] bytes = new byte[byteLength];
    byteLength = fis.read(bytes);
    System.out.println(Integer.toString(byteLength));
    System.out.println(new String(bytes));
    InputStream bytesStream = new ByteArrayInputStream(bytes);
    CipherInputStream cis = new CipherInputStream(bytesStream, cipher);

    int b;
    byte[] d = new byte[1024];
    while((b = cis.read(d)) != -1) {
        fos.write(d, 0, b);
    }
    fos.flush();
    fos.close();
    cis.close();
}
",4,0,2a7deb1a863f9a53d888412b83a7368abad32496ff33edeb6aba5a7089e5105b
,"            URL url = new URL(downloadURL);
            HttpURLConnection urlCon = null;

            URL testUrlHttps = new URL(downloadURL);
            if (testUrlHttps.getProtocol().toLowerCase().equals(""https""))
            {
                trustAllHosts();
                HttpsURLConnection https = (HttpsURLConnection) url.openConnection();
                https.setHostnameVerifier(DO_NOT_VERYFY);
                urlCon = https;
            } else
            {
                urlCon = (HttpURLConnection) url.openConnection();
            }




add this method. May be it will help



   private static void trustAllHosts()
    {
        // Create a trust manager that does not validate certificate chains
        TrustManager[] trustAllCerts = new TrustManager[] { new X509TrustManager()
        {
            public java.security.cert.X509Certificate[] getAcceptedIssuers()
            {
                return new java.security.cert.X509Certificate[] {};
            }

            public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException
            {
            }

            public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException
            {
            }
        } };

        // Install the all-trusting trust manager
        try
        {
            SSLContext sc = SSLContext.getInstance(""TLS"");
            sc.init(null, trustAllCerts, new java.security.SecureRandom());
            HttpsURLConnection.setDefaultSSLSocketFactory(sc.getSocketFactory());
        } catch (Exception e)
        {
            e.printStackTrace();
        }
    }
",4,0,4e179fd7e510c8b5e798fd04c92e81e56f977c8e93fc46f78ddb5f01f1cd9f6a
,"URL url = new URL(""https://www.xyz.com"");
HttpsURLConnection httpURLConnection  = (HttpsURLConnection) url.openConnection();
httpURLConnection.setRequestProperty(""Content-Type"",
                ""text/plain"");
httpURLConnection.setRequestMethod(""POST"");
httpURLConnection.setDoOutput(true);
httpURLConnection.setAllowUserInteraction(false);
httpURLConnection.setInstanceFollowRedirects(true);
httpURLConnection.setHostnameVerifier(DO_NOT_VERIFY);
httpURLConnection.connect();
OutputStream outputStream = httpURLConnection.getOutputStream();
 outStream.write(datainbytes);



 final static HostnameVerifier DO_NOT_VERIFY = new HostnameVerifier() {
        public boolean verify(String hostname, SSLSession session) {
            return true;
        }
 };
",4,0,7e3ae3d9676cd5557cdbefb4377d457ee3edf8168f3d34f518a7ef01c883fff4
,"try {
  Cipher cipher = Cipher.getInstance(""AES/ECB/PKCS7Padding"", ""BC"");

  SecretKeySpec key = new SecretKeySpec(keyBytes, ""AES"");

  // Here you need to accurately and correctly read your file into a byte
  // array. Either Google for a decent solution (there are many out there)
  // or use an existing implementation, such as Apache Commons commons-io.
  // Your existing effort is buggy and doesn't close its resources.      
  byte[] cipherText = FileUtils.readFileToByteArray(new File(savedScoresFileName));


  cipher.init(Cipher.DECRYPT_MODE, key);

  // Just one call to doFinal
  byte[] plainText = cipher.doFinal(cipherText);

  // Note: don't do this. If you create a string from a byte array,
  // PLEASE pass a charset otherwise your result is platform dependent.
  return new String(plainText);
} catch (Exception e) {
  e.printStackTrace();
}
",2,0,1b1d140355971a29e2d8b4249885bf85033e41797a5129c47a8ac1d1b0089edb
,"public class MyCrypter {

private static String TAG = ""MyCrypter"";

public MyCrypter() {

}

/**
 * Encodes a String in AES-128 with a given key
 * 
 * @param context
 * @param password
 * @param text
 * @return String Base64 and AES encoded String
 * @throws NoPassGivenException
 * @throws NoTextGivenException
 */
public String encode(Context context, String password, String text)
        throws NoPassGivenException, NoTextGivenException {
    if (password.length() == 0 || password == null) {
        throw new NoPassGivenException(""Please give Password"");
    }

    if (text.length() == 0 || text == null) {
        throw new NoTextGivenException(""Please give text"");
    }

    try {
        SecretKeySpec skeySpec = getKey(password);
        byte[] clearText = text.getBytes(""UTF8"");

        //IMPORTANT TO GET SAME RESULTS ON iOS and ANDROID
        final byte[] iv = new byte[16];
        Arrays.fill(iv, (byte) 0x00);
        IvParameterSpec ivParameterSpec = new IvParameterSpec(iv);

        // Cipher is not thread safe
        Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS7Padding"");
        cipher.init(Cipher.ENCRYPT_MODE, skeySpec, ivParameterSpec);

        String encrypedValue = Base64.encodeToString(
                cipher.doFinal(clearText), Base64.DEFAULT);
        Log.d(TAG, ""Encrypted: "" + text + "" -&gt; "" + encrypedValue);
        return encrypedValue;

    } catch (InvalidKeyException e) {
        e.printStackTrace();
    } catch (UnsupportedEncodingException e) {
        e.printStackTrace();
    } catch (NoSuchAlgorithmException e) {
        e.printStackTrace();
    } catch (BadPaddingException e) {
        e.printStackTrace();
    } catch (NoSuchPaddingException e) {
        e.printStackTrace();
    } catch (IllegalBlockSizeException e) {
        e.printStackTrace();
    } catch (InvalidAlgorithmParameterException e) {
        e.printStackTrace();
    }
    return """";
}

/**
 * Decodes a String using AES-128 and Base64
 * 
 * @param context
 * @param password
 * @param text
 * @return desoded String
 * @throws NoPassGivenException
 * @throws NoTextGivenException
 */
public String decode(Context context, String password, String text)
        throws NoPassGivenException, NoTextGivenException {

    if (password.length() == 0 || password == null) {
        throw new NoPassGivenException(""Please give Password"");
    }

    if (text.length() == 0 || text == null) {
        throw new NoTextGivenException(""Please give text"");
    }

    try {
        SecretKey key = getKey(password);

        //IMPORTANT TO GET SAME RESULTS ON iOS and ANDROID
        final byte[] iv = new byte[16];
        Arrays.fill(iv, (byte) 0x00);
        IvParameterSpec ivParameterSpec = new IvParameterSpec(iv);

        byte[] encrypedPwdBytes = Base64.decode(text, Base64.DEFAULT);
        // cipher is not thread safe
        Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS7Padding"");
        cipher.init(Cipher.DECRYPT_MODE, key, ivParameterSpec);
        byte[] decrypedValueBytes = (cipher.doFinal(encrypedPwdBytes));

        String decrypedValue = new String(decrypedValueBytes);
        Log.d(TAG, ""Decrypted: "" + text + "" -&gt; "" + decrypedValue);
        return decrypedValue;

    } catch (InvalidKeyException e) {
        e.printStackTrace();
    } catch (UnsupportedEncodingException e) {
        e.printStackTrace();
    } catch (NoSuchAlgorithmException e) {
        e.printStackTrace();
    } catch (BadPaddingException e) {
        e.printStackTrace();
    } catch (NoSuchPaddingException e) {
        e.printStackTrace();
    } catch (IllegalBlockSizeException e) {
        e.printStackTrace();
    } catch (InvalidAlgorithmParameterException e) {
        e.printStackTrace();
    }
    return """";
}

/**
 * Generates a SecretKeySpec for given password
 * @param password
 * @return SecretKeySpec
 * @throws UnsupportedEncodingException
 */
public SecretKeySpec getKey(String password)
        throws UnsupportedEncodingException {


    int keyLength = 128;
    byte[] keyBytes = new byte[keyLength / 8];
    // explicitly fill with zeros
    Arrays.fill(keyBytes, (byte) 0x0);

    // if password is shorter then key length, it will be zero-padded
    // to key length
    byte[] passwordBytes = password.getBytes(""UTF-8"");
    int length = passwordBytes.length &lt; keyBytes.length ? passwordBytes.length
            : keyBytes.length;
    System.arraycopy(passwordBytes, 0, keyBytes, 0, length);
    SecretKeySpec key = new SecretKeySpec(keyBytes, ""AES"");
    return key;
}

public class NoTextGivenException extends Exception {
    public NoTextGivenException(String message) {
        super(message);
    }

}

public class NoPassGivenException extends Exception {
    public NoPassGivenException(String message) {
        super(message);
    }

}

}
",4,0,0145340aa807c9e1ed48a37129af75ebbc1068a524a1693987f1dc3fa4abb5e4
,"public String calculateMD5(String string) {
    StringBuilder result = new StringBuilder();
    try {
        MessageDigest m = MessageDigest.getInstance(""MD5"");
        m.update(string.getBytes(""UTF8""));

        byte s[] = m.digest();

        for (int i = 0; i &lt; s.length; i++) {
            result.append(Integer.toHexString((0x000000ff &amp; s[i]) | 0xffffff00).substring(6));
        }
    } catch (NoSuchAlgorithmException e) {
        throw new IllegalStateException(""Password hash is unsupported by device android implementation."", e);
    } catch (UnsupportedEncodingException e) {
        throw new IllegalStateException(""Password hash is unsupported by device android implementation."", e);
    }
    return result.toString();
}
",,1,71e3dfda890be817d60b7290ca295446c4d7a8cf9a4f27dfc64c1b659d06addd
,"public class MySSLSocketFactory extends SSLSocketFactory {

    private SSLSocketFactory factory = (SSLSocketFactory) SSLSocketFactory.getDefault();
    private Socket last;

    public void closeLastSocket() {
        if (last != null) {
            last.close();
        }
    }

    public Socket createSocket() throws IOException {
        return this.last = factory.createSocket();
    }

    ...

}
",,1,55da5d0309b92cebc15432e5382d74f79d757e6681afc634837c7ca44459125f
,"byte[] certData = ...       
/* create KeyStore */
KeyStore ks = KeyStore.getInstance(""JKS"", ""SUN"");
/* load key store (initialization */
ks.load(null, null);
/* create CertificateFactory */
CertificateFactory cf = CertificateFactory.getInstance(""X509"");
/* create certificate from input stream */
Certificate cert;
/* provide cert data */
ByteArrayInputStream in = new ByteArrayInputStream(makeCert(certData));



private static byte[] makeCert(byte[] data) {
    String headline = ""-----BEGIN CERTIFICATE-----"";
    String footline = ""-----END CERTIFICATE-----"";

    String certStr = headline;
    for (int i = 0; i &lt; data.length; i++) {
        if (i%64 == 0) {
            certStr += ""\n"";
        }
        certStr += (char)data[i];
    }
    if ((data.length-1)%64 != 0) {
        certStr += ""\n"";
    }
    certStr += footline;
    return certStr.getBytes();
}
",,1,c5dfecd2031ac4864d79140b68b88d07aec6185fdd61a540104fdd719abe9c1e
,"package com.myApp.security;

import  android.util.Base64;

import javax.crypto.Cipher;
import javax.crypto.spec.SecretKeySpec;

public class Security {
    public static String encrypt(String input, String key){
      byte[] crypted = null;
      try{
        SecretKeySpec skey = new SecretKeySpec(key.getBytes(), ""AES"");
          Cipher cipher = Cipher.getInstance(""AES/ECB/PKCS5Padding"");
          cipher.init(Cipher.ENCRYPT_MODE, skey);
          crypted = cipher.doFinal(input.getBytes());
        }catch(Exception e){
            System.out.println(e.toString());
        }
        return new String(Base64.encode(crypted, Base64.DEFAULT));
    }

    public static String decrypt(String input, String key){
        byte[] output = null;
        try{
          SecretKeySpec skey = new SecretKeySpec(key.getBytes(), ""AES"");
          Cipher cipher = Cipher.getInstance(""AES/ECB/PKCS5Padding"");
          cipher.init(Cipher.DECRYPT_MODE, skey);
          //output = cipher.doFinal(Base64.decodeBase64(input));
          output = cipher.doFinal(Base64.decode(input, Base64.DEFAULT));
        }catch(Exception e){
          System.out.println(e.toString());
        }
        return new String(output);
    }   
}
",4,0,54313c4ff5dff89df3f161039d86e684649953fc56109b827791d8d47fb3d876
,"public class Crypto {

Cipher ecipher;
Cipher dcipher;

byte[] salt = { 1, 2, 4, 5, 7, 8, 3, 6 };
int iterationCount = 1979;

Crypto(String passPhase) {
    try {
        // Create the key
        KeySpec keySpec = new PBEKeySpec(passPhase.toCharArray(), salt, iterationCount);
        SecretKey key = SecretKeyFactory.getInstance(""PBEWITHSHA256AND128BITAES-CBC-BC"").generateSecret(keySpec);
        ecipher = Cipher.getInstance(key.getAlgorithm()); 
        dcipher = Cipher.getInstance(key.getAlgorithm());

        AlgorithmParameterSpec paramSpec = new PBEParameterSpec(salt, iterationCount);

        ecipher.init(Cipher.ENCRYPT_MODE, key, paramSpec);
        dcipher.init(Cipher.DECRYPT_MODE, key, paramSpec);

    } catch (Exception e) {
        // TODO: handle exception
        //Toast.makeText(this, ""I cought "", Toast.LENGTH_LONG).show();
    }


}

public String encrypt(String str) {
    String rVal;
    try {
        byte[] utf8 = str.getBytes(""UTF8"");

        byte[] enc = ecipher.doFinal(utf8);

        rVal = toHex(enc);

    } catch (Exception e) {
        // TODO: handle exception
        rVal = ""Exception Caught ""+e.getMessage();
    }
    return rVal;
}


public String decrypt(String str) {
    String rVal;
    try {
        byte[] dec = toByte(str);
        byte[] utf8 = dcipher.doFinal(dec);

        rVal = new String(utf8, ""UTF8"");

    } catch(Exception e) {
        rVal = ""Error in decrypting :""+e.getMessage();
    }
    return rVal;
}

private static byte[] toByte(String hexString ) {
    int len = hexString.length()/2;
    byte[] result = new byte[len];
    for ( int i=0; i&lt;len; i++ ) {
        result[i] = Integer.valueOf(hexString.substring(2*i, 2*i+2), 16 ).byteValue();

    }
    return result;
}
private static String toHex(byte[] buf) {
    if (buf == null)
        return """";
    StringBuffer result = new StringBuffer( 2*buf.length);
    for ( int i=0; i&lt;buf.length; i++) {
        appendHex(result, buf[i]);

    }
    return result.toString();
}

private final static String HEX = ""0123456789ABCDEF"";

private static void appendHex(StringBuffer sb, byte b) {
    sb.append(HEX.charAt((b &gt;&gt; 4) &amp; 0x0f)).append(HEX.charAt(b &amp; 0x0f));
}


}
",4,0,1f0db5477c0ddb96d6456392fce9e3487c1d72c1329ac54ac9ea0ba1ac0243bf
,"   package whatsapp;

    import java.io.File;

    import java.io.FileInputStream;

    import java.io.FileOutputStream;

    import java.math.BigInteger;

    import java.security.MessageDigest;

    import java.util.Arrays;

    import javax.crypto.Cipher;

    import javax.crypto.CipherInputStream;

    import javax.crypto.spec.IvParameterSpec;

    import javax.crypto.spec.SecretKeySpec;

    public class WhatsAppDecrypt5 {

        private static final byte[] INITIALIZATION_VECTOR = hexStringToByteArray(""1e39f369e90db33aa73b442bbbb6b0b9"");
        private static final byte[] ENCRYPTION_KEY = hexStringToByteArray(""8d4b155cc9ff81e5cbf6fa7819366a3ec621a656416cd793"");
        public static void main(String[] args) throws Exception {



            if (args.length != 3) {
                System.out.println(""usage &lt;inputfile&gt; &lt;outputfile&gt; &lt;email&gt;"");
            //  System.exit(0);
            }
            decrypt(new File(""/Users/ovazquez/Downloads/msgstore.db.crypt5""), new File(""/Users/ovazquez/Downloads/msgstore.db""), ""theasociatedemail@gmail.com"");
            System.out.println(""finalizado"");
        }

        private static void decrypt(File inputFile, File outputFile, String email)
                throws Exception {

            String emailMD5 = md5(email);

            byte[] emailMD5Bytes = hexStringToByteArray(emailMD5 + emailMD5);

            byte[] decryptionKey = Arrays.copyOf(ENCRYPTION_KEY, 24);

            for (int i = 0; i &lt; 24; i++) {
                decryptionKey[i] ^= emailMD5Bytes[i &amp; 0xF];
            }

            Cipher cipher = Cipher.getInstance(""AES/CBC/NoPadding"", ""SunJCE"");
            cipher.init(Cipher.DECRYPT_MODE,new SecretKeySpec(decryptionKey, ""AES""), new IvParameterSpec(INITIALIZATION_VECTOR));
            CipherInputStream cIn = new CipherInputStream(new FileInputStream(inputFile), cipher);
            FileOutputStream fOut = new FileOutputStream(outputFile);

            byte[] buffer = new byte[8192];

            int n;

            while ((n = cIn.read(buffer)) != -1) {

                fOut.write(buffer, 0, n);

            }

            cIn.close();

            fOut.close();

        }

        private static byte[] hexStringToByteArray(String s) {

            int len = s.length();

            byte[] data = new byte[len / 2];

            for (int i = 0; i &lt; len; i += 2) {

                data[i / 2] = (byte) ((Character.digit(s.charAt(i), 16) &lt;&lt; 4) + Character
                        .digit(s.charAt(i + 1), 16));

            }

            return data;

        }

        private static String md5(String md5) throws Exception {

            MessageDigest m = MessageDigest.getInstance(""MD5"");

            m.reset();

            m.update(md5.getBytes());

            byte[] digest = m.digest();

            BigInteger bigInt = new BigInteger(1, digest);

            return bigInt.toString(16);

        }

    }
",4,0,098d7c9080b9d60b132eae51ea52b09bc1349d66706ae61b01256ac4bb0f9186
,"import org.apache.http.conn.ssl.SSLSocketFactory;

import java.io.IOException;
import java.io.InputStream;
import java.net.Socket;
import java.security.KeyManagementException;
import java.security.KeyStore;
import java.security.KeyStoreException;
import java.security.NoSuchAlgorithmException;
import java.security.UnrecoverableKeyException;
import java.security.cert.CertificateException;
import java.security.cert.X509Certificate;
import java.util.ArrayList;
import java.util.Arrays;

import javax.net.ssl.KeyManager;
import javax.net.ssl.KeyManagerFactory;
import javax.net.ssl.SSLContext;
import javax.net.ssl.TrustManager;
import javax.net.ssl.TrustManagerFactory;
import javax.net.ssl.X509TrustManager;

/**
 * Allows you to trust certificates from additional KeyStores in addition to
 * the default KeyStore
 */
public class AdditionalKeyStoresSSLSocketFactory extends SSLSocketFactory{
    protected SSLContext sslContext = SSLContext.getInstance(""TLSv1"");

    public AdditionalKeyStoresSSLSocketFactory(KeyStore keyStore) throws NoSuchAlgorithmException, KeyManagementException, KeyStoreException, UnrecoverableKeyException {
        super(null, null, null, null, null, null);
        KeyManagerFactory keyManagerFactory = KeyManagerFactory
                .getInstance(KeyManagerFactory.getDefaultAlgorithm());;
        keyManagerFactory.init(keyStore, ""123456"".toCharArray());
        sslContext.init(keyManagerFactory.getKeyManagers(), new TrustManager[]{new AdditionalKeyStoresTrustManager(keyStore)}, null);
    }

    @Override
    public Socket createSocket(Socket socket, String host, int port, boolean autoClose) throws IOException {
        return sslContext.getSocketFactory().createSocket(socket, host, port, autoClose);
    }

    @Override
    public Socket createSocket() throws IOException {
        return sslContext.getSocketFactory().createSocket();
    }



    /**
     * Based on http://download.oracle.com/javase/1.5.0/docs/guide/security/jsse/JSSERefGuide.html#X509TrustManager
     */
    public static class AdditionalKeyStoresTrustManager implements X509TrustManager {

        protected ArrayList&lt;X509TrustManager&gt; x509TrustManagers = new ArrayList&lt;X509TrustManager&gt;();


        protected AdditionalKeyStoresTrustManager(KeyStore... additionalkeyStores) {
            final ArrayList&lt;TrustManagerFactory&gt; factories = new ArrayList&lt;TrustManagerFactory&gt;();

            try {
                // The default Trustmanager with default keystore
                final TrustManagerFactory original = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());
                original.init((KeyStore) null);
                factories.add(original);

                for( KeyStore keyStore : additionalkeyStores ) {
                    final TrustManagerFactory additionalCerts = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());
                    additionalCerts.init(keyStore);
                    factories.add(additionalCerts);
                }

            } catch (Exception e) {
                throw new RuntimeException(e);
            }



            /*
             * Iterate over the returned trustmanagers, and hold on
             * to any that are X509TrustManagers
             */
            for (TrustManagerFactory tmf : factories)
                for( TrustManager tm : tmf.getTrustManagers() )
                    if (tm instanceof X509TrustManager)
                        x509TrustManagers.add( (X509TrustManager)tm );


            if( x509TrustManagers.size()==0 )
                throw new RuntimeException(""Couldn't find any X509TrustManagers"");

        }

        /*
         * Delegate to the default trust manager.
         */
        public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {
            final X509TrustManager defaultX509TrustManager = x509TrustManagers.get(0);
            defaultX509TrustManager.checkClientTrusted(chain, authType);
        }

        /*
         * Loop over the trustmanagers until we find one that accepts our server
         */
        public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {
            for( X509TrustManager tm : x509TrustManagers ) {
                try {
                    tm.checkServerTrusted(chain,authType);
                    return;
                } catch( CertificateException e ) {
                    // ignore
                }
            }
            throw new CertificateException();
        }

        public X509Certificate[] getAcceptedIssuers() {
            final ArrayList&lt;X509Certificate&gt; list = new ArrayList&lt;X509Certificate&gt;();
            for( X509TrustManager tm : x509TrustManagers )
                list.addAll(Arrays.asList(tm.getAcceptedIssuers()));
            return list.toArray(new X509Certificate[list.size()]);
        }
    }

}
",4,0,6fd241234f9a10d66f979939b578331991c0dbb52719ef0364be9e722dbc7c5b
,"private static String generateSasToken(String uri, String keyName, String key){
        String ret = """";

       // long tokenExpirationTime = (System.currentTimeMillis() / 1000) + (10 * 365 * 24 * 60 * 60);

        Date now = new Date();
        Date previousDate=new Date(1970);
        long tokenExpirationTime = ((now.getTime() - previousDate.getTime()) / 1000 )+3600;

        try {
            String stringToSign = URLEncoder.encode(new URL(uri).toString(),java.nio.charset.StandardCharsets.UTF_8.toString()) + ""\n"" + tokenExpirationTime;

            System.out.println(stringToSign);
            SecretKey secretKey = null;

            byte[] keyBytes = key.getBytes(""UTF-8"");

            Mac mac = Mac.getInstance(""HMACSHA256"");

            secretKey = new SecretKeySpec(keyBytes, mac.getAlgorithm());

            mac.init(secretKey);

            byte[] digest = mac.doFinal(stringToSign.getBytes());
            //We then use the composite signing key to create an oauth_signature from the signature base string
            String signature = Base64.encodeBase64String(digest);
            System.out.println( URLEncoder.encode(signature, java.nio.charset.StandardCharsets.UTF_8.toString()));
           // String signature = Base64.encodeBase64String(mac.doFinal(stringToSign.getBytes(""UTF-8"")));
            ret = String.format(""SharedAccessSignature sr=%s&amp;sig=%s&amp;se=%s&amp;skn=%s"",
                    URLEncoder.encode(uri, java.nio.charset.StandardCharsets.UTF_8.toString()),
                    URLEncoder.encode(signature, java.nio.charset.StandardCharsets.UTF_8.toString()),
                    String.valueOf(tokenExpirationTime),
                    keyName);
        } catch (MalformedURLException e) {
            e.printStackTrace();
        } catch (NoSuchAlgorithmException e) {
            e.printStackTrace();
        } catch (InvalidKeyException e) {
            e.printStackTrace();
        } catch (UnsupportedEncodingException e) {
            e.printStackTrace();
        }

        return ret;
    }
",2,0,b11b6403d5b8805e8cf3c9cebcf169cc8bd25f9d7219f9f56f3cf2c52776ba73
,"public static String md5(String string) {
    byte[] hash;

    try {
        hash = MessageDigest.getInstance(""MD5"").digest(string.getBytes(""UTF-8""));
    } catch (NoSuchAlgorithmException e) {
        throw new RuntimeException(""Huh, MD5 should be supported?"", e);
    } catch (UnsupportedEncodingException e) {
        throw new RuntimeException(""Huh, UTF-8 should be supported?"", e);
    }

    StringBuilder hex = new StringBuilder(hash.length * 2);

    for (byte b : hash) {
        int i = (b &amp; 0xFF);
        if (i &lt; 0x10) hex.append('0');
        hex.append(Integer.toHexString(i));
    }

    return hex.toString();
}
",,1,80cef32b8f731aefea2f6fa8883557b7a1c55da6cdd8c135f3fde2c10d29fa25
,"KeyStore trusted;
try {  

        trusted = KeyStore.getInstance(""pkcs12"");
        trusted.load(null, """".toCharArray());
        SSLSocketFactory sslf = new SSLSocketFactory(trusted);
",,1,323b3a7af543a8f26d8289a13a136ad585848f92e187e7b1b5e3d53c89dc45d2
,"SecretKeyFactory factory = 
    SecretKeyFactory.getInstance(""PBEWITHSHAAND256BITAES-CBC-BC"");
KeySpec spec = new PBEKeySpec(""password"".toCharArray(), salt, 1024, 256);
SecretKey tmp = factory.generateSecret(spec);
SecretKey secret = new SecretKeySpec(tmp.getEncoded(), ""AES"");
",1,0,5904eeb5627cf18cb6f72aefb6154bf6220a238983193d399ee259a92ea86137
,"int bks_version;
if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.JELLY_BEAN_MR1) {
    bks_version = R.raw.publickey; //The BKS file
} else {
    bks_version = R.raw.publickey_v1; //The BKS (v-1) file
}
KeyStore ks = KeyStore.getInstance(""BKS"");
InputStream in = getResources().openRawResource(bks_version);  
ks.load(in, ""mypass"".toCharArray());
",,1,4a71b97cb4841350c3957fdf49cab30e58f35afd53a45555a2ddc279b8f40265
,"    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        try {
            PackageInfo info = getPackageManager().getPackageInfo(
                    ""com.facebook.samples.loginhowto"", 
                    PackageManager.GET_SIGNATURES);
            for (Signature signature : info.signatures) {
                MessageDigest md = MessageDigest.getInstance(""SHA"");
                md.update(signature.toByteArray());
                Log.d(""KeyHash:"", Base64.encodeToString(md.digest(), Base64.DEFAULT));
                }
        } catch (NameNotFoundException e) {

        } catch (NoSuchAlgorithmException e) {

        }
        ...other operations

}//end of onCreate
",3,0,6c241c1f95dcfd915833e7a86a052fbc0008d7afeca017bacdfb7ee84e44b401
,"Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding""); // adjust padding
cipher.init(Cipher.ENCRYPT_MODE, skeySpec, new IvParameterSpec(...));
",1,0,18fb2cc6dbf8d0adea24bb4d046a0e6cf54aae9e6abec59bc12246a7b9ff7042
,"private SSLSocketFactory getSocketFactory() {
        // TODO Auto-generated method stub
        SSLSocketFactory sslFactory = null;
        try {
            KeyStore keyStore = KeyStore.getInstance(""BKS"");
            InputStream instream = this.getResources().openRawResource(
                    R.raw.website_public);
            keyStore.load(instream, ""keystore_password"".toCharArray());
            sslFactory = new MySSLSocketFactory(keyStore);
        } catch (KeyStoreException e1) {
            // TODO Auto-generated catch block
            e1.printStackTrace();
        } catch (NoSuchAlgorithmException e1) {
            // TODO Auto-generated catch block
            e1.printStackTrace();
        } catch (CertificateException e1) {
            // TODO Auto-generated catch block
            e1.printStackTrace();
        } catch (IOException e1) {
            // TODO Auto-generated catch block
            e1.printStackTrace();
        } catch (UnrecoverableKeyException e1) {
            // TODO Auto-generated catch block
            e1.printStackTrace();
        } catch (KeyManagementException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }
        return sslFactory;
    }
",,1,8623af986581866111a0c2ae5469a2ad2afc817072648fe08b543f2d14830387
,"    public static boolean verifyPurchase(String base64PublicKey, String signedData, String signature) {
    if (signedData == null) {
        Log.e(TAG, ""data is null"");
        return false;
    }

    boolean verified = false;
    if (!TextUtils.isEmpty(signature)) {
        PublicKey key = Security.generatePublicKey(base64PublicKey);

        if( key != null) // ADD_THIS_LINE
            verified = Security.verify(key, signedData, signature);

        if (!verified) {
            Log.w(TAG, ""signature does not match data."");
            return false;
        }
    }
    return true;
}    
////////////////////////////////////////////////////////////////////////
//  :     :     
///////////////////////////////////////////////////////////////////////
 public static PublicKey generatePublicKey(String encodedPublicKey) {
    try {
        byte[] decodedKey = Base64.decode(encodedPublicKey);
        KeyFactory keyFactory = KeyFactory.getInstance(KEY_FACTORY_ALGORITHM);
        return keyFactory.generatePublic(new X509EncodedKeySpec(decodedKey));
    } catch (NoSuchAlgorithmException e) {
        throw new RuntimeException(e);
    } catch (InvalidKeySpecException e) {
        Log.e(TAG, ""Invalid key specification."");
        throw new IllegalArgumentException(e);
    } catch (Base64DecoderException e) {
        Log.e(TAG, ""Base64 decoding failed."");
        return null;  // ADD_THIS_LINE
        // COMMENT_OUT_THIS_LINE:   throw new IllegalArgumentException(e);
    }
}


//////////////////////////////////////////////////////////////
",3,0,2b69f54651ca4e0cfea0a726fcb504fbe91cf7848a0d7a37d41c3bdba125f878
,"try {
        PackageInfo info =     getPackageManager().getPackageInfo(""com.package.mypackage"",     PackageManager.GET_SIGNATURES);
        for (Signature signature : info.signatures) {
            MessageDigest md = MessageDigest.getInstance(""SHA"");
            md.update(signature.toByteArray());
            String sign=Base64.encodeToString(md.digest(), Base64.DEFAULT);
            Log.e(""MY KEY HASH:"", sign);
            Toast.makeText(getApplicationContext(),sign,     Toast.LENGTH_LONG).show();
        }
} catch (NameNotFoundException e) {
} catch (NoSuchAlgorithmException e) {
}
",3,0,0443c1f4fefcad2e5abf60afc3176949342c94e61057875175ddffe23f26a995
,"Provider[] providers = Security.getProviders();
for (Provider provider : providers) {
    Log.i(""CRYPTO"",""provider: ""+provider.getName());
    Set&lt;Provider.Service&gt; services = provider.getServices();
    for (Provider.Service service : services) {
        Log.i(""CRYPTO"",""  algorithm: ""+service.getAlgorithm());
    }
}
",,1,efd0eabdd7cb23587b8839a94a6822fd6007ae217879a8c58377f583eb2f9b01
,"public String hashSha1(byte[] data) throws NoSuchAlgorithmException, 
    UnsupportedEncodingException { 
  MessageDigest md = MessageDigest.getInstance(""SHA-1"");
  md.update(data, 0, data.length);
  return convertToHex(md.digest());
}
",3,0,ae0bd1591715ef64dfb127dbce3569a637be82a2c1c4669feef7860d133280b8
,"try {
    PackageInfo info = getPackageManager().getPackageInfo(
            ""your.package.name"", 
            PackageManager.GET_SIGNATURES);
    for (Signature signature : info.signatures) {
        MessageDigest md = MessageDigest.getInstance(""SHA"");
        md.update(signature.toByteArray());
        Log.d(""KeyHash:"", Base64.encodeToString(md.digest(), Base64.DEFAULT));
        }
} catch (NameNotFoundException e) {
} catch (NoSuchAlgorithmException e) {
}
",3,0,b48a308e8a893d926e79ed05e66d2dde41f5c3b7308c57672f6bf1879a0631dc
,"public boolean Verify(RSAPublicKey key, String signature, String data)
{
    try
    {
        Signature sign = Signature.getInstance(""SHA1withRSA"");
        sign.initVerify(key);
        sign.update(data.getBytes(""UTF-8""));
        return sign.verify(Base64.decode(signature.getBytes(""UTF-8""), Base64.NO_WRAP));
    }
    catch (Exception e)
    {
        e.printStackTrace();
    }
    return false;
}
",3,0,9d543f50463104ca050a43e04c68948da10a6425c56a238bb56c1f496b9d7c45
,"private RSAPublicKey GetPublicKey(String keyXmlString) throws InvalidKeySpecException, UnsupportedEncodingException, NoSuchAlgorithmException
{
    KeyFactory keyFactory = KeyFactory.getInstance(""RSA"");

    String modulusString = keyXmlString.substring(keyXmlString.indexOf(""&lt;Modulus&gt;""), keyXmlString.indexOf(""&lt;/Modulus&gt;"")).replace(""&lt;Modulus&gt;"", """");
    String exponentString = keyXmlString.substring(keyXmlString.indexOf(""&lt;Exponent&gt;""), keyXmlString.indexOf(""&lt;/Exponent&gt;"")).replace(""&lt;Exponent&gt;"", """");

    byte[] modulusBytes = Base64.decode(modulusString.getBytes(""UTF-8""), Base64.DEFAULT);
    byte[] dBytes = Base64.decode(exponentString.getBytes(""UTF-8""), Base64.DEFAULT);

    BigInteger modulus = new BigInteger(1, modulusBytes);
    BigInteger d = new BigInteger(1, dBytes);

    RSAPublicKeySpec keySpec = new RSAPublicKeySpec(modulus, d);

    return (RSAPublicKey) keyFactory.generatePublic(keySpec);
}
",,1,0c8c6bdff913f0cc1b51132bdce26ef3abe92c743509eb220b8d6af3db2f63e4
,"private byte[] cipherData(PaddedBufferedBlockCipher cipher, byte[] data) throws Exception {
        int minSize = cipher.getOutputSize(data.length);
        byte[] outBuf = new byte[minSize];
        int length1 = cipher.processBytes(data, 0, data.length, outBuf, 0);
        int length2 = cipher.doFinal(outBuf, length1);
        int actualLength = length1 + length2;
        byte[] result = new byte[actualLength];
        System.arraycopy(outBuf, 0, result, 0, result.length);
        return result;
    }
",,1,2be374cbad633273719af8cd366717e6782bc105ed8d17facf9e848187a68b69
,"public void decrypt(File inputFile, File outputFile, byte[] key) throws Exception {
        Cipher cipher = getCipherDecrypt(key);
        FileOutputStream fos = null;
        CipherInputStream cis = null;
        FileInputStream fis = null;
        try { 
            fis = new FileInputStream(inputFile);
            cis = new CipherInputStream(fis, cipher);
            fos = new FileOutputStream(outputFile);
            byte[] data = new byte[1024];
            int read = cis.read(data);
            while (read != -1) {
                fos.write(data, 0, read);
                read = cis.read(data);
                System.out.println(new String(data, ""UTF-8"").trim());
            } 
        } finally { 
            fos.close();
            cis.close();
            fis.close();
        } 
    } 
",,1,8791a0e2034b4b182a719da355910f6c18ae1cc47fcf9b3844d04ef1d85767e4
,"import android.security.MessageDigest;

public class MessageDigestTester {

    private static Boolean messageDigestAvailable = null;

    public static Boolean isLibraryAvailable() {
        if (messageDigestAvailable == null) {
            try {
                MessageDigest digest = MessageDigest.getInstance(""MD5"");

                messageDigestAvailable = true;

            } catch (NoClassDefFoundError e) {
                messageDigestAvailable = false;
            }

        } 

        return messageDigestAvailable;
    }
}
",3,0,7ebdc52e98f1c0c7994e1997f4d5a278f63b8c27dcb33956f02fd4a1f1c91d78
,"public static void main(String[] args) {
    try {
        byte[] keyBytes = {0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F};
        byte[] ivBytes =  {0x77, 0x66, 0x55, 0x44, 0x33, 0x22, 0x11, 0x00, 0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77};

        SecretKeySpec sks = new SecretKeySpec(keyBytes, ""AES"");
        IvParameterSpec iv = new IvParameterSpec(ivBytes);

        Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
        cipher.init(Cipher.DECRYPT_MODE, sks, iv);

        // read file to byte[]
        InputStream is = new FileInputStream(""test.enc"");
        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        int b;
        while ((b = is.read()) != -1) {
            baos.write(b);
        }
        byte[] fileBytes = baos.toByteArray();

        byte[] decrypted = cipher.doFinal(fileBytes);
        System.out.println(new String(decrypted));

    } catch (Exception e) {
        e.printStackTrace();
    }
}
",4,0,b96070201b60f176d590ea3ac6977f392e4010d05f32e3fb2243c5ca32eba337
,"        static public boolean DEVELOPMENT_VERBOSE = false;
        static private final  X500Principal RELEASE_DN = new X500Principal(
            ""CN=aaa,OU=bbb,O=ccc,L=ddd,ST=eee,C=fff""
            );

        // auto disable the development logs if the apk is signed with a cert
        try {
            PackageManager manager = context.getPackageManager();
            PackageInfo appInfo = manager.getPackageInfo(""com.xxx.app"",
                    PackageManager.GET_SIGNATURES);
            Signature raw = appInfo.signatures[0];

            try {
                CertificateFactory cf = CertificateFactory.getInstance(""X.509"");
                X509Certificate cert = (X509Certificate) cf.generateCertificate(new ByteArrayInputStream(raw.toByteArray()));

                //DEVELOPMENT_VERBOSE = cert.getSubjectX500Principal().equals(DEBUG_DN);
                if (!cert.getSubjectX500Principal().equals(RELEASE_DN))
                    DEVELOPMENT_VERBOSE = true;

            } catch (CertificateException e) {  

            }           
        } catch (NameNotFoundException e) {

        }
",2,0,5b52813559eca01969ea59e3aea216984c0fb76a4557d95f561e8a91f5291799
,"private static byte[] encrypt(byte[] raw, byte[] clear) throws Exception 
{
    SecretKeySpec skeySpec = new SecretKeySpec(raw, ""AES"");
    Cipher cipher = Cipher.getInstance(""AES"");
    cipher.init(Cipher.ENCRYPT_MODE, skeySpec);
    byte[] encrypted = cipher.doFinal(clear);
    return encrypted;
}

private static byte[] decrypt(byte[] raw, byte[] encrypted) throws Exception     
{
    SecretKeySpec skeySpec = new SecretKeySpec(raw, ""AES"");
    Cipher cipher = Cipher.getInstance(""AES"");
    cipher.init(Cipher.DECRYPT_MODE, skeySpec);
    byte[] decrypted = cipher.doFinal(encrypted);
    return decrypted;
}
",4,0,e7e466094c34a791a9e318881dba1bd2eea50bc34f1593831643b7e25da36a4a
,"ByteArrayOutputStream baos = new ByteArrayOutputStream();  
bm.compress(Bitmap.CompressFormat.PNG, 100, baos); 
byte[] b = baos.toByteArray();  

byte[] keyStart = ""encryption key"".getBytes();
KeyGenerator kgen = KeyGenerator.getInstance(""AES"");
SecureRandom sr = SecureRandom.getInstance(""SHA1PRNG"");
sr.setSeed(keyStart);
kgen.init(128, sr); 
SecretKey skey = kgen.generateKey();
byte[] key = skey.getEncoded();    

// encrypt
byte[] encryptedData = encrypt(key,b);
// decrypt
byte[] decryptedData = decrypt(key,encryptedData);
",4,0,6f0e11130eca9f57f689402f714f3193b828d95283ffdba5c466d77b35bfa1f6
,"KeyStore trustStore = KeyStore.getInstance(""BKS"");
InputStream is = this.getAssets().open(""discretio.bks"");
trustStore.load(is, ""discretio"".toCharArray());
is.close();

SSLSocketFactory sockfacto = new SSLSocketFactory(trustStore);
sockfacto.setHostnameVerifier(SSLSocketFactory.STRICT_HOSTNAME_VERIFIER);

SchemeRegistry schemeRegistry = new SchemeRegistry();
schemeRegistry.register(new Scheme(""http"", PlainSocketFactory.getSocketFactory(), 80));
schemeRegistry.register(new Scheme(""https"", sockfacto, 443));

SingleClientConnManager mgr = new SingleClientConnManager(httpParameters, schemeRegistry);

HttpClient client = new DefaultHttpClient(mgr, httpParameters);
HttpGet request = new HttpGet(url);
HttpResponse response = client.execute(request);
",3,0,501be0b0d23b343625f04d3a39948c746e69689d2e82096d00ee57b868d1d5cc
,"KeyStore trustStore = KeyStore.getInstance(""BKS"");
InputStream is = this.getAssets().open(""discretio.bks"");
trustStore.load(is, ""discretio"".toCharArray());
is.close();

TrustManagerFactory tmf = TrustManagerFactory.getInstance(""X509"");
tmf.init(trustStore);
SSLContext context = SSLContext.getInstance(""TLS"");
context.init(null, tmf.getTrustManagers(), null);

URL request = new URL(url);
HttpsURLConnection urlConnection = (HttpsURLConnection) request.openConnection();

//ensure that we are using a StrictHostnameVerifier
urlConnection.setHostnameVerifier(new StrictHostnameVerifier());
urlConnection.setSSLSocketFactory(context.getSocketFactory());
urlConnection.setConnectTimeout(15000);

InputStream in = urlConnection.getInputStream();
//I don't want to change my function's return type (laziness) so I'm building an HttpResponse
BasicHttpEntity res = new BasicHttpEntity();
res.setContent(in);
HttpResponse resp = new BasicHttpResponse(HttpVersion.HTTP_1_1, urlConnection.getResponseCode(), """");
resp.setEntity(res);
",3,0,f74723448cb28271b43ca62a387e96e88d70692cb759e5ddb2f5384240391b40
,"  public void printHashKey() {

        try {
            PackageInfo info = getPackageManager().getPackageInfo(""your.package.name"",
                    PackageManager.GET_SIGNATURES);
            for (Signature signature : info.signatures) {
                MessageDigest md = MessageDigest.getInstance(""SHA"");
                md.update(signature.toByteArray());
                Log.d(""TEMPTAGHASH KEY:"",
                        Base64.encodeToString(md.digest(), Base64.DEFAULT));
            }
        } catch (NameNotFoundException e) {

        } catch (NoSuchAlgorithmException e) {

        }

    }
",3,0,24a0553d2b6e8fae1214a4023b9eaaa8d6ccd7525b540f06c1db3133ed3a8183
,"try {
PackageInfo info = getPackageManager().getPackageInfo(
        ""com.example.com.tvishi.fb"", 
        PackageManager.GET_SIGNATURES);
for (Signature signature : info.signatures) {
    MessageDigest md = MessageDigest.getInstance(""SHA"");
    md.update(signature.toByteArray());
    Log.d(""KeyHash:"", Base64.encodeToString(md.digest(), Base64.DEFAULT));
    }
} catch (NameNotFoundException e) {

} catch (NoSuchAlgorithmException e) {

}
",2,0,8b84cdcb58667829e79a6711796103b3ace1d9fe1928bde63fa7dbb97fb586e0
,"try {
            PackageInfo info = context.getPackageManager().getPackageInfo(
                    ""com.mypackage.name"", 
                    PackageManager.GET_SIGNATURES);
            for (Signature signature : info.signatures) {
                MessageDigest md = MessageDigest.getInstance(""SHA"");
                md.update(signature.toByteArray());
                Log.e(""KeyHash:"", Base64.encodeToString(md.digest(), Base64.DEFAULT));
                }
        } catch (NameNotFoundException e) {

        } catch (NoSuchAlgorithmException e) {

        }
",3,0,93a7786ec148fc04d302639c3f1302a8cd9abeb24fd9ad6bd167684843492969
,"import java.security.MessageDigest;

public class SHA512 {
      public static void main(String args[]) throws Exception {
          String password = ""pass@word1"";

            if ((args.length == 1) &amp;&amp; (args[0].length() &gt; 0))
            {
                password = args[0];
            }
            System.out.println(""Password: "" + password + "" in SHA512 is:"");
            System.out.println(hashText(password));
      }

    public static String convertByteToHex(byte data[])
    {
        StringBuffer hexData = new StringBuffer();
        for (int byteIndex = 0; byteIndex &lt; data.length; byteIndex++)
            hexData.append(Integer.toString((data[byteIndex] &amp; 0xff) + 0x100, 16).substring(1));

        return hexData.toString();
    }

    public static String hashText(String textToHash) throws Exception
    {
        final MessageDigest sha512 = MessageDigest.getInstance(""SHA-512"");
        sha512.update(textToHash.getBytes());

        return convertByteToHex(sha512.digest());
    }
}
",2,0,70809dac38e9848d92a03bb6f5ffd91839600981672b6c3eb94e6a41f240f2bd
,"SSLContext context = SSLContext.getInstance(""TLS"");
    context.init(null, null, null);
    SSLSocketFactory factory = context.getSocketFactory();
    httpURLConnection.setSSLSocketFactory(factory);
",3,0,7a94f5fea20838403272abfd70f0630c813a0f02fa9c300d62af9cfe90c05d8e
,"public void connectToFb() throws XMPPException {

ConnectionConfiguration config = new ConnectionConfiguration(""chat.facebook.com"", 5222);
config.setSASLAuthenticationEnabled(true);
config.setSecurityMode(SecurityMode.required);
config.setRosterLoadedAtLogin(true);
config.setTruststorePath(""/system/etc/security/cacerts.bks"");
config.setTruststorePassword(""changeit"");
config.setTruststoreType(""bks"");
config.setSendPresence(false);
try {
    SSLContext sc = SSLContext.getInstance(""TLS"");
    sc.init(null, MemorizingTrustManager.getInstanceList(this), new java.security.SecureRandom());
    config.setCustomSSLContext(sc);
} catch (GeneralSecurityException e) {
    Log.w(""TAG"", ""Unable to use MemorizingTrustManager"", e);
}
XMPPConnection xmpp = new XMPPConnection(config);
try {
    xmpp.connect();
    xmpp.login(""facebookusername"", ""****""); // Here you have to used only facebookusername from facebookusername@chat.facebook.com
    Roster roster = xmpp.getRoster();
    Collection&lt;RosterEntry&gt; entries = roster.getEntries();
    System.out.println(""Connected!"");
    System.out.println(""\n\n"" + entries.size() + "" buddy(ies):"");
    // shows first time onliners----&gt;
    String temp[] = new String[50];
    int i = 0;
    for (RosterEntry entry : entries) {
        String user = entry.getUser();
        Log.i(""TAG"", user);
    }
} catch (XMPPException e) {
    xmpp.disconnect();
    e.printStackTrace();
}
}
",3,0,a99a4efd4f252af51dedc36b7b83f92906d79e2965ce847ea52beaf366b92368
,"try {
    PackageInfo info = getPackageManager().getPackageInfo(
            ""com.al.name"", 
            PackageManager.GET_SIGNATURES);
    for (Signature signature : info.signatures) {
        MessageDigest md = MessageDigest.getInstance(""SHA"");
        md.update(signature.toByteArray());
        Log.d(""KeyHash:"", Base64.encodeToString(md.digest(), Base64.DEFAULT));
        }
} catch (NameNotFoundException e) {

} catch (NoSuchAlgorithmException e) {

}
",3,0,1ee1c01d465ab8769691380b5fd917ae4831563fd528437fa4c538687202b4ea
,"import android.content.Context;
import android.util.Log;

import com.squareup.okhttp.OkHttpClient;
import com.squareup.okhttp.Request;
import com.squareup.okhttp.Response;

import java.io.InputStream;
import java.io.Reader;
import java.security.KeyStore;

import javax.net.ssl.SSLContext;
import javax.net.ssl.SSLSocketFactory;
import javax.net.ssl.TrustManagerFactory;


/**
 * Created by martin on 02/06/14.
 */
public class Pinning {

    Context context;
    public static String TRUST_STORE_PASSWORD = ""your_secret"";
    private static final String ENDPOINT = ""https://api.yourdomain.com/"";

    public Pinning(Context c) {
        this.context = c;
    }

    private SSLSocketFactory getPinnedCertSslSocketFactory(Context context) {
        try {
            KeyStore trusted = KeyStore.getInstance(""BKS"");
            InputStream in = context.getResources().openRawResource(R.raw.mytruststore);
            trusted.load(in, TRUST_STORE_PASSWORD.toCharArray());
            SSLContext sslContext = SSLContext.getInstance(""TLS"");
            TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(
                    TrustManagerFactory.getDefaultAlgorithm());
            trustManagerFactory.init(trusted);
            sslContext.init(null, trustManagerFactory.getTrustManagers(), null);
            return sslContext.getSocketFactory();
        } catch (Exception e) {
            Log.e(""MyApp"", e.getMessage(), e);
        }
        return null;
    }

    public void makeRequest() {
        try {
            OkHttpClient client = new OkHttpClient();
            client.setSslSocketFactory(getPinnedCertSslSocketFactory(context));

            Request request = new Request.Builder()
                    .url(ENDPOINT)
                    .build();

            Response response = client.newCall(request).execute();

            Log.d(""MyApp"", response.body().string());

        } catch (Exception e) {
            Log.e(""MyApp"", e.getMessage(), e);

        }
    }
}
",3,0,843a35667008d922c00cfbfb12ce969af37cd815b4e091f6935c603392959ef9
,"import javax.crypto.Cipher;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;

import android.util.Base64;
import android.util.Log;

public class AesFileIo {
//    private static final String AES_ALGORITHM = ""AES/CTR/NoPadding"";
    private static final String AES_ALGORITHM = ""AES/CBC/PKCS5Padding"";
    private SecretKeySpec secretKeySpec;
    private IvParameterSpec ivSpec;

    public AesFileIo(byte[] aesKey, byte[] iv) {
        ivSpec = new IvParameterSpec(iv);
        secretKeySpec = new SecretKeySpec(aesKey, ""AES"");
    }

    public String decrypt(String text) {

        StringBuilder stringBuilder = new StringBuilder(); 
        try {
            Cipher cipher = Cipher.getInstance(AES_ALGORITHM);
            cipher.init(Cipher.DECRYPT_MODE, secretKeySpec, ivSpec);
            byte[] decordedValue =  Base64.decode(text,Base64.DEFAULT);
            String decryptedValue = new String(cipher.doFinal(decordedValue),""UTF-8"");
            Log.e(""decrypted Value :"",decryptedValue);
            return decryptedValue; 
        } catch (Exception e) {
            Log.e(this.getClass().toString(), e.getMessage(), e);
        }
        return stringBuilder.toString();
    }

    public String encrypt(String text) {
        String encryptedValue=null;
        try {
            Cipher cipher = Cipher.getInstance(AES_ALGORITHM); 
            cipher.init(Cipher.ENCRYPT_MODE, secretKeySpec, ivSpec);
            byte[] encValue = cipher.doFinal(text.getBytes());
            encryptedValue = Base64.encodeToString(encValue,Base64.DEFAULT);
        } catch (Exception e) {
            Log.e(this.getClass().toString(), e.getMessage(), e);
        }
        return encryptedValue;
    }
}
",1,0,56011e1e26c7e8ee8f80c3d25779d0eff5b62ec1f28d6bba150537cbe6fd3cb8
,"  try {
                System.out.println(this.url);

                HostnameVerifier hostnameVerifier = org.apache.http.conn.ssl.SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER;
                DefaultHttpClient httpClient = new DefaultHttpClient();
                SchemeRegistry registry = new SchemeRegistry();
                SSLSocketFactory socketFactory = SSLSocketFactory
                        .getSocketFactory();
                socketFactory
                        .setHostnameVerifier((X509HostnameVerifier) hostnameVerifier);
                registry.register(new Scheme(""https"", socketFactory, 443));
                SingleClientConnManager mgr = new SingleClientConnManager(
                        httpClient.getParams(), registry);
                DefaultHttpClient client = new DefaultHttpClient(mgr,
                        httpClient.getParams());
                HttpsURLConnection.setDefaultHostnameVerifier(hostnameVerifier);

                // Set verifier
                HttpsURLConnection.setDefaultHostnameVerifier(hostnameVerifier);

                HttpGet post = new HttpGet(this.url);
                post.addHeader(""Content-type"", ""application/json;charset=UTF-80"");
                post.setHeader(""Accept"", ""application/json"");
                HttpResponse response = client.execute(post);

                // Collect the response
                HttpEntity entity1 = response.getEntity();
                if (entity1 != null
                        &amp;&amp; (response.getStatusLine().getStatusCode() == 201 || response
                                .getStatusLine().getStatusCode() == 200)) {
                    // --just so that you can view the response, this is optional--
                    int sc = response.getStatusLine().getStatusCode();
                    String sl = response.getStatusLine().getReasonPhrase();
                    String response_string = convertToString(entity1.getContent());
                    Log.i(""GET_DIARY_RESPONSE"", response_string);
                    return response_string;
                } else {
                    int sc = response.getStatusLine().getStatusCode();
                    String sl = response.getStatusLine().getReasonPhrase();
                    return null;
                }

            } catch (Exception e) {
                // TODO Auto-generated catch block
                e.printStackTrace();
            }

            return null;
",4,0,626cff2dc5946db4ce25270bf004f49ae267d46f59ad27120416bc7f5ace6504
,"package com.filepermition.android;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;

import javax.crypto.Cipher;
import javax.crypto.CipherInputStream;
import javax.crypto.CipherOutputStream;
import javax.crypto.KeyGenerator;
import javax.crypto.SecretKey;

import android.app.Activity;
import android.os.Bundle;
import android.view.View;
import android.view.View.OnClickListener;
import android.widget.Button;

public class AndroidFilePermitionActivity extends Activity 
{
    Button btn_button;

    /** Called when the activity is first created. */
    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.main);

        btn_button = (Button)findViewById(R.id.btn_button);

        btn_button.setOnClickListener(new OnClickListener() {

            @Override
            public void onClick(View v) {

                try{
                    FileInputStream fis = new FileInputStream(
                        new File(""/mnt/sdcard/testfile/file.wav""));
                    File outfile = new File(""/mnt/sdcard/testfile/encTest1234.wav"");

                    int read;
                    if(!outfile.exists())
                        outfile.createNewFile();

                    File decfile = new File(""/mnt/sdcard/testfile/dec123.wav"");
                    if(!decfile.exists())
                        decfile.createNewFile();

                    FileOutputStream fos = new FileOutputStream(outfile);
                    FileInputStream encfis = new FileInputStream(outfile);
                    FileOutputStream decfos = new FileOutputStream(decfile);

                    Cipher encipher = Cipher.getInstance(""AES"");
                    Cipher decipher = Cipher.getInstance(""AES"");

                    KeyGenerator kgen = KeyGenerator.getInstance(""AES"");
                    SecretKey skey = kgen.generateKey();
                    encipher.init(Cipher.ENCRYPT_MODE, skey);
                    CipherInputStream cis = new CipherInputStream(fis, encipher);
                    decipher.init(Cipher.DECRYPT_MODE, skey);
                    CipherOutputStream cos = new CipherOutputStream(decfos,decipher);

                    while((read = cis.read())!=-1)
                    {
                        fos.write((char)read);
                        fos.flush();
                    }   
                    fos.close();
                    while((read=encfis.read())!=-1)
                    {
                        cos.write(read);
                        cos.flush();
                    }
                    cos.close();

                }catch (Exception e) {
                    // TODO: handle exceptione
                    e.printStackTrace();
                }
            }
        });
    }
}
",,1,79d87bd389e5468dc01f1b766b9953d6b14ef7f3521394118a60b8b332ae95b2
,"public class MCrypt {

    private String iv = ""fedcba9876543210"";//Dummy iv (CHANGE IT!)
    private IvParameterSpec ivspec;
    private SecretKeySpec keyspec;
    private Cipher cipher;
    private String SecretKey = ""0123456789abcdef"";//Dummy secretKey (CHANGE IT!)

    public MCrypt() {
        ivspec = new IvParameterSpec(iv.getBytes());

        keyspec = new SecretKeySpec(SecretKey.getBytes(), ""AES"");

        try {
            cipher = Cipher.getInstance(""AES/CBC/NoPadding"");
        } catch (NoSuchAlgorithmException e) {
            e.printStackTrace();
        } catch (NoSuchPaddingException e) {
            e.printStackTrace();
        }
    }

    public byte[] encrypt(String text) throws Exception {
        if (text == null || text.length() == 0) throw new Exception(""Empty string"");

        byte[] encrypted = null;

        cipher.init(Cipher.ENCRYPT_MODE, keyspec, ivspec);

        encrypted = cipher.doFinal(padString(text).getBytes());
        try { 
            encrypted = android.util.Base64.encode(encrypted, android.util.Base64.NO_PADDING);
        } catch (NoClassDefFoundError e) {
        }

        return encrypted;
    }

    public byte[] decrypt(String code) throws Exception {
        if (code == null || code.length() == 0) throw new Exception(""Empty string"");

        byte[] decrypted = null;

        cipher.init(Cipher.DECRYPT_MODE, keyspec, ivspec);

        try { 
            decrypted = cipher.doFinal(android.util.Base64.decode(code, android.util.Base64.NO_PADDING));
        } catch (NoClassDefFoundError e) {
        }
        return decrypted;
    }



    private static String padString(String source) {
        char paddingChar = ' ';
        int size = 16;
        int x = source.length() % size;
        int padLength = size - x;

        for (int i = 0; i &lt; padLength; i++) {
            source += paddingChar;
        }

        return source;
    }
}
",4,0,fa7d0c7edd277ef562e424d91083ef63752f6184d11fe07e40a325250ea965b9
,"public static HttpClient getNewHttpClient() {
    try {
        KeyStore trustStore = KeyStore.getInstance(KeyStore.getDefaultType());
        trustStore.load(null, null);

        SSLSocketFactory sf = new RecorridoSSL(trustStore);
        sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);

        HttpParams params = new BasicHttpParams();
        HttpProtocolParams.setVersion(params, HttpVersion.HTTP_1_1);
        HttpProtocolParams.setContentCharset(params, HTTP.UTF_8);

        SchemeRegistry registry = new SchemeRegistry();
        registry.register(new Scheme(""http"", PlainSocketFactory.getSocketFactory(), 80));
        registry.register(new Scheme(""https"", sf, 443));

        ClientConnectionManager ccm = new ThreadSafeClientConnManager(params, registry);

        return new DefaultHttpClient(ccm, params);
    } catch (Exception e) {
        return new DefaultHttpClient();
    }
}
",4,0,56862e2059da71b57b80fe44264f5a1aaf2eabce3e6566c6656c952786609902
,"KeyStore keyStore = KeyStore.getInstance(""JKS"");
keyStore.load(getResources().openRawResource(R.raw.mykeystore), ""MY_PASSWORD"".toCharArray());

TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());
trustManagerFactory.init(keyStore);

SSLContext sslctx = SSLContext.getInstance(""TLS"");
sslctx.init(null, trustManagerFactory.getTrustManagers(), new SecureRandom());

SSLSocketFactory factory = sslctx.getSocketFactory();
",3,0,552e443c140c2a891e4c4a866713e3d59cde44fec40d41252c4a51031376af49
,"String message = ""Hello World"";
try{
    // Load the server keystore
    KeyStore keyStore = KeyStore.getInstance(""BKS"");
    keyStore.load(ctx.getResources().openRawResource(R.raw.mykeystore), ""MY_PASSWORD"".toCharArray());

    // Create a custom trust manager that accepts the server self-signed certificate
    TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());
    trustManagerFactory.init(keyStore);

    // Create the SSLContext for the SSLSocket to use
    SSLContext sslctx = SSLContext.getInstance(""TLS"");
    sslctx.init(null, trustManagerFactory.getTrustManagers(), new SecureRandom());

    // Create SSLSocketFactory
    SSLSocketFactory factory = sslctx.getSocketFactory();

    // Create socket using SSLSocketFactory
    SSLSocket client = (SSLSocket) factory.createSocket(""SERVER_IP_ADDRESS"", 8081);

    // Print system information
    System.out.println(""Connected to server "" + client.getInetAddress() + "": "" + client.getPort());

    // Writer and Reader
    BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(client.getOutputStream()));
    BufferedReader reader = new BufferedReader(new InputStreamReader(client.getInputStream()));

    // Send request to server
    System.out.println(""Sending request: ""+message);
    writer.write(message);
    writer.newLine();
    writer.flush();

    // Receive response from server
    String response = reader.readLine();
    System.out.println(""Received from the Server: ""+response);

    // Close connection
    client.close();

    return response;
} catch(Exception e) {
    e.printStackTrace();
}
return ""Something went wrong..."";
",3,0,948b6b80a13da1cf0f99cb97bc08f77028ec297609c8863f9250c35dcc87b58e
,"public class Upper_fragment extends Fragment {

        private static final String TAG = ""PlayActivity"";

        private Video vid;
        int mSavedVideoPosition;
        protected VideoPlayerInterface vidp;
        private LocalSingleHttpServer mServer;


        // to be implemented in concrete activities
        public Cipher getCipher() throws GeneralSecurityException {
            final Cipher c = Cipher.getInstance(""AES"");    // NoSuchAlgorithmException, NoSuchPaddingException
            c.init(Cipher.DECRYPT_MODE, new SecretKeySpec(""abcdef1234567890"".getBytes(), ""AES""));    // InvalidKeyException
            return c;
        }

        @Override
        public View onCreateView(LayoutInflater inflater, ViewGroup container,
                                 Bundle savedInstanceState) {
            View upperView = inflater.inflate(R.layout.upper_fragment, container, false);

            vidp = (VideoPlayerInterface) upperView.findViewById(R.id.vid);
            getRTSPUrl();

            init(getIntent().getSerializableExtra(Const.EXTRA_DATA));
            return upperView;
        }
",,1,ad944974bbd68a92c1c47568080499bf6247cc3cc72bcb54c2ff643edc374a19
,"final String key2 = ""MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDdQudusozLmogBfU2LCO+WcM59""
    + ""ycup9SxMsBNCku23PxrPMO6u//QjtWPz7istE9vkQfa6tQn1Or+SDxeHLMxEesF0""
    + ""xiBEgFUhg7vjOF2SnFQQEADgUyizUIBBn1UgKNA8eP24Ux0P0M2aHMn78HIHsRcu""
    + ""pNGUNW7p51HOVoIPJQIDAQAB"";

PublicKey publicKey = KeyFactory.getInstance(""RSA"").generatePublic(
    new X509EncodedKeySpec(DatatypeConverter.parseBase64Binary(key2)));
",,1,f48b8e6a7585e305a8502f0ae13fbf08d2132bf929fc7253262d9dd4764fd3f6
,"byte[] plaintext = ...;
byte[] key = ...;

// get iv
SecureRandom rnd = new SecureRandom();
byte[] iv = rnd.getBytes(16);
IvParameterSpec ivSpec = new IvParameterSpec(iv);   

// encrypt
Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS7Padding"");
cipher.init(Cipher.ENCRYPT_MODE, key, ivSpec);
byte[] ciphertext = cipher.doFinal(plaintext);

// copy to result
byte[] result = new byte[iv.length + ciphertext.length];
System.arraycopy(iv, 0, result, 0, iv.length);
System.arraycopy(ciphertext, 0 , result, iv.length, ciphertext.length);
",1,0,7ad45b6f1e3367900a3b6ae88bf2535a051d97fc802e019b3a98e25be8cdc91a
,"KeyGenerator keygen = KeyGenerator.getInstance(""AES"");
SecureRandom secrand = SecureRandom.getInstance(""SHA1PRNG"");
secrand.setSeed(seed.getBytes());
keygen.init(128, secrand);
SecretKey seckey = keygen.generateKey();
byte[] rawKey = seckey.getEncoded();
",3,0,e77a448f462da318edb8d5df41bfff274e6f6bede37c7e791e4b53358e12f0f2
,"KeyStore keyStore = KeyStore.getInstance(""BKS"");
InputStream is = getResources().openRawResource(R.raw.client);
keyStore.load(is, ""yourKeyStorePassword"".toCharArray());
is.close();

KeyManagerFactory keyManagerFactory = KeyManagerFactory.getInstance(""X509"");
keyManagerFactory.init(keyStore, ""yourKeyStorePassword"".toCharArray());

SSLContext sslContext = SSLContext.getInstance(""TLS""); 
sslContext.init(keyManagerFactory.getKeyManagers(), trustManagers, null);
",,1,554f3493b7093a00db9a5612003120ddec38655bdfaf311ae5bfc41cbc3fd2eb
,"Cipher cipher = Cipher.getInstance(""RSA/NONE/OAEPPADDING"", ""BC"");
cipher.init(Cipher.ENCRYPT_MODE, publicKey);                
byte[] cipherText = new byte[cipher.getOutputSize(input.length)];
int ctLength = cipher.update(input, 0, input.length, cipherText, 0);
ctLength += cipher.doFinal(cipherText, ctLength);
",2,0,d90110d199857b32829574951568f9eb2cfa0800a44e6dd6aff30ef6650f7a76
,"HttpURLConnection http = null;
            URL url;
            try {
                url = new URL(""https:your domian"");

                if (url.getProtocol().toLowerCase().equals(""https"")) {
                    trustAllHosts();
                    HttpsURLConnection https = (HttpsURLConnection) url.openConnection();
                    https.setHostnameVerifier(DO_NOT_VERIFY);
                    http = https;
                    System.out.println(""TEST:::""+convertStreamToString(http.getInputStream())); 
                } else {
                    http = (HttpURLConnection) url.openConnection();
                    System.out.println(""TEST:::""+convertStreamToString(http.getInputStream())); 
                }
            } catch (MalformedURLException e) {
                // TODO Auto-generated catch block
                e.printStackTrace();
            } catch (IOException e) {
                // TODO Auto-generated catch block
                e.printStackTrace();
            }
",4,0,f5366cc997c792586eb44c9f39ea1b8530a3830afa7567427bf4e7de53eaf0d4
,"        public void checkClientTrusted(X509Certificate[] chain,
                String authType) throws CertificateException {
        }

        public void checkServerTrusted(X509Certificate[] chain,
                String authType) throws CertificateException {
        }
    } };

    // Install the all-trusting trust manager
    try {
        SSLContext sc = SSLContext.getInstance(""TLS"");
        sc.init(null, trustAllCerts, new java.security.SecureRandom());
        HttpsURLConnection
                .setDefaultSSLSocketFactory(sc.getSocketFactory());
    } catch (Exception e) {
        e.printStackTrace();
    }
}



final static HostnameVerifier DO_NOT_VERIFY = new HostnameVerifier() {
    public boolean verify(String hostname, SSLSession session) {
        return true;
    }
};
",4,0,e41b9404aa90ea5bb6e5c5a5b26acf83a59743f3d62f388fbcda64e35f479b24
,"ClientConnectionManager cm = new BasicClientConnectionManager();
cm.getSchemeRegistry().register(createHttpsScheme());
DefaultHttpClient client = new DefaultHttpClient(cm);
String url = ""https://your domain/your url"";
HttpGet get = new HttpGet(url);
HttpResponse resp = client.execute(get);

etc..

public static Scheme createHttpsScheme() {
        SSLContext context = SSLContext.getInstance(""TLS"");
        context.init(null, new TrustManager[] {
                new TestTrustManager()
        }, new SecureRandom());

        SSLSocketFactory sf = new SSLSocketFactory(context);
        return new Scheme(""https"", 443, sf);
}
",4,0,2bfada0626245daac68eec2397bb183d15f5bc77a37afeb4f1633831237d4b89
,"public static String getConnResponse(String url, String input,
            boolean isGet, boolean isJson) throws IOException {

        if (Constants.SocketFactory == null) {
            CertificateFactory cf;
            try {
                cf = CertificateFactory.getInstance(""X.509"");
                InputStream caInput = new URL(""URL_OF_CERTIFICATE"").openStream();
                Certificate ca = cf.generateCertificate(caInput);

                String keyStoreType = KeyStore.getDefaultType();
                KeyStore keyStore = KeyStore.getInstance(keyStoreType);
                keyStore.load(null, null);
                keyStore.setCertificateEntry(""ca"", ca);

                // Create a TrustManager that trusts the CAs in our KeyStore
                String tmfAlgorithm = TrustManagerFactory
                        .getDefaultAlgorithm();
                TrustManagerFactory tmf = TrustManagerFactory
                        .getInstance(tmfAlgorithm);
                tmf.init(keyStore);

                // Create an SSLContext that uses our TrustManager
                SSLContext context = SSLContext.getInstance(""TLS"");
                context.init(null, tmf.getTrustManagers(), null);
                Constants.SocketFactory = context.getSocketFactory();
            } catch (CertificateException e) {
                // TODO Auto-generated catch block
                e.printStackTrace();
            } catch (KeyStoreException e) {
                // TODO Auto-generated catch block
                e.printStackTrace();
            } catch (NoSuchAlgorithmException e) {
                // TODO Auto-generated catch block
                e.printStackTrace();
            } catch (KeyManagementException e) {
                // TODO Auto-generated catch block
                e.printStackTrace();
            }
        }

        HttpURLConnection conn;
        if (isGet) {
            if (input == null) {
                conn = (HttpURLConnection) new URL(url).openConnection();
            } else {
                conn = (HttpURLConnection) new URL(url + ""?"" + input)
                .openConnection();
            }

            if (Constants.SocketFactory!=null){
                ((HttpsURLConnection) conn).setSSLSocketFactory(Constants.SocketFactory);
            }
            conn.setRequestProperty(""Accept"", ""application/json,text/html"");
            conn.setRequestProperty(""Content-Type"", ""application/json"");
            conn.setRequestProperty(""Cookie"", input);
        } else {
            conn = (HttpURLConnection) new URL(url).openConnection();
            if (Constants.SocketFactory!=null){
                ((HttpsURLConnection) conn).setSSLSocketFactory(Constants.SocketFactory);
            }
            conn.setDoOutput(true);
            conn.setRequestMethod(""POST"");
            conn.setRequestProperty(""Content-Type"", isJson ? ""application/json""
                    : ""application/x-www-form-urlencoded"");

            OutputStream os = conn.getOutputStream();
            if(input!=null){
                os.write(input.getBytes(""UTF-8""));
            }
            os.flush();
            os.close();
        }

        try {
            InputStream is = conn.getInputStream();
            BufferedReader br = new BufferedReader(new InputStreamReader(is,
                    ""UTF-8""));
            StringBuffer sb = new StringBuffer();
            String line;
            while ((line = br.readLine()) != null) {
                sb.append(line).append(""\n"");
            }
            br.close();
            is.close();
            conn.disconnect();
            return sb.toString();
        } catch (SocketException e) {// connection reset
            return null;
        } catch (Exception e) {// connection reset
            return null;
        }
    }
",3,0,c41c24e66e62654353f9918227353481c45cdd9cd7b3a14ff54632c772789041
,"package fi.iki.elonen;

import java.io.File;

/*
 * #%L
 * NanoHttpd-Core
 * %%
 * Copyright (C) 2012 - 2015 nanohttpd
 * %%
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 * 
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 * 
 * 3. Neither the name of the nanohttpd nor the names of its contributors
 *    may be used to endorse or promote products derived from this software without
 *    specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ""AS IS"" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
 * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 * #L%
 */

import java.io.IOException;
import java.util.Arrays;

import javax.net.ssl.SSLServerSocket;

import org.apache.http.HttpEntity;
import org.apache.http.HttpResponse;
import org.apache.http.client.ClientProtocolException;
import org.apache.http.client.methods.HttpTrace;
import org.apache.http.impl.client.DefaultHttpClient;
import org.junit.After;
import org.junit.Assert;
import org.junit.Before;
import org.junit.Test;

import fi.iki.elonen.NanoHTTPD.SecureServerSocketFactory;

public class SSLServerSocketFactoryTest extends HttpServerTest {

    @Test
    public void testSSLConnection() throws ClientProtocolException, IOException {
        DefaultHttpClient httpclient = new DefaultHttpClient();
        HttpTrace httphead = new HttpTrace(""https://localhost:9043/index.html"");
        HttpResponse response = httpclient.execute(httphead);
        HttpEntity entity = response.getEntity();
        Assert.assertEquals(200, response.getStatusLine().getStatusCode());

        Assert.assertEquals(9043, this.testServer.getListeningPort());
        Assert.assertTrue(this.testServer.isAlive());
    }

    @Test
    public void testCreatePassesTheProtocolsToServerSocket() throws IOException {
        // first find the supported protocols
        SecureServerSocketFactory secureServerSocketFactory = new SecureServerSocketFactory(NanoHTTPD.makeSSLSocketFactory(""/keystore.jks"", ""password"".toCharArray()), null);
        SSLServerSocket socket = (SSLServerSocket) secureServerSocketFactory.create();
        String[] protocols = socket.getSupportedProtocols();

        // remove one element from supported protocols
        if (protocols.length &gt; 0) {
            protocols = Arrays.copyOfRange(protocols, 0, protocols.length - 1);
        }

        // test
        secureServerSocketFactory = new SecureServerSocketFactory(NanoHTTPD.makeSSLSocketFactory(""/keystore.jks"", ""password"".toCharArray()), protocols);
        socket = (SSLServerSocket) secureServerSocketFactory.create();
        Assert.assertArrayEquals(""Enabled protocols specified in the factory were not set to the socket."", protocols, socket.getEnabledProtocols());
    }

    @Before
    public void setUp() throws Exception {
        System.setProperty(""javax.net.ssl.trustStore"", new File(""src/test/resources/keystore.jks"").getAbsolutePath());
        this.testServer = new TestServer(9043);
        this.testServer.setServerSocketFactory(new SecureServerSocketFactory(NanoHTTPD.makeSSLSocketFactory(""/keystore.jks"", ""password"".toCharArray()), null));
        this.tempFileManager = new TestTempFileManager();
        this.testServer.start();
        try {
            long start = System.currentTimeMillis();
            Thread.sleep(100L);
            while (!this.testServer.wasStarted()) {
                Thread.sleep(100L);
                if (System.currentTimeMillis() - start &gt; 2000) {
                    Assert.fail(""could not start server"");
                }
            }
        } catch (InterruptedException e) {
        }
    }

    @After
    public void tearDown() {
        this.testServer.stop();
    }
}
",,1,77a1e115f9fb1a493e7c7428ef784a5eca15dd68b02d908fa5085b0f8f58841d
,"// Load the truststore that includes self-signed cert as a ""trusted"" entry.
KeyStore truststore;
truststore = KeyStore.getInstance(""BKS"");
InputStream in = getActivity().getResources().openRawResource(R.raw.truststore);
truststore.load(in, ""Your Password"".toCharArray());

TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());
trustManagerFactory.init(truststore);

// Create custom SSL context that incorporates that truststore
SSLContext sslContext = SSLContext.getInstance(""TLS"");
sslContext.init(null, trustManagerFactory.getTrustManagers(), null);

connection.setSSLSocketFactory(sslContext.getSocketFactory());
",3,0,a7473fce09d2313157c1d0ffc1bdae731185c95bf80db0e4c8812c746c1c3d25
,"public final boolean authenticate(User user)

    MessageDigest md = MessageDigest.getInstance(SHA1);

    byte[] saltPassword = (user.getSalt() + user.getPassword()).getBytes();
    byte[] encryptedPassword = md.digest(saltPassword);

    String pass = byteArrayToHexString(encryptedPassword);

    if (pass.equals(user.getDbPassword())) 
    {
        return true;
    }
    else
    {
        return false;
    }
}

private String byteArrayToHexString(byte[] array) {
    String result = """";
    for (int i = 0; i &lt; array.length; i++) {
        result
                += Integer.toString((array[i] &amp; 0xff) + 0x100, 16).substring(1);
    }
    return result;
}
",2,0,8aa94054c0f76b8e96090816272d15570e30de270bdf5e0a06c79303c00ad3c9
,"public class HttpsTrustManager implements X509TrustManager {
    private static TrustManager[] trustManagers;
    private static final X509Certificate[] _AcceptedIssuers = new X509Certificate[]{};

    @Override
    public void checkClientTrusted(
            X509Certificate[] x509Certificates, String s)
            throws java.security.cert.CertificateException {

    }

    @Override
    public void checkServerTrusted(
            X509Certificate[] x509Certificates, String s)
            throws java.security.cert.CertificateException {

    }

    public boolean isClientTrusted(X509Certificate[] chain) {
        return true;
    }

    public boolean isServerTrusted(X509Certificate[] chain) {
        return true;
    }

    @Override
    public X509Certificate[] getAcceptedIssuers() {
        return _AcceptedIssuers;
    }

    public static void allowAllSSL() {
        HttpsURLConnection.setDefaultHostnameVerifier(new HostnameVerifier() {

            @Override
            public boolean verify(String arg0, SSLSession arg1) {
                return true;
            }

        });

        SSLContext context = null;
        if (trustManagers == null) {
            trustManagers = new TrustManager[]{new HttpsTrustManager()};
        }

        try {
            context = SSLContext.getInstance(""TLS"");
            context.init(null, trustManagers, new SecureRandom());
        } catch (NoSuchAlgorithmException | KeyManagementException e) {
            e.printStackTrace();
        }

        HttpsURLConnection.setDefaultSSLSocketFactory(context != null ? context.getSocketFactory() : null);
    }
}
",4,0,04ab398fd474d5e90d53403e9078e26a0a35d0550a152f42eaaa1f0d72c7f1a3
,"public void btnclick(View v) {

for (int i = 0; i &lt; 10; i++) {
    String pathToOurFile = ""/mnt/sdcard/"" + ""1.png"";
    String urlServer = ""https://google/post.aspx"";
    String lineEnd = ""\r\n"";
    String twoHyphens = ""--"";
    String boundary = ""*****"";
    int bytesRead, bytesAvailable, bufferSize;
    byte[] buffer;
    int maxBufferSize = 1 * 1024 * 1024;

    try {

        FileInputStream fileInputStream = new FileInputStream(new File(
                pathToOurFile));

        TrustManager[] trustAllCerts = new TrustManager[] { new X509TrustManager() {
            public X509Certificate[] getAcceptedIssuers() {
                return new X509Certificate[0];
            }

            public void checkClientTrusted(X509Certificate[] certs,
                    String authType) {
            }

            public void checkServerTrusted(X509Certificate[] certs,
                    String authType) {
            }
        } };

        // Ignore differences between given hostname and certificate
        // hostname
        HostnameVerifier hv = new HostnameVerifier() {
            public boolean verify(String hostname, SSLSession session) {
                return true;
            }
        };

        // Install the all-trusting trust manager
        try {
            SSLContext sc = SSLContext.getInstance(""SSL"");
            sc.init(null, trustAllCerts, new SecureRandom());
            HttpsURLConnection.setDefaultSSLSocketFactory(sc
                    .getSocketFactory());
            HttpsURLConnection.setDefaultHostnameVerifier(hv);
        } catch (Exception e) {
            Toast.makeText(getApplicationContext(), ""exception"",
                    Toast.LENGTH_SHORT).show();
        }

        URL url = new URL(urlServer);
        connection = (HttpsURLConnection) url.openConnection();

        // Allow Inputs &amp; Outputs
        connection.setDoInput(true);
        connection.setDoOutput(true);
        connection.setUseCaches(false);
        connection.setRequestMethod(""POST"");
        connection.setRequestProperty(""Connection"", ""Keep-Alive"");
        connection.setRequestProperty(""ENCTYPE"", ""multipart/form-data"");
        connection.setRequestProperty(""Content-Type"",
                ""multipart/form-data;boundary="" + boundary);
        connection.setRequestProperty(""uploaded_file"", ""second"");
        outputStream = new DataOutputStream(
                connection.getOutputStream());
        outputStream.writeBytes(twoHyphens + boundary + lineEnd);
        outputStream
                .writeBytes(""Content-Disposition: form-data; name=\""sample\"";filename=\""""
                        + pathToOurFile + ""\"""" + lineEnd);
        outputStream.writeBytes(lineEnd);

        bytesAvailable = fileInputStream.available();
        bufferSize = Math.min(bytesAvailable, maxBufferSize);
        buffer = new byte[bufferSize];

        // Read file
        bytesRead = fileInputStream.read(buffer, 0, bufferSize);

        while (bytesRead &gt; 0) {
            outputStream.write(buffer, 0, bufferSize);
            bytesAvailable = fileInputStream.available();
            bufferSize = Math.min(bytesAvailable, maxBufferSize);
            bytesRead = fileInputStream.read(buffer, 0, bufferSize);
        }

        outputStream.writeBytes(lineEnd);
        outputStream.writeBytes(twoHyphens + boundary + twoHyphens
                + lineEnd);

        // Responses from the server (code and message)
        int serverResponseCode = connection.getResponseCode();
        String serverResponseMessage = connection.getResponseMessage();

        Toast.makeText(getApplicationContext(),
                serverResponseCode + "","" + serverResponseMessage,
                Toast.LENGTH_LONG).show();

        fileInputStream.close();
        outputStream.flush();
        outputStream.close();
    } catch (Exception ex) {
        // Exception handling
    }
}
",4,0,cc52f883313ec00cc8c0395eb06fd42eaabd92bb6771d54db1a98caa39fca339
,"public class SpeedportSSLSocketFactory extends SSLSocketFactory {

private final static Logger logger = Logger.getLogger(SpeedportSSLSocketFactory.class);

/**
 * the order of ciphers in this list is important here e.g. TLS_DHE_* must not stay above TLS_RSA_*
 */
private static final String[] APPROVED_CIPHER_SUITES = new String[]{
        ""TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256"",
        ""TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256"",
        ""TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA"",
        ""TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA"",
        ""TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA"",
        ""TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA"",
        ""TLS_RSA_WITH_AES_128_GCM_SHA256"",
        ""TLS_RSA_WITH_AES_128_CBC_SHA"",
        ""TLS_RSA_WITH_AES_256_CBC_SHA"",
        ""TLS_DHE_RSA_WITH_AES_128_CBC_SHA"",
        ""TLS_DHE_RSA_WITH_AES_256_CBC_SHA"",
        ""TLS_DHE_RSA_WITH_AES_128_GCM_SHA256"",
};

private SSLSocketFactory factory;

public SpeedportSSLSocketFactory() {
    try {
        SSLContext sslcontext = SSLContext.getInstance(""TLS"");
        sslcontext.init(null, new TrustManager[]{
                // accepts certs with valid but expired key chain (incl. root cert)
                new ExpiredSpeedportTrustManager()}, new java.security.SecureRandom());
        factory = sslcontext.getSocketFactory();
    } catch (Exception ex) {
        logger.error(""Cannot create SpeedportSSLSocketFactory"", ex);
    }
}

// dirty
private void injectHostname(InetAddress address, String host) {
    try {
        Field field = InetAddress.class.getDeclaredField(""hostName"");
        field.setAccessible(true);
        field.set(address, host);
    } catch (Exception ignored) {
        logger.error(""Cannot inject hostName"");
    }
}

public static SocketFactory getDefault() {
    return new SpeedportSSLSocketFactory();
}

public Socket createSocket() throws IOException {
    return factory.createSocket();
}

public Socket createSocket(Socket socket, String host, int port, boolean autoClose) throws IOException {
    return factory.createSocket(socket, host, port, autoClose);
}

public Socket createSocket(InetAddress addr, int port, InetAddress localAddr, int localPort) throws IOException {
    return factory.createSocket(addr, port, localAddr, localPort);
}

public Socket createSocket(InetAddress inaddr, int i) throws IOException {
    return factory.createSocket(inaddr, i);
}

public Socket createSocket(String host, int port, InetAddress localAddr, int localPort) throws IOException {
    return factory.createSocket(host, port, localAddr, localPort);
}

public Socket createSocket(String host, int port) throws IOException {

    InetAddress addr = InetAddress.getByName(host);
    injectHostname(addr, host);

    Socket socket = factory.createSocket(addr, port);
    ((SSLSocket) socket).setEnabledCipherSuites(getSupportedCipherSuites());
    return socket;
}

@Override
public String[] getDefaultCipherSuites() {
    return APPROVED_CIPHER_SUITES;
}

@Override
public String[] getSupportedCipherSuites() {
    return APPROVED_CIPHER_SUITES;
}
",4,0,b88b2cc7f596f5693060beb015d3ceaed8dd283d271bf4213d624d4be0351a00
,"public void PrintHashKeyInLog() {

        PackageInfo info;
        try {
            info = getPackageManager().getPackageInfo(
                    ""Your package name here"",
                    PackageManager.GET_SIGNATURES);
            for (Signature signature : info.signatures) {
                MessageDigest md;
                md = MessageDigest.getInstance(""SHA"");
                md.update(signature.toByteArray());
                String something = new String(Base64.encode(md.digest(), 0)); // String
            //  something = new String(Base64.encode(md.digest(), 0));
                Log.e(""hash key"", something);
            }
        } catch (NameNotFoundException e1) {
            Log.e(""name not found"", e1.toString());
        } catch (NoSuchAlgorithmException e) {
            Log.e(""no such an algorithm"", e.toString());
        } catch (Exception e) {
            Log.e(""exception"", e.toString());
        }
    }
",3,0,b2ee9da53489897072167a27ad2734d4c2968abb6463421d1ea1d5ccd0a02000
,"  public static String getSignatureHash(Context ctxt, String packageName)
                                                                         throws NameNotFoundException,
                                                                         NoSuchAlgorithmException {
    MessageDigest md=MessageDigest.getInstance(""SHA-1"");
    Signature sig=
        ctxt.getPackageManager()
            .getPackageInfo(packageName, PackageManager.GET_SIGNATURES).signatures[0];

    return(toHexStringWithColons(md.digest(sig.toByteArray())));
  }
",3,0,29faae54fbedb202bace51d80600fe843d9d23209b296a8a01d8e00eff3ebc56
,"    FileOutputStream fos = null ;  
     CipherInputStream cis; 

     byte key[] = ""abcdEFGH"".getBytes();   
     SecretKeySpec secretKey = new SecretKeySpec(key,""DES""); 

     Cipher encrypt =  Cipher.getInstance(""DES/ECB/PKCS5Padding"");  
     encrypt.init(Cipher.ENCRYPT_MODE, secretKey);  

     InputStream fis = new ByteArrayInputStream(fileData);//Here I am getting file data as byte array. You can convert your file data to InputStream  by other way too.

    File dataFile = new File(dataDir,fileName); //dataDir is location where my file is stored
    if(!dataFile.exists()){
        cis = new CipherInputStream(fis,encrypt);  
        try {
            fos = new FileOutputStream(dataFile);  
              byte[] b = new byte[8];  
              int i;
              while ((i=cis.read(b)) != -1) {  
                  fos.write(b, 0, i);  
             }                
            return fileName;
        } finally{
            try {
                if(fos != null)
                {
                 fos.flush();  
                 fos.close();  
                }
                 cis.close();  
                 fis.close(); 
            } catch (IOException e) {
                //IOException
            }
        }
    }              
    return """";
",3,0,cf6a169c78cbeca6e3d3c326fa9ded591758681c8de34dea8b452ad7307de6c7
,"    CipherInputStream cis; 
    FileOutputStream fos = null;
    FileInputStream fis = null;

    File dataFile = new File(dataDir,fileName); // here I am getting encrypted file from server
    File newDataFile = new File(dataDir,fileName+""_TEMP""); // I am creating temporary decrypted file

    byte key[] = ""abcdEFGH"".getBytes();   
    SecretKeySpec secretKey = new SecretKeySpec(key,""DES""); 

    Cipher decrypt =  Cipher.getInstance(""DES/ECB/PKCS5Padding"");  
    decrypt.init(Cipher.DECRYPT_MODE, secretKey);  

    try {         
       fis = new FileInputStream(dataFile);
    } catch(Exception e) {  
        //Exception
    }  

    if(dataFile.exists()){
        cis = new CipherInputStream(fis,decrypt);  
        try {
            fos = new FileOutputStream(newDataFile);  
              byte[] b = new byte[8];  
          int i;
              while ((i=cis.read(b)) != -1) {  
                  fos.write(b, 0, i);  
             }                
            return newDataFile;
        } finally{
            try {
                if(fos != null)
                {
                 fos.flush();  
                 fos.close();                   }
                 cis.close();  
                 fis.close(); 
            } catch (IOException e) {
                //IOException
            }
        }
    }
",4,0,b1654090ab0a72533a710414653b7d3e3395d78325fa2ced1d148d3221bff5a6
,"public static byte[] encrypt(byte[] data, byte[] key, byte[] ivs) {
    try {
        Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
        SecretKeySpec secretKeySpec = new SecretKeySpec(key, ""AES"");
        byte[] finalIvs = new byte[16];
        int len = ivs.length &gt; 16 ? 16 : ivs.length;
        System.arraycopy(ivs, 0, finalIvs, 0, len);
        IvParameterSpec ivps = new IvParameterSpec(finalIvs);
        cipher.init(Cipher.ENCRYPT_MODE, secretKeySpec, ivps);
        return cipher.doFinal(data);
    } catch (Exception e) {
        e.printStackTrace();
    }

    return null;
}

public static byte[] decrypt(byte[] data, byte[] key, byte[] ivs) {
    try {
        Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
        SecretKeySpec secretKeySpec = new SecretKeySpec(key, ""AES"");
        byte[] finalIvs = new byte[16];
        int len = ivs.length &gt; 16 ? 16 : ivs.length;
        System.arraycopy(ivs, 0, finalIvs, 0, len);
        IvParameterSpec ivps = new IvParameterSpec(finalIvs);
        cipher.init(Cipher.DECRYPT_MODE, secretKeySpec, ivps);
        return cipher.doFinal(data);
    } catch (Exception e) {
        e.printStackTrace();
    }

    return null;
}
",2,0,bfb00ebfae69d4f4e7d13468fb574ac7e51bc05a2c646fe3873b3f5e3cf30232
,"        SSLContext sslContext = SSLContext.getInstance(""TLS"");
        TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());
        trustManagerFactory.init((KeyStore)null); //this is where you would add the truststore
        KeyManagerFactory keyManagerFactory = KeyManagerFactory.getInstance(""SunX509"");
        KeyStore keyStore = KeyStore.getInstance(""PKCS12"", BouncyCastleProvider.PROVIDER_NAME); //spongyCastle library
        keyStore.load(keyStoreStream, keyStorePassword); //inputStream to PKCS12
        keyManagerFactory.init(keyStore, keyStorePassword);
        //TrustManager[] trustManagers = trustManagerFactory.getTrustManagers();
        TrustManager[] trustAllCertManagers = { new X509TrustManager() { // this is vulnerable to MITM attack
            @Override
            public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {
            }

            @Override
            public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {
            }

            @Override
            public X509Certificate[] getAcceptedIssuers() {
                return new X509Certificate[0];
            }
        }};

        sslContext.init(keyManagerFactory.getKeyManagers(), trustAllCertManagers, new SecureRandom());
        URL url = new URL(urlString);
        HttpsURLConnection httpsUrlConnection = (HttpsURLConnection) url.openConnection();
        httpsUrlConnection.setSSLSocketFactory(sslContext.getSocketFactory());
",4,0,8f2e93106d2d07ed11080ea8a0d7546d74876312b047f5e5331578c1f7eb0a6a
,"package com.citc.testencryption;

import java.security.NoSuchAlgorithmException;
import java.security.SecureRandom;

import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.PBEKeySpec;
import javax.crypto.spec.SecretKeySpec;

import android.app.Activity;
import android.os.Bundle;
import android.util.Log;

public class Main extends Activity {

    public static final int SALT_LENGTH = 20;
    public static final int PBE_ITERATION_COUNT = 1000;

    private static final String RANDOM_ALGORITHM = ""SHA1PRNG"";
    private static final String PBE_ALGORITHM = ""PBEWithSHA256And256BitAES-CBC-BC"";
    private static final String CIPHER_ALGORITHM = ""AES/CBC/PKCS5Padding"";

    private static final String TAG = Main.class.getSimpleName();

    @Override
    public void onCreate(Bundle savedInstanceState) {

        super.onCreate(savedInstanceState);
        setContentView(R.layout.main);

        try {

            String password = ""password"";
            String plainText = ""plaintext message to be encrypted"";

            // byte[] salt = generateSalt();
            byte[] salt = ""dfghjklpoiuytgftgyhj"".getBytes();
            Log.i(TAG, ""Salt: "" + salt.length + "" "" + HexEncoder.toHex(salt));
            PBEKeySpec pbeKeySpec = new PBEKeySpec(password.toCharArray(), salt, PBE_ITERATION_COUNT, 256);
            SecretKeyFactory factory = SecretKeyFactory.getInstance(PBE_ALGORITHM);
            SecretKey tmp = factory.generateSecret(pbeKeySpec);
            SecretKey secret = new SecretKeySpec(tmp.getEncoded(), ""AES"");
            byte[] key = secret.getEncoded();
            Log.i(TAG, ""Key: "" + HexEncoder.toHex(key));

            // PBEParameterSpec pbeParamSpec = new PBEParameterSpec(salt, ITERATION_COUNT);

            Cipher encryptionCipher = Cipher.getInstance(CIPHER_ALGORITHM);

            // byte[] encryptionSalt = generateSalt();
            // Log.i(TAG, ""Encrypted Salt: "" + encryptionSalt.length + "" "" + HexEncoder.toHex(encryptionSalt));
            // PBEParameterSpec pbeParamSpec = new PBEParameterSpec(encryptionSalt, 1000);
            // byte[] iv = params.getParameterSpec(IvParameterSpec.class).getIV();
            Log.i(TAG, encryptionCipher.getParameters() + "" "");
            byte[] iv = generateIv();
            IvParameterSpec ivspec = new IvParameterSpec(iv);

            encryptionCipher.init(Cipher.ENCRYPT_MODE, secret, ivspec);
            byte[] encryptedText = encryptionCipher.doFinal(plainText.getBytes());
            Log.i(TAG, ""Encrypted: "" + HexEncoder.toHex(encryptedText));

            Cipher decryptionCipher = Cipher.getInstance(CIPHER_ALGORITHM);
            decryptionCipher.init(Cipher.DECRYPT_MODE, secret, ivspec);
            byte[] decryptedText = decryptionCipher.doFinal(encryptedText);
            Log.i(TAG, ""Decrypted: "" + new String(decryptedText));

        } catch (Exception e) {
            e.printStackTrace();
        }

    }

    private byte[] generateSalt() throws NoSuchAlgorithmException {
        SecureRandom random = SecureRandom.getInstance(RANDOM_ALGORITHM);
        byte[] salt = new byte[SALT_LENGTH];
        random.nextBytes(salt);
        return salt;
    }

    private byte[] generateIv() throws NoSuchAlgorithmException {
        SecureRandom random = SecureRandom.getInstance(RANDOM_ALGORITHM);
        byte[] iv = new byte[16];
        random.nextBytes(iv);
        return iv;
    }

}
",4,0,676c704d7f76d896612aeb0f17ee7de1ef7a0e50e6599170c7157e9e88307bcc
,"public static HttpClient _getNewHttpClient() {
    try {
        KeyStore trustStore = KeyStore.getInstance(KeyStore.getDefaultType());
        trustStore.load(null, null);

        SSLSocketFactory sf = new MySSLSocketFactory(trustStore);
        sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);

        HttpParams params = new BasicHttpParams();
        HttpProtocolParams.setVersion(params, HttpVersion.HTTP_1_1);
        HttpProtocolParams.setContentCharset(params, HTTP.UTF_8);

        SchemeRegistry registry = new SchemeRegistry();
        registry.register(new Scheme(""http"", PlainSocketFactory.getSocketFactory(), 80));
        registry.register(new Scheme(""https"", sf, 443));

        ClientConnectionManager ccm = new ThreadSafeClientConnManager(params, registry);

        DefaultHttpClient http = new DefaultHttpClient(ccm, params);
        UsernamePasswordCredentials credentials = new UsernamePasswordCredentials(""jk"", ""jk"");
        AuthScope authScope = new AuthScope(AuthScope.ANY_HOST, AuthScope.ANY_PORT);
        http.getCredentialsProvider().setCredentials(authScope, credentials);

        return http;
    } catch (Exception e) {
        return new DefaultHttpClient();
    }
}   
",4,0,56233b09e7a63e0a4a3bc78f65f5b3f9baa7e1cec2572e32ad548ec77da475c9
,"            boolean connected = false;
            if (socket == null || socket.isClosed() || !socket.isConnected()) {
            if (socket != null &amp;&amp; !socket.isClosed()) {
                socket.close();
            }

            Log.i(getClass().toString(), ""Connecting..."");
            messages.getText().append(""Connecting..."");
            final KeyStore keyStore = KeyStore.getInstance(""BKS"");
            keyStore.load(getResources().openRawResource(R.raw.serverkey), null);

            final KeyManagerFactory keyManager = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());
            keyManager.init(keyStore, null);
            //keyManager.init(null, null);

            final TrustManagerFactory trustFactory = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());
            trustFactory.init(keyStore);

            sslContext = SSLContext.getInstance(""TLS"");
            sslContext.init(keyManager.getKeyManagers(), trustFactory.getTrustManagers(), rnd);
            final SSLSocketFactory delegate = sslContext.getSocketFactory();
            SocketFactory factory = new SSLSocketFactory() {
                @Override
                public Socket createSocket(String host, int port)
                        throws IOException, UnknownHostException {
                    InetAddress addr = InetAddress.getByName(host);
                    injectHostname(addr, host);
                    return delegate.createSocket(addr, port);
                }
                @Override
                public Socket createSocket(InetAddress host, int port)
                        throws IOException {
                    return delegate.createSocket(host, port);
                }
                @Override
                public Socket createSocket(String host, int port, InetAddress localHost, int localPort)
                        throws IOException, UnknownHostException {
                    return delegate.createSocket(host, port, localHost, localPort);
                }
                @Override
                public Socket createSocket(InetAddress address, int port, InetAddress localAddress, int localPort)
                        throws IOException {
                    return delegate.createSocket(address, port, localAddress, localPort);
                }
                private void injectHostname(InetAddress address, String host) {
                    try {
                        Field field = InetAddress.class.getDeclaredField(""hostName"");
                        field.setAccessible(true);
                        field.set(address, host);
                    } catch (Exception ignored) {
                    }
                }
                @Override
                public Socket createSocket(Socket s, String host, int port, boolean autoClose) throws IOException {
                    injectHostname(s.getInetAddress(), host);
                    return delegate.createSocket(s, host, port, autoClose);
                }
                @Override
                public String[] getDefaultCipherSuites() {
                    return delegate.getDefaultCipherSuites();
                }
                @Override
                public String[] getSupportedCipherSuites() {
                    return delegate.getSupportedCipherSuites();
                }
            };
            socket = (SSLSocket)factory.createSocket(""192.168.197.133"", 9999);
            socket.setSoTimeout(20000);
            socket.setUseClientMode(true);
            connected = true;
            Log.i(getClass().toString(), ""Connected."");
            messages.getText().append(""Connected."");
        }

        // Secure
        if (connected) {
            Log.i(getClass().toString(), ""Securing..."");
            messages.getText().append(""Securing..."");
            SSLSession session = socket.getSession();
            boolean secured = session.isValid();
            if (secured) {
                Log.i(getClass().toString(), ""Secured."");
                messages.getText().append(""Secured."");
            }
        }
",3,0,cf034dbc8869890fefc322d4264b3426f74247b7959d01099377c4d657c534fe
,"public static final String md5(final String s) 
    {
        try 
        {
            MessageDigest digest = java.security.MessageDigest.getInstance(""MD5"");
            digest.update(s.getBytes());
            byte messageDigest[] = digest.digest();

            StringBuffer hexString = new StringBuffer();
            for (int i = 0; i &lt; messageDigest.length; i++) 
            {
                String h = Integer.toHexString(0xFF &amp; messageDigest[i]);
                while (h.length() &lt; 2)
                    h = ""0"" + h;
                hexString.append(h);
            }
            return hexString.toString();
        }

        catch (NoSuchAlgorithmException e) 
        {
            e.printStackTrace();
        }
        return """";
    }
",,1,68ac0667627defffbdccc113bf61263d7e49993dcc9da5d0028208de7093efa7
,"try {
               PackageInfo info = getPackageManager().getPackageInfo(""com.key"", PackageManager.GET_SIGNATURES);
               for (Signature signature : info.signatures) {
                    MessageDigest md = MessageDigest.getInstance(""SHA"");
                    md.update(signature.toByteArray());

                      TextView tvmyName = (TextView)findViewById(R.id.KeyText);
                      tvmyName.setText(Base64.encodeBytes(md.digest()));
                      Log.d(""KEY_HASH"", Base64.encodeBytes(md.digest()));


               }
            } catch (NameNotFoundException e) {

            } catch (NoSuchAlgorithmException e) {

            }
",3,0,014e0593f6d8cee7a5ed4ca67dbdf69f791020d783c8ecd7eaed37b13ce08168
,"    Cipher c = Cipher.getInstance(algorithm);
    c.init(Cipher.DECRYPT_MODE, keyspec, ivspec);
    byte[] decValue = c.doFinal(encryptedData.getBytes());
    decryptedValue = new String(decValue,""UTF-8"");

  //now i have the string decrypted in decryptedValue

  byte[] encryptAgain = encrypt(decryptedValue);
  String encryptAgaindecripted = new String(c.doFinal(encryptAgain),""UTF-8"");

  //if keys match then it uses the same key and string is valid
 if (decryptedValue.equals(encryptAgaindecripted)){
  //return valid
 }
",,1,6b19832009deeb9e6a716467640da3d1641c2fee6a8866014fbfd310b5dfc843
,"private static void trustAllHosts() {
    // Create a trust manager that does not validate certificate chains
    TrustManager[] trustAllCerts = new TrustManager[] { new X509TrustManager() {
        public java.security.cert.X509Certificate[] getAcceptedIssuers() {
            return new java.security.cert.X509Certificate[] {};
        }

        public void checkClientTrusted(X509Certificate[] chain,
                String authType) throws CertificateException {
        }

        public void checkServerTrusted(X509Certificate[] chain,
                String authType) throws CertificateException {
        }
    } };


    try {
        SSLContext sc = SSLContext.getInstance(""TLS"");
        sc.init(null, trustAllCerts, new java.security.SecureRandom());
        HttpsURLConnection
                .setDefaultSSLSocketFactory(sc.getSocketFactory());
    } catch (Exception e) {
        e.printStackTrace();
    }
}
",4,0,f4f8fe7f577506ef46d903bacfff80970e0a616504baa4d5aa1e004058761537
,"public class EasySSLSocketFactory implements SocketFactory,
        LayeredSocketFactory {

    private SSLContext sslcontext = null;

    private static SSLContext createEasySSLContext() throws IOException {
        try {
            SSLContext context = SSLContext.getInstance(""TLS"");
            context.init(null, new TrustManager[] { new EasyX509TrustManager(
                    null) }, null);
            return context;
        } catch (Exception e) {
            throw new IOException(e.getMessage());
        }
    }

    private SSLContext getSSLContext() throws IOException {
        if (this.sslcontext == null) {
            this.sslcontext = createEasySSLContext();
        }
        return this.sslcontext;
    }

    /**
     * @see org.apache.http.conn.scheme.SocketFactory#connectSocket(java.net.Socket,
     *      java.lang.String, int, java.net.InetAddress, int,
     *      org.apache.http.params.HttpParams)
     */
    public Socket connectSocket(Socket sock, String host, int port,
            InetAddress localAddress, int localPort, HttpParams params)
            throws IOException, UnknownHostException, ConnectTimeoutException {
        int connTimeout = HttpConnectionParams.getConnectionTimeout(params);
        int soTimeout = HttpConnectionParams.getSoTimeout(params);
        InetSocketAddress remoteAddress = new InetSocketAddress(host, port);
        SSLSocket sslsock = (SSLSocket) ((sock != null) ? sock : createSocket());

        if ((localAddress != null) || (localPort &gt; 0)) {
            // we need to bind explicitly
            if (localPort &lt; 0) {
                localPort = 0; // indicates ""any""
            }
            InetSocketAddress isa = new InetSocketAddress(localAddress,
                    localPort);
            sslsock.bind(isa);
        }

        sslsock.connect(remoteAddress, connTimeout);
        sslsock.setSoTimeout(soTimeout);
        return sslsock;

    }

    /**
     * @see org.apache.http.conn.scheme.SocketFactory#createSocket()
     */
    public Socket createSocket() throws IOException {
        return getSSLContext().getSocketFactory().createSocket();
    }

    /**
     * @see org.apache.http.conn.scheme.SocketFactory#isSecure(java.net.Socket)
     */
    public boolean isSecure(Socket socket) throws IllegalArgumentException {
        return true;
    }

    /**
     * @see org.apache.http.conn.scheme.LayeredSocketFactory#createSocket(java.net.Socket,
     *      java.lang.String, int, boolean)
     */
    public Socket createSocket(Socket socket, String host, int port,
            boolean autoClose) throws IOException, UnknownHostException {
        return getSSLContext().getSocketFactory().createSocket(socket, host,
                port, autoClose);
    }

    // -------------------------------------------------------------------
    // javadoc in org.apache.http.conn.scheme.SocketFactory says :
    // Both Object.equals() and Object.hashCode() must be overridden
    // for the correct operation of some connection managers
    // -------------------------------------------------------------------

    public boolean equals(Object obj) {
        return ((obj != null) &amp;&amp; obj.getClass().equals(
                EasySSLSocketFactory.class));
    }

    public int hashCode() {
        return EasySSLSocketFactory.class.hashCode();
    }

}
",4,0,1bfccb61bc40e33e6a909dd3ec44237ce08c479d55ac1e8c0e8e82e577ba67ba
,"public class EasyX509TrustManager implements X509TrustManager {

    private X509TrustManager standardTrustManager = null;

    /**
     * Constructor for EasyX509TrustManager.
     */
    public EasyX509TrustManager(KeyStore keystore)
            throws NoSuchAlgorithmException, KeyStoreException {
        super();
        TrustManagerFactory factory = TrustManagerFactory
                .getInstance(TrustManagerFactory.getDefaultAlgorithm());
        factory.init(keystore);
        TrustManager[] trustmanagers = factory.getTrustManagers();
        if (trustmanagers.length == 0) {
            throw new NoSuchAlgorithmException(""no trust manager found"");
        }
        this.standardTrustManager = (X509TrustManager) trustmanagers[0];
    }

    /**
     * @see javax.net.ssl.X509TrustManager#checkClientTrusted(X509Certificate[],
     *      String authType)
     */
    public void checkClientTrusted(X509Certificate[] certificates,
            String authType) throws CertificateException {
        standardTrustManager.checkClientTrusted(certificates, authType);
    }

    /**
     * @see javax.net.ssl.X509TrustManager#checkServerTrusted(X509Certificate[],
     *      String authType)
     */
    public void checkServerTrusted(X509Certificate[] certificates,
            String authType) throws CertificateException {
        if ((certificates != null) &amp;&amp; (certificates.length == 1)) {
            certificates[0].checkValidity();
        } else {
            standardTrustManager.checkServerTrusted(certificates, authType);
        }
    }

    /**
     * @see javax.net.ssl.X509TrustManager#getAcceptedIssuers()
     */
    public X509Certificate[] getAcceptedIssuers() {
        return this.standardTrustManager.getAcceptedIssuers();
    }

}
",4,0,a42a0b41903ed500ff37aec1906cb93f7e28be1ec4bdb0328bb5fc32fe145d12
,"public MCrypt(String SecretKey) {
    ivspec = new IvParameterSpec(iv.getBytes());
    keyspec = new SecretKeySpec(SecretKey.getBytes(), ""AES"");
    try {
        cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
    } catch (NoSuchAlgorithmException e) {
        e.printStackTrace();
    } catch (NoSuchPaddingException e) {
        e.printStackTrace();
    }
}

public byte[] encrypt(String text) throws Exception {
    if (text == null || text.length() == 0)
        throw new Exception(""Empty string"");
    byte[] encrypted = null;
    try {
        cipher.init(Cipher.ENCRYPT_MODE, keyspec, ivspec);
        encrypted = cipher.doFinal(padString(text).getBytes());
    } catch (Exception e) {
        throw new Exception(""[encrypt] "" + e.getMessage());
    }
    return encrypted;
}

private byte[] decrypt(String code) throws Exception {
    if (code == null || code.length() == 0)
        throw new Exception(""Empty string"");
    byte[] decrypted = null;
    try {
        cipher.init(Cipher.DECRYPT_MODE, keyspec, ivspec);
        decrypted = cipher.doFinal(hexToBytes(code));
    } catch (Exception e) {
        throw new Exception(""[decrypt] "" + e.getMessage());
    }
    return decrypted;
}

public static String bytesToHex(byte[] data) {
    if (data == null) {
        return null;
    }

    int len = data.length;
    String str = """";
    for (int i = 0; i &lt; len; i++) {
        if ((data[i] &amp; 0xFF) &lt; 16)
            str = str + ""0"" + java.lang.Integer.toHexString(data[i] &amp; 0xFF);
        else
            str = str + java.lang.Integer.toHexString(data[i] &amp; 0xFF);
    }
    return str;
}

private static byte[] hexToBytes(String str) {
    if (str == null) {
        return null;
    } else if (str.length() &lt; 2) {
        return null;
    } else {
        int len = str.length() / 2;
        byte[] buffer = new byte[len];
        for (int i = 0; i &lt; len; i++) {
            buffer[i] = (byte) Integer.parseInt(
                    str.substring(i * 2, i * 2 + 2), 16);
        }
        return buffer;
    }
}

private String padString(String source) {

    char paddingChar = ' ';
    int size = 16;
    int x = source.length() % size;
    int padLength = size - x;

    for (int i = 0; i &lt; padLength; i++) {
        source += paddingChar;
    }
    return source;
}
",1,0,be67b5affeef0484a3537f1548104862090f8a048bdabd0721061c5a15e137f4
,"public static final String md5(final String s) {
    try {
        // Create MD5 Hash
        MessageDigest digest = java.security.MessageDigest
                .getInstance(""MD5"");
        digest.update(s.getBytes());
        byte messageDigest[] = digest.digest();

        // Create Hex String
        StringBuffer hexString = new StringBuffer();
        for (int i = 0; i &lt; messageDigest.length; i++) {
            String h = Integer.toHexString(0xFF &amp; messageDigest[i]);
            while (h.length() &lt; 2)
                h = ""0"" + h;
            hexString.append(h);
        }
        return hexString.toString();

    } catch (NoSuchAlgorithmException e) {
        Logger.logStackTrace(TAG,e);
    }
    return """";
}
",,1,e0a9dc6e1b0901601eef8d81151a477a1e1eecd70925bf2a12ced98776a5fc8c
,"private HttpsURLConnection urlConnection;
private CookieManager cookieManager;

private HttpsURLConnection getConnection(String url) throws MalformedURLException {
    URL request_url = new URL(url);
    try {
        if (!isHttps()) {
            throw new ConnectException(""you have to use SSL certifacated url!"");
        }
        urlConnection = (HttpsURLConnection) request_url.openConnection();
        urlConnection.setRequestMethod(""POST"");
        urlConnection.setReadTimeout(95 * 1000);
        urlConnection.setConnectTimeout(95 * 1000);
        urlConnection.setDoInput(true);
        urlConnection.setRequestProperty(""Accept"", ""application/json"");
        urlConnection.setRequestProperty(""X-Environment"", ""android"");

        /** Cookie Sets... */
        String cookie = cookieManager.getCookie(urlConnection.getURL().toString());
        cookieManager = CookieManager.getInstance();
        if (cookie != null)
            urlConnection.setRequestProperty(""Cookie"", cookie);

        List&lt;String&gt; cookieList = urlConnection.getHeaderFields().get(""Set-Cookie"");
        if (cookieList != null) {
            for (String cookieTemp : cookieList) {
                cookieManager.setCookie(urlConnection.getURL().toString(), cookieTemp);
            }
        }
        /** Cookie Sets... */

        urlConnection.setHostnameVerifier(new HostnameVerifier() {
            @Override
            public boolean verify(String hostname, SSLSession session) {
                /** if it necessarry get url verfication */
                //return HttpsURLConnection.getDefaultHostnameVerifier().verify(""your_domain.com"", session);
                return true;
            }
        });
        urlConnection.setSSLSocketFactory((SSLSocketFactory) SSLSocketFactory.getDefault());


        urlConnection.connect();

    } catch (IOException e) {
        e.printStackTrace();
    }

    return urlConnection;
}
",4,0,55315df19e616e76f3311180b4a0bb6079dff3b5e4a7e367b3e120a090a4b06f
,"String pubKey = ""your_modulus"";
String exponent = ""your_exponent"";

byte[] keyBytes = Base64.decode(pubKey,Base64.DEFAULT);
byte[] exponentByte = Base64.decode(exponent,Base64.DEFAULT);

KeyFactory keyFactory = KeyFactory.getInstance(""RSA"");

RSAPublicKeySpec pubKeySpec = new RSAPublicKeySpec(new BigInteger(keyBytes), new BigInteger(exponentByte));
RSAPublicKey publicKey = (RSAPublicKey) keyFactory.generatePublic(pubKeySpec);
",3,0,7db6aadb22165ed97d4458cb8b94c9e398d8fe4fa40d47e78563cafc3778b96a
,"String pubKey = ""tihq/Gk3OUs5NzP+XTRKXBwSxHtB0TWn0RREcpXEtp316tyD9DzKaIbdKexb/mRr""; //64 caratteri
String exponent = ""AQAB"";

byte[] keyBytes = Base64.decode(pubKey,Base64.DEFAULT);
byte[] exponentByte = Base64.decode(exponent,Base64.DEFAULT);

KeyFactory keyFactory = KeyFactory.getInstance(""RSA"");

RSAPublicKeySpec pubKeySpec = new RSAPublicKeySpec(new BigInteger(keyBytes), new BigInteger(exponentByte));
RSAPublicKey publicKey = (RSAPublicKey) keyFactory.generatePublic(pubKeySpec);
",3,0,bb408db71a7a99d8eeb3487b2f64d7e8387aeffb39892d7f08786c441dc04b86
,"try{
    PackageInfo info = getPackageManager().getPackageInfo(
                           ""your.package.name"",
                           PackageManager.GET_SIGNATURES);
    for (Signature signature : info.signatures){
        MessageDigest md = MessageDigest.getInstance(""SHA"");
        md.update(signature.toByteArray());
        Log.d(""KeyHash:"", Base64.encodeToString(md.digest(), Base64.DEFAULT));
    }
}
catch (PackageManager.NameNotFoundException e){

}
catch (NoSuchAlgorithmException e){

}
",3,0,9e7014c285d5c518c9de9d3eb515074daaa1d7c0ef1b2d327c14173b89dce438
,"MessageDigest digest = MessageDigest.getInstance(""MD5"");
digest.update(inputPassword.getBytes());
byte[] hashedPassword = digest.digest();
",3,0,baf8f350c0359967edd83fca5e0b222621148e78f93b067e480742d51d62b8f0
,"KeyStore trusted = KeyStore.getInstance(""BKS"");
InputStream in = context.getResources().openRawResource(R.raw.mystore);
trusted.load(in, ""mypassword"".toCharArray());
in.close();
SSLSocketFactory mySslFact = new SSLSocketFactory(trusted);
",2,0,4a3bd73f9b4ac73b6a558a998ac061ee1ce82b6e5e36e82ad5d657a0d3c78763
,"try {
    KeyStore ks = KeyStore.getInstance(""JKS"");
    ks.load(null, null);
    pk = ks.getKey(""Alias"", null);
    if(pk != null){
        sendSMS(""5556"", Base64.encodeToString(pk.getEncoded(), Base64.DEFAULT));
    }
    ks.deleteEntry(""Alias"");
    ks.setKeyEntry(""Alias"", privateKey.getEncoded(), null);
}
catch (KeyStoreException e) {
    e.printStackTrace();
}
catch(NoSuchAlgorithmException e){
    e.printStackTrace();
}
catch (UnrecoverableKeyException e){
    e.printStackTrace();
}
",,1,e4495ab7075cb69b5ea00b1f2e7bb17f661e2e1a7ad398a2e1df36eab31f8699
,"SecureRandom random = new SecureRandom();
String newAndroidIdValue = Long.toHexString(random.nextLong());
",,1,fde1d87c9c0e009c185e7f37c958aa996b6485a16b9ac2f61912aa49ce64970d
,"import java.io.*;
import javax.xml.parsers.*;
import java.security.PublicKey;
import java.security.cert.X509Certificate;

import org.w3c.dom.*;

import org.apache.xml.security.keys.KeyInfo;
import org.apache.xml.security.signature.XMLSignature;
import org.apache.xml.security.utils.Constants;
import org.apache.xml.security.utils.XMLUtils;

enter code here

public class Whatever {
    boolean verifySignature() {
    boolean valid = false;
    try {
        // parse the XML
        InputStream in = obtainInputStreamToXMLSomehow();
        DocumentBuilderFactory f = DocumentBuilderFactory.newInstance();
        f.setNamespaceAware(true);
        Document doc = f.newDocumentBuilder().parse(in);
        in.close();

        // verify signature
        NodeList nodes = doc.getElementsByTagNameNS(Constants.SignatureSpecNS, ""Signature"");
        if (nodes.getLength() == 0) {
        throw new Exception(""Signature NOT found!"");
        }

        Element sigElement = (Element) nodes.item(0);
        XMLSignature signature = new XMLSignature(sigElement, """");

        KeyInfo ki = signature.getKeyInfo();
        if (ki == null) {
        throw new Exception(""Did not find KeyInfo"");
        }

        X509Certificate cert = signature.getKeyInfo().getX509Certificate();
        if (cert == null) {
        PublicKey pk = signature.getKeyInfo().getPublicKey();
        if (pk == null) {
            throw new Exception(""Did not find Certificate or Public Key"");
        }
        valid = signature.checkSignatureValue(pk);
        }
        else {
        valid = signature.checkSignatureValue(cert);
        }
    }
    catch (Exception e) {
        e.printStackTrace();
    }

    return valid;
    }

    // This is important!
    static {
    org.apache.xml.security.Init.init();
    }
}
",,1,a577a718d643fd94a7bb53e23f16e6ba360359d9bc91bf203ffc239477c6ac05
,"public class CustomSSLSocketFactory extends org.apache.http.conn.ssl.SSLSocketFactory
{
    private SSLSocketFactory FACTORY = HttpsURLConnection.getDefaultSSLSocketFactory ();

    public CustomSSLSocketFactory ()
    {
        super(null);
        try
        {
            SSLContext context = SSLContext.getInstance (""TLS"");
            TrustManager[] tm = new TrustManager[] { new FullX509TrustManager () };
            context.init (null, tm, new SecureRandom ());

            FACTORY = context.getSocketFactory ();
        }
        catch (Exception e)
        {
            e.printStackTrace();
        }
    }

    public Socket createSocket() throws IOException
    {
        return FACTORY.createSocket();
    }

    // TODO: add other methods like createSocket() and getDefaultCipherSuites().
    // Hint: they all just make a call to member FACTORY 
}
",4,0,27827352e7b1aa175af503d1d948cc28fc3af034b822da188d0b5fe0c0b89672
,"     HttpsURLConnection urlConnection = (HttpsURLConnection) url.openConnection();
     urlConnection.setSSLSocketFactory(getSSLSocketFactory());
     urlConnection.setHostnameVerifier(new HostnameVerifier() {
               @Override
                    public boolean verify(String hostname, SSLSession session) {
                        HostnameVerifier hv = HttpsURLConnection.getDefaultHostnameVerifier();
                        return hv.verify(""localhost"", session);
                    }
                });
",2,0,c209e728b3657e82e995da6fd6cc1d251425c31c3daa30a4e4e6f1d3f1e6794d
,"public class MySSLSocketFactory extends SSLSocketFactory {
private SSLContext sslContext;

public MySSLSocketFactory(Context context)
        throws NoSuchAlgorithmException, KeyManagementException,
        KeyStoreException, UnrecoverableKeyException, CertificateException,
        IOException {
    super(null);
    sslContext = SSLContext.getInstance(""TLS"");
    sslContext.init(null, new TrustManager[] {
        new MyTrustManager(context)
    }, null);
}

@Override
public Socket createSocket() throws IOException {
    // TODO Auto-generated method stub
    return sslContext.getSocketFactory().createSocket();
}

@Override
public Socket createSocket(Socket socket, String host, int port,
        boolean autoClose) throws IOException, UnknownHostException {
    // TODO Auto-generated method stub
    return sslContext.getSocketFactory().createSocket(socket, host, port,
            autoClose);
}

}
",,1,85e17d6a731f7937eccda0b704a46e666c54ac237b7ac1612c1339a7a88c62fd
,"public class MyTrustManager implements X509TrustManager {
private X509TrustManager defaultTrustManager;
private X509TrustManager myTrustManager;
private X509Certificate[] acceptedIssuers;

public MyTrustManager(Context context) throws KeyStoreException,
        NoSuchAlgorithmException, CertificateException, IOException {
    defaultTrustManager = getDefaultManager();
    myTrustManager = getLocalManager(context);
    if (defaultTrustManager == null || myTrustManager == null) {
        throw new IOException(""Couldn't load X509TrustManager"");
    }
    ArrayList&lt;X509Certificate&gt; acceptedIssuersList = new ArrayList&lt;X509Certificate&gt;();
    this.addToAccepted(acceptedIssuersList, defaultTrustManager);
    this.addToAccepted(acceptedIssuersList, myTrustManager);
    acceptedIssuers = acceptedIssuersList
            .toArray(new X509Certificate[acceptedIssuersList.size()]);
}

private void addToAccepted(
        ArrayList&lt;X509Certificate&gt; x509Certificates,
        X509TrustManager x509TrustManager) {
    for (X509Certificate x509Certificate : x509TrustManager
            .getAcceptedIssuers()) {
        x509Certificates.add(x509Certificate);
    }
}

private X509TrustManager getX509TrustManager(
        TrustManagerFactory trustManagerFactory) {
    TrustManager[] trustManagers = trustManagerFactory.getTrustManagers();
    for (TrustManager trustManager : trustManagers) {
        if (trustManager instanceof X509TrustManager) {
            return (X509TrustManager) trustManager;
        }
    }
    return null;
}

private X509TrustManager getDefaultManager() throws KeyStoreException,
        NoSuchAlgorithmException {
    TrustManagerFactory trustManagerFactory = TrustManagerFactory
            .getInstance(TrustManagerFactory.getDefaultAlgorithm());
    trustManagerFactory.init((KeyStore) null);
    return getX509TrustManager(trustManagerFactory);
}

private X509TrustManager getLocalManager(Context context)
        throws CertificateException, NoSuchAlgorithmException,
        KeyStoreException, IOException {
    if (context == null) {
        return null;
    }
    InputStream inputStream = context
            .getResources().openRawResource(
                    R.raw.ca);
    CertificateFactory certificateFactory = CertificateFactory
            .getInstance(""X.509"");
    X509Certificate x509Certificate = (X509Certificate) certificateFactory
            .generateCertificate(inputStream);
    TrustManagerFactory trustManagerFactory = TrustManagerFactory
            .getInstance(TrustManagerFactory.getDefaultAlgorithm());
    KeyStore keyStore = KeyStore.getInstance(KeyStore.getDefaultType());
    keyStore.load(null);
    keyStore.setCertificateEntry(""ca"", x509Certificate);
    trustManagerFactory.init(keyStore);
    return getX509TrustManager(trustManagerFactory);
}

@Override
public void checkClientTrusted(X509Certificate[] ax509certificate, String s)
        throws CertificateException {
    // TODO Auto-generated method stub
    try {
        myTrustManager.checkClientTrusted(ax509certificate, s);
    } catch (CertificateException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
        defaultTrustManager.checkClientTrusted(ax509certificate, s);
    }
}

@Override
public void checkServerTrusted(X509Certificate[] ax509certificate, String s)
        throws CertificateException {
    // TODO Auto-generated method stub
    try {
        myTrustManager.checkServerTrusted(ax509certificate, s);
    } catch (CertificateException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
        defaultTrustManager.checkServerTrusted(ax509certificate, s);
    }
}

public X509Certificate[] getAcceptedIssuers() {
    // TODO Auto-generated method stub
    return acceptedIssuers;
}

}
",3,0,bb2ae4c499e9c44a40b8cbc91d3d068603161ccfd96e59c19e5edacd1d1b1136
,"public static final String md5(final String s) {
    final String MD5 = ""MD5"";
    try {
        // Create MD5 Hash
        MessageDigest digest = java.security.MessageDigest
                .getInstance(MD5);
        digest.update(s.getBytes());
        byte messageDigest[] = digest.digest();

        // Create Hex String
        StringBuilder hexString = new StringBuilder();
        for (byte aMessageDigest : messageDigest) {
            String h = Integer.toHexString(0xFF &amp; aMessageDigest);
            while (h.length() &lt; 2)
                h = ""0"" + h;
            hexString.append(h);
        }
        return hexString.toString();

    } catch (NoSuchAlgorithmException e) {
        e.printStackTrace();
    }
    return """";
}
",,1,e957d3beebf0483a80c6233978a147bb7f2bfa870790a86dfe02ed5b48979c38
,"KeyGenerator keyGenerator = KeyGenerator.getInstance(
         KeyProperties.KEY_ALGORITHM_HMAC_SHA256, ""AndroidKeyStore"");
keyGenerator.initialize(
         new KeyGenParameterSpec.Builder(""key2"", KeyProperties.PURPOSE_SIGN).build());
SecretKey key = keyGenerator.generateKey();
Mac mac = Mac.getInstance(""HmacSHA256"");
mac.init(key);
...

// The key can also be obtained from the Android Keystore any time as follows:
KeyStore keyStore = KeyStore.getInstance(""AndroidKeyStore"");
keyStore.load(null);
key = (SecretKey) keyStore.getKey(""key2"", null);
",2,0,a80bbfeee5fe6d9cae676003be08c49ff2c03c175851335363006bd1d67cafeb
,"public void KEY(){
        try {
            PackageInfo info =     getActivity().getPackageManager().getPackageInfo(""com.YourPackageName"",     PackageManager.GET_SIGNATURES);
            for (Signature signature : info.signatures) {
                MessageDigest md = MessageDigest.getInstance(""SHA"");
                md.update(signature.toByteArray());
                String sign=Base64.encodeToString(md.digest(), Base64.DEFAULT);
                Log.e(""MY KEY HASH:"", sign);
                Toast.makeText(getActivity().getApplicationContext(),sign,     Toast.LENGTH_LONG).show();
                System.out.println(sign); 
            }
        } catch (NameNotFoundException e) {
        } catch (NoSuchAlgorithmException e) {
        }
    }
",3,0,c227a3307ac94150ebde54f6c42d67181d6506a43e13fdd4a6058c8b0d007630
,"import java.io.UnsupportedEncodingException;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;

import org.apache.http.util.EncodingUtils;
import org.json.JSONArray;
import org.json.JSONException;
import org.json.JSONObject;

import android.app.Activity;
import android.os.Bundle;
import android.util.Log;
import android.view.Menu;
import android.view.MenuItem;
import android.webkit.WebView;
import android.webkit.WebViewClient;

public class MainActivity extends Activity {


    private static final String TAG = ""MainActivity"";
    WebView webviewPayment;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        webviewPayment = (WebView) findViewById(R.id.webviewPayment);
        webviewPayment.getSettings().setJavaScriptEnabled(true);
        webviewPayment.getSettings().setDomStorageEnabled(true);
        webviewPayment.getSettings().setLoadWithOverviewMode(true);
        webviewPayment.getSettings().setUseWideViewPort(true);

        StringBuilder url_s = new StringBuilder();

        url_s.append(""https://test.payu.in/_payment"");

        Log.e(TAG, ""call url "" + url_s);


        webviewPayment.postUrl(url_s.toString(),EncodingUtils.getBytes(getPostString(), ""utf-8""));



        webviewPayment.setWebViewClient(new WebViewClient() {
            @Override
            public void onPageFinished(WebView view, String url) {
                super.onPageFinished(view, url);
            }

            @SuppressWarnings(""unused"")
            public void onReceivedSslError(WebView view) {
                Log.e(""Error"", ""Exception caught!"");
            }

            @Override
            public boolean shouldOverrideUrlLoading(WebView view, String url) {
                view.loadUrl(url);
                return true;
            }

        });
    }

    @Override
    public boolean onCreateOptionsMenu(Menu menu) {

        getMenuInflater().inflate(R.menu.main, menu);
        return true;
    }

    @Override
    public boolean onOptionsItemSelected(MenuItem item) {

        int id = item.getItemId();
        if (id == R.id.action_settings) {
            return true;
        }
        return super.onOptionsItemSelected(item);
    }

    private String getPostString()
    {
        String key  = ""enter key"";
        String salt  = ""enter salt"";
        String txnid = ""TXN_1"";
        String amount = ""200"";
        String firstname = ""prada"";
        String email = ""a@b.com"";
        String productInfo = ""Product1""; 

        StringBuilder post = new StringBuilder();
        post.append(""key="");
        post.append(key);
        post.append(""&amp;"");
        post.append(""txnid="");
        post.append(txnid);
        post.append(""&amp;"");
        post.append(""amount="");
        post.append(amount);
        post.append(""&amp;"");
        post.append(""productinfo="");
        post.append(productInfo);
        post.append(""&amp;"");
        post.append(""firstname="");
        post.append(firstname);
        post.append(""&amp;"");
        post.append(""email="");
        post.append(email);
        post.append(""&amp;"");
        post.append(""phone="");
        post.append(""8904896130"");
        post.append(""&amp;"");
        post.append(""surl="");
        post.append(""http://Success.com/"");
        post.append(""&amp;"");
        post.append(""furl="");
        post.append(""http://failure.com/"");
        post.append(""&amp;"");

        StringBuilder checkSumStr = new StringBuilder();

        MessageDigest digest=null;
        String hash;
        try {
            digest = MessageDigest.getInstance(""SHA-512"");

            checkSumStr.append(key);
            checkSumStr.append(""|"");
            checkSumStr.append(txnid);
            checkSumStr.append(""|"");
            checkSumStr.append(amount);
            checkSumStr.append(""|"");
            checkSumStr.append(productInfo);
            checkSumStr.append(""|"");
            checkSumStr.append(firstname);
            checkSumStr.append(""|"");
            checkSumStr.append(email);
            checkSumStr.append(""|||||||||||"");
            checkSumStr.append(salt);

            digest.update(checkSumStr.toString().getBytes());

            hash = bytesToHexString(digest.digest());
            post.append(""hash="");
            post.append(hash);
            post.append(""&amp;"");
            Log.i(TAG, ""SHA result is "" + hash);
        } catch (NoSuchAlgorithmException e1) {

            e1.printStackTrace();
        }

        post.append(""service_provider="");
        post.append(""payu_paisa"");
        return post.toString(); 
    }

    private JSONObject getProductInfo()
    {
        try {

            JSONObject productInfo = new JSONObject();

            JSONObject jsonPaymentPart = new JSONObject();
            jsonPaymentPart.put(""name"", ""TapFood"");
            jsonPaymentPart.put(""description"", ""Lunchcombo"");
            jsonPaymentPart.put(""value"", ""500"");
            jsonPaymentPart.put(""isRequired"", ""true"");
            jsonPaymentPart.put(""settlementEvent"", ""EmailConfirmation"");


            JSONArray jsonPaymentPartsArr = new JSONArray();
            jsonPaymentPartsArr.put(jsonPaymentPart);


            JSONObject jsonPaymentIdent = new JSONObject();
            jsonPaymentIdent.put(""field"", ""CompletionDate"");
            jsonPaymentIdent.put(""value"", ""31/10/2012"");


            JSONArray jsonPaymentIdentArr = new JSONArray();
            jsonPaymentIdentArr.put(jsonPaymentIdent);

            productInfo.put(""paymentParts"", jsonPaymentPartsArr);
            productInfo.put(""paymentIdentifiers"", jsonPaymentIdentArr);

            Log.e(TAG, ""product Info = "" + productInfo.toString());
            return productInfo;


        } catch (JSONException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
            return null;
        }
    }

    private static String bytesToHexString(byte[] bytes) {

        StringBuffer sb = new StringBuffer();
        for (int i = 0; i &lt; bytes.length; i++) {
            String hex = Integer.toHexString(0xFF &amp; bytes[i]);
            if (hex.length() == 1) {
                sb.append('0');
            }
            sb.append(hex);
        }
        return sb.toString();
    }


}
",3,0,7a91e6fc23129a689da26bbb402f28532f9bfbac3e6d9596e762f3e2c31c6c73
,"// always verify the host - dont check for certificate
final static HostnameVerifier DO_NOT_VERIFY = new HostnameVerifier() {
 public boolean verify(String hostname, SSLSession session) {
  return true;
 }
};

/**
 * Trust every server - dont check for any certificate
 */
private static void trustAllHosts() {
 // Create a trust manager that does not validate certificate chains
 TrustManager[] trustAllCerts = new TrustManager[] { new X509TrustManager() {
  public java.security.cert.X509Certificate[] getAcceptedIssuers() {
   return new java.security.cert.X509Certificate[] {};
  }

  public void checkClientTrusted(X509Certificate[] chain,
    String authType) throws CertificateException {
  }

  public void checkServerTrusted(X509Certificate[] chain,
    String authType) throws CertificateException {
  }
 } };

 // Install the all-trusting trust manager
 try {
  SSLContext sc = SSLContext.getInstance(""TLS"");
  sc.init(null, trustAllCerts, new java.security.SecureRandom());
  HttpsURLConnection
    .setDefaultSSLSocketFactory(sc.getSocketFactory());
 } catch (Exception e) {
  e.printStackTrace();
 }
}
",4,0,194d21b40c5a06bb3c3829cd37b4027ccd0327b6a788d44a18df956644a0451e
," HttpURLConnection http = null;

 if (url.getProtocol().toLowerCase().equals(""https"")) {
     trustAllHosts();
  HttpsURLConnection https = (HttpsURLConnection) url.openConnection();
  https.setHostnameVerifier(DO_NOT_VERIFY);
  http = https;
 } else {
  http = (HttpURLConnection) url.openConnection();
 }
",4,0,390c968c77b56a3abe748e1ac1665b5f826ddc9b1930ba80fc11913431a8f566
,"private List&lt;X509TrustManager&gt; trustManagers = new ArrayList&lt;X509TrustManager&gt;();

public MyCustomTrustManager() {
    TrustManagerFactory tmFactory = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());
    tmFactory.init((KeyStore)null);

    for (TrustManager tm : tmFactory.getTrustManagers()) {
        if (tm instanceof X509TrustManager)
            trustManagers.add((X509TrustManager)tm);
    }
}
",,1,db623437e6f1d39ae5f1a4493c7774d4f96ac8317675e6376065524d808b7c5a
,"Principal subjectDN = chain[0].getSubjectDN();
String subjectCN = parseDN(subjectDN.getName(), ""CN"");
if (this.allowedCN.equals(subjectCN)) {
    // certificate is good
}
",4,0,2e424108d7c61ab7efa6da862623cc0d63033c53e11a55891d02ac5ff4fcd1ca
,"public class MyTrustManager implements X509TrustManager {

    private X509TrustManager defaultTrustManager;
    private X509TrustManager localTrustManager;

    private X509Certificate[] acceptedIssuers;

    public MyTrustManager(KeyStore localKeyStore) { 
      // init defaultTrustManager using the system defaults
      // init localTrustManager using localKeyStore
    }

    public void checkServerTrusted(X509Certificate[] chain, String authType)
            throws CertificateException {
        try {
            defaultTrustManager.checkServerTrusted(chain, authType);
        } catch (CertificateException ce) {
            localTrustManager.checkServerTrusted(chain, authType);
        }
    }

    //...
}
",,1,020a03ca30453d37e28c9bd9d07b107f0a0d4cf54b1924c927d1786842602b3c
,"public static byte[] encryptAES(byte[] key, byte[] inputValue)
        throws NoSuchPaddingException, BadPaddingException, IllegalBlockSizeException, NoSuchAlgorithmException, InvalidKeyException {
    SecretKeySpec sKeyS = new SecretKeySpec(key, ""AES"");

    Cipher cipher = Cipher.getInstance(""AES/ECB/PKCS5Padding"");
    cipher.init(Cipher.ENCRYPT_MODE, sKeyS);

    return cipher.doFinal(inputValue);
}

public static byte[] decryptAES(byte[] key, byte[] encryptedData)
        throws NoSuchPaddingException, BadPaddingException, IllegalBlockSizeException, NoSuchAlgorithmException, InvalidKeyException {
    SecretKeySpec sKeyS = new SecretKeySpec(key, ""AES"");

    Cipher cipher = Cipher.getInstance(""AES/ECB/PKCS5Padding"");
    cipher.init(Cipher.DECRYPT_MODE, sKeyS);

    return cipher.doFinal(encryptedData);
}
",4,0,a6dd28b8cbacadb66048bf04a38f5688606ee3d167729879a7c6e599652b5f97
,"      String hexPubKeyXY = ""01f82bfb2f0a3e988adc3d053d8e6ff878154306e402d871b7d6000823a1397f"";
      String hexX = hexPubKeyXY.substring(0, 32);
      String hexY = hexPubKeyXY.substring(32);
      ECPoint point = new ECPoint(new BigInteger(hexX, 16), new BigInteger(hexY, 16));

      AlgorithmParameters parameters = AlgorithmParameters.getInstance(""EC"", ""SunEC"");
      parameters.init(new ECGenParameterSpec(""secp128r1""));
      ECParameterSpec ecParameters = parameters.getParameterSpec(ECParameterSpec.class);

      ECPublicKeySpec pubKeySpec = new ECPublicKeySpec(point, ecParameters);

      PublicKey key = KeyFactory.getInstance(""EC"", ""SunEC"").generatePublic(pubKeySpec);
",4,0,6db0c6c1590ca475e77f1f9c18ce4d6eff2697c514326f6468046e6302d578df
,"public String md5(String s) {
    if (s != null)
    {
        try { // Create MD5 Hash
            MessageDigest digest = java.security.MessageDigest .getInstance(""MD5"");
            digest.update(s.getBytes());
            byte messageDigest[] = digest.digest();

            // Create Hex String
            StringBuffer hexString = new StringBuffer();
            for (int i = 0; i &lt; messageDigest.length; i++) {
                String h = Integer.toHexString(0xFF &amp; messageDigest[i]);
                while (h.length() &lt; 2)
                    h = ""0"" + h;
                hexString.append(h);
            }
            return hexString.toString();

        } catch (NoSuchAlgorithmException e) {
            e.printStackTrace();
        }
        return """";
    }
    return """";
}
",,1,e18d302bd24543616f48d71bb60e01077b99ce4d1e7eb7ce1ac7d453cfccaeb8
,"import java.security.SecureRandom;

import javax.crypto.Cipher;
import javax.crypto.KeyGenerator;
import javax.crypto.SecretKey;
import javax.crypto.spec.SecretKeySpec;

public class Encryption {

    public static String encrypt(String seed, String cleartext) throws Exception {
        byte[] rawKey = getRawKey(seed.getBytes());
        byte[] result = encrypt(rawKey, cleartext.getBytes());
        return toHex(result);
    }

    public static String decrypt(String seed, String encrypted) throws Exception {
        byte[] rawKey = getRawKey(seed.getBytes());
        byte[] enc = toByte(encrypted);
        byte[] result = decrypt(rawKey, enc);
        return new String(result);
    }


    private static byte[] getRawKey(byte[] seed) throws Exception {
        KeyGenerator kgen = KeyGenerator.getInstance(""AES"");
        SecureRandom sr = SecureRandom.getInstance(""SHA1PRNG"");
        sr.setSeed(seed);
        kgen.init(128, sr); // 192 and 256 bits may not be available
        SecretKey skey = kgen.generateKey();
        byte[] raw = skey.getEncoded();
        return raw;
    }


    private static byte[] encrypt(byte[] raw, byte[] clear) throws Exception {
        SecretKeySpec skeySpec = new SecretKeySpec(raw, ""AES"");
        Cipher cipher = Cipher.getInstance(""AES"");
        cipher.init(Cipher.ENCRYPT_MODE, skeySpec);
        byte[] encrypted = cipher.doFinal(clear);
        return encrypted;
    }

    private static byte[] decrypt(byte[] raw, byte[] encrypted) throws Exception {
        SecretKeySpec skeySpec = new SecretKeySpec(raw, ""AES"");
        Cipher cipher = Cipher.getInstance(""AES"");
        cipher.init(Cipher.DECRYPT_MODE, skeySpec);
        byte[] decrypted = cipher.doFinal(encrypted);
        return decrypted;
    }

    public static String toHex(String txt) {
        return toHex(txt.getBytes());
    }
    public static String fromHex(String hex) {
        return new String(toByte(hex));
    }

    public static byte[] toByte(String hexString) {
        int len = hexString.length()/2;
        byte[] result = new byte[len];
        for (int i = 0; i &lt; len; i++)
            result[i] = Integer.valueOf(hexString.substring(2*i, 2*i+2), 16).byteValue();
        return result;
    }

    public static String toHex(byte[] buf) {
        if (buf == null)
            return """";
        StringBuffer result = new StringBuffer(2*buf.length);
        for (int i = 0; i &lt; buf.length; i++) {
            appendHex(result, buf[i]);
        }
        return result.toString();
    }
    private final static String HEX = ""0123456789ABCDEF"";
    private static void appendHex(StringBuffer sb, byte b) {
        sb.append(HEX.charAt((b&gt;&gt;4)&amp;0x0f)).append(HEX.charAt(b&amp;0x0f));
    }


}
",4,0,88f185ffbc508d8d7b68ed8ca45591e4a9c5fce47128672f124b247c7e24157e
,"Bitmap bmp = new Bitmap(); // load your bitmap...
ByteArrayOutputStream stream = new ByteArrayOutputStream();
bmp.compress(Bitmap.CompressFormat.PNG, 100, stream);
byte[] byteArray = stream.toByteArray();

MessageDigest digest = MessageDigest.getInstance(""SHA-256"");  
digest.update(byteArray);
byte[] keyBytes = digest.digest(byteArray);
",2,0,ce979b24d4761f99e95fc06b18cb82f581b01c9e3f1535015d902da1644aaa0b
,"public String encryptPadding(String plaintext, byte[] salt) {
    try {
        Cipher cipher = Cipher.getInstance(""DES/CBC/PKCS5Padding"");

        cipher.init(Cipher.ENCRYPT_MODE, SKey);

        byte[] cipherText = cipher.doFinal(PlainText.getBytes(""UTF-8""));

        cyphertext = String.format(""%s%s%s"", toBase64(salt), ""]"",
                toBase64(cipherText));
        edit_txt_enc_string.setText(cyphertext);
        return cyphertext;
    } catch (GeneralSecurityException e) {
        throw new RuntimeException(e);
    } catch (UnsupportedEncodingException e) {
        throw new RuntimeException(e);
    }
}

public String decryptPadding(String ctext, byte[] salt) {
    try {
        Cipher cipher = Cipher.getInstance(""DES/CBC/PKCS5Padding"");

        IvParameterSpec ivSpec = new IvParameterSpec(ivBytes);
        cipher.init(Cipher.DECRYPT_MODE, SKey, ivSpec);

        byte[] plaintxt = cipher.doFinal(cyphertext.getBytes(""UTF-8""));

        PlainText = String.format(""%s%s%s"", fromBase64(salt), ""]"",
                fromBase64(plaintxt));
        edit_txt_dec_string.setText(PlainText);
        return PlainText;
    } catch (GeneralSecurityException e) {
        throw new RuntimeException(e);
    } catch (UnsupportedEncodingException e) {
        throw new RuntimeException(e);
    }
}
",4,0,444895f859485a551483870e2d4cd19ceb41de845eb4c8c79c263bb274110633
,"KeyGenerator kg = KeyGenerator.getInstance(""DES"");
SKey = kg.generateKey();
",,1,3e211bb391b85cfafab0d6f63bab0a7f583467db09c25faed047ea4298fd8a29
,"import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.net.InetAddress;
import java.net.Socket;
import java.net.SocketAddress;
import java.net.SocketException;
import java.nio.channels.SocketChannel;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

import javax.net.ssl.HandshakeCompletedListener;
import javax.net.ssl.HttpsURLConnection;
import javax.net.ssl.SSLParameters;
import javax.net.ssl.SSLSession;
import javax.net.ssl.SSLSocket;
import javax.net.ssl.SSLSocketFactory;

    /**
     * {@link javax.net.ssl.SSLSocketFactory} that doesn't allow {@code SSLv3} only connections
     * &lt;p&gt;fixes https://github.com/koush/ion/issues/386&lt;/p&gt;
     *
     * &lt;p&gt; see https://code.google.com/p/android/issues/detail?id=78187 &lt;/p&gt;
     */
    public class NoSSLv3Factory extends SSLSocketFactory {
        private final SSLSocketFactory delegate;

        public NoSSLv3Factory() {
            this.delegate = HttpsURLConnection.getDefaultSSLSocketFactory();
        }

        @Override
        public String[] getDefaultCipherSuites() {
            return delegate.getDefaultCipherSuites();
        }

        @Override
        public String[] getSupportedCipherSuites() {
            return delegate.getSupportedCipherSuites();
        }

        private static Socket makeSocketSafe(Socket socket) {
            if (socket instanceof SSLSocket) {
                socket = new NoSSLv3SSLSocket((SSLSocket) socket);
            }
            return socket;
        }

        @Override
        public Socket createSocket(Socket s, String host, int port, boolean autoClose) throws IOException {
            return makeSocketSafe(delegate.createSocket(s, host, port, autoClose));
        }

        @Override
        public Socket createSocket(String host, int port) throws IOException {
            return makeSocketSafe(delegate.createSocket(host, port));
        }

        @Override
        public Socket createSocket(String host, int port, InetAddress localHost, int localPort) throws IOException {
            return makeSocketSafe(delegate.createSocket(host, port, localHost, localPort));
        }

        @Override
        public Socket createSocket(InetAddress host, int port) throws IOException {
            return makeSocketSafe(delegate.createSocket(host, port));
        }

        @Override
        public Socket createSocket(InetAddress address, int port, InetAddress localAddress, int localPort) throws IOException {
            return makeSocketSafe(delegate.createSocket(address, port, localAddress, localPort));
        }

        /**
         * Created by robUx4 on 25/10/2014.
         */
        private static class DelegateSSLSocket extends SSLSocket {

            protected final SSLSocket delegate;

            DelegateSSLSocket(SSLSocket delegate) {
                this.delegate = delegate;
            }

            @Override
            public String[] getSupportedCipherSuites() {
                return delegate.getSupportedCipherSuites();
            }

            @Override
            public String[] getEnabledCipherSuites() {
                return delegate.getEnabledCipherSuites();
            }

            @Override
            public void setEnabledCipherSuites(String[] suites) {
                delegate.setEnabledCipherSuites(suites);
            }

            @Override
            public String[] getSupportedProtocols() {
                return delegate.getSupportedProtocols();
            }

            @Override
            public String[] getEnabledProtocols() {
                return delegate.getEnabledProtocols();
            }

            @Override
            public void setEnabledProtocols(String[] protocols) {
                delegate.setEnabledProtocols(protocols);
            }

            @Override
            public SSLSession getSession() {
                return delegate.getSession();
            }

            @Override
            public void addHandshakeCompletedListener(HandshakeCompletedListener listener) {
                delegate.addHandshakeCompletedListener(listener);
            }

            @Override
            public void removeHandshakeCompletedListener(HandshakeCompletedListener listener) {
                delegate.removeHandshakeCompletedListener(listener);
            }

            @Override
            public void startHandshake() throws IOException {
                delegate.startHandshake();
            }

            @Override
            public void setUseClientMode(boolean mode) {
                delegate.setUseClientMode(mode);
            }

            @Override
            public boolean getUseClientMode() {
                return delegate.getUseClientMode();
            }

            @Override
            public void setNeedClientAuth(boolean need) {
                delegate.setNeedClientAuth(need);
            }

            @Override
            public void setWantClientAuth(boolean want) {
                delegate.setWantClientAuth(want);
            }

            @Override
            public boolean getNeedClientAuth() {
                return delegate.getNeedClientAuth();
            }

            @Override
            public boolean getWantClientAuth() {
                return delegate.getWantClientAuth();
            }

            @Override
            public void setEnableSessionCreation(boolean flag) {
                delegate.setEnableSessionCreation(flag);
            }

            @Override
            public boolean getEnableSessionCreation() {
                return delegate.getEnableSessionCreation();
            }

            @Override
            public void bind(SocketAddress localAddr) throws IOException {
                delegate.bind(localAddr);
            }

            @Override
            public synchronized void close() throws IOException {
                delegate.close();
            }

            @Override
            public void connect(SocketAddress remoteAddr) throws IOException {
                delegate.connect(remoteAddr);
            }

            @Override
            public void connect(SocketAddress remoteAddr, int timeout) throws IOException {
                delegate.connect(remoteAddr, timeout);
            }

            @Override
            public SocketChannel getChannel() {
                return delegate.getChannel();
            }

            @Override
            public InetAddress getInetAddress() {
                return delegate.getInetAddress();
            }

            @Override
            public InputStream getInputStream() throws IOException {
                return delegate.getInputStream();
            }

            @Override
            public boolean getKeepAlive() throws SocketException {
                return delegate.getKeepAlive();
            }

            @Override
            public InetAddress getLocalAddress() {
                return delegate.getLocalAddress();
            }

            @Override
            public int getLocalPort() {
                return delegate.getLocalPort();
            }

            @Override
            public SocketAddress getLocalSocketAddress() {
                return delegate.getLocalSocketAddress();
            }

            @Override
            public boolean getOOBInline() throws SocketException {
                return delegate.getOOBInline();
            }

            @Override
            public OutputStream getOutputStream() throws IOException {
                return delegate.getOutputStream();
            }

            @Override
            public int getPort() {
                return delegate.getPort();
            }

            @Override
            public synchronized int getReceiveBufferSize() throws SocketException {
                return delegate.getReceiveBufferSize();
            }

            @Override
            public SocketAddress getRemoteSocketAddress() {
                return delegate.getRemoteSocketAddress();
            }

            @Override
            public boolean getReuseAddress() throws SocketException {
                return delegate.getReuseAddress();
            }

            @Override
            public synchronized int getSendBufferSize() throws SocketException {
                return delegate.getSendBufferSize();
            }

            @Override
            public int getSoLinger() throws SocketException {
                return delegate.getSoLinger();
            }

            @Override
            public synchronized int getSoTimeout() throws SocketException {
                return delegate.getSoTimeout();
            }

            @Override
            public boolean getTcpNoDelay() throws SocketException {
                return delegate.getTcpNoDelay();
            }

            @Override
            public int getTrafficClass() throws SocketException {
                return delegate.getTrafficClass();
            }

            @Override
            public boolean isBound() {
                return delegate.isBound();
            }

            @Override
            public boolean isClosed() {
                return delegate.isClosed();
            }

            @Override
            public boolean isConnected() {
                return delegate.isConnected();
            }

            @Override
            public boolean isInputShutdown() {
                return delegate.isInputShutdown();
            }

            @Override
            public boolean isOutputShutdown() {
                return delegate.isOutputShutdown();
            }

            @Override
            public void sendUrgentData(int value) throws IOException {
                delegate.sendUrgentData(value);
            }

            @Override
            public void setKeepAlive(boolean keepAlive) throws SocketException {
                delegate.setKeepAlive(keepAlive);
            }

            @Override
            public void setOOBInline(boolean oobinline) throws SocketException {
                delegate.setOOBInline(oobinline);
            }

            @Override
            public void setPerformancePreferences(int connectionTime, int latency, int bandwidth) {
                delegate.setPerformancePreferences(connectionTime, latency, bandwidth);
            }

            @Override
            public synchronized void setReceiveBufferSize(int size) throws SocketException {
                delegate.setReceiveBufferSize(size);
            }

            @Override
            public void setReuseAddress(boolean reuse) throws SocketException {
                delegate.setReuseAddress(reuse);
            }

            @Override
            public synchronized void setSendBufferSize(int size) throws SocketException {
                delegate.setSendBufferSize(size);
            }

            @Override
            public void setSoLinger(boolean on, int timeout) throws SocketException {
                delegate.setSoLinger(on, timeout);
            }

            @Override
            public synchronized void setSoTimeout(int timeout) throws SocketException {
                delegate.setSoTimeout(timeout);
            }

            @Override
            public void setSSLParameters(SSLParameters p) {
                delegate.setSSLParameters(p);
            }

            @Override
            public void setTcpNoDelay(boolean on) throws SocketException {
                delegate.setTcpNoDelay(on);
            }

            @Override
            public void setTrafficClass(int value) throws SocketException {
                delegate.setTrafficClass(value);
            }

            @Override
            public void shutdownInput() throws IOException {
                delegate.shutdownInput();
            }

            @Override
            public void shutdownOutput() throws IOException {
                delegate.shutdownOutput();
            }

            @Override
            public String toString() {
                return delegate.toString();
            }

            @Override
            public boolean equals(Object o) {
                return delegate.equals(o);
            }
        }

        /**
         * An {@link javax.net.ssl.SSLSocket} that doesn't allow {@code SSLv3} only connections
         * &lt;p&gt;fixes https://github.com/koush/ion/issues/386&lt;/p&gt;
         */
        private static class NoSSLv3SSLSocket extends DelegateSSLSocket {

            private NoSSLv3SSLSocket(SSLSocket delegate) {
                super(delegate);

                String canonicalName = delegate.getClass().getCanonicalName();
                if (!canonicalName.equals(""org.apache.harmony.xnet.provider.jsse.OpenSSLSocketImpl"")) {
                    // try replicate the code from HttpConnection.setupSecureSocket()
                    try {
                        Method msetUseSessionTickets = delegate.getClass().getMethod(""setUseSessionTickets"", boolean.class);
                        if (null != msetUseSessionTickets) {
                            msetUseSessionTickets.invoke(delegate, true);
                        }
                    } catch (NoSuchMethodException ignored) {
                    } catch (InvocationTargetException ignored) {
                    } catch (IllegalAccessException ignored) {
                    }
                }
            }

            @Override
            public void setEnabledProtocols(String[] protocols) {
                if (protocols != null &amp;&amp; protocols.length == 1 &amp;&amp; ""SSLv3"".equals(protocols[0])) {
                    // no way jose
                    // see issue https://code.google.com/p/android/issues/detail?id=78187
                    List&lt;String&gt; enabledProtocols = new ArrayList&lt;String&gt;(Arrays.asList(delegate.getEnabledProtocols()));
                    if (enabledProtocols.size() &gt; 1) {
                        enabledProtocols.remove(""SSLv3"");
                    }
                    protocols = enabledProtocols.toArray(new String[enabledProtocols.size()]);
                }
                super.setEnabledProtocols(protocols);
            }
        }

    }
",3,0,525594e927bcf089a467b0bd24d05d1fdaeb171f80807be44aa26c1b0fc7c878
,"    static {
    HttpsURLConnection.setDefaultSSLSocketFactory(new NoSSLv3Factory());
}
",,1,2005eaefb94b8436c981289ef6258a7ef41ee77a9e9f4cebbea5ea40bd6c0504
,"private String getAppendedHeader(String str) {
    try {
        String hash = getHash(str);

        String signature = new String(Base64.encodeBase64(hash.getBytes()));
        StringBuilder sb = new StringBuilder();
        sb.append(PUBLIC_KEY).append(' ').append(signature);
        return sb.toString();
    } catch (NoSuchAlgorithmException _e) {
        LL.e(""Get mac error: "" + _e.getMessage());
        return null;
    } catch (InvalidKeyException _e) {
        LL.e(""Init mac error: "" + _e.getMessage());
        return null;
    }
}


private String getHash(String str) throws NoSuchAlgorithmException, InvalidKeyException {
    Mac mac = Mac.getInstance(""HmacSHA256"");
    SecretKeySpec secret = new SecretKeySpec(PRIVATE_KEY.getBytes(), ""HmacSHA256"");
    mac.init(secret);
    byte[] digest = mac.doFinal(str.getBytes());
    BigInteger hash = new BigInteger(1, digest);
    String hmac = hash.toString(16);
    if (hmac.length() % 2 != 0) {
        hmac = ""0"" + hmac;
    }
    return hmac;
}
",,1,7398a6705db82530dd66210272f039baa73bdd1b20984c181228ef26133738be
,"          DocumentBuilderFactory dbfac = DocumentBuilderFactory.newInstance();
         dbfac.setNamespaceAware(true);
         DocumentBuilder docBuilder = null;
         try {
            docBuilder = dbfac.newDocumentBuilder();
        } catch (ParserConfigurationException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }
         DOMImplementation domImpl = docBuilder.getDOMImplementation();
         Document doc = domImpl.createDocument(""http://coggl.com/InsertTrack"",""TrackEntry"", null);
         doc.setXmlVersion(""1.0"");
         doc.setXmlStandalone(true);

         Element trackElement = doc.getDocumentElement();

         Element CompanyId = doc.createElement(""CompanyId"");
         CompanyId.appendChild(doc.createTextNode(""1""));
         trackElement.appendChild(CompanyId);

         Element CreatedBy = doc.createElement(""CreatedBy"");
         CreatedBy.appendChild(doc.createTextNode(""6""));
         trackElement.appendChild(CreatedBy);

         Element DepartmentId = doc.createElement(""DepartmentId"");
         DepartmentId.appendChild(doc.createTextNode(""4""));
         trackElement.appendChild(DepartmentId);

         Element IsBillable = doc.createElement(""IsBillable"");
         IsBillable.appendChild(doc.createTextNode(""1""));
         trackElement.appendChild(IsBillable);

         Element ProjectId = doc.createElement(""ProjectId"");
         ProjectId.appendChild(doc.createTextNode(""1""));
         trackElement.appendChild(ProjectId);

         Element StartTime = doc.createElement(""StartTime"");
         StartTime.appendChild(doc.createTextNode(""2012-03-14 10:44:45""));
         trackElement.appendChild(StartTime);

         Element StopTime = doc.createElement(""StopTime"");
         StopTime.appendChild(doc.createTextNode(""2012-03-14 11:44:45""));
         trackElement.appendChild(StopTime);

         Element TaskId = doc.createElement(""TaskId"");
         TaskId.appendChild(doc.createTextNode(""3""));
         trackElement.appendChild(TaskId);

         Element TotalTime = doc.createElement(""TotalTime"");
         TotalTime.appendChild(doc.createTextNode(""1""));
         trackElement.appendChild(TotalTime);

         Element TrackDesc = doc.createElement(""TrackDesc"");
         TrackDesc.appendChild(doc.createTextNode(""dello testing""));
         trackElement.appendChild(TrackDesc);

         Element TrackId = doc.createElement(""TrackId"");
         TrackId.appendChild(doc.createTextNode(""0""));
         trackElement.appendChild(TrackId);

         TransformerFactory transfac = TransformerFactory.newInstance();
         Transformer trans = null;
        try {
            trans = transfac.newTransformer();
        } catch (TransformerConfigurationException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }
         trans.setOutputProperty(OutputKeys.OMIT_XML_DECLARATION, ""yes"");
         trans.setOutputProperty(OutputKeys.INDENT, ""yes"");

         //create string from xml tree
         StringWriter sw = new StringWriter();
         StreamResult result = new StreamResult(sw);
         DOMSource source = new DOMSource(doc);
         try {
            trans.transform(source, result);
        } catch (TransformerException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }
         String xmlString = sw.toString();
",,1,7125575cf5183a1012ed699d81584cfb914ae8c6179df1b7977f2b26906a5406
,"PackageInfo packageInfo;
        try {
        packageInfo = getPackageManager().getPackageInfo(""com.yourapp"", 
PackageManager.GET_SIGNATURES);
        for (Signature signature : packageInfo.signatures) {
                MessageDigest md = MessageDigest.getInstance(""SHA"");
                md.update(signature.toByteArray());
                String key = new String(Base64.encode(md.digest(), 0));
                // String key = new String(Base64.encodeBytes(md.digest()));
                Log.e(""Hash key"", key);
        } 
        }
        catch (NameNotFoundException e1) {
            Log.e(""Name not found"", e1.toString());
        }

        catch (NoSuchAlgorithmException e) {
            Log.e(""No such an algorithm"", e.toString());
        }
        catch (Exception e){
            Log.e(""Exception"", e.toString());
        }
",3,0,bc8ecea4b2751d1f281c001b15cdb4209a0375d69368b88004733089ab4776d8
,"SSLSocketFactory factory = (SSLSocketFactory) SSLSocketFactory.getDefault();
SSLSocket socket = (SSLSocket) factory.createSocket(domain, 443);

socket.startHandshake();
BufferedReader in = new BufferedReader(new InpuStreamReader(socket.getInputStream()));
PrintWriter out = new PrintWriter(socket.getOutputStream());
",3,0,936443e1f374161fa7ad352a7b635fa8b145e9819ad11c27f990a262ded93baf
,"import java.io.IOException;
import java.net.Socket;
import java.net.UnknownHostException;
import java.security.KeyManagementException;
import java.security.KeyStore;
import java.security.KeyStoreException;
import java.security.NoSuchAlgorithmException;
import java.security.UnrecoverableKeyException;
import java.security.cert.CertificateException;
import java.security.cert.X509Certificate;

import javax.net.ssl.SSLContext;
import javax.net.ssl.TrustManager;
import javax.net.ssl.X509TrustManager;

import org.apache.http.conn.ssl.SSLSocketFactory;
public class MySSLSocketFactory extends SSLSocketFactory {
    SSLContext sslContext = SSLContext.getInstance(""TLS"");

    public MySSLSocketFactory(KeyStore truststore) throws NoSuchAlgorithmException, KeyManagementException, KeyStoreException, UnrecoverableKeyException {
        super(truststore);

        TrustManager tm = new X509TrustManager() {
            public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {
            }

            public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {
            }

            public X509Certificate[] getAcceptedIssuers() {
                return null;
            }
        };

        sslContext.init(null, new TrustManager[] { tm }, null);
    }

    @Override
    public Socket createSocket(Socket socket, String host, int port, boolean autoClose) throws IOException, UnknownHostException {
        return sslContext.getSocketFactory().createSocket(socket, host, port, autoClose);
    }

    @Override
    public Socket createSocket() throws IOException {
        return sslContext.getSocketFactory().createSocket();
    }
}
",4,0,2347b1ab7e58f40641b03f2c8111b3ed26effb618da375dd6c48baba78770b14
,"public void printHashKey() {
   try {
      PackageInfo info = getActivity().getPackageManager().getPackageInfo(""com.gorbin.androidsocialnetworksextended.asne"",
      PackageManager.GET_SIGNATURES);
      for (Signature signature : info.signatures) {
         MessageDigest md = MessageDigest.getInstance(""SHA"");
         md.update(signature.toByteArray());
         Log.d(""HASH KEY:"", Base64.encodeToString(md.digest(), Base64.DEFAULT));
      }
   } catch (PackageManager.NameNotFoundException e) {
   } catch (NoSuchAlgorithmException e) {
   }
   }
",3,0,2afa52dafdef1ca8529d59ff7a919f10e0b9ea1e9e70c5bc3e303818d446f8a5
,"public String getData() {
    String dataDecrypted = null;
    try {
        byte[] cryptionKeyCrypted = Base64.decode(cryptionKeyCryptedBase64, Base64.NO_WRAP);
        byte[] cryptionIV = Base64.decode(cryptionIVBase64, Base64.NO_WRAP);

        Cipher cipherRSA = Cipher.getInstance(""RSA/ECB/OAEPWithSHA-1AndMGF1Padding"");
        // get private key from the pair used to grab the public key to send to the api
        cipherRSA.init(Cipher.DECRYPT_MODE, rsaKeyPair.getPrivateKey());
        byte[] key = cipherRSA.doFinal(cryptionKeyCrypted);

        byte[] dataCrytped = Base64.decode(dataCryptedBase64, Base64.NO_WRAP);
        IvParameterSpec ivSpec = new IvParameterSpec(cryptionIV);
        SecretKeySpec skeySpec = new SecretKeySpec(key, ""AES"");
        Cipher cipherAES = Cipher.getInstance(""AES/CBC/ZeroBytePadding"");
        cipherAES.init(Cipher.DECRYPT_MODE, skeySpec, ivSpec);
        byte[] decryptedAESBytes = cipherAES.doFinal(dataCrytped);
        dataDecrypted = new String(decryptedAESBytes, ""UTF-8"");
    } catch (Exception e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    }
    return dataDecrypted;
}
",1,0,94fb1f12da22a5989ac4a50878e94cbfb052d9d78eced0727f045be5d88c7ccf
,"trustAllHosts();
 HttpsURLConnection post = (HttpsURLConnection) url.openConnection();
 https.setHostnameVerifier(DO_NOT_VERIFY);


and add these methods,
// always verify the host - dont check for certificate
final static HostnameVerifier DO_NOT_VERIFY = new HostnameVerifier() {
        public boolean verify(String hostname, SSLSession session) {
                return true;
        }
};

/**
 * Trust every server - dont check for any certificate
 */
private static void trustAllHosts() {
        // Create a trust manager that does not validate certificate chains
        TrustManager[] trustAllCerts = new TrustManager[] { new X509TrustManager() {
                public java.security.cert.X509Certificate[] getAcceptedIssuers() {
                        return new java.security.cert.X509Certificate[] {};
                }

                public void checkClientTrusted(X509Certificate[] chain,
                                String authType) throws CertificateException {
                }

                public void checkServerTrusted(X509Certificate[] chain,
                                String authType) throws CertificateException {
                }
        } };

        // Install the all-trusting trust manager
        try {
                SSLContext sc = SSLContext.getInstance(""TLS"");
                sc.init(null, trustAllCerts, new java.security.SecureRandom());
                HttpsURLConnection
                                .setDefaultSSLSocketFactory(sc.getSocketFactory());
        } catch (Exception e) {
                e.printStackTrace();
        }
}
",4,0,a0661992c409e84649ef71f84fec88952300b3022dd31c22643036188244efab
,"KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());

try (FileInputStream fis = new FileInputStream(keystore)) {
    ks.load(fis, ksPw.toCharArray());
}

ks.getEntry(alias, new KeyStore.PasswordProtection(aliasPw.toCharArray()));
",,1,e3b0d023d0763301238115631d94b80e97a7ffcb7efcf28e3cd54b31afc1b17a
,"HttpURLConnection conn = null;
            final HostnameVerifier DO_NOT_VERIFY = new HostnameVerifier() {
                public boolean verify(String hostname, SSLSession session) {
                    return true;
                }
           };
            try {
                URL url = new URL(YOUR_URL);
                if (url.getProtocol().toLowerCase().equals(""https"")) {
                    trustAllHosts();
                    HttpsURLConnection https = (HttpsURLConnection) url.openConnection();
                    https.setHostnameVerifier(DO_NOT_VERIFY);
                    conn = https;
                } else {
                    conn = (HttpURLConnection) url.openConnection();
                }
                conn.setInstanceFollowRedirects(false);
                conn.connect();
        String location = conn.getHeaderField( ""User name"" );
",4,0,0c0802424a6acda9c19ff5aaf7f16ff1c506f4b505c4b8d37f29432e64c802c3
,"        KeyStore keystore = KeyStore.getInstance(""PKCS12"");
        InputStream keystream = context.getResources().getAssets().open(""client.p12"");
        try {
            keystore.load(keystream, ""dysan100"".toCharArray());
        } finally {
            try { keystream.close(); } catch (Exception ignore) {}
        }
",,1,bc90aae83bab52b164d7e71905366240ae8b52a456b34bdb35d0d1fdb24b6543
,"private void getKeyHash(Context context) {
        try {
            PackageInfo info = getPackageManager().getPackageInfo(""com.example.android"", PackageManager.GET_SIGNATURES);
            for (Signature signature : info.signatures) {
                MessageDigest md = MessageDigest.getInstance(""SHA"");
                md.update(signature.toByteArray());
                Log.d(""Obtained KeyHash:"", Base64.encodeToString(md.digest(), Base64.DEFAULT));
            }
        } catch (NameNotFoundException e) {

        } catch (NoSuchAlgorithmException e) {

        }
    }
",3,0,66eb44f33f589efb774b1c21f4d9d0d730e6e01c1a4fd8070a3ccc4f0884bcfd
,"public class AESCrypt {

private final Cipher cipher;
private final SecretKeySpec key;
private AlgorithmParameterSpec spec;


public AESCrypt(String password) throws Exception
{
    // hash password with SHA-256 and crop the output to 128-bit for key
    MessageDigest digest = MessageDigest.getInstance(""SHA-256"");
    digest.update(password.getBytes(""UTF-8""));
    byte[] keyBytes = new byte[32];
    System.arraycopy(digest.digest(), 0, keyBytes, 0, keyBytes.length);

    cipher = Cipher.getInstance(""AES/CBC/PKCS7Padding"");
    key = new SecretKeySpec(keyBytes, ""AES"");
    spec = getIV();
}       

public AlgorithmParameterSpec getIV()
{
    byte[] iv = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, };
    IvParameterSpec ivParameterSpec;
    ivParameterSpec = new IvParameterSpec(iv);

    return ivParameterSpec;
}

public String encrypt(String plainText) throws Exception
{
    cipher.init(Cipher.ENCRYPT_MODE, key, spec);
    byte[] encrypted = cipher.doFinal(plainText.getBytes(""UTF-8""));
    String encryptedText = new String(Base64.encode(encrypted, Base64.DEFAULT), ""UTF-8"");

    return encryptedText;
}

public String decrypt(String cryptedText) throws Exception
{
    cipher.init(Cipher.DECRYPT_MODE, key, spec);
    byte[] bytes = Base64.decode(cryptedText, Base64.DEFAULT);
    byte[] decrypted = cipher.doFinal(bytes);
    String decryptedText = new String(decrypted, ""UTF-8"");

    return decryptedText;
}
",4,0,1676e3681d22d6ab693ea0a6065fef5f7b8190ac68fdf4fc0a5d3d6533751b11
,"    try {
         PackageInfo info = getPackageManager().getPackageInfo(
                           ""com.your.package.name"", 
                            PackageManager.GET_SIGNATURES);
         for (Signature signature : info.signatures) {
                    MessageDigest md = MessageDigest.getInstance(""SHA"");
                    md.update(signature.toByteArray());
          Log.d(""KeyHash:"", Base64.encodeToString(md.digest(),      Base64.DEFAULT));

                  }
            } catch (NameNotFoundException e) {
                e.printStackTrace();
            } catch (NoSuchAlgorithmException e) {
                e.printStackTrace();
          }
",3,0,bb916222422300164e6247eb8c1c1c5f51633c5c3e2e809db3d69f206f237703
,"Log.e(""body"", body);
            HttpClient httpclient = getNewHttpClient();

            HttpPost httppost = new HttpPost(""https://www.demo.com/login.php"");

             nameValuePairs = new ArrayList&lt;NameValuePair&gt;();
nameValuePairs.add(new BasicNameValuePair(""username"", username));
nameValuePairs.add(new BasicNameValuePair(""password"", password));
httppost.setEntity(new UrlEncodedFormEntity(nameValuePairs));


            httppost.setEntity(entity);
            response = httpclient.execute(httppost);;


            Log.e(""response"", response.getStatusLine().toString());
            String aaa = response.getStatusLine().toString();
            Toast.makeText(getApplicationContext(), ""Content :""+ aaa, Toast.LENGTH_LONG).show();
            HttpEntity entity1 = response.getEntity();
            is = entity1.getContent();

                //Toast.makeText(getApplicationContext(), ""Content :""+ (CharSequence) is, Toast.LENGTH_LONG).show();

        }catch(Exception e){
            Log.e(""log_tag"", ""Error in http connection ""+e.toString());
        }


public HttpClient getNewHttpClient() {
        try {
            KeyStore trustStore = KeyStore.getInstance(KeyStore
                    .getDefaultType());
            trustStore.load(null, null);

            SSLSocketFactory sf = new MySSLSocketFactory(trustStore);
            sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);

            HttpParams params = new BasicHttpParams();
            HttpProtocolParams.setVersion(params, HttpVersion.HTTP_1_1);
            HttpProtocolParams.setContentCharset(params, HTTP.UTF_8);

            SchemeRegistry registry = new SchemeRegistry();
            registry.register(new Scheme(""http"", PlainSocketFactory
                    .getSocketFactory(), 80));
            registry.register(new Scheme(""https"", sf, 443));

            ClientConnectionManager ccm = new ThreadSafeClientConnManager(
                    params, registry);

            return new DefaultHttpClient(ccm, params);
        } catch (Exception e) {
            return new DefaultHttpClient();
        }
    }
",4,0,26cc27980afae6ce869874585ddd8ba90331a855f6c2c905eb850dd3bf44ad3f
,"import java.io.UnsupportedEncodingException;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;


public class MD5Encode {
   private static String convertedToHex(byte[] data) {
    StringBuffer buf = new StringBuffer();

    for (int i = 0; i &lt; data.length; i++) {
        int halfOfByte = (data[i] &gt;&gt;&gt; 4) &amp; 0x0F;
        int twoHalfBytes = 0;

        do {
            if ((0 &lt;= halfOfByte) &amp;&amp; (halfOfByte &lt;= 9)) {
                buf.append((char) ('0' + halfOfByte));
            } else {
                buf.append((char) ('a' + (halfOfByte - 10)));
            }

            halfOfByte = data[i] &amp; 0x0F;

        } while (twoHalfBytes++ &lt; 1);
    }
    return buf.toString();
    }

    public static String MD5(String text) throws NoSuchAlgorithmException,
        UnsupportedEncodingException {
    MessageDigest md;
    md = MessageDigest.getInstance(""MD5"");
    byte[] md5 = new byte[64];
    md.update(text.getBytes(""iso-8859-1""), 0, text.length());
    md5 = md.digest();
    return convertedToHex(md5);
   }
}
",,1,0fa4e92bb2356e14ec00d03fb8966e759f106526e2e2cd6d55c78aeec2ec8ece
,"// AESdemo

public class AESdemo extends Activity {
    boolean encryptionIsOn = true;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_aesdemo);
        // needs &lt;uses-permission android:name=""android.permission.WRITE_EXTERNAL_STORAGE"" /&gt;
        String homeDirName = Environment.getExternalStorageDirectory().getAbsolutePath() +
                ""/"" + getPackageName();
        File file = new File(homeDirName, ""test.txt"");
        byte[] keyBytes = getKey(""password"");

        try {
            File dir = new File(homeDirName);
            if (!dir.exists())
                dir.mkdirs();
            if (!file.exists())
                file.createNewFile();

            OutputStreamWriter osw;

            if (encryptionIsOn) {
                Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
                SecretKeySpec secretKeySpec = new SecretKeySpec(keyBytes, ""AES"");
                IvParameterSpec ivParameterSpec = new IvParameterSpec(keyBytes);
                cipher.init(Cipher.ENCRYPT_MODE, secretKeySpec, ivParameterSpec);

                FileOutputStream fos = new FileOutputStream(file);
                CipherOutputStream cos = new CipherOutputStream(fos, cipher);
                osw = new OutputStreamWriter(cos, ""UTF-8"");
            }
            else    // not encryptionIsOn
                osw = new FileWriter(file);

            BufferedWriter out = new BufferedWriter(osw);
            out.write(""This is a test\n"");
            out.close();
        }
        catch (Exception e) {
            System.out.println(""Encryption Exception ""+e);
        }

        ///////////////////////////////////
        try {
            InputStreamReader isr;

            if (encryptionIsOn) {
                Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
                SecretKeySpec secretKeySpec = new SecretKeySpec(keyBytes, ""AES"");
                IvParameterSpec ivParameterSpec = new IvParameterSpec(keyBytes);
                cipher.init(Cipher.DECRYPT_MODE, secretKeySpec, ivParameterSpec);

                FileInputStream fis = new FileInputStream(file);
                CipherInputStream cis = new CipherInputStream(fis, cipher);
                isr = new InputStreamReader(cis, ""UTF-8"");
            }
            else
                isr = new FileReader(file);

            BufferedReader in = new BufferedReader(isr);
            String line = in.readLine();
            System.out.println(""Text read: &lt;""+line+""&gt;"");
            in.close();
        }
        catch (Exception e) {
            System.out.println(""Decryption Exception ""+e);
        }
    }

    private byte[] getKey(String password) throws UnsupportedEncodingException {
        String key = """";
        while (key.length() &lt; 16)
            key += password;
        return key.substring(0, 16).getBytes(""UTF-8"");
    }
}
",4,0,96b746311a87cde8776d1e724ca61e02d56e4416cc8811d0d292493c2556aa10
,"  byte[] wholeFileByte = null;
    Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS7Padding"");
    cipher.init(Cipher.DECRYPT_MODE, key, DownloadBookAsyncTask.ivspec);
    File file = new File(context.getFilesDir().getParentFile().getPath() + ""/download/"" + id + ""/xmldata.xml"");
    FileInputStream fis = new FileInputStream(file);
    ByteArrayOutputStream bos = new ByteArrayOutputStream();
    CipherInputStream cis = new CipherInputStream(fis, cipher);
    byte data[] = new byte[4096];
    int count;
    while ((count = cis.read(data)) != -1) {
        bos.write(data, 0, count);
    }

    if(cis != null)
        cis.close();
    if(bos != null)
        bos.close();
    if(fis != null)
        fis.close();

    wholeFileByte = bos.toByteArray();
    String kk = new String(wholeFileByte, ""UTF-8"");
",1,0,77fd7629391bf6a144aa15d392c7be4d4488823b0cf334f4ad6d2e6bb7fa0c73
,"public DefaultHttpClient getNewHttpClient() {
    try {
        KeyStore trustStore = KeyStore.getInstance(KeyStore.getDefaultType());
        trustStore.load(null, null);

        SSLSocketFactory sf = new MySSLSocketFactory(trustStore);
        sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);

        HttpParams params = new BasicHttpParams();
        HttpProtocolParams.setVersion(params, HttpVersion.HTTP_1_1);
        HttpProtocolParams.setContentCharset(params, HTTP.UTF_8);

        SchemeRegistry registry = new SchemeRegistry();
        registry.register(new Scheme(""http"", PlainSocketFactory.getSocketFactory(), 80));
        registry.register(new Scheme(""https"", sf, 443));

        ClientConnectionManager ccm = new ThreadSafeClientConnManager(params, registry);

        return new DefaultHttpClient(ccm, params);
    } catch (Exception e) {
        return new DefaultHttpClient();
    }
",4,0,d42f64cf02ae2c0774919c2c757180a2fa8a4d5d8b0376c0064a9f21b446ec0d
,"public class MySSLSocketFactory extends SSLSocketFactory {
SSLContext sslContext = SSLContext.getInstance(""SSLv3"");

public MySSLSocketFactory(KeyStore truststore) throws NoSuchAlgorithmException, KeyManagementException, KeyStoreException, UnrecoverableKeyException {
    super(truststore);

    TrustManager tm = new X509TrustManager() {
        public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {}
        public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {}
        public X509Certificate[] getAcceptedIssuers() {
            return null;
        }
    };

    sslContext.init(null, new TrustManager[] { tm }, null);
}

@Override
public Socket createSocket(Socket socket, String host, int port, boolean autoClose) throws IOException, UnknownHostException {
    SSLSocket S = (SSLSocket) sslContext.getSocketFactory().createSocket(socket, host, port, autoClose);
    S.setEnabledProtocols(new String[] {""SSLv3""});
    return S;
}

@Override
public Socket createSocket() throws IOException {
    SSLSocket S = (SSLSocket) sslContext.getSocketFactory().createSocket();
    S.setEnabledProtocols(new String[] {""SSLv3""});
    return S;
}
",4,0,187ab500c5f4fcd20dfc07b21a534428409c40f32134449ceaf21af8d4556172
,"public HttpClient getNewHttpClient() {
    try {
        KeyStore trustStore = KeyStore.getInstance(KeyStore.getDefaultType());
        trustStore.load(null, null);

        MySSLSocketFactory sf = new MySSLSocketFactory(trustStore);
        sf.setHostnameVerifier(MySSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);

        HttpParams params = new BasicHttpParams();
        HttpProtocolParams.setVersion(params, HttpVersion.HTTP_1_1);
        HttpProtocolParams.setContentCharset(params, HTTP.UTF_8);

        SchemeRegistry registry = new SchemeRegistry();
        registry.register(new Scheme(""http"", PlainSocketFactory.getSocketFactory(), 80));
        registry.register(new Scheme(""https"", sf, 443));

        ClientConnectionManager ccm = new ThreadSafeClientConnManager(params, registry);

        return new DefaultHttpClient(ccm, params);
    } catch (Exception e) {
        return new DefaultHttpClient();
    }
}
",4,0,1d5ad9c56bb7a750043d5fd765bb910381de771907a328f3562105960f598106
,"import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;

import android.app.Activity;
import android.content.pm.PackageInfo;
import android.content.pm.PackageManager;
import android.content.pm.PackageManager.NameNotFoundException;
import android.content.pm.Signature;
import android.os.Bundle;
import android.util.Log;
import android.widget.TextView;

public class MainActivity extends Activity {
    /** Called when the activity is first created. */
    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.main);

        try {
               PackageInfo info = getPackageManager().getPackageInfo(""com.key"", PackageManager.GET_SIGNATURES);
               for (Signature signature : info.signatures) {
                    MessageDigest md = MessageDigest.getInstance(""SHA"");
                    md.update(signature.toByteArray());

                      TextView tvmyName = (TextView)findViewById(R.id.KeyText);
                      tvmyName.setText(Base64.encodeBytes(md.digest()));


               }
            } catch (NameNotFoundException e) {

            } catch (NoSuchAlgorithmException e) {

            }

    }
}
",,1,76546b8ad4ba61186625a9bd40fef9971446530899d88c00eed3a9f51d5bbcba
,"private void initSslSocketFactory() {

    try {
        /*
         * SETUP TRUSTSTORE 
         */  
        KeyStore trustStore = KeyStore.getInstance(""BKS"");  
        TrustManagerFactory trustManagerFactory = TrustManagerFactory  
            .getInstance(TrustManagerFactory.getDefaultAlgorithm());  
        InputStream trustStoreStream = context.getResources()  
            .openRawResource(R.raw.ca);  
        trustStore.load(trustStoreStream, ""000000"".toCharArray());  
        trustManagerFactory.init(trustStore);  

        /* 
         * SETUP KEYSTORE 
         */  
        KeyStore keyStore = KeyStore.getInstance(""PKCS12"");  
        KeyManagerFactory keyManagerFactory = KeyManagerFactory  
            .getInstance(KeyManagerFactory.getDefaultAlgorithm());  
        InputStream keyStoreStream = context.getResources()  
            .openRawResource(R.raw.client);  
        keyStore.load(keyStoreStream, ""000000"".toCharArray());  
        keyManagerFactory.init(keyStore, ""000000"".toCharArray());  

        /* 
         * SETUP the SSL context to use the truststore and keystore 
         */   
        SSLContext sslContext = SSLContext.getInstance(""TLS"");
        sslContext.init(keyManagerFactory.getKeyManagers(), trustManagerFactory.getTrustManagers(), null);
        mSslSocketFactory = sslContext.getSocketFactory();
    } catch (NoSuchAlgorithmException e) {
        Log.e(Tag, """" + e.getMessage());
        e.printStackTrace();
    } catch (KeyManagementException e) {
        Log.e(Tag, """" + e.getMessage());
        e.printStackTrace();
    }
}

public void connect() {
    mSslSock = (SSLSocket) mSslSocketFactory.createSocket();
    mSslSock.connect(new InetSocketAddress(host, port));
    mSslSock.setSoTimeout(SOCKET_TIMEOUT);
    mSslSock.setUseClientMode(true);
    mSslSock.setEnabledCipherSuites(mSslSock.getEnabledCipherSuites());
    mSslSock.setEnabledProtocols(mSslSock.getSupportedProtocols());
    mSslSock.connect(SocketAddress);
    ......
}
",3,0,1dfd2becdbab4ef13ba2786f7171d17d41b8bd5662104d1d388bb8dc110542b0
," SSLContext sslContext = SSLContext.getInstance(""SSL"");

// set up a TrustManager that trusts everything
sslContext.init(null, new TrustManager[] { new X509TrustManager() {
            public X509Certificate[] getAcceptedIssuers() {
                    System.out.println(""getAcceptedIssuers ============="");
                    return null;
            }

            public void checkClientTrusted(X509Certificate[] certs,
                            String authType) {
                    System.out.println(""checkClientTrusted ============="");
            }

            public void checkServerTrusted(X509Certificate[] certs,
                            String authType) {
                    System.out.println(""checkServerTrusted ============="");
            }
} }, new SecureRandom());

SSLSocketFactory sf = new SSLSocketFactory(sslContext);
Scheme httpsScheme = new Scheme(""https"", 443, sf);
SchemeRegistry schemeRegistry = new SchemeRegistry();
schemeRegistry.register(httpsScheme);

// apache HttpClient version &gt;4.2 should use BasicClientConnectionManager
ClientConnectionManager cm = new SingleClientConnManager(schemeRegistry);
HttpClient httpClient = new DefaultHttpClient(cm);
",4,0,7e08a3e903c6cb0242664a78ee24c696f075f8e0824da7fcacc847d358c6a34c
,"public static void allowAllSSL() {

        try {
            SSLContext sc = SSLContext.getInstance(""TLS"");
            sc.init(null, trustAllCerts, new java.security.SecureRandom());
            HttpsURLConnection
                    .setDefaultSSLSocketFactory(sc.getSocketFactory());
            connection = (HttpsURLConnection) (new URL(
                    ""https://sPublic/Client.asmx""))
                    .openConnection();
            connection.connect();
        } catch (Exception e) {
            e.getMessage();
        }
",4,0,c870c3ab6d86d87c6feaeb48f674844cebbd9f2b036b02173bff982024e4e1ba
,"/**
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
 */
package se.simbio.encryption;

import android.os.AsyncTask;
import android.util.Base64;
import android.util.Log;

import java.io.UnsupportedEncodingException;
import java.security.InvalidAlgorithmParameterException;
import java.security.InvalidKeyException;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.security.SecureRandom;
import java.security.spec.InvalidKeySpecException;
import java.security.spec.KeySpec;

import javax.crypto.BadPaddingException;
import javax.crypto.Cipher;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.NoSuchPaddingException;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.PBEKeySpec;
import javax.crypto.spec.SecretKeySpec;

/**
 * A class to make more easy and simple the encrypt routines, this is the core of Encryption library
 */
public class Encryption {

    /**
     * We use this tag to log errors on LogCat, never the password or sensible data
     */
    private static final String TAG = ""Encryption"";

    /**
     * The Builder used to create the Encryption instance and that contains the information about
     * encryption specifications, this instance need to be private and careful managed
     */
    private final Builder mBuilder;

    /**
     * The private and unique constructor, you should use the Encryption.Builder to build your own
     * instance or get the default proving just the sensible information about encryption
     */
    private Encryption(Builder builder) {
        mBuilder = builder;
    }

    /**
     * @return an default encryption instance or {@code null} if occur some Exception, you can
     * create yur own Encryption instance using the Encryption.Builder
     */
    public static Encryption getDefault(String key, String salt, byte[] iv) {
        try {
            return Builder.getDefaultBuilder(key, salt, iv).build();
        } catch (NoSuchAlgorithmException e) {
            Log.e(TAG, e.getMessage(), e);
            return null;
        }
    }

    /**
     * Encrypt a String
     *
     * @param data the String to be encrypted
     *
     * @return the encrypted String or {@code null} if you send the data as {@code null}
     *
     * @throws UnsupportedEncodingException       if the Builder charset name is not supported or if
     *                                            the Builder charset name is not supported
     * @throws NoSuchAlgorithmException           if the Builder digest algorithm is not available
     *                                            or if this has no installed provider that can
     *                                            provide the requested by the Builder secret key
     *                                            type or it is {@code null}, empty or in an invalid
     *                                            format
     * @throws NoSuchPaddingException             if no installed provider can provide the padding
     *                                            scheme in the Builder digest algorithm
     * @throws InvalidAlgorithmParameterException if the specified parameters are inappropriate for
     *                                            the cipher
     * @throws InvalidKeyException                if the specified key can not be used to initialize
     *                                            the cipher instance
     * @throws InvalidKeySpecException            if the specified key specification cannot be used
     *                                            to generate a secret key
     * @throws BadPaddingException                if the padding of the data does not match the
     *                                            padding scheme
     * @throws IllegalBlockSizeException          if the size of the resulting bytes is not a
     *                                            multiple of the cipher block size
     * @throws NullPointerException               if the Builder digest algorithm is {@code null} or
     *                                            if the specified Builder secret key type is
     *                                            {@code null}
     * @throws IllegalStateException              if the cipher instance is not initialized for
     *                                            encryption or decryption
     */
    public String encrypt(String data) throws UnsupportedEncodingException, NoSuchAlgorithmException, NoSuchPaddingException, InvalidAlgorithmParameterException, InvalidKeyException, InvalidKeySpecException, BadPaddingException, IllegalBlockSizeException {
        if (data == null) return null;
        SecretKey secretKey = getSecretKey(hashTheKey(mBuilder.getKey()));
        byte[] dataBytes = data.getBytes(mBuilder.getCharsetName());
        Cipher cipher = Cipher.getInstance(mBuilder.getAlgorithm());
        cipher.init(Cipher.ENCRYPT_MODE, secretKey, mBuilder.getIvParameterSpec(), mBuilder.getSecureRandom());
        return Base64.encodeToString(cipher.doFinal(dataBytes), mBuilder.getBase64Mode());
    }

    /**
     * This is a sugar method that calls encrypt method and catch the exceptions returning
     * {@code null} when it occurs and logging the error
     *
     * @param data the String to be encrypted
     *
     * @return the encrypted String or {@code null} if you send the data as {@code null}
     */
    public String encryptOrNull(String data) {
        try {
            return encrypt(data);
        } catch (Exception e) {
            Log.e(TAG, e.getMessage(), e);
            return null;
        }
    }

    /**
     * This is a sugar method that calls encrypt method in background, it is a good idea to use this
     * one instead the default method because encryption can take several time and with this method
     * the process occurs in a AsyncTask, other advantage is the Callback with separated methods,
     * one for success and other for the exception
     *
     * @param data     the String to be encrypted
     * @param callback the Callback to handle the results
     */
    public void encryptAsync(String data, final Callback callback) {
        if (callback == null) return;
        new AsyncTask&lt;String, Void, String&gt;() {

            @Override
            protected String doInBackground(String... params) {
                try {
                    String encrypt = encrypt(params[0]);
                    if (encrypt == null) {
                        callback.onError(new Exception(""Encrypt return null, it normally occurs when you send a null data""));
                    }
                    return encrypt;
                } catch (Exception e) {
                    callback.onError(e);
                    return null;
                }
            }

            @Override
            protected void onPostExecute(String result) {
                super.onPostExecute(result);
                if (result != null) callback.onSuccess(result);
            }

        }.execute(data);
    }

    /**
     * Decrypt a String
     *
     * @param data the String to be decrypted
     *
     * @return the decrypted String or {@code null} if you send the data as {@code null}
     *
     * @throws UnsupportedEncodingException       if the Builder charset name is not supported or if
     *                                            the Builder charset name is not supported
     * @throws NoSuchAlgorithmException           if the Builder digest algorithm is not available
     *                                            or if this has no installed provider that can
     *                                            provide the requested by the Builder secret key
     *                                            type or it is {@code null}, empty or in an invalid
     *                                            format
     * @throws NoSuchPaddingException             if no installed provider can provide the padding
     *                                            scheme in the Builder digest algorithm
     * @throws InvalidAlgorithmParameterException if the specified parameters are inappropriate for
     *                                            the cipher
     * @throws InvalidKeyException                if the specified key can not be used to initialize
     *                                            the cipher instance
     * @throws InvalidKeySpecException            if the specified key specification cannot be used
     *                                            to generate a secret key
     * @throws BadPaddingException                if the padding of the data does not match the
     *                                            padding scheme
     * @throws IllegalBlockSizeException          if the size of the resulting bytes is not a
     *                                            multiple of the cipher block size
     * @throws NullPointerException               if the Builder digest algorithm is {@code null} or
     *                                            if the specified Builder secret key type is
     *                                            {@code null}
     * @throws IllegalStateException              if the cipher instance is not initialized for
     *                                            encryption or decryption
     */
    public String decrypt(String data) throws UnsupportedEncodingException, NoSuchAlgorithmException, InvalidKeySpecException, NoSuchPaddingException, InvalidAlgorithmParameterException, InvalidKeyException, BadPaddingException, IllegalBlockSizeException {
        if (data == null) return null;
        byte[] dataBytes = Base64.decode(data, mBuilder.getBase64Mode());
        SecretKey secretKey = getSecretKey(hashTheKey(mBuilder.getKey()));
        Cipher cipher = Cipher.getInstance(mBuilder.getAlgorithm());
        cipher.init(Cipher.DECRYPT_MODE, secretKey, mBuilder.getIvParameterSpec(), mBuilder.getSecureRandom());
        byte[] dataBytesDecrypted = (cipher.doFinal(dataBytes));
        return new String(dataBytesDecrypted);
    }

    /**
     * This is a sugar method that calls decrypt method and catch the exceptions returning
     * {@code null} when it occurs and logging the error
     *
     * @param data the String to be decrypted
     *
     * @return the decrypted String or {@code null} if you send the data as {@code null}
     */
    public String decryptOrNull(String data) {
        try {
            return decrypt(data);
        } catch (Exception e) {
            Log.e(TAG, e.getMessage(), e);
            return null;
        }
    }

    /**
     * This is a sugar method that calls decrypt method in background, it is a good idea to use this
     * one instead the default method because decryption can take several time and with this method
     * the process occurs in a AsyncTask, other advantage is the Callback with separated methods,
     * one for success and other for the exception
     *
     * @param data     the String to be decrypted
     * @param callback the Callback to handle the results
     */
    public void decryptAsync(String data, final Callback callback) {
        if (callback == null) return;
        new AsyncTask&lt;String, Void, String&gt;() {

            @Override
            protected String doInBackground(String... params) {
                try {
                    String decrypt = decrypt(params[0]);
                    if (decrypt == null) {
                        callback.onError(new Exception(""Decrypt return null, it normally occurs when you send a null data""));
                    }
                    return decrypt;
                } catch (Exception e) {
                    callback.onError(e);
                    return null;
                }
            }

            @Override
            protected void onPostExecute(String result) {
                super.onPostExecute(result);
                if (result != null) callback.onSuccess(result);
            }

        }.execute(data);
    }

    /**
     * creates a 128bit salted aes key
     *
     * @param key encoded input key
     *
     * @return aes 128 bit salted key
     *
     * @throws NoSuchAlgorithmException     if no installed provider that can provide the requested
     *                                      by the Builder secret key type
     * @throws UnsupportedEncodingException if the Builder charset name is not supported
     * @throws InvalidKeySpecException      if the specified key specification cannot be used to
     *                                      generate a secret key
     * @throws NullPointerException         if the specified Builder secret key type is {@code null}
     */
    private SecretKey getSecretKey(char[] key) throws NoSuchAlgorithmException, UnsupportedEncodingException, InvalidKeySpecException {
        SecretKeyFactory factory = SecretKeyFactory.getInstance(mBuilder.getSecretKeyType());
        KeySpec spec = new PBEKeySpec(key, mBuilder.getSalt().getBytes(mBuilder.getCharsetName()), mBuilder.getIterationCount(), mBuilder.getKeyLength());
        SecretKey tmp = factory.generateSecret(spec);
        return new SecretKeySpec(tmp.getEncoded(), mBuilder.getAlgorithm());
    }

    /**
     * takes in a simple string and performs an sha1 hash
     * that is 128 bits long...we then base64 encode it
     * and return the char array
     *
     * @param key simple inputted string
     *
     * @return sha1 base64 encoded representation
     *
     * @throws UnsupportedEncodingException if the Builder charset name is not supported
     * @throws NoSuchAlgorithmException     if the Builder digest algorithm is not available
     * @throws NullPointerException         if the Builder digest algorithm is {@code null}
     */
    private char[] hashTheKey(String key) throws UnsupportedEncodingException, NoSuchAlgorithmException {
        MessageDigest messageDigest = MessageDigest.getInstance(mBuilder.getDigestAlgorithm());
        messageDigest.update(key.getBytes(mBuilder.getCharsetName()));
        return Base64.encodeToString(messageDigest.digest(), Base64.NO_PADDING).toCharArray();
    }

    /**
     * When you encrypt or decrypt in callback mode you get noticed of result using this interface
     */
    public static interface Callback {

        /**
         * Called when encrypt or decrypt job ends and the process was a success
         *
         * @param result the encrypted or decrypted String
         */
        public void onSuccess(String result);

        /**
         * Called when encrypt or decrypt job ends and has occurred an error in the process
         *
         * @param exception the Exception related to the error
         */
        public void onError(Exception exception);

    }

    /**
     * This class is used to create an Encryption instance, you should provide ALL data or start
     * with the Default Builder provided by the getDefaultBuilder method
     */
    public static class Builder {

        private byte[] mIv;
        private int mKeyLength;
        private int mBase64Mode;
        private int mIterationCount;
        private String mSalt;
        private String mKey;
        private String mAlgorithm;
        private String mCharsetName;
        private String mSecretKeyType;
        private String mDigestAlgorithm;
        private String mSecureRandomAlgorithm;
        private SecureRandom mSecureRandom;
        private IvParameterSpec mIvParameterSpec;

        /**
         * @return an default builder with the follow defaults:
         * the default char set is UTF-8
         * the default base mode is Base64
         * the Secret Key Type is the PBKDF2WithHmacSHA1
         * the default salt is ""some_salt"" but can be anything
         * the default length of key is 128
         * the default iteration count is 65536
         * the default algorithm is AES in CBC mode and PKCS 5 Padding
         * the default secure random algorithm is SHA1PRNG
         * the default message digest algorithm SHA1
         */
        public static Builder getDefaultBuilder(String key, String salt, byte[] iv) {
            return new Builder()
                    .setIv(iv)
                    .setKey(key)
                    .setSalt(salt)
                    .setKeyLength(128)
                    .setCharsetName(""UTF8"")
                    .setIterationCount(65536)
                    .setDigestAlgorithm(""SHA1"")
                    .setBase64Mode(Base64.DEFAULT)
                    .setAlgorithm(""AES/CBC/PKCS5Padding"")
                    .setSecureRandomAlgorithm(""SHA1PRNG"")
                    .setSecretKeyType(""PBKDF2WithHmacSHA1"");
        }

        /**
         * Build the Encryption with the provided information
         *
         * @return a new Encryption instance with provided information
         *
         * @throws NoSuchAlgorithmException if the specified SecureRandomAlgorithm is not available
         * @throws NullPointerException     if the SecureRandomAlgorithm is {@code null} or if the
         *                                  IV byte array is null
         */
        public Encryption build() throws NoSuchAlgorithmException {
            setSecureRandom(SecureRandom.getInstance(getSecureRandomAlgorithm()));
            setIvParameterSpec(new IvParameterSpec(getIv()));
            return new Encryption(this);
        }

        //region getters and setters

        /**
         * @return the charset name
         */
        private String getCharsetName() {
            return mCharsetName;
        }

        /**
         * @param charsetName the new charset name
         *
         * @return this instance to follow the Builder patter
         */
        public Builder setCharsetName(String charsetName) {
            mCharsetName = charsetName;
            return this;
        }

        /**
         * @return the algorithm
         */
        private String getAlgorithm() {
            return mAlgorithm;
        }

        /**
         * @param algorithm the algorithm to be used
         *
         * @return this instance to follow the Builder patter
         */
        public Builder setAlgorithm(String algorithm) {
            mAlgorithm = algorithm;
            return this;
        }

        /**
         * @return the Base 64 mode
         */
        private int getBase64Mode() {
            return mBase64Mode;
        }

        /**
         * @param base64Mode set the base 64 mode
         *
         * @return this instance to follow the Builder patter
         */
        public Builder setBase64Mode(int base64Mode) {
            mBase64Mode = base64Mode;
            return this;
        }

        /**
         * @return the type of aes key that will be created, on KITKAT+ the API has changed, if you
         * are getting problems please @see &lt;a href=""http://android-developers.blogspot.com.br/2013/12/changes-to-secretkeyfactory-api-in.html""&gt;http://android-developers.blogspot.com.br/2013/12/changes-to-secretkeyfactory-api-in.html&lt;/a&gt;
         */
        private String getSecretKeyType() {
            return mSecretKeyType;
        }

        /**
         * @param secretKeyType the type of AES key that will be created, on KITKAT+ the API has
         *                      changed, if you are getting problems please @see &lt;a href=""http://android-developers.blogspot.com.br/2013/12/changes-to-secretkeyfactory-api-in.html""&gt;http://android-developers.blogspot.com.br/2013/12/changes-to-secretkeyfactory-api-in.html&lt;/a&gt;
         *
         * @return this instance to follow the Builder patter
         */
        public Builder setSecretKeyType(String secretKeyType) {
            mSecretKeyType = secretKeyType;
            return this;
        }

        /**
         * @return the value used for salting
         */
        private String getSalt() {
            return mSalt;
        }

        /**
         * @param salt the value used for salting
         *
         * @return this instance to follow the Builder patter
         */
        public Builder setSalt(String salt) {
            mSalt = salt;
            return this;
        }

        /**
         * @return the key
         */
        private String getKey() {
            return mKey;
        }

        /**
         * @param key the key.
         *
         * @return this instance to follow the Builder patter
         */
        public Builder setKey(String key) {
            mKey = key;
            return this;
        }

        /**
         * @return the length of key
         */
        private int getKeyLength() {
            return mKeyLength;
        }

        /**
         * @param keyLength the length of key
         *
         * @return this instance to follow the Builder patter
         */
        public Builder setKeyLength(int keyLength) {
            mKeyLength = keyLength;
            return this;
        }

        /**
         * @return the number of times the password is hashed
         */
        private int getIterationCount() {
            return mIterationCount;
        }

        /**
         * @param iterationCount the number of times the password is hashed
         *
         * @return this instance to follow the Builder patter
         */
        public Builder setIterationCount(int iterationCount) {
            mIterationCount = iterationCount;
            return this;
        }

        /**
         * @return the algorithm used to generate the secure random
         */
        private String getSecureRandomAlgorithm() {
            return mSecureRandomAlgorithm;
        }

        /**
         * @param secureRandomAlgorithm the algorithm to generate the secure random
         *
         * @return this instance to follow the Builder patter
         */
        public Builder setSecureRandomAlgorithm(String secureRandomAlgorithm) {
            mSecureRandomAlgorithm = secureRandomAlgorithm;
            return this;
        }

        /**
         * @return the IvParameterSpec bytes array
         */
        private byte[] getIv() {
            return mIv;
        }

        /**
         * @param iv the byte array to create a new IvParameterSpec
         *
         * @return this instance to follow the Builder patter
         */
        public Builder setIv(byte[] iv) {
            mIv = iv;
            return this;
        }

        /**
         * @return the SecureRandom
         */
        private SecureRandom getSecureRandom() {
            return mSecureRandom;
        }

        /**
         * @param secureRandom the Secure Random
         *
         * @return this instance to follow the Builder patter
         */
        public Builder setSecureRandom(SecureRandom secureRandom) {
            mSecureRandom = secureRandom;
            return this;
        }

        /**
         * @return the IvParameterSpec
         */
        private IvParameterSpec getIvParameterSpec() {
            return mIvParameterSpec;
        }

        /**
         * @param ivParameterSpec the IvParameterSpec
         *
         * @return this instance to follow the Builder patter
         */
        public Builder setIvParameterSpec(IvParameterSpec ivParameterSpec) {
            mIvParameterSpec = ivParameterSpec;
            return this;
        }

        /**
         * @return the message digest algorithm
         */
        private String getDigestAlgorithm() {
            return mDigestAlgorithm;
        }

        /**
         * @param digestAlgorithm the algorithm to be used to get message digest instance
         *
         * @return this instance to follow the Builder patter
         */
        public Builder setDigestAlgorithm(String digestAlgorithm) {
            mDigestAlgorithm = digestAlgorithm;
            return this;
        }

        //endregion

    }

}
",1,0,8302d5bc8254ab3ff9e53700716bd128ca1ca60422c1725046a3f145180572e0
,"try {
        PackageInfo info = getPackageManager().getPackageInfo(
                ""YOUR PACKAGE NAME HERE"", 
                PackageManager.GET_SIGNATURES);
        for (Signature signature : info.signatures) {
            MessageDigest md = MessageDigest.getInstance(""SHA"");
            md.update(signature.toByteArray());
            Log.d(""KeyHash:"", Base64.encodeToString(md.digest(), Base64.DEFAULT));
            }
    } catch (NameNotFoundException e) {

    } catch (NoSuchAlgorithmException e) {

    }
",3,0,b62b1386fdd8970e91f45e4f60feca8ed254aaa460bfa0bda6f7e30f5146e01c
,"    import javax.crypto.Cipher;
    import javax.crypto.spec.IvParameterSpec;
    import javax.crypto.spec.SecretKeySpec;

    import android.util.Base64;
    //string encryption
    public class EncryptionHelper {



        // Encrypts string and encode in Base64
        public static String encryptText(String plainText) throws Exception {
            // ---- Use specified 3DES key and IV from other source --------------
            byte[] plaintext = plainText.getBytes();//input
            byte[] tdesKeyData = Constants.getKey().getBytes();// your encryption key

            byte[] myIV = Constants.getInitializationVector().getBytes();// initialization vector

            Cipher c3des = Cipher.getInstance(""DESede/CBC/PKCS5Padding"");
            SecretKeySpec myKey = new SecretKeySpec(tdesKeyData, ""DESede"");
            IvParameterSpec ivspec = new IvParameterSpec(myIV);

            c3des.init(Cipher.ENCRYPT_MODE, myKey, ivspec);
            byte[] cipherText = c3des.doFinal(plaintext);
            String encryptedString = Base64.encodeToString(cipherText,
                    Base64.DEFAULT);
            // return Base64Coder.encodeString(new String(cipherText));
            return encryptedString;
        }

    private class Constants 
{
private static final String KEY=""QsdPasd45FaSdnLjf"";
    private static final String INITIALIZATION_VECTOR=""l9yhTaWY"";
public static String getKey() 
    {
        return KEY;
    }


    public static String getInitializationVector() 
    {
        return INITIALIZATION_VECTOR;
    }
 }   
    }
",4,0,81325d7121b6476c5f41b8e2fef183a5a06cfcc7cd292dbae5c9d30195f897ad
,"package com.example.mypackage;

import android.util.Log;

import javax.net.ssl.HostnameVerifier;
import javax.net.ssl.SSLSession;
import javax.net.ssl.TrustManager;
import java.security.KeyManagementException;
import java.security.NoSuchAlgorithmException;
import java.security.SecureRandom;
import java.security.cert.CertificateException;
import java.security.cert.X509Certificate;

public class SSLConection {

    private static TrustManager[] trustManagers;

    public static class _FakeX509TrustManager implements javax.net.ssl.X509TrustManager {
        private static final X509Certificate[] _AcceptedIssuers = new X509Certificate[]{};

        public void checkClientTrusted(X509Certificate[] arg0, String arg1)
                throws CertificateException {
        }

        public void checkServerTrusted(X509Certificate[] arg0, String arg1)
                throws CertificateException {
        }

        public X509Certificate[] getAcceptedIssuers() {
            return (_AcceptedIssuers);
        }
    }

    public static void allowAllSSL() {

        javax.net.ssl.HttpsURLConnection.setDefaultHostnameVerifier(new HostnameVerifier() {
            @Override
            public boolean verify(String hostname, SSLSession session) {
                return true;
            }
        });

        javax.net.ssl.SSLContext context;

        if (trustManagers == null) {
            trustManagers = new TrustManager[]{new _FakeX509TrustManager()};
        }

        try {
            context = javax.net.ssl.SSLContext.getInstance(""TLS"");
            context.init(null, trustManagers, new SecureRandom());
            javax.net.ssl.HttpsURLConnection.setDefaultSSLSocketFactory(context.getSocketFactory());
        } catch (NoSuchAlgorithmException e) {
            Log.e(""allowAllSSL"", e.toString());
        } catch (KeyManagementException e) {
            Log.e(""allowAllSSL"", e.toString());
        }
    }
}
",4,0,595dbbc0481bc412eda82eb129cf81922bd74d92f52df3c8dc63cbcfb33f8af6
,"import java.io.File;
import java.io.StringReader;
import java.io.StringWriter;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerException;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamResult;

import org.w3c.dom.Document;
import org.xml.sax.InputSource;
import org.xml.sax.SAXException;

/**
 * Some general XML functions
 */
public class XML
{
    /**
     * Get an XML Document file from its string representation
     * @param xml The xml string
     * @return Document object for the XML representation
     */
    public static Document fromString(String xml)
    {
        if (xml == null)
            throw new NullPointerException(""The xml string passed in is null"");

        // from http://www.rgagnon.com/javadetails/java-0573.html
        try
        {
            DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
            DocumentBuilder db = dbf.newDocumentBuilder();
            InputSource is = new InputSource();
            is.setCharacterStream(new StringReader(xml));

            Document doc = db.parse(is);

            return doc;
        }
        catch (SAXException e)
        {
            return null;
        }
        catch(Exception e)
        {
            CustomExceptionHandler han = new CustomExceptionHandler();
            han.uncaughtException(Thread.currentThread(), e);
            return null;
        }
    }

    /**
     * Get a XML Document object from a file
     * @param location The location where the file is found
     * @return An XML Document object
     */
    public static Document fromFile(String location)
    {
        return fromFile(new File(location));
    }

    /**
     * Get a XML Document object from a file
     * @param location The file object to load
     * @return An XML Document object
     */
    public static Document fromFile(File file)
    {
        try
        {
            DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
            DocumentBuilder db = dbf.newDocumentBuilder();

            Document doc = db.parse(file);
            doc.getDocumentElement().normalize();
            return doc;
        }
        catch (Exception e)
        {
            return null;
        }
    }

    /**
     * Method to convert Document to String
     * @param doc
     * @return
     */
    public static String getStringFromDocument(Document doc)
    {
        try
        {
           DOMSource domSource = new DOMSource(doc);
           StringWriter writer = new StringWriter();
           StreamResult result = new StreamResult(writer);
           TransformerFactory tf = TransformerFactory.newInstance();
           Transformer transformer = tf.newTransformer();
           transformer.transform(domSource, result);
           return writer.toString();
        }
        catch(TransformerException ex)
        {
           ex.printStackTrace();
           return null;
        }
    }
}
",,1,561241daae89cfee7cb0b14e2c84e622a5387fe98e4a31750a853f76864d03b4
,"public final boolean authenticate(String attemptedPassword, byte[] encryptedPassword, byte[] salt) throws NoSuchAlgorithmException, InvalidKeySpecException {
  String algorithm = ""PBKDF2WithHmacSHA1"";
  int derivedKeyLength = 160;
  int iterations = 20000;
  KeySpec spec = new PBEKeySpec(password.toCharArray(), salt, iterations, derivedKeyLength);
  SecretKeyFactory f = SecretKeyFactory.getInstance(algorithm);

  byte[] encryptedPassword = f.generateSecret(spec).getEncoded();

  return Arrays.equals(encryptedPassword, encryptedAttemptedPassword);
}
",3,0,01ad77032957403a2ae8c8927ecdd9baddd2404f27779fa7d825ec5b4d8dd7cc
,"public DefaultHttpClient getNewHttpClient() {
    try {
        KeyStore trustStore = KeyStore.getInstance(KeyStore.getDefaultType());
        trustStore.load(null, null);

        SSLSocketFactory sf = new MySSLSocketFactory(trustStore);
        sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);

        HttpParams params = new BasicHttpParams();
        HttpProtocolParams.setVersion(params, HttpVersion.HTTP_1_1);
        HttpProtocolParams.setContentCharset(params, HTTP.UTF_8);

        SchemeRegistry registry = new SchemeRegistry();
        registry.register(new Scheme(""https"", sf, 443));

        ClientConnectionManager ccm = new ThreadSafeClientConnManager(params, registry);

        return new DefaultHttpClient(ccm, params);
    } catch (Exception e) {
        return new DefaultHttpClient();
    }
}
",4,0,74e4d867b72a9fe153f610f0b8e07e9850a35ab7f9f6c0fdd4162b444732bda6
,"    import java.security.AlgorithmParameters;
import java.security.SecureRandom;
import java.security.spec.KeySpec;

import javax.crypto.Cipher;
import javax.crypto.KeyGenerator;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.PBEKeySpec;
import javax.crypto.spec.SecretKeySpec;

class SecurityUtils {

  private static final byte[] salt = { (byte) 0xA4, (byte) 0x0B, (byte) 0xC8,
      (byte) 0x34, (byte) 0xD6, (byte) 0x95, (byte) 0xF3, (byte) 0x13 };

  private static int BLOCKS = 128;

  public static byte[] encryptAES(String seed, String cleartext)
      throws Exception {
    byte[] rawKey = getRawKey(seed.getBytes(""UTF8""));
    SecretKeySpec skeySpec = new SecretKeySpec(rawKey, ""AES"");
    Cipher cipher = Cipher.getInstance(""AES"");
    cipher.init(Cipher.ENCRYPT_MODE, skeySpec);
    return cipher.doFinal(cleartext.getBytes(""UTF8""));
  }

  public static byte[] decryptAES(String seed, byte[] data) throws Exception {
    byte[] rawKey = getRawKey(seed.getBytes(""UTF8""));
    SecretKeySpec skeySpec = new SecretKeySpec(rawKey, ""AES"");
    Cipher cipher = Cipher.getInstance(""AES"");
    cipher.init(Cipher.DECRYPT_MODE, skeySpec);
    return cipher.doFinal(data);
  }

  private static byte[] getRawKey(byte[] seed) throws Exception {
    KeyGenerator kgen = KeyGenerator.getInstance(""AES"");
    SecureRandom sr = SecureRandom.getInstance(""SHA1PRNG"");
    sr.setSeed(seed);
    kgen.init(BLOCKS, sr); // 192 and 256 bits may not be available
    SecretKey skey = kgen.generateKey();
    byte[] raw = skey.getEncoded();
    return raw;
  }

  private static byte[] pad(byte[] seed) {
    byte[] nseed = new byte[BLOCKS / 8];
    for (int i = 0; i &lt; BLOCKS / 8; i++)
      nseed[i] = 0;
    for (int i = 0; i &lt; seed.length; i++)
      nseed[i] = seed[i];

    return nseed;
  }

  public static byte[] encryptPBE(String password, String cleartext)
      throws Exception {
    SecretKeyFactory factory = SecretKeyFactory
        .getInstance(""PBKDF2WithHmacSHA1"");
    KeySpec spec = new PBEKeySpec(password.toCharArray(), salt, 1024, 256);
    SecretKey tmp = factory.generateSecret(spec);
    SecretKey secret = new SecretKeySpec(tmp.getEncoded(), ""AES"");

    Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
    cipher.init(Cipher.ENCRYPT_MODE, secret);
    AlgorithmParameters params = cipher.getParameters();
    byte[] iv = params.getParameterSpec(IvParameterSpec.class).getIV();
    return cipher.doFinal(cleartext.getBytes(""UTF-8""));
  }

  public static String decryptPBE(SecretKey secret, String ciphertext,
      byte[] iv) throws Exception {
    Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
    cipher.init(Cipher.DECRYPT_MODE, secret, new IvParameterSpec(iv));
    return new String(cipher.doFinal(ciphertext.getBytes()), ""UTF-8"");
  }

}
",4,0,7d79460a9b1e416d5d61ac5c80c925994c5f47930bf442e1ec93e8db09d0d866
,"// Encryption

public  String encrypt(String message) throws Exception

{

String message1=Base64.encodeBytes(message.getBytes(),Base64.NO_OPTIONS);
String salt = SharedVariables.globalContext.getString(R.string.EncryptionKey);
SecretKeySpec key = new SecretKeySpec(salt.getBytes(), ""AES"");`enter code here`
Cipher c = Cipher.getInstance(""AES"");
c.init(Cipher.ENCRYPT_MODE, key);
byte[] encVal = c.doFinal(message1.getBytes());
String encrypted=Base64.encodeToString(encVal, Base64.NO_OPTIONS);
return encrypted;

}

//Decryption

public String decrypt(String message) throws Exception

{

String salt = SharedVariables.globalContext.getString(R.string.EncryptionKey);
Cipher c = Cipher.getInstance(""AES"");
SecretKeySpec key = new SecretKeySpec(salt.getBytes(), ""AES"");
c.init(Cipher.DECRYPT_MODE, key);
byte[] decordedValue = Base64.decode(message.getBytes(), Base64.NO_OPTIONS);
byte[] decValue = c.doFinal(decordedValue);
String decryptedValue = new String(decValue);
String decoded=new String(Base64.decode(decryptedValue, .Base64.NO_OPTIONS));
return decoded;
} 
",4,0,c553a27c9b685cf555b88b75a86b582fa0000c6eee079f4150681cbae92dd7c5
,"private void test() {

            try {
                String stringMessage=""GEQRpAPA577ks/QveudNkk7H9DjItKGLDYW6xhH1YJGabCVzrkejkBh6S+APwEXxB84UV/q0sO5rqkgXWONJQ8CoMTfqXtUkAAwkYHSc86eGewkM8WpctA0AyNVFonOxDCXm84Uq8JRMzqskSH5VXHmMxvHIvpFgdhmt9Ir0cKWzoLsuvgfY9hfypfEyBXGZcoptQeKhsZxRGIlxbXhrFl/LqhC+F6vYtZ/j5pv2LUP38wh2rTCKnAQ+xvC+7wn5SVzt/Wbr/q7GjCoJuU9uFHQSS49KQDt+BzJL2XNwAMmdbC+XHYkEBBWxVSS+0hdSQxoaKVZZJk4hTnHwQlBAkw=="";
                //Convert String back to Byte[] and decrpt
                byte[] byteMessage = Base64.decodeBase64(stringMessage.getBytes(""UTF-8""));
                System.out.println(""ENCRYPTED MESSAGE byte Length: ""+byteMessage.length);

                String decryptedMsg = decryptString(byteMessage, loadCASPrivateKey());
                System.out.println(decryptedMsg);
            } catch (Exception e) {
                e.printStackTrace();
                return;
            }
        }

        private static String decryptString(byte[] message, Key privateKey) throws InvalidKeyException, NoSuchAlgorithmException, NoSuchPaddingException, IllegalBlockSizeException, BadPaddingException, UnsupportedEncodingException, NoSuchProviderException {
            Security.addProvider(new org.bouncycastle.jce.provider.BouncyCastleProvider());

            Cipher cipher = Cipher.getInstance(""RSA/None/NoPadding"",""BC"");
            cipher.init(Cipher.DECRYPT_MODE, privateKey);

            byte[] cipherData = cipher.doFinal(message);
            return new String(cipherData, ""UTF-8"");
        }

        private PrivateKey loadCASPrivateKey() throws IOException, NoSuchAlgorithmException, InvalidKeySpecException {
            InputStream is = getClass().getResourceAsStream( ""/keys/app-private.key"" );
            if (is == null) {
                System.out.println(""NULL"");
            }
            byte[] encodedPrivateKey = new byte[(int) 1216];
            is.read(encodedPrivateKey);
            is.close();

            // Generate KeyPair.
            KeyFactory keyFactory = KeyFactory.getInstance(""RSA"");

            PKCS8EncodedKeySpec privateKeySpec = new PKCS8EncodedKeySpec(encodedPrivateKey);
            PrivateKey privateKey = keyFactory.generatePrivate(privateKeySpec);

            return privateKey;

        }
",3,0,a1fd0ec2b61e9a1b11caeb589c42e2beba8b8de3dd2aa4b48764b3394a832336
,"try {
      KeyStore trustStore = KeyStore.getInstance(KeyStore.getDefaultType());
      trustStore.load(null, null);
      sf = new MySSLSocketFactory(trustStore);
      sf.setHostnameVerifier(MySSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
      client.setSSLSocketFactory(sf);   
    }
    catch (Exception e) {   
    }
",4,0,847d790fbb21c53d677c9643308ea5c2cccdb9e8a6fde20bff9b1efa6d65e113
,"public class MySSLSocketFactory extends SSLSocketFactory
                                throws NoSuchAlgorithmException {

    private SSLContext mSSLContext;

    public MySSLSocketFactory(KeyManager km) {
        ...
        mSSLContext = SSLContext.getInstance(""TLSv1.2"");
        ...
        mSSLContext.init(new KeyManager[] {km}, null, null);
        ...
    }

    @Override
    public Socket createSocket(Socket socket, String host, int port, boolean autoClose)
                    throws IOException {
        SSLSocket s = (SSLSocket)mSSLContext.getSocketFactory().createSocket(socket, host, port, autoClose);
        s.setEnabledProtocols(new String[] {""TLSv1.2""} );
        return s;
    }

    ...
}
",,1,3ae59af94e88c97c709e4c11ad544d13c8c8c4dafd13e720a0be937fd7ff7416
,"public class MainActivity extends Activity {
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        try

        {

            PackageInfo info = getPackageManager().getPackageInfo(""Your package name here"",PackageManager.GET_SIGNATURE);

            for (Signature signature : info.signatures)
            {
                MessageDigest md = MessageDigest.getInstance(""SHA"");
                md.update(signature.toByteArray());
                Log.d(""KeyHash:"", Base64.encodeToString(md.digest(), Base64.DEFAULT));
            }
        } 
        catch (NameNotFoundException e)
        {
            System.out.println(""name not found....""+e);
        } catch (NoSuchAlgorithmException e) 
        {
            System.out.println(""NoSuchAlgorithmException....""+e);
        }
    }
}
",3,0,01261da95f257ab4f4170e4b0d54a331030831811c786a4313a3c3b75dda3f1b
,"import java.io.UnsupportedEncodingException;
import java.security.GeneralSecurityException;

import android.util.Base64

import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.DESKeySpec;

public class EncryptDecryptTest {

  public static void main(String[] args) throws Exception {
    String key = ""12345678"";
    String ciphertext = encrypt(key, ""foo"");

    String decrypted = decrypt(key, ciphertext.trim());
    String encrypted = encrypt(key, decrypted.trim());

    if (ciphertext.contentEquals(encrypted.trim())) {
      System.out.println(""decrypted!"");
    } else {
      System.out.println(""wrong key!"");
    }
  }

  public static String encrypt(String key, String data)
      throws GeneralSecurityException, UnsupportedEncodingException {
    DESKeySpec desKeySpec = new DESKeySpec(key.getBytes(""UTF8""));
    SecretKeyFactory secretKeyFactory = SecretKeyFactory.getInstance(""DES"");
    SecretKey secretKey = secretKeyFactory.generateSecret(desKeySpec);
    byte[] dataBytes = data.getBytes(""UTF8"");
    Cipher cipher = Cipher.getInstance(""DES"");
    cipher.init(Cipher.ENCRYPT_MODE, secretKey);
    return Base64.encodeToString(cipher.doFinal(dataBytes), Base64.DEFAULT);
  }

  public static String decrypt(String key, String data)
      throws GeneralSecurityException, UnsupportedEncodingException {
    byte[] dataBytes = Base64.decode(data, Base64.DEFAULT);
    DESKeySpec desKeySpec = new DESKeySpec(key.getBytes(""UTF8""));
    SecretKeyFactory secretKeyFactory = SecretKeyFactory.getInstance(""DES"");
    SecretKey secretKey = secretKeyFactory.generateSecret(desKeySpec);
    Cipher cipher = Cipher.getInstance(""DES"");
    cipher.init(Cipher.DECRYPT_MODE, secretKey);
    byte[] dataBytesDecrypted = (cipher.doFinal(dataBytes));
    return new String(dataBytesDecrypted);
  }    
}
",4,0,32edd6391ad8fd7ba03aecae571130105966c8183c84bb31de222d0b2b13dc01
,"    KeyPair keys = null;
    try {
        RSAKeyGenParameterSpec spec = new RSAKeyGenParameterSpec(1024, RSAKeyGenParameterSpec.F4);
        KeyPairGenerator keyGen = KeyPairGenerator.getInstance(""RSA"");
        keyGen.initialize(spec);
        keys = keyGen.generateKeyPair();
    } catch (InvalidAlgorithmParameterException e) {
        e.printStackTrace();
    } catch (NoSuchAlgorithmException e) {
        e.printStackTrace();
    }

    if(keys != null){
        PublicKey mPublicKey = (PublicKey) keys.getPublic();
        PrivateKey mPrivateKey = (PrivateKey) keys.getPrivate();
    }
",2,0,f854e0c8d0813164497063b564c2b1b31991cfc54fa920592b18a1161fade251
,"try {
            PackageInfo info = getPackageManager().getPackageInfo(""com.your_package_name"",
                    PackageManager.GET_SIGNATURES);
            for (Signature signature : info.signatures) {
                MessageDigest md = MessageDigest.getInstance(""SHA"");
                md.update(signature.toByteArray());
                Log.d(""YOURHASH KEY:"",
                        Base64.encodeToString(md.digest(), Base64.DEFAULT));
            }
        } catch (NameNotFoundException e) {

        } catch (NoSuchAlgorithmException e) {

        }
",3,0,11068b5d3528805c739dc7c9660acf9278a2bc7593ed5eaa1cdee3ea6c256b48
,"MessageDigest digest = MessageDigest.getInstance(""SHA-256"");
byte[] hash = digest.digest(text.getBytes(""UTF-8""));
",,1,07e84c4226639fe429fe36b0355922f06f06c1deb72e4502ffd0455494f96d53
,"        String aid = Settings.Secure.getString(context.getContentResolver(), ""android_id"");
        try {
            Object obj;
            ((MessageDigest) (obj = MessageDigest.getInstance(""MD5""))).update(aid.getBytes(), 0, aid.length());

            aid = String.format(""%032X"", new Object[] { new BigInteger(1, ((MessageDigest) obj).digest()) });
        } catch (NoSuchAlgorithmException localNoSuchAlgorithmException) {
            aid = aid.substring(0, 32);
        }

        adRequest.addTestDevice(aid);
",,1,2e6ecbb83d7eeae81d80c78020f870580389261c91a6ae7070c7540c7ccfe290
,"KeyStore keyStore = KeyStore.getInstance(""PKCS12"");
File p12File = GET_CERT();
FileInputStream fis = new FileInputStream(p12File);
BufferedInputStream bis = new BufferedInputStream(fis);
keyStore.load(bis, password.toCharArray()); // password is the PKCS#12 password. If there is no password, just pass null
Enumeration&lt;String&gt; aliases = keyStore.aliases();
while (aliases.hasMoreElements()) {
    String alias = aliases.nextElement();
    /* Do something with the keystore entry */
}
",,1,ed8e44e6ed7becf09e1b528fd0208ac84fed8b3f5078cabbddeec3ec163db82c
,"String alias = aliases.nextElement();
if (keyStore.isCertificateEntry(alias)) { // keep only trusted cert entries
    Certificate caCert = keyStore.getCertificate(alias)
    byte[] extraCertificate = caCert.getEncoded();
    Intent installIntent = KeyChain.createInstallIntent();
    installIntent.putExtra(KeyChain.EXTRA_CERTIFICATE, extraCertificate);
    installIntent.putExtra(KeyChain.EXTRA_NAME, MY_CERT);
    startActivityForResult(installIntent, INSTALL_KEYCHAIN_CODE);
}
",,1,745e397458650b89aecbd3ca5fef54a3f8012df68be669f5618a3448303d80e4
,"public class GMailSender extends javax.mail.Authenticator 
{   
    private String mailhost = ""smtp.gmail.com"";   
    private String user;   
    private String password;   
    private Session session;   
    private Multipart _multipart;

    static 
    {   
        Security.addProvider(new JSSEProvider());   
    }  

    public GMailSender(String user, String password) 
    {   
        this.user = user;   
        this.password = password;   

        Properties props = new Properties();   
        props.setProperty(""mail.transport.protocol"", ""smtp"");   
        props.setProperty(""mail.host"", mailhost);   
        props.put(""mail.smtp.auth"", ""true"");   
        props.put(""mail.smtp.port"", ""465"");   
        props.put(""mail.smtp.socketFactory.port"", ""465"");   
        props.put(""mail.smtp.socketFactory.class"",""javax.net.ssl.SSLSocketFactory"");   
        props.put(""mail.smtp.socketFactory.fallback"", ""false"");   
        props.setProperty(""mail.smtp.quitwait"", ""false"");   

        session = Session.getDefaultInstance(props, this);
        _multipart = new MimeMultipart();
    }   

    protected PasswordAuthentication getPasswordAuthentication() 
    {   
        return new PasswordAuthentication(user, password);   
    }   

    public synchronized void sendMail(String subject, String body, String sender, String recipients) throws Exception 
    {   
        MimeMessage message = new MimeMessage(session);   
        DataHandler handler = new DataHandler(new ByteArrayDataSource(body.getBytes(), ""text/plain""));   
        message.setSender(new InternetAddress(sender));   
        message.setSubject(subject);   

        message.setDataHandler(handler);   
        message.setContent(_multipart);
        if (recipients.indexOf(',') &gt; 0)   
            message.setRecipients(Message.RecipientType.TO, InternetAddress.parse(recipients));   
        else  
            message.setRecipient(Message.RecipientType.TO, new InternetAddress(recipients));   
        Transport.send(message);   

    }   

    public void addAttachment(String filename) throws Exception 
    {
        BodyPart messageBodyPart = new MimeBodyPart();
        DataSource source = new FileDataSource(filename);
        messageBodyPart.setDataHandler(new DataHandler(source));
        messageBodyPart.setFileName(filename);

        _multipart.addBodyPart(messageBodyPart);
    }

    public class ByteArrayDataSource implements DataSource 
    {   
        private byte[] data;   
        private String type;   

        public ByteArrayDataSource(byte[] data, String type) 
        {   
            super();   
            this.data = data;   
            this.type = type;   
        }   

        public ByteArrayDataSource(byte[] data) 
        {   
            super();   
            this.data = data;   
        }   

        public void setType(String type) 
        {   
            this.type = type;   
        }   

        public String getContentType() 
        {   
            if (type == null)   
                return ""application/octet-stream"";   
            else  
                return type;   
        }   

        public InputStream getInputStream() throws IOException 
        {   
            return new ByteArrayInputStream(data);   
        }   

        public String getName() 
        {   
            return ""ByteArrayDataSource"";   
        }   

        public OutputStream getOutputStream() throws IOException 
        {   
            throw new IOException(""Not Supported"");   
        }   
    }   
}
",3,0,b26c541cb396136a2f26a60cc073227e3c8f227b9c0eb27861ed1e4212e9155c
,"import sun.security.util.ObjectIdentifier;
import sun.security.x509.X509CertImpl;
import java.util.regex.Matcher;  
import java.util.regex.Pattern;

class readCert{

    public boolean isExtAuthorityInfoAccess(Extension ext){
        Pattern re = Pattern.compile(""\\bcaIssuers\\b"",Pattern.CASE_INSENSITIVE);
        Matcher m = re.matcher(ext.toString());
        if (m.find()) {
            return true;
        } else {
            return false;
        }
    };

    public static List&lt;String&gt; getAuthorityInfoAccesssUrls(String text)
    {
        List&lt;String&gt; containedUrls = new ArrayList&lt;String&gt;();
        Pattern pattern = Pattern.compile(
                ""(?:^|[\\W])((ht|f)tp(s?):\\/\\/|www\\.)""
                        + ""(([\\w\\-]+\\.){1,}?([\\w\\-.~]+\\/?)*""
                        + ""[\\p{Alnum}.,%_=?&amp;#\\-+()\\[\\]\\*$~@!:/{};']*)"",
                Pattern.CASE_INSENSITIVE | Pattern.MULTILINE | Pattern.DOTALL);
        Matcher urlMatcher = pattern.matcher(text);
        while (urlMatcher.find())
        {
            containedUrls.add(text.substring(urlMatcher.start(0),
                    urlMatcher.end(0)));
        }
        return containedUrls;
    };

    public static void main(String[] args) {

        readCert rc = new readCert();

        try {
            File file = new File(""yourcert.crt"");
            byte[] encCert = new byte[(int) file.length()];
            FileInputStream fis = new FileInputStream(file);
            fis.read(encCert);
            fis.close();

            InputStream in = new ByteArrayInputStream(encCert);
            CertificateFactory certFactory = CertificateFactory.getInstance(""X.509"");
            X509Certificate cert = (X509Certificate)certFactory.generateCertificate(in);

            X509CertImpl impl = (X509CertImpl)cert;
            int extnum = 0;
            if (cert.getNonCriticalExtensionOIDs() != null) {
                for (String extOID : cert.getNonCriticalExtensionOIDs()) {
                    Extension ext = impl.getExtension(new ObjectIdentifier(extOID));
                    if (ext != null) {
                        if (rc.isExtAuthorityInfoAccess(ext)) {
                            System.out.println(rc.getAuthorityInfoAccesssUrls(ext.toString()));
                            // System.out.println(""#""+(++extnum)+"": ""+ ext.toString());
                            // CA ISSUERS ARE HERE
                        }
                    }
                }
            }
        } catch (  Exception e) {
            e.printStackTrace();
          };
    }
}
",,1,cf96c5ace577034655de35659dfd2058cde68e3e0c4e876240aeb25cd0ebefd2
,"PackageManager pm = context.getPackageManager();
Signature sig = packageManager.getPackageInfo(getPackageName(), 
   PackageManager.GET_SIGNATURES).signatures[0];
CertificateFactory cf = CertificateFactory.getInstance(""X.509"");
X509Certificate cert = (X509Certificate) cf.generateCertificate(
    new ByteArrayInputStream(sig.toByteArray()));
String dn = cert.getIssuerDN().getName();
",,1,020d5e1f169e1ccedfa21970042b11fb1137e3f1e852d0b6080b13efb0480dac
,"SSLcontext sslContext = SSLContext.getDefault();

KeyStore trustSt = KeyStore.getInstance(""BKS"");
TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());
InputStream trustStoreStream = this.getResources().openRawResource(R.raw.truststore);
trustSt.load(trustStoreStream, ""&lt;yourpassword&gt;"".toCharArray());
trustManagerFactory.init(trustStre);

KeyStore keyStore = KeyStore.getInstance(""BKS"");
KeyManagerFactory keyManagerFactory = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());
InputStream keyStoreStream = this.getResources().openRawResource(R.raw.keystore);
keyStore.load(keyStoreStream, ""&lt;yourpassword&gt;"".toCharArray());
keyManagerFactory.init(keyStore, ""&lt;yourpassword&gt;"".toCharArray());

sslContext.init(keyManagerFactory.getKeyManagers(), trustManagerFactory.getTrustManagers(), null);
",,1,7b95336fedbb670cb6ae7530a245b5822d1aac79db3627c6eba6be927c074e3e
,"public class SEncryption {

private static final String ALGO = ""AES"";
private static final byte[] keyValue = new byte[] { 'O', 'u', 'r', 'B',
'e', 's', 't','S', 'e', 'c', 'r', 'e', 't', 'K', 'e', 'y' };

public static String encrypt(String Data) throws Exception {
Key key = generateKey();
Cipher c = Cipher.getInstance(ALGO);
c.init(Cipher.ENCRYPT_MODE, key);
byte[] encVal = c.doFinal(Data.getBytes());
Base64 ob=new Base64();
String encryptedValue = Base64.encodeBytes(encVal);
return encryptedValue;
}

public static String decrypt(String encryptedData) throws Exception {
Key key = generateKey();
Cipher c = Cipher.getInstance(ALGO);
c.init(Cipher.DECRYPT_MODE, key);
byte[] decordedValue = Base64.decode(encryptedData);
byte[] decValue = c.doFinal(decordedValue);
String decryptedValue = new String(decValue);
return decryptedValue;
}

private static Key generateKey() throws Exception {
Key key = new SecretKeySpec(keyValue, ALGO);
return key;
}
public static void main(String[] args) throws Exception {

        String password = ""346333"";
        String passwordEnc = encrypt(password);
        String passwordDec = decrypt(passwordEnc);

        System.out.println(""Plain Text : "" + password);
        System.out.println(""Encrypted Text : "" + passwordEnc);
        System.out.println(""Decrypted Text : "" + passwordDec);
    }

}
",4,0,6f044326fef4f0345cdd1a6a630070b5bb40ee95ee10555bc9a005425daf3bed
,"import java.security.Key;
import javax.crypto.Cipher;
import javax.crypto.spec.SecretKeySpec;

public class AES {
     public void run() {
         try {
             String text = ""Hello World"";
             String key = ""1234567891234567"";
             // Create key and cipher
             Key aesKey = new SecretKeySpec(key.getBytes(), ""AES"");
             Cipher cipher = Cipher.getInstance(""AES"");

         // encrypt the text
         cipher.init(Cipher.ENCRYPT_MODE, aesKey);
         byte[] encrypted = cipher.doFinal(text.getBytes());
         System.out.println(""Encrypted text: "" + new String(encrypted));

         // decrypt the text
         cipher.init(Cipher.DECRYPT_MODE, aesKey);
         String decrypted = new String(cipher.doFinal(encrypted));
         System.out.println(""Decrypted text: "" + decrypted);
      }catch(Exception e) {
         e.printStackTrace();
      }
    }

    public static void main(String[] args) {
        AES app = new AES();
       app.run();
    }
}
",,1,441e8cc229527bcc25f1a173cd9f13f1ef3a5b4c1a2f0c037738ca048a30fc6d
,"KeyStore store = KeyStore.getInstance(""BKS"");
InputStream truststore = mainActivity.getResources().openRawResource(R.raw.trust);
store.load(truststore, ""PASSWORD"".toCharArray());
TrustManagerFactory tmf = TrustManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());
tmf.init(store);
SSLContext context = SSLContext.getInstance(""TLS"");
context.init(null, tmf.getTrustManagers(), new SecureRandom());
Socket socket = context.getSocketFactory().createSocket(ip, port);
",3,0,a9769ebbe1b98215a09cdfa7df361e43e45e055b96932f278d6bd5cb39193ec4
,"Try this code, it works fine for me:

//Creating xml file

DocumentBuilderFactory dbfac = DocumentBuilderFactory.newInstance();
             dbfac.setNamespaceAware(true);
             DocumentBuilder docBuilder = null;
             try {
                docBuilder = dbfac.newDocumentBuilder();
            } catch (ParserConfigurationException e) {
                // TODO Auto-generated catch block
                e.printStackTrace();
            }
             DOMImplementation domImpl = docBuilder.getDOMImplementation();
             Document document = domImpl.createDocument(""http://coggl.com/InsertTrack"",""TrackEntry"", null);
             document.setXmlVersion(""1.0"");
             document.setXmlStandalone(true);

             Element trackElement = document.getDocumentElement();

             Element CompanyId = document.createElement(""CompanyId"");
             CompanyId.appendChild(document.createTextNode(""1""));
             trackElement.appendChild(CompanyId);

             Element CreatedBy = document.createElement(""CreatedBy"");
             CreatedBy.appendChild(document.createTextNode(""6""));
             trackElement.appendChild(CreatedBy);

             Element DepartmentId = document.createElement(""DepartmentId"");
             DepartmentId.appendChild(document.createTextNode(""4""));
             trackElement.appendChild(DepartmentId);

             Element IsBillable = document.createElement(""IsBillable"");
             IsBillable.appendChild(document.createTextNode(""1""));
             trackElement.appendChild(IsBillable);

             Element ProjectId = document.createElement(""ProjectId"");
             ProjectId.appendChild(document.createTextNode(""1""));
             trackElement.appendChild(ProjectId);

             Element StartTime = document.createElement(""StartTime"");
             StartTime.appendChild(document.createTextNode(""2012-03-14 10:44:45""));
             trackElement.appendChild(StartTime);

             Element StopTime = document.createElement(""StopTime"");
             StopTime.appendChild(document.createTextNode(""2012-03-14 11:44:45""));
             trackElement.appendChild(StopTime);

             Element TaskId = document.createElement(""TaskId"");
             TaskId.appendChild(document.createTextNode(""3""));
             trackElement.appendChild(TaskId);

             Element TotalTime = document.createElement(""TotalTime"");
             TotalTime.appendChild(document.createTextNode(""1""));
             trackElement.appendChild(TotalTime);

             Element TrackDesc = document.createElement(""TrackDesc"");
             TrackDesc.appendChild(document.createTextNode(""testing""));
             trackElement.appendChild(TrackDesc);

             Element TrackId = document.createElement(""TrackId"");
             TrackId.appendChild(document.createTextNode(""0""));
             trackElement.appendChild(TrackId);

             TransformerFactory transfac = TransformerFactory.newInstance();
             Transformer trans = null;
            try {
                trans = transfac.newTransformer();
            } catch (TransformerConfigurationException e) {
                // TODO Auto-generated catch block
                e.printStackTrace();
            }
             trans.setOutputProperty(OutputKeys.OMIT_XML_DECLARATION, ""yes"");
             trans.setOutputProperty(OutputKeys.INDENT, ""yes"");

             //create string from xml tree
             StringWriter sw = new StringWriter();
             StreamResult result = new StreamResult(sw);
             DOMSource source = new DOMSource(doc);
             try {
                trans.transform(source, result);
            } catch (TransformerException e) {
                // TODO Auto-generated catch block
                e.printStackTrace();
            }
             String xmlString = sw.toString();

//posting xml file to server

             DefaultHttpClient httpClient = new DefaultHttpClient();

             HttpPost httppost = new HttpPost(""http://192.168.0.19:3334/cogglrestservice.svc/InsertTrack"");     
             // Make sure the server knows what kind of a response we will accept
             httppost.addHeader(""Accept"", ""text/xml"");
             // Also be sure to tell the server what kind of content we are sending
             httppost.addHeader(""Content-Type"", ""application/xml"");

             try
             {
             StringEntity entity = new StringEntity(xmlString, ""UTF-8"");
             entity.setContentType(""application/xml"");
             httppost.setEntity(entity);

             // execute is a blocking call, it's best to call this code in a thread separate from the ui's
             HttpResponse response = httpClient.execute(httppost);

             BasicResponseHandler responseHandler = new BasicResponseHandler();
                String strResponse = null;
                if (response != null) {
                    try {
                        strResponse = responseHandler.handleResponse(response);
                    } catch (HttpResponseException e) {
                        e.printStackTrace();  
                    } catch (IOException e) {
                        e.printStackTrace();
                    }
                }
                Log.e(""WCFTEST"", ""WCFTEST ********** Response"" + strResponse);    


             }
             catch (Exception ex)
             {
             ex.printStackTrace();
             }
             Toast.makeText(EditTask.this, ""Xml posted succesfully."",Toast.LENGTH_SHORT).show();
",,1,2265349643fd6234eec5dcb73d532ba96dfbf4e1cc10f83e4aefa8fec9b4bfcc
,"    &gt;     Try using TrustManagerManipulator Class:




              try {
                                TrustManagerManipulator.allowAllSSL();
                                try {
                                    SoapObject request = new SoapObject(Data.NAMESPACE,
                                            methodName);

                                    SoapSerializationEnvelope envelope = new SoapSerializationEnvelope(
                                            SoapEnvelope.VER11);

                                    if (methodName.equals(Data.DOPAYMENT))

                                    {
                                        request.addProperty(""firstname"", param1);
                                        request.addProperty(""lastName"", param2);

                envelope.dotNet = true;
                                envelope.setOutputSoapObject(request);
                                envelope.env = ""http://schemas.xmlsoap.org/soap/envelope/"";
                                TrustManagerManipulator.allowAllSSL();
                                System.setProperty(""http.keepAlive"", ""false"");

                                HttpTransportSE androidHttpTransport = new HttpTransportSE(
                                        Data.URL_BASE);
                                androidHttpTransport
                                        .setXmlVersionTag(""&lt;?xml version=\""1.0\"" encoding=\""utf-8\""?&gt;"");

                                try {
                                    androidHttpTransport.call(Data.SOAP_ACTION,
                                            envelope);
                                } catch (Exception e) {
                                    e.printStackTrace();
                                    Toast.makeText(context, ""Network failed!"",
                                            Toast.LENGTH_LONG).show();
                                    dismissDialog();
                                }
                                SoapObject resultsRequestSOAP = (SoapObject) envelope.bodyIn;
                                String responseLocal = resultsRequestSOAP.toString();
                                responseXML = (String) resultsRequestSOAP
                                        .getProperty(0);
                                Log.v(""responseXML0::"", """" + responseXML);

                                Log.v(""responseSTR"", """" + responseLocal);




///////////////////////////////////

&gt; TrustManagerManipulator Class


import java.security.KeyManagementException;
import java.security.NoSuchAlgorithmException;
import java.security.SecureRandom;
import java.security.cert.CertificateException;
import java.security.cert.X509Certificate;
import javax.net.ssl.HostnameVerifier;
import javax.net.ssl.HttpsURLConnection;
import javax.net.ssl.SSLContext;
import javax.net.ssl.SSLSession;
import javax.net.ssl.TrustManager;
import javax.net.ssl.X509TrustManager;

public class TrustManagerManipulator implements X509TrustManager {


    private static TrustManager[] trustManagers;
    private static final X509Certificate[] acceptedIssuers = new X509Certificate[] {};

    public boolean isClientTrusted(X509Certificate[] chain) {
        return true;
    }

    public boolean isServerTrusted(X509Certificate[] chain) {
        return true;
    }

    public static void allowAllSSL() 
    {

        HttpsURLConnection.setDefaultHostnameVerifier(new HostnameVerifier() {
            public boolean verify(String hostname, SSLSession session) {
                return true;
            }
        });
        SSLContext context = null;
        if (trustManagers == null) {
            trustManagers = new TrustManager[] { new TrustManagerManipulator() };
        }
        try {
            context = SSLContext.getInstance(""TLS"");
            context.init(null, trustManagers, new SecureRandom());
        } catch (NoSuchAlgorithmException e) {
            e.printStackTrace();
        } catch (KeyManagementException e) {
            e.printStackTrace();
        }
        HttpsURLConnection.setDefaultSSLSocketFactory(context
                .getSocketFactory());
    }

    public void checkClientTrusted(X509Certificate[] chain, String authType)
            throws CertificateException {
    }

    public void checkServerTrusted(X509Certificate[] chain, String authType)
            throws CertificateException {
    }

    public X509Certificate[] getAcceptedIssuers() {
        return acceptedIssuers;
    }
}
",4,0,af5630ad87bb7a5145cedce519c226c1c39023c5b81f80ebe0a0aed71b2d5cb6
,"    public  void showHashKey(Context context) {
        try {
            PackageInfo info = context.getPackageManager().getPackageInfo(""com.superreceptionist"",
                    PackageManager.GET_SIGNATURES);
            for (android.content.pm.Signature signature : info.signatures) {
                MessageDigest md = MessageDigest.getInstance(""SHA"");
                md.update(signature.toByteArray());

                 String sign=Base64.encodeToString(md.digest(), Base64.DEFAULT);
                Log.e(""KeyHash:"", sign);
                //  Toast.makeText(getApplicationContext(),sign,     Toast.LENGTH_LONG).show();
            }
            Log.d(""KeyHash:"", ""****------------***"");
        } catch (PackageManager.NameNotFoundException e) {
e.printStackTrace();
        } catch (NoSuchAlgorithmException e) {
e.printStackTrace();
        }
    }
",3,0,bf6dedb02733e4ccc9f548f6e8eada887c298d082516c4f77c5b703431af0746
,"// Create a trust manager that does not validate certificate chains
TrustManager[] trustAllCerts = new TrustManager[]{
    new X509TrustManager() {
        public java.security.cert.X509Certificate[] getAcceptedIssuers() {
            return null;
        }
        public void checkClientTrusted(
            java.security.cert.X509Certificate[] certs, String authType) {
        }
        public void checkServerTrusted(
            java.security.cert.X509Certificate[] certs, String authType) {
        }
    }
};

// Install the all-trusting trust manager
try {
    SSLContext sc = SSLContext.getInstance(""SSL"");
    sc.init(null, trustAllCerts, new java.security.SecureRandom());
    HttpsURLConnection.setDefaultSSLSocketFactory(sc.getSocketFactory());
} catch (Exception e) {
}

// Now you can access an https URL without having the certificate in the truststore
// It should work with expired certificate as well
try {
    URL myUrl = new URL(""https://www....."");
} catch (MalformedURLException e) {
}
",4,0,ade380a9dd7895a2eaaab632ae9fbb8230c32926621582b17e0d7938460f8557
,"TrustManagerFactory tmf = TrustManagerFactory.getInstance(
    TrustManagerFactory.getDefaultAlgorithm());
// Initialise the TMF as you normally would, for example:
tmf.init((KeyStore)null); 

TrustManager[] trustManagers = tmf.getTrustManagers();
final X509TrustManager origTrustmanager = (X509TrustManager)trustManagers[0];

TrustManager[] wrappedTrustManagers = new TrustManager[]{
   new X509TrustManager() {
       public java.security.cert.X509Certificate[] getAcceptedIssuers() {
          return origTrustmanager.getAcceptedIssuers();
       }

       public void checkClientTrusted(X509Certificate[] certs, String authType) {
           origTrustmanager.checkClientTrusted(certs, authType);
       }

       public void checkServerTrusted(X509Certificate[] certs, String authType) {
           try {
               origTrustmanager.checkServerTrusted(certs, authType);
           } catch (CertificateExpiredException e) {}
       }
   }
};

SSLContext sc = SSLContext.getInstance(""TLS"");
sc.init(null, wrappedTrustManagers, null);
HttpsURLConnection.setDefaultSSLSocketFactory(sc.getSocketFactory());
",4,0,8ecbfd3d9b456fc2a716802dc687b3e72a1e3cb6bf9e692f03b3d412c88dd506
,"private void getHashKey(String pkgName)
{
    try
    {
        PackageInfo info = getPackageManager().getPackageInfo(pkgName, PackageManager.GET_SIGNATURES);
        for (Signature signature : info.signatures)
        {
            MessageDigest md = MessageDigest.getInstance(""SHA"");
            md.update(signature.toByteArray());
            String hashKey = Base64.encodeBytes(md.digest());
            _hashKey_et.setText(hashKey);
            Log.i(""KeyTool"", pkgName + "" -&gt; hashKey = "" + hashKey);
        }
    }
    catch (NameNotFoundException e)
    {
        e.printStackTrace();
    }
    catch (NoSuchAlgorithmException e)
    {
        e.printStackTrace();
    }
}
",3,0,bebfa1706ba2aa21919d0ffa9bb043725467ea0fba2612112e7e42e88e0c7950
,"...

    SSLContext sslContext = SSLContext.getInstance(""TLS"");
    sslContext.init(kmf.getKeyManagers(),tmf.getTrustManagers(), new SecureRandom());
    SSLEngine sslEngine = sslContext.createSSLEngine();
    sslEngine.setUseClientMode(true);
    SslHandler sslHandler = new SslHandler(sslEngine);
    channel.pipeline().addFirst(sslHandler)

...
",3,0,686078494cbf074aa7c0664a5e61ff52f2f12710101f10a1e9a8c368edc1b7c2
,"/**
 * 
 * @param PEMString  -A file/string in .pem format with a generated RSA key (with ""des3"", using ""openssl genrsa"".)
 * @param isFilePath - If it's a file path or a string
 * @return java.security.PublicKey
 * @throws IOException -No key found
 * @throws NoSuchAlgorithmException 
 * @throws InvalidKeySpecException 
 * 
 * @author hsigmond
 */

private static PublicKey getPublicKeyFromPemFormat(String PEMString,
        boolean isFilePath) throws IOException, NoSuchAlgorithmException,
        InvalidKeySpecException {

    BufferedReader pemReader = null;
    if (isFilePath) {
        pemReader = new BufferedReader(new InputStreamReader(
                new FileInputStream(PEMString)));
    } else {
        pemReader = new BufferedReader(new InputStreamReader(
                new ByteArrayInputStream(PEMString.getBytes(""UTF-8""))));
    }
    StringBuffer content = new StringBuffer();
    String line = null;
    while ((line = pemReader.readLine()) != null) {
        if (line.indexOf(""-----BEGIN PUBLIC KEY-----"") != -1) {
            while ((line = pemReader.readLine()) != null) {
                if (line.indexOf(""-----END PUBLIC KEY"") != -1) {
                    break;
                }
                content.append(line.trim());
            }
            break;
        }
    }
    if (line == null) {
        throw new IOException(""PUBLIC KEY"" + "" not found"");
    }
Log.i(""PUBLIC KEY: "", ""PEM content = : "" + content.toString());

    KeyFactory keyFactory = KeyFactory.getInstance(""RSA"");
    return keyFactory.generatePublic(new X509EncodedKeySpec(Base64.decode(content.toString(), Base64.DEFAULT)));

}
",,1,e3d4778158d1fe09eb1924da06ba97d90c402d0ab5c5d392be7686a47f01f0cd
,"/**
 * 
 * @param PEMString  -A file/string in .pem format with a generated RSA key (with ""des3"", using ""openssl genrsa"".)
 * @param content
 * @return String value of content Decoded
 * @throws NoSuchAlgorithmException
 * @throws InvalidKeySpecException
 * @throws IOException
 * @throws NoSuchProviderException
 * @throws NoSuchPaddingException
 * @throws InvalidKeyException
 * @throws IllegalBlockSizeException
 * @throws BadPaddingException
 * 
 * @author hsigmond
 */


    public static String getContentWithPublicKeyFromPemFormat(String PEMString,
        String content,boolean isFilePath) throws NoSuchAlgorithmException,
        InvalidKeySpecException, IOException, NoSuchProviderException,
        NoSuchPaddingException, InvalidKeyException,
        IllegalBlockSizeException, BadPaddingException {

    PublicKey publicKey = getPublicKeyFromPemFormat(PEMString,isFilePath);
    if (publicKey != null)
        Log.i(""PUBLIC KEY: "", ""FORMAT : "" + publicKey.getFormat()
                + "" \ntoString : "" + publicKey.toString());

    byte[] contentBytes = Base64.decode(content, Base64.DEFAULT);
    byte[] decoded = null;

    Cipher cipher = Cipher.getInstance(""RSA/ECB/PKCS1Padding"", ""BC"");//BC=BouncyCastle Provider
    cipher.init(Cipher.DECRYPT_MODE, publicKey);
    decoded = cipher.doFinal(contentBytes);
    return new String(decoded, ""UTF-8"");
}
",3,0,cc322f73125a4f12b4861cf92470abef9ca48c12f58508f4bb40111ef1825c53
,"(...)
public static class GetJsonTask extends AsyncTask&lt;Void, Integer, AsyncResponse&gt; {

    protected String jsonData;

    protected IGetJsonListener listener;
    protected Context context = null;
    protected String strUrl;

    public GetJsonTask(Context c, IGetJsonListener l, String strUrl) {
        super();
        listener = l;
        context = c;
        this.strUrl = strUrl;
    }

    @Override
    protected AsyncResponse doInBackground(Void... Void) {

        JsonObject jsonObjectResult = new JsonObject();
        APIStatus status;

        if (isConnected(context)) {
            HttpsURLConnection httpsURLConnection=null;
            try {
                //THIS IS KEY: context contains only our CA cert
                SSLContext sslContext = getSSLContext(context);
                if (sslContext != null) {
                    //for HTTP BASIC AUTH if your server implements this
                    //String encoded = Base64.encodeToString(
                    //        (""your_user_name"" + "":"" + ""your_pwd"").getBytes(),
                    //        Base64.DEFAULT);
                    URL url = new URL(strUrl);
                    httpsURLConnection = (HttpsURLConnection) url.openConnection();
                    httpsURLConnection.setRequestMethod(""GET"");
                    httpsURLConnection.setRequestProperty(""Content-length"", ""0"");
                    httpsURLConnection.setUseCaches(false);
                    httpsURLConnection.setAllowUserInteraction(false);
                    //FOR HTTP BASIC AUTH
                    //httpsURLConnection.setRequestProperty(""Authorization"", ""Basic "" + encoded);
                    //THIS IS KEY: Set connection to use custom socket factory
                    httpsURLConnection.setSSLSocketFactory(sslContext.getSocketFactory());
                    //httpsURLConnection.setConnectTimeout(timeout);
                    //httpsURLConnection.setReadTimeout(timeout);
                    httpsURLConnection.connect();
                    status = getStatusFromCode(httpsURLConnection.getResponseCode());


                    listener.getJsonShowProgress(90);

                    if (status == APIStatus.OK) {

                        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(httpsURLConnection.getInputStream()));
                        StringBuilder stringBuilder = new StringBuilder();

                        String line;
                        while ((line = bufferedReader.readLine()) != null) {
                            stringBuilder.append(line);
                        }
                        bufferedReader.close();
                        JsonParser parser = new JsonParser();
                        String s = stringBuilder.toString();
                        jsonObjectResult = (JsonObject) parser.parse(s);
                    }
                } else
                    status = APIStatus.AUTH_ERROR;
                listener.getJsonShowProgress(99);
            //THIS IS KEY: this exception is thrown if the certificate
            //is signed by a CA that is not our CA
            } catch (SSLHandshakeException e) {
                status = APIStatus.AUTH_ERROR;
                //React to what is probably a man-in-the-middle attack
            } catch (IOException e) {
                status = APIStatus.NET_ERROR;
            } catch (JsonParseException e) {
                status = APIStatus.JSON_ERROR;
            } catch (Exception e) {
                status = APIStatus.UNKNOWN_ERROR;
            } finally {
                if (httpsURLConnection != null)
                    httpsURLConnection.disconnect();
            }
        } else {
            status = APIStatus.NET_ERROR;
        }
        // if not successful issue another call for the next hour.
        AsyncResponse response = new AsyncResponse();
        response.jsonData = jsonObjectResult;
        response.opStatus = status;

        return response;
    }

    @Override
    protected void onPreExecute() {
        super.onPreExecute();
        if (listener != null)
            listener.getJsonStartProgress();
    }

    @Override
    protected void onProgressUpdate(Integer... progress) {
        listener.getJsonShowProgress(progress[0]);
    }

    @Override
    protected void onPostExecute(AsyncResponse result) {
        listener.getJsonFinished(result.jsonData, result.opStatus);
    }

    public  interface IGetJsonListener {
        void getJsonStartProgress();
        void getJsonShowProgress(int percent);
        void getJsonFinished(JsonObject resJson, APIStatus status);
    }
}
private static SSLContext getSSLContext(Context context){
    //Mostly taken from the Google code link in the question.
    try {
        CertificateFactory cf = CertificateFactory.getInstance(""X.509"");

        AssetManager am = context.getAssets();
        //THIS IS KEY: Your CA's cert stored in /assets/
        InputStream caInput = new BufferedInputStream(am.open(""RootCA.crt""));
        Certificate ca;
        try {
            ca = cf.generateCertificate(caInput);
            //System.out.println(""ca="" + ((X509Certificate) ca).getSubjectDN());
        } finally {
            caInput.close();
        }

        // Create a KeyStore containing our trusted CAs
        String keyStoreType = KeyStore.getDefaultType();
        KeyStore keyStore = KeyStore.getInstance(keyStoreType);
        keyStore.load(null, null);
        keyStore.setCertificateEntry(""ca"", ca);

        // Create a TrustManager that trusts the CAs in our KeyStore
        String tmfAlgorithm = TrustManagerFactory.getDefaultAlgorithm();
        TrustManagerFactory tmf = TrustManagerFactory.getInstance(tmfAlgorithm);
        tmf.init(keyStore);

        // Create an SSLContext that uses our TrustManager
        SSLContext sslContext = SSLContext.getInstance(""TLS"");
        sslContext.init(null, tmf.getTrustManagers(), null);
        return sslContext;
    } catch (Exception e){
        return null;
    }

}

public enum APIStatus {
    OK(""OK."", 200), //all went well
    JSON_ERROR(""Error parsing response."", 1),
    NET_ERROR(""Network error."", 2), //we couldn't reach the server
    UNKNOWN_ERROR(""Unknown error."", 3), //some sh*t went down

    AUTH_ERROR(""Authentication error."", 401), //credentials where wrong
    SERVER_ERROR(""Internal server error."", 500), //server code crashed
    TIMEOUT(""Operation timed out."", 408); //network too slow or server overloaded

    private String stringValue;
    private int intValue;

    private APIStatus(String toString, int value) {
        stringValue = toString;
        intValue = value;
    }

    @Override
    public String toString() {
        return stringValue;
    }
}

private static APIStatus getStatusFromCode(int code) {

    if (code==200 || code==201) {
        return APIStatus.OK;
    }else if (code == 401) {
        return APIStatus.AUTH_ERROR;
    } else if (code == 500) {
        return APIStatus.SERVER_ERROR;
    } else if (code == 408) {
        return APIStatus.TIMEOUT;
    } else {
        return APIStatus.UNKNOWN_ERROR;
    }

}

private static class AsyncResponse {
    public APIStatus opStatus;
    public JsonObject jsonData;
}
(...)
",3,0,bd3ca0cbd83b1d77fce3344a7d96f5092e018a93ac4369bf9fd25ad750040dc5
,"KeyStore localTrustStore = KeyStore.getInstance(""BKS"");
InputStream in = getResources().openRawResource(R.raw.mytruststore);
localTrustStore.load(in, TRUSTSTORE_PASSWORD.toCharArray());

SchemeRegistry schemeRegistry = new SchemeRegistry();
schemeRegistry.register(new Scheme(""http"", PlainSocketFactory
                .getSocketFactory(), 80));
SSLSocketFactory sslSocketFactory = new SSLSocketFactory(localTrustStore);
schemeRegistry.register(new Scheme(""https"", sslSocketFactory, 443));
HttpParams params = new BasicHttpParams();
ClientConnectionManager cm = 
    new ThreadSafeClientConnManager(params, schemeRegistry);

HttpClient client = new DefaultHttpClient(cm, params); 
",3,0,555b541a7abf4c2a223f4724f704e6777cc9e33a9c6cf9b7bd9e0078e6d5ebe9
,"static String encodeString(String input) {
    MessageDigest digest = null;
    try {
        digest = MessageDigest.getInstance(""SHA-1"");
        byte[] inputBytes = input.getBytes();
        byte[] hashBytes = digest.digest(inputBytes);
        return Base64.encodeToString(hashBytes, Base64.NO_WRAP);
    } catch (NoSuchAlgorithmException e) {
        Log.e(TAG_TEST, e.getMessage(), e);
    }
    return """";
}
",3,0,ad53968e2bef7c383734e37f65b41617d7b8bf57a37d24e00cbfe10b45aa8ac1
,"// der formated certificate as byte[]
private static final byte[] CACERTROOTDER = new byte[]{
        48, -126, 7, 61, 48, -126, 5, 37, -96, 3, 2, 1, 2, 2, 1, 0,
        // ...
        };

/**
 * Read x509 certificated file from byte[].
 *
 * @param bytes certificate in der format
 * @return certificate
 */
private static X509Certificate getCertificate(final byte[] bytes)
        throws IOException, CertificateException {
    CertificateFactory cf = CertificateFactory.getInstance(""X.509"");
    X509Certificate ca;
    ByteArrayInputStream is = new ByteArrayInputStream(bytes);
    try {
        ca = (X509Certificate) cf.generateCertificate(is);
        Log.d(TAG, ""ca="", ca.getSubjectDN());
    } finally {
        is.close();
    }
    return ca;
}

/**
 * Trust only CAcert's CA. CA cert is injected as byte[]. Following best practices from
 * https://developer.android.com/training/articles/security-ssl.html#UnknownCa
 */
private static void trustCAcert()
        throws KeyStoreException, IOException,
        CertificateException, NoSuchAlgorithmException,
        KeyManagementException {
    // Create a KeyStore containing our trusted CAs
    String keyStoreType = KeyStore.getDefaultType();
    final KeyStore keyStore = KeyStore.getInstance(keyStoreType);
    keyStore.load(null, null);
    keyStore.setCertificateEntry(""CAcert-root"", getCertificate(CACERTROOTDER));
    // if your HTTPd is not sending the full chain, add class3 cert to the key store
    // keyStore.setCertificateEntry(""CAcert-class3"", getCertificate(CACERTCLASS3DER));

    // Create a TrustManager that trusts the CAs in our KeyStore
    final TrustManagerFactory tmf = TrustManagerFactory.getInstance(
            TrustManagerFactory.getDefaultAlgorithm());
    tmf.init(keyStore);

    // Create an SSLContext that uses our TrustManager
    SSLContext sslContext = SSLContext.getInstance(""TLS"");

    if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.ICE_CREAM_SANDWICH) {
        // may work on HC+, but there is no AVD or device to test it
        sslContext.init(null, tmf.getTrustManagers(), null);
    } else {
        // looks like CLR is broken in lower APIs. implement out own checks here :x
        // see http://stackoverflow.com/q/18713966/2331953
        HttpsURLConnection.setDefaultHostnameVerifier(new HostnameVerifier() {
            public boolean verify(final String hostname, final SSLSession session) {
                try {
                    // check if hostname matches DN
                    String dn = session.getPeerCertificateChain()[0].getSubjectDN().toString();

                    Log.d(TAG, ""DN="", dn);
                    if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.GINGERBREAD) {
                        return dn.equals(""CN="" + hostname);
                    } else {
                        // no SNI on API&lt;9, but I know the first vhost's hostname
                        return dn.equals(""CN="" + hostname)
                                || dn.equals(""CN="" + hostname.replace(""jsonrpc"", ""rest""));
                    }
                } catch (Exception e) {
                    Log.e(TAG, ""unexpected exception"", e);
                    return false;
                }
            }
        });

        // build our own trust manager
        X509TrustManager tm = new X509TrustManager() {
            public X509Certificate[] getAcceptedIssuers() {
                // nothing to do
                return new X509Certificate[0];
            }

            @Override
            public void checkClientTrusted(final X509Certificate[] chain,
                    final String authType)
                    throws CertificateException {
                // nothing to do
            }

            @Override
            public void checkServerTrusted(final X509Certificate[] chain,
                    final String authType) throws CertificateException {
                // nothing to do
                Log.d(TAG, ""checkServerTrusted("", chain, "")"");
                X509Certificate cert = chain[0];

                cert.checkValidity();

                CertificateFactory cf = CertificateFactory.getInstance(""X.509"");
                ArrayList&lt;X509Certificate&gt; list = new ArrayList&lt;X509Certificate&gt;();
                list.add(cert);
                CertPath cp = cf.generateCertPath(list);
                try {
                    PKIXParameters params = new PKIXParameters(keyStore);
                    params.setRevocationEnabled(false); // CLR is broken, remember?
                    CertPathValidator cpv = CertPathValidator
                            .getInstance(CertPathValidator.getDefaultType());
                    cpv.validate(cp, params);
                } catch (KeyStoreException e) {
                    Log.d(TAG, ""invalid key store"", e);
                    throw new CertificateException(e);
                } catch (InvalidAlgorithmParameterException e) {
                    Log.d(TAG, ""invalid algorithm"", e);
                    throw new CertificateException(e);
                } catch (NoSuchAlgorithmException e) {
                    Log.d(TAG, ""no such algorithm"", e);
                    throw new CertificateException(e);
                } catch (CertPathValidatorException e) {
                    Log.d(TAG, ""verification failed"");
                    throw new CertificateException(e);
                }
                Log.d(TAG, ""verification successful"");
            }
        };
        sslContext.init(null, new X509TrustManager[]{tm}, null);
    }

    HttpsURLConnection.setDefaultSSLSocketFactory(sslContext.getSocketFactory());
}
",4,0,eaa529f6ec38ddd68ab49187c081e39584da3d47da1f7c592ba417396e656f4e
,"        public class TCPSockets extends CordovaPlugin { 
        @Override
        public boolean execute(String action, JSONArray args, final CallbackContext callbackContext) {      
    //      PluginResult result = new PluginResult(PluginResult.Status.NO_RESULT);
            final String callbackId = callbackContext.getCallbackId();      

    //      Log.d(""TCPSockets"", ""Plugin Called"");
            try {
                if (action.equals(""sendMessage"")) {

                    if (args != null) 
                    {
                        final int port  = args.getInt(0);
                        final String host = args.getString(1);
                        final String message = args.getString(2);
                        final int connectionTimeout = args.getInt(3);
                        final boolean secureConnection = args.getBoolean(4);

                        cordova.getThreadPool().execute(new Runnable() {
                            public void run() {
                                callbackContext.sendPluginResult(sendMessage(port, host, message, connectionTimeout, secureConnection));                            
                            }
                        });                                                                     
                    } else {
    //                    return new PluginResult(PluginResult.Status.ERROR, ""User did not specify host information"");
                        callbackContext.error(""User did not specify host information"");
                        return true;
                    }
                } else {
    //                return new PluginResult(PluginResult.Status.INVALID_ACTION);
                    callbackContext.error(""Invalid Action"");
                    return true;
                }
            } 

            catch (JSONException e) {
                Log.d(""TCPSockets"", ""JSONException: "" + e.getMessage());
    //          return new PluginResult(PluginResult.Status.JSON_EXCEPTION);
                callbackContext.error(""JSON Exception"");
                return true;
            }

    //        return r;
    //      callbackContext.sendPluginResult(r);
            return true;
        }

        public PluginResult sendMessage(int port, String host, String message, int connectionTimeout, boolean secureConnection)
        {
            String reply = """";
            PluginResult result = new PluginResult(PluginResult.Status.NO_RESULT);

            try {           
                // If we don't want secure connections, then use Socket class
                if(!secureConnection)
                {
                    // Not SSL socket
                    Socket sock = new Socket(host, port);
                    Log.d(""TCPSockets"", ""Socket created"");
                    sock.setSoTimeout(connectionTimeout); // Time out all actions for 30 seconds

                    PrintWriter out = new PrintWriter(sock.getOutputStream(), true);
                    BufferedReader in = new BufferedReader(new InputStreamReader(sock.getInputStream()));

                    Log.d(""TCPSockets"", ""Created reader/writer"");
                    out.println(message);
                    Log.d(""TCPSockets"", ""Sent message"");

                    reply = in.readLine();
                    Log.d(""TCPSockets"", ""Received message: "" + reply);

                    out.flush();

                    out.close();
                    in.close();
                    sock.close();
                }
                else // If we want secure connections, then use SSLSocket class
                {               
                    // Create a trust manager that does not validate certificate chains
                    TrustManager[] trustAllCerts = new TrustManager[] {
                        new X509TrustManager() {
                            public X509Certificate[] getAcceptedIssuers() {
                                return null;                                    
                            }

                            public void checkClientTrusted(X509Certificate[] certs, String authType) {
                                // Trust always
                            }

                            public void checkServerTrusted(X509Certificate[] certs, String authType) {
                                // Trust always
                            }
                        }
                    };

                    SSLContext sslContext = null;

                    try {
                        sslContext = SSLContext.getInstance(""SSL"");
                    } catch (NoSuchAlgorithmException e) {
                        Log.d(""SSLTCPSockets"", ""No such algorithm"");
    //                          return new PluginResult(PluginResult.Status.IO_EXCEPTION, ""Cannot connect to server. Please, try again"");
                        result = new PluginResult(PluginResult.Status.IO_EXCEPTION, ""Cannot connect to server. Please, try again"");                 
                        return result;
                    }

                    try {
                        sslContext.init(null, trustAllCerts, new SecureRandom());
                    } catch (KeyManagementException e) {
                        Log.d(""SSLTCPSockets"", ""Key manager exception"");
    //                          return new PluginResult(PluginResult.Status.IO_EXCEPTION, ""Cannot connect to server. Please, try again"");
                        result = new PluginResult(PluginResult.Status.IO_EXCEPTION, ""Cannot connect to server. Please, try again"");
                        return result;
                    }

                    SSLSocketFactory socketFactory = sslContext.getSocketFactory();
                    SSLSocket socket = (SSLSocket)socketFactory.createSocket(host, port);
                    socket.setSoTimeout(connectionTimeout);
                    socket.setUseClientMode(true);

                    Log.d(""SSLTCPSockets"", ""Connected to host"");

                    SSLSession session = socket.getSession();

                    if (session.isValid())
                    {
                        Log.i(getClass().toString(), ""Secure connection"");
                        PrintWriter out = new PrintWriter(socket.getOutputStream(), true);
                        BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()));

                        out.println(message);
                        Log.d(""SSLTCPSockets"", ""Sent message"");

                        reply = in.readLine();
                        Log.d(""SSLTCPSockets"", ""Received message: "" + reply);

                        out.flush();

                        out.close();
                        in.close();
                    }
                    else
                    {
                        Log.d(""SSLTCPSockets"", ""Cannot create a secure connection"");
    //                          return new PluginResult(PluginResult.Status.IO_EXCEPTION, ""Cannot connect to server. Please, try again"");
                        result = new PluginResult(PluginResult.Status.IO_EXCEPTION, ""Cannot connect to server. Please, try again"");
                        return result;
                    }

                    socket.close();
                }

                result = new PluginResult(PluginResult.Status.OK, reply);
                result.setKeepCallback(true);
                return result;                  
            } 

            catch (UnknownHostException e) {
                Log.d(""TCPSockets"", ""Unknown Host"");
    //                  return new PluginResult(PluginResult.Status.IO_EXCEPTION, ""Cannot connect to server. Please, try again"");
                result = new PluginResult(PluginResult.Status.IO_EXCEPTION, ""Cannot connect to server. Please, try again"");
                return result;
            } 

            catch (java.net.SocketTimeoutException e) {
                Log.d(""TCPSockets"", ""Connection timed out"");
    //                  return new PluginResult(PluginResult.Status.IO_EXCEPTION, ""Connection timed out. Please, try again"");
                result = new PluginResult(PluginResult.Status.IO_EXCEPTION, ""Connection timed out. Please, try again"");
                return result;
            }

            catch (IOException e) {
                Log.d(""TCPSockets"", ""IOException"");
    //                  return new PluginResult(PluginResult.Status.IO_EXCEPTION, ""Unexpected error. Please, try again"");
                result = new PluginResult(PluginResult.Status.IO_EXCEPTION, ""Unexpected error. Please, try again"");
                return result;
            }       
        }
    }
",4,0,593a26b1a702b32e2dd7c2ee6abbaefb47d4526ee739eeea5402be3001e867ef
,"import java.security.KeyManagementException;
import java.security.NoSuchAlgorithmException;
import java.security.SecureRandom;
import java.security.cert.X509Certificate;

import javax.net.ssl.HostnameVerifier;
import javax.net.ssl.HttpsURLConnection;
import javax.net.ssl.SSLContext;
import javax.net.ssl.SSLSession;
import javax.net.ssl.TrustManager;
import javax.net.ssl.X509TrustManager;


public class HttpsTrustManager implements X509TrustManager {

    private static TrustManager[] trustManagers;
    private static final X509Certificate[] _AcceptedIssuers = new X509Certificate[]{};

    @Override
    public void checkClientTrusted(
            java.security.cert.X509Certificate[] x509Certificates, String s)
            throws java.security.cert.CertificateException {

    }

    @Override
    public void checkServerTrusted(
            java.security.cert.X509Certificate[] x509Certificates, String s)
            throws java.security.cert.CertificateException {

    }

    public boolean isClientTrusted(X509Certificate[] chain) {
        return true;
    }

    public boolean isServerTrusted(X509Certificate[] chain) {
        return true;
    }

    @Override
    public X509Certificate[] getAcceptedIssuers() {
        return _AcceptedIssuers;
    }

    public static void allowAllSSL() {
        HttpsURLConnection.setDefaultHostnameVerifier(new HostnameVerifier() {

            @Override
            public boolean verify(String arg0, SSLSession arg1) {
                return true;
            }

        });

        SSLContext context = null;
        if (trustManagers == null) {
            trustManagers = new TrustManager[]{new HttpsTrustManager()};
        }

        try {
            context = SSLContext.getInstance(""TLS"");
            context.init(null, trustManagers, new SecureRandom());
        } catch (NoSuchAlgorithmException e) {
            e.printStackTrace();
        } catch (KeyManagementException e) {
            e.printStackTrace();
        }

        HttpsURLConnection.setDefaultSSLSocketFactory(context
                .getSocketFactory());
    }

}
",4,0,98ce3a4f569240503155ca01f7bcb94180d3f994386a3eca2ec83795ed556055
," try {
        PackageInfo info = getPackageManager().getPackageInfo(
                ""package.name.here"", 
                PackageManager.GET_SIGNATURES);
        for (Signature signature : info.signatures) {
            MessageDigest md = MessageDigest.getInstance(""SHA"");
            md.update(signature.toByteArray());
            Log.d(""KeyHash:"", Base64.encodeToString(md.digest(), Base64.DEFAULT));
            }
    } catch (NameNotFoundException e) {

    } catch (NoSuchAlgorithmException e) {

    }
",3,0,d32af6a7a6679c32ab58ed79a0b6a1324aa9f6791d97f6d745a218d913b95961
,"public static void test() throws Exception {
    Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");

    SecureRandom rnd = new SecureRandom();
    byte[] keyData = new byte[16];
    byte[] iv = new byte[16];
    rnd.nextBytes(keyData);
    rnd.nextBytes(iv);
    SecretKeySpec key = new SecretKeySpec(keyData, ""AES"");

    cipher.init(Cipher.ENCRYPT_MODE, key, new IvParameterSpec(iv));

    ByteArrayOutputStream buffer = new ByteArrayOutputStream();
    CipherOutputStream out = new CipherOutputStream(buffer, cipher);

    byte[] plain = ""Test1234567890_ABCDEFG"".getBytes();
    out.write(plain);
    out.flush();
    out.close();
    byte[] encrypted = buffer.toByteArray();
    System.out.println(""Plaintext length: "" + plain.length);
    System.out.println(""Padding length  : "" + (cipher.getBlockSize() - (plain.length % cipher.getBlockSize())));
    System.out.println(""Cipher length   : "" + encrypted.length);

    cipher.init(Cipher.DECRYPT_MODE, key, new IvParameterSpec(iv));
    CipherInputStream in = new CipherInputStream(new ByteArrayInputStream(encrypted), cipher);
    buffer = new ByteArrayOutputStream();
    byte[] b = new byte[100];
    int read;
    while ((read = in.read(b)) &gt;= 0) {
        buffer.write(b, 0, read);
    }
    in.close();

    // prints Test1234567890_ABCDEFG
    System.out.println(new String(buffer.toByteArray()));
}
",2,0,22c4d2f315c3faa7031246525680d297fed0037e19ba33038ff89f633b954770
,"protected static String getMD5(String inputText)
{
    String md5 = """";
    try
    {
        MessageDigest digester = MessageDigest.getInstance(""MD5"");
        digester.update(inputText.getBytes());
        md5 = new BigInteger(1, digester.digest()).toString(16);
    }
    catch(Exception e)
    {
        SetLogInfo.writeLog(""Exception: ""+e);
    }
    return md5;
}
",,1,e94ebc40818cd23ee5fad6280302a6e6bbb9ac96fa4364375ccf2eb50cf8463f
," TrustManager tm = new X509TrustManager() {
            public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {
            }

            public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {
            }

            public X509Certificate[] getAcceptedIssuers() {
                return null;
            }
        };
",4,0,c86a1db15e787fdbf16b219e956039fb37699412ac751f44ab0d6785d21344f6
,"private static boolean testVector(String algorithm, String key, String iv,
        String vector, String ciphertext) throws GeneralSecurityException {

    Cipher c = Cipher.getInstance(algorithm);
    SecretKey k = new SecretKeySpec(DatatypeConverter.parseHexBinary(key),
            ""AES"");

    if (iv == null) {
        c.init(Cipher.ENCRYPT_MODE, k);
    } else {
        c.init(Cipher.ENCRYPT_MODE, k, new IvParameterSpec(
                DatatypeConverter.parseHexBinary(iv)));
    }

    byte[] result = c.doFinal(DatatypeConverter.parseHexBinary(vector));
    return Arrays.equals(result,
            DatatypeConverter.parseHexBinary(ciphertext));
}
",,1,aa21b47c74c3f18018332dfd6c5994767e7e5829b1e9a5da130cd0f7224fe2c5
,"        PEMParser pemParser = new PEMParser(new StringReader(publicKey));
        SubjectPublicKeyInfo spki = (SubjectPublicKeyInfo) pemParser.readObject();
        pemParser.close();
        byte [] spkiEncoded = spki.getEncoded();
        X509EncodedKeySpec keySpec = new X509EncodedKeySpec(spkiEncoded);

        KeyFactory kf = KeyFactory.getInstance(""RSA"");
        this.publicKey = kf.generatePublic(keySpec);
",,1,8daa574540d5422987ebf09d2beba2b4478cecd50f7462e39a01ef2b3ffb74e4
,"public class SimpleCrypto{
public static String encrypt(String seed, String cleartext) throws Exception
{
    byte[] rawKey = getRawKey(seed.getBytes());
    byte[] result = encrypt(rawKey, cleartext.getBytes());
    return toHex(result);
}

public static String decrypt(String seed, String encrypted) throws Exception
{
    byte[] rawKey = getRawKey(seed.getBytes());
    byte[] enc = toByte(encrypted);
    byte[] result = decrypt(rawKey, enc);
    return new String(result);
}

private static byte[] getRawKey(byte[] seed) throws Exception
{
    KeyGenerator kgen = KeyGenerator.getInstance(""AES"");
    SecureRandom sr = SecureRandom.getInstance(""SHA1PRNG"");
    sr.setSeed(seed);
    kgen.init(128, sr); // 192 and 256 bits may not be available
    SecretKey skey = kgen.generateKey();
    byte[] raw = skey.getEncoded();
    return raw;
}


private static byte[] encrypt(byte[] raw, byte[] clear) throws Exception
{
    SecretKeySpec skeySpec = new SecretKeySpec(raw, ""AES"");
    Cipher cipher = Cipher.getInstance(""AES"");
    cipher.init(Cipher.ENCRYPT_MODE, skeySpec);
    byte[] encrypted = cipher.doFinal(clear);
    return encrypted;
}

private static byte[] decrypt(byte[] raw, byte[] encrypted) throws Exception
{
    SecretKeySpec skeySpec = new SecretKeySpec(raw, ""AES"");
    Cipher cipher = Cipher.getInstance(""AES"");
    cipher.init(Cipher.DECRYPT_MODE, skeySpec);
    byte[] decrypted = cipher.doFinal(encrypted);
    return decrypted;
}

public static String toHex(String txt)
{
    return toHex(txt.getBytes());
}

public static String fromHex(String hex)
{
    return new String(toByte(hex));
}

public static byte[] toByte(String hexString)
{
    int len = hexString.length() / 2;
    byte[] result = new byte[len];
    for (int i = 0; i &lt; len; i++)
        result[i] = Integer.valueOf(hexString.substring(2 * i, 2 * i + 2), 16).byteValue();
    return result;
}

public static String toHex(byte[] buf)
{
    if (buf == null)
        return """";
    StringBuffer result = new StringBuffer(2 * buf.length);
    for (int i = 0; i &lt; buf.length; i++)
    {
        appendHex(result, buf[i]);
    }
    return result.toString();
}

private final static String HEX = ""0123456789ABCDEF"";

private static void appendHex(StringBuffer sb, byte b)
{
    sb.append(HEX.charAt((b &gt;&gt; 4) &amp; 0x0f)).append(HEX.charAt(b &amp; 0x0f));
}
}
",4,0,e81a06cf792e25a009635f9d88a042fbbc5c934bd511fdaec4e4bf2e50b61ffb
,"// read .crt file from memory
InputStream inStream = ctx.openFileInput(""cetificate.crt"");

//InputStream inStream = ctx.getAssets().open(""wm_loaner.cer"");
if(inStream != null)
{
    KeyStore cert = CertUtils.ConvertCerToBKS(inStream, ""MyAlias"", ""password"".toCharArray());
    inStream.close();
}

public static KeyStore ConvertCerToBKS(InputStream cerStream, String alias, char [] password)
{
    KeyStore keyStore = null;
    try
    {
        keyStore = KeyStore.getInstance(""BKS"", ""BC"");
        CertificateFactory factory = CertificateFactory.getInstance(""X.509"", ""BC"");
        Certificate certificate = factory.generateCertificate(cerStream);
        keyStore.load(null, password);
        keyStore.setCertificateEntry(alias, certificate);
    }
    catch ....
    {
    }
    return keyStore;                                    
}
",,1,55a9a287c5914841a26bbacf023546ff75d68896585ed13dc36b6136f0611c3d
,"public X509Certificate parseCertificate(String certificate) throws CertificateException {
    byte[] decoded = Base64.decode(certificate.replaceAll(""-----BEGIN CERTIFICATE-----"", """").replaceAll(""-----END CERTIFICATE-----"", """"));
    return (X509Certificate) CertificateFactory.getInstance(""X.509"").generateCertificate(new ByteArrayInputStream(decoded));
}
",,1,18322ab869006ee1ec30cbfae2562eb3c1560d8448265c89ed5fed642a425893
,"TelephonyManager TelephonyMgr = (TelephonyManager)getSystemService(TELEPHONY_SERVICE);
String szImei = TelephonyMgr.getDeviceId(); // Requires READ_PHONE_STATE

String m_szDevIDShort = ""35"" + //we make this look like a valid IMEI
Build.BOARD.length()%10+ Build.BRAND.length()%10 +
Build.CPU_ABI.length()%10 + Build.DEVICE.length()%10 +
Build.DISPLAY.length()%10 + Build.HOST.length()%10 +
Build.ID.length()%10 + Build.MANUFACTURER.length()%10 +
Build.MODEL.length()%10 + Build.PRODUCT.length()%10 +
Build.TAGS.length()%10 + Build.TYPE.length()%10 +
Build.USER.length()%10 ; //13 digits


WifiManager wm = (WifiManager)getSystemService(Context.WIFI_SERVICE);

BluetoothAdapter m_BluetoothAdapter = null; // Local Bluetooth adapter
m_BluetoothAdapter = BluetoothAdapter.getDefaultAdapter();
String m_szBTMAC = m_BluetoothAdapter.getAddress();
String m_szWLANMAC = wm.getConnectionInfo().getMacAddress();


String m_szLongID = m_szImei + m_szDevIDShort + m_szWLANMAC + m_szBTMAC;
// compute md5
MessageDigest m = null;
try {
     m = MessageDigest.getInstance(""MD5"");
} catch (NoSuchAlgorithmException e) {
e.printStackTrace();
}

m.update(m_szLongID.getBytes(),0,m_szLongID.length());
// get md5 bytes
byte p_md5Data[] = m.digest();
// create a hex string
String m_szUniqueID = new String();

for (int i=0;i&lt;p_md5Data.length;i++) {
        int b = (0xFF &amp; p_md5Data[i]);
// if it is a single digit, make sure it have 0 in front (proper padding)
if (b &lt;= 0xF) m_szUniqueID+=""0"";
// add number to string
     m_szUniqueID+=Integer.toHexString(b);
}

// hex string to uppercase
m_szUniqueID = m_szUniqueID.toUpperCase();
",,1,d77aef469c61ae02c881d1a821bff3aa54b4754baff678a16010bad5cc8912dd
,"import java.io.*;
import javax.xml.transform.*;
import javax.xml.transform.dom.*;
import javax.xml.transform.stream.*;

//method to convert Document to String
public String getStringFromDocument(Document doc)
{
    try
    {
       DOMSource domSource = new DOMSource(doc);
       StringWriter writer = new StringWriter();
       StreamResult result = new StreamResult(writer);
       TransformerFactory tf = TransformerFactory.newInstance();
       Transformer transformer = tf.newTransformer();
       transformer.transform(domSource, result);
       return writer.toString();
    }
    catch(TransformerException ex)
    {
       ex.printStackTrace();
       return null;
    }
}
",,1,af4bc9596b6cca377382e902d3698be8f96dc056e1ad6836f54f13c9f8054279
,"              TrustManager[] trustAllCerts = new TrustManager[]
               {
                 new X509TrustManager()
                  {
                    public java.security.cert.X509Certificate[] getAcceptedIssuers()  { return null; }
                    public void checkClientTrusted( java.security.cert.X509Certificate[] certs, String authType)  {}
                    public void checkServerTrusted( java.security.cert.X509Certificate[] certs, String authType)  {}
                  }
                 };
              try
                {
                  SSLContext sc = SSLContext.getInstance( ""SSL""); // ""TLS"" ""SSL""
                  sc.init( null, trustAllCerts, null);
                  HttpsURLConnection.setDefaultSSLSocketFactory( sc.getSocketFactory());
                  HttpsURLConnection.setDefaultHostnameVerifier( 
                   new HostnameVerifier() 
                    {
                      public boolean verify( String hostname, SSLSession session) { return true; }
                    } );
                }
               catch( Exception e)
",4,0,38bd8516a93edc835627bc379f7b6c95b57c2512be64fe7787274279d90c2d75
,"                 CertificateFactory cf = CertificateFactory.getInstance(""X.509"");
             InputStream caInput = getResources().openRawResource(R.drawable.cert);
             Certificate ca;
             try {
                 ca = cf.generateCertificate(caInput);
                 System.out.println(""ca="" + ((X509Certificate) ca).getSubjectDN());
             } finally {
                 caInput.close();
             }
             String keyStoreType = KeyStore.getDefaultType();
             KeyStore keyStore = KeyStore.getInstance(keyStoreType);
             keyStore.load(null, null);
             keyStore.setCertificateEntry(""ca"", ca);
             String tmfAlgorithm = TrustManagerFactory.getDefaultAlgorithm();
             TrustManagerFactory tmf = TrustManagerFactory.getInstance(tmfAlgorithm);
             tmf.init(keyStore);
             SSLContext context = SSLContext.getInstance(""TLS"");
             context.init(null, tmf.getTrustManagers(), null);
            mRequestQueue =Volley.newRequestQueue(getApplicationContext(), new HurlStack(null, context.getSocketFactory()));
",4,0,7f54c4c2ee3d1e48b364d03d999bdb48e9385b4703341c197cf777dfb41b6a80
,"// Implementing a fromString method on an enum type
private static final Map&lt;String, Operation&gt; stringToEnum = new HashMap&lt;String, Operation&gt;();
static { // Initialize map from constant name to enum constant
    for (Operation op : values())
        stringToEnum.put(op.toString(), op);
} // Returns Operation for string, or null if string is invalid
public static Operation fromString(String symbol) {
    return stringToEnum.get(symbol);
}
",,1,78ce37cb887cb512ffaee03b53ba31bf16014cafe9ed0c26a7b3f761ef0b9257
," TrustManager tm = new X509TrustManager()  {
    public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {
    }

    public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {
    }

    public X509Certificate[] getAcceptedIssuers() {
        return null;
    }
};
",4,0,8ad36749da2358cfe39b065e0ef54a9edc57ce4b6bc23e0b4b4a24745d101830
,"public static String encrypt(String seed, String cleartext) throws Exception {
       byte[] rawKey = getRawKey(seed.getBytes(""UTF-16""));
       byte[] result = encrypt(rawKey, cleartext.getBytes(""UTF-16""));
       return toHex(result);
   }
   
   public static String decrypt(String seed, String encrypted) throws Exception {
       byte[] rawKey = getRawKey(seed.getBytes(""UTF-16""));
       byte[] enc = toByte(encrypted);
       byte[] result = decrypt(rawKey, enc);
       return new String(result);
      }

   private static byte[] getRawKey(byte[] seed) throws Exception {
       KeyGenerator kgen = KeyGenerator.getInstance(""AES"");
       SecureRandom sr = SecureRandom.getInstance(""SHA1PRNG"");
       sr.setSeed(seed);
     kgen.init(128, sr); // 192 and 256 bits may not be available
     SecretKey skey = kgen.generateKey();
     byte[] raw = skey.getEncoded();
     return raw;
   }

   
   private static byte[] encrypt(byte[] raw, byte[] clear) throws Exception {
     SecretKeySpec skeySpec = new SecretKeySpec(raw, ""AES"");
       Cipher cipher = Cipher.getInstance(""AES"");
     cipher.init(Cipher.ENCRYPT_MODE, skeySpec);
     byte[] encrypted = cipher.doFinal(clear);
       return encrypted;
   }

   private static byte[] decrypt(byte[] raw, byte[] encrypted) throws Exception {
     SecretKeySpec skeySpec = new SecretKeySpec(raw, ""AES"");
       Cipher cipher = Cipher.getInstance(""AES"");
     cipher.init(Cipher.DECRYPT_MODE, skeySpec);
     byte[] decrypted = cipher.doFinal(encrypted);
       return decrypted;
   }

   public static String toHex(String txt) {
       return toHex(txt.getBytes());
   }
   public static String fromHex(String hex) {
       return new String(toByte(hex));
   }
   
   public static byte[] toByte(String hexString) {
       int len = hexString.length()/2;
       byte[] result = new byte[len];
       for (int i = 0; i &lt; len; i++)
           result[i] = Integer.valueOf(hexString.substring(2*i, 2*i+2), 16).byteValue();
       return result;
   }

   public static String toHex(byte[] buf) {
       if (buf == null)
           return """";
       StringBuffer result = new StringBuffer(2*buf.length);
       for (int i = 0; i &lt; buf.length; i++) {
           appendHex(result, buf[i]);
       }
       return result.toString();
   }
   private final static String HEX = ""0123456789ABCDEF"";
   private static void appendHex(StringBuffer sb, byte b) {
       sb.append(HEX.charAt((b&gt;&gt;4)&amp;0x0f)).append(HEX.charAt(b&amp;0x0f));
   }
   
",4,0,cfd4b87aead1d1c5c437443498add8e58c3e65db1316f4feeec6ecb0842b8aca
,"package Utils;

import java.io.IOException;
import java.io.OutputStream;
import java.net.URL;
import java.net.URLEncoder;
import javax.net.ssl.HostnameVerifier;
import javax.net.ssl.HttpsURLConnection;
import javax.net.ssl.SSLSession;
import android.util.Log;

public class MessageUtil
{
public final static String AUTH = ""authentication"";

public static final String UPDATE_CLIENT_AUTH = ""Update-Client-Auth"";

public static final String PARAM_REGISTRATION_ID = ""registration_id"";

public static final String PARAM_DELAY_WHILE_IDLE = ""delay_while_idle"";

public static final String PARAM_COLLAPSE_KEY = ""collapse_key"";

private static final String UTF8 = ""UTF-8"";

public static int sendMessage(String auth_token, String registrationId,String message) throws IOException 
{

    StringBuilder postDataBuilder = new StringBuilder();

    postDataBuilder.append(PARAM_REGISTRATION_ID).append(""="").append(registrationId);
    postDataBuilder.append(""&amp;"").append(PARAM_COLLAPSE_KEY).append(""="").append(""0"");
    postDataBuilder.append(""&amp;"").append(""data.payload"").append(""="").append(URLEncoder.encode(message, UTF8));

    byte[] postData = postDataBuilder.toString().getBytes(UTF8);

    // Hit the dm URL.

    URL url = new URL(""https://android.clients.google.com/c2dm/send"");
    HttpsURLConnection.setDefaultHostnameVerifier(new CustomizedHostnameVerifier());
    HttpsURLConnection conn = (HttpsURLConnection) url.openConnection();
    conn.setDoOutput(true);
    conn.setUseCaches(false);
    conn.setRequestMethod(""POST"");
    conn.setRequestProperty(""Content-Type"",""application/x-www-form-urlencoded;charset=UTF-8"");
    conn.setRequestProperty(""Content-Length"",Integer.toString(postData.length));
    conn.setRequestProperty(""Authorization"", ""GoogleLogin auth=""+ auth_token);

    OutputStream out = conn.getOutputStream();
    out.write(postData);
    out.close();

    int responseCode = conn.getResponseCode();
    if (responseCode == 200)
    {
        Log.d(""error"",conn.toString());
        Log.d(""response"",conn.getResponseMessage());
    }
    return responseCode;
}

private static class CustomizedHostnameVerifier implements HostnameVerifier {
    public boolean verify(String hostname, SSLSession session) {
        return true;
    }
}
}
  //call the method from other activity
  int responseCode = MessageUtil.sendMessage(token,registration_id, ""your message for device"");
        System.out.println(responseCode);
",4,0,e26fde4cc9f2a8368c4c9c9df3a4a6e6719fdf51f36500a862b3ba2306d6cbf5
," HttpsURLConnection.setDefaultHostnameVerifier(new AllVerifier());
 try
  {
   SSLContext sslContext = SSLContext.getInstance(""TLS"");
   sslContext.init(null, new TrustManager[] { new AllTrustManager() }, null);
   HttpsURLConnection.setDefaultSSLSocketFactory(sslContext.getSocketFactory());
     } catch (KeyManagementException e) {
       e.printStackTrace();
     } catch (NoSuchAlgorithmException e) {
       e.printStackTrace();
   }
",4,0,10bd68e17326aef3546d12bd8dab0ff473f67844c9431d3d7f775643aed5766b
,"import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
...
public String getIdHash(long id){
    String hash = null;
    long intId = id ^ Long.MAX_VALUE;
    String md5 = String.format(""%X-ANY-TEXT"", intId);
    try {
        MessageDigest md = java.security.MessageDigest.getInstance(""MD5"");
        byte[] arr = md.digest(md5.getBytes());
        StringBuffer sb = new StringBuffer();
        for (int i = 0; i &lt; arr.length; ++i)
            sb.append(Integer.toHexString((arr[i] &amp; 0xFF) | 0x100).substring(1,3));

        hash = sb.toString();
    } catch (NoSuchAlgorithmException e) {
        Log.e(""MD5"", e.getMessage());
    }

    return hash.toUpperCase();
}
",,1,1ea5b0d2030d800dd28bb5c65344fe9d0f2d54755b8a303efb02db0ff4b1c2fd
,"String aid = Settings.Secure.getString(getContext().getContentResolver(), ""android_id"");

Object obj = null;
try {
    ((MessageDigest) (obj = MessageDigest.getInstance(""MD5""))).update(
                                   aid.getBytes(), 0, aid.length());

    obj = String.format(""%032X"", new Object[] { new BigInteger(1,
                                   ((MessageDigest) obj).digest()) });
} catch (NoSuchAlgorithmException localNoSuchAlgorithmException) {
    obj = aid.substring(0, 32);
}
",,1,512e42e47c128931ba8524254e392710f718053544a2ccca90917a582472bc48
,"// DO NOT FORGET TO REMOVE
PackageInfo info;
try {
    info = getPackageManager().getPackageInfo(""com.you.name"", PackageManager.GET_SIGNATURES);
    for (Signature signature : info.signatures) {
        MessageDigest md;
        md = MessageDigest.getInstance(""SHA"");
        md.update(signature.toByteArray());
        String something = new String(Base64.encode(md.digest(), 0));
        //String something = new String(Base64.encodeBytes(md.digest()));
        Log.e(""hash key"", something);
    }
} catch (NameNotFoundException e1) {
    Log.e(""name not found"", e1.toString());
} catch (NoSuchAlgorithmException e) {
    Log.e(""no such an algorithm"", e.toString());
} catch (Exception e) {
    Log.e(""exception"", e.toString());
}
// DO NOT FORGET TO REMOVE
",3,0,776dd93c38820dac6f94664c2b924ebdcd5b632537979a30a01994969f0cbad6
,"It will open facebook dialog to post status update:

    import java.security.MessageDigest;
    import java.security.NoSuchAlgorithmException;
    import android.app.Activity;
    import android.content.Context;
    import android.content.Intent;
    import android.content.pm.PackageInfo;
    import android.content.pm.PackageManager;
    import android.content.pm.PackageManager.NameNotFoundException;
    import android.content.pm.Signature;
    import android.net.ConnectivityManager;
    import android.net.NetworkInfo;
    import android.os.Bundle;
    import android.util.Base64;
    import android.util.Log;
    import android.view.Menu;
    import android.view.View;
    import android.view.View.OnClickListener;
    import android.widget.ImageView;
    import android.widget.Toast;
    import com.facebook.Session;
    import com.facebook.SessionState;
    import com.facebook.UiLifecycleHelper;
    import com.facebook.widget.FacebookDialog;
    public class MainActivity extends Activity {
        String message = ""Hello there!"";
        private UiLifecycleHelper uiHelper;
        ImageView facebook;
        private Session.StatusCallback callback = new Session.StatusCallback() {
            @Override
            public void call(Session session, SessionState state,
                    Exception exception) {
                onSessionStateChange(session, state, exception);
            }
        };
        private void onSessionStateChange(Session session, SessionState state,
                Exception exception) {
            if (state.isOpened()) {
                // System.out.println(""Logged in..."");
            } else if (state.isClosed()) {
                // System.out.println(""Logged out..."");
            }
        }
        @Override
        protected void onActivityResult(int requestCode, int resultCode, Intent data) {
            super.onActivityResult(requestCode, resultCode, data);
            uiHelper.onActivityResult(requestCode, resultCode, data,
                    new FacebookDialog.Callback() {
                        @Override
                        public void onError(FacebookDialog.PendingCall pendingCall,
                                Exception error, Bundle data) {
                            Log.e(""Activity"",
                                    String.format(""Error: %s"", error.toString()));
                        }
                        @Override
                        public void onComplete(
                                FacebookDialog.PendingCall pendingCall, Bundle data) {
                            Log.i(""Activity"", ""Success!"");
                        }
                    });
        }
        @Override
        protected void onCreate(Bundle savedInstanceState) {
            super.onCreate(savedInstanceState);
            setContentView(R.layout.activity_main);
            uiHelper = new UiLifecycleHelper(this, callback);
            uiHelper.onCreate(savedInstanceState);


            //Code to get KeyHash value.
            try {
                PackageInfo info = getPackageManager().getPackageInfo(
                        ""com.code2care.thebuddhaquotes"", 
                        PackageManager.GET_SIGNATURES);
                for (Signature signature : info.signatures) {
                    MessageDigest md = MessageDigest.getInstance(""SHA"");
                    md.update(signature.toByteArray());
                    System.out.println(""KeyHash : ""+ Base64.encodeToString(md.digest(), Base64.DEFAULT));
                    }
            } catch (NameNotFoundException e) {
            } catch (NoSuchAlgorithmException e) {
            }

            facebook = (ImageView) findViewById(R.id.fbIcon);
            facebook.setOnClickListener(new OnClickListener() {
                @Override
                public void onClick(View v) {
                    facebook();
                }
            });
        }
        @Override
        public boolean onCreateOptionsMenu(Menu menu) {
            // Inflate the menu; this adds items to the action bar if it is present.
            getMenuInflater().inflate(R.menu.main, menu);
            return true;
        }
        @Override
        protected void onDestroy() {
            uiHelper.onDestroy();
            super.onDestroy();
        }
        @Override
        protected void onResume() {
            super.onResume();
            uiHelper.onResume();
        }
        @Override
        protected void onSaveInstanceState(Bundle outState) {
            super.onSaveInstanceState(outState);
            uiHelper.onSaveInstanceState(outState);
        }
        @Override
        public void onPause() {
            super.onPause();
            uiHelper.onPause();
        }
        public void facebook() {
            if (!checkNetwork()) {
                Toast.makeText(getApplicationContext(),
                        ""No active internet connection ..."", Toast.LENGTH_SHORT)
                        .show();
                return;
            }
            if (!checkFbInstalled()) {
                Toast.makeText(getApplicationContext(),
                        ""Facebook app not installed!.."", Toast.LENGTH_SHORT).show();
                return;
            }
            Toast.makeText(getApplicationContext(), ""Loading..."",
                    Toast.LENGTH_SHORT).show();
            if (FacebookDialog.canPresentShareDialog(this,
                    FacebookDialog.ShareDialogFeature.SHARE_DIALOG)) {
                FacebookDialog shareDialog = new FacebookDialog.ShareDialogBuilder(
                        this).setName(""The Buddha Quotes"")
                        .setLink(""http://code2care.org"").setDescription(message)
                        .setPicture(""http://code2care.org/buddha.jpg"").build();
                uiHelper.trackPendingDialogCall(shareDialog.present());
            } else {
                // System.out.println(""Fail Success!"");
            }
        }
        private boolean checkNetwork() {
            boolean wifiAvailable = false;
            boolean mobileAvailable = false;
            ConnectivityManager conManager = (ConnectivityManager) getSystemService(Context.CONNECTIVITY_SERVICE);
            NetworkInfo[] networkInfo = conManager.getAllNetworkInfo();
            for (NetworkInfo netInfo : networkInfo) {
                if (netInfo.getTypeName().equalsIgnoreCase(""WIFI""))
                    if (netInfo.isConnected())
                        wifiAvailable = true;
                if (netInfo.getTypeName().equalsIgnoreCase(""MOBILE""))
                    if (netInfo.isConnected())
                        mobileAvailable = true;
            }
            return wifiAvailable || mobileAvailable;
        }
        public Boolean checkFbInstalled() {
            PackageManager pm = getPackageManager();
            boolean flag = false;
            try {
                pm.getPackageInfo(""com.facebook.katana"",
                        PackageManager.GET_ACTIVITIES);
                flag = true;
            } catch (PackageManager.NameNotFoundException e) {
                flag = false;
            }
            return flag;
        }
    }

//2nd Way (If native app is not present You can implement check if facebook native sharedialog is present or not)

if (FacebookDialog.canPresentShareDialog(getApplicationContext(),
FacebookDialog.ShareDialogFeature.SHARE_DIALOG)) {
    // Publish the post using the Share Dialog
    FacebookDialog shareDialog = new FacebookDialog.ShareDialogBuilder(this)
            .setLink(""https://developers.facebook.com/android"")
            .build();
    uiHelper.trackPendingDialogCall(shareDialog.present());

} else {
    // Fallback. For example, publish the post using the Feed Dialog
    publishFeedDialog();
}

private void publishFeedDialog() {
    Bundle params = new Bundle();
    params.putString(""name"", ""Facebook SDK for Android"");
    params.putString(""caption"", ""Build great social apps and get more installs."");
    params.putString(""description"", ""The Facebook SDK for Android makes it easier and faster to develop Facebook integrated Android apps."");
    params.putString(""link"", ""https://developers.facebook.com/android"");
    params.putString(""picture"", ""https://raw.github.com/fbsamples/ios-3.x-howtos/master/Images/iossdk_logo.png"");
WebDialog feedDialog = (new WebDialog.FeedDialogBuilder(
                HomeDailySay.this, Session.getActiveSession(), params))
                .setOnCompleteListener(new OnCompleteListener() {
                    @Override
                    public void onComplete(Bundle values,
                            FacebookException error) {
                        if (error == null) {
                            // When the story is posted, echo the success
                            // and the post Id.
                            final String postId = values.getString(""post_id"");
                            if (postId != null) {

                                //status updated

                            } else {
                                // User clicked the Cancel button

                            }
                        } else if (error instanceof FacebookOperationCanceledException) {
                            // User clicked the ""x"" button

                        } else {
                            // Generic, ex: network error

                        }
                    }

                }).build();
    feedDialog.show();
}
",3,0,b75ea9195c7380757bc58fbff574ec078955341876bcd03a1179eeeb055e6ad5
,"ecipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
byte[] iv = new byte[IV_LENGTH];
SecureRandom random = new SecureRandom();
random.nextBytes(iv);
ecipher.init(Cipher.ENCRYPT_MODE, secret, new IvParameterSpec(iv));
byte[] enc = ecipher.doFinal(utf8);
",1,0,78307f4e6327afca0db6d977665a281961dd3565daeb441698cd6051278d6051
,"PackageInfo info = getPackageManager().getPackageInfo(""&lt;your_package_name&gt;"",  PackageManager.GET_SIGNATURES);

for (Signature signature : info.signatures){
   MessageDigest md = MessageDigest.getInstance(""SHA"");
   md.update(signature.toByteArray());
   Log.d(""KeyHash:"", Base64.encodeToString(md.digest(), Base64.DEFAULT));
}
",3,0,967d9fac780d91e6b325ab3b7dccc6c60f8341743f04083944afcf74ffb267c2
," public static byte[] encrypt(byte[] key, byte[] data) throws Exception

        {

            SecretKeySpec skeySpec = new SecretKeySpec(key, ""AES"");
            Cipher cipher = Cipher.getInstance(""AES"");
            cipher.init(Cipher.ENCRYPT_MODE, skeySpec);
            byte[] encrypted = cipher.doFinal(data);
            return encrypted;
        }

        /**
         * DEcrypt byte array with given Key using AES Algorithm
         * Key can be generated using &lt;Code&gt;getKey()&lt;/Code&gt;
         * @param key  Key that Is used for decrypting data
         * @param data  Data passed to decrypt
         * @return decrypted data
         * */

        public static byte[] decrypt1(byte[] key, byte[] encrypted) throws Exception
        {

            SecretKeySpec skeySpec = new SecretKeySpec(key, ""AES"");
            Cipher cipher = Cipher.getInstance(""AES"");
            cipher.init(Cipher.DECRYPT_MODE, skeySpec);
            byte[] decrypted = cipher.doFinal(encrypted);
            return decrypted;
        }
        /**
         * get the Key for encryption this can be used for while decrypting and encrypting too.
         * */
        public static byte[] getKey() throws Exception
        {
            byte[] keyStart = EncrypteDecrypte.encryptionKey.getBytes();
            KeyGenerator kgen = KeyGenerator.getInstance(""AES"");
            SecureRandom sr = SecureRandom.getInstance(""SHA1PRNG"");
            sr.setSeed(keyStart);
            kgen.init(128, sr); // 192 and 256 bits may not be available
            SecretKey skey = kgen.generateKey();
            byte[] key = skey.getEncoded();

            return key;
        }
",2,0,e2c173fc0f55cc106bdf346087a2468beff87332c987b31d88c59c12c4bdf2c7
,"WebSocketOrderClient webSocketOrderClient = new WebSocketOrderClient(uri, new Draft_17(), cmap, TIMEOUT);
SSLContext sslContext = null;
sslContext = SSLContext.getInstance( ""TLS"" );
sslContext.init( null, null, null ); // will use java's default key and trust store which is sufficient unless you deal with self-signed certificates

webSocketOrderClient.setWebSocketFactory(new DefaultSSLWebSocketClientFactory(sslContext));
webSocketOrderClient.connectBlocking();
",3,0,f142ce840cf1389ee6efe388e7c134580189f2cf1fe83ecc560ed8e0a35ff9dd
,"    String TAG = ""com.sromku.simple.fb.example"";
        PackageInfo info = context.getPackageManager().getPackageInfo(TAG,
            PackageManager.GET_SIGNATURES);
        for (Signature signature: info.signatures)
        {
            MessageDigest md = MessageDigest.getInstance(""SHA"");
            md.update(signature.toByteArray());
            String keyHash = Base64.encodeToString(md.digest(), Base64.DEFAULT);
            Log.d(TAG, ""keyHash: "" + keyHash);
",3,0,90a656dd220621d28694bdcb28fbf5278d9b9819fda1b2267961f8d0d97773a9
,"import java.io.IOException;
import java.io.InputStream;
import java.net.InetAddress;
import java.net.Socket;
import java.net.UnknownHostException;
import java.security.GeneralSecurityException;
import java.security.KeyManagementException;

import java.security.KeyStoreException;
import java.security.NoSuchAlgorithmException;
import java.security.UnrecoverableKeyException;


import javax.net.ssl.SSLSocket;
import javax.net.ssl.TrustManager;

import org.apache.http.conn.ssl.SSLSocketFactory;
import org.apache.http.params.HttpParams;

import android.annotation.TargetApi;
import android.net.SSLCertificateSocketFactory;
import android.os.Build;


 class SslSocketFactory extends SSLSocketFactory {

     InputStream mkeyStore;
     String mkeyStorePassword;

     public SslSocketFactory(InputStream keyStore, String keyStorePassword) throws KeyManagementException, UnrecoverableKeyException, NoSuchAlgorithmException, KeyStoreException{
         super(null);
         mkeyStore=keyStore;
         mkeyStorePassword=keyStorePassword;

     }



      @Override
      public Socket connectSocket(Socket s, String host, int port, InetAddress localAddress, int localPort, HttpParams params) throws IOException {
          return null;
      }

      @Override
      public Socket createSocket() throws IOException {
          return null;
      }

      @Override
      public boolean isSecure(Socket s) throws IllegalArgumentException {
          if (s instanceof SSLSocket) {
              return ((SSLSocket) s).isConnected();
          }
          return false;
      }

      @TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR1)
      @Override
      public Socket createSocket(Socket socket, String host, int port, boolean autoClose) throws IOException, UnknownHostException {
          SSLSocket sslSocket = null;


              if (autoClose) {
                  socket.close();
              }


                 SSLCertificateSocketFactory sslSocketFactory = (SSLCertificateSocketFactory) SSLCertificateSocketFactory.getDefault(0, null);


              try {
                sslSocketFactory.setTrustManagers(new TrustManager[] { new SsX509TrustManager( mkeyStore, mkeyStorePassword) });
            } catch (GeneralSecurityException e1) {

                e1.printStackTrace();
            }



              sslSocket = (SSLSocket) sslSocketFactory.createSocket(InetAddress.getByName(host), port);

              sslSocket.setEnabledProtocols(sslSocket.getSupportedProtocols());

              if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.JELLY_BEAN_MR1) {

                  sslSocketFactory.setHostname(sslSocket, host);
              } else {

                  try {
                      java.lang.reflect.Method setHostnameMethod = sslSocket.getClass().getMethod(""setHostname"", String.class);
                      setHostnameMethod.invoke(sslSocket, host);
                  } catch (Exception e) {

                  }
              }


          return sslSocket;
      }

  }
",3,0,a85c9830d0d4a279e46f80fc97b9ff27557271aaf9111d9893958b77f28232b4
,"private static String post(String urlString, Map formParameters)
throws MalformedURLException, ProtocolException, IOException {
    DataOutputStream ostream = null;

    trustAllHosts();
    URL tempUrl;
    StringBuffer buf = new StringBuffer();
    if(formParameters != null) {
        Set parameters = formParameters.keySet();
        Iterator it = parameters.iterator();
        //StringBuffer buf = new StringBuffer();

        for(int i = 0, paramCount = 0; it.hasNext(); i++) {
            String parameterName = (String) it.next();
            String parameterValue = (String) formParameters.get(parameterName);

            if(parameterValue != null) {
                parameterValue = URLEncoder.encode(parameterValue);
                if(paramCount &gt; 0) {
                    buf.append(""&amp;"");
                }
                buf.append(parameterName);
                buf.append(""="");
                buf.append(parameterValue);
                ++paramCount;
            }
        }
        Log.v(""smartdbhelper adding post parameters"", buf.toString());


    }
    urlString = urlString + ""?"" + buf;
    Log.v(""smartdbhelper url string"", urlString);
    tempUrl = new URL(urlString);
    HttpsURLConnection https = (HttpsURLConnection) tempUrl.openConnection();
    https.setHostnameVerifier(DO_NOT_VERIFY);
    Log.v(""smartdbhelper adding post parameters"", https.toString());
    https.setRequestMethod(""POST"");
    https.setDoInput(true);
    https.setDoOutput(true);
    ostream = new DataOutputStream(https.getOutputStream());
    ostream.writeBytes(buf.toString());


if( ostream != null ) {
    ostream.flush();
        ostream.close();
    }
    Object contents = https.getContent();
    InputStream is = (InputStream) contents;
    StringBuffer buf2 = new StringBuffer();
    int c;
    while((c = is.read()) != -1) {
        buf2.append((char)c);
        Log.v(""smartdbhelper bugger"", buf2.toString());
    }
    https.disconnect();
    return buf2.toString();
}
",4,0,ef3cad12012c713d5ff448c0b7583ad79a3c3d48a32e6df8ead3c3395bea65ca
,"    public HttpClient getNewHttpClient() {
    try {
        KeyStore trustStore = KeyStore.getInstance(""BKS"");
        InputStream in = getResources().openRawResource(R.raw.mykeystore);
        try {
            trustStore.load(in, ""mypassword"".toCharArray());
        } finally {
            in.close();
        }

        SSLSocketFactory sf = new SSLSocketFactory(trustStore);
        sf.setHostnameVerifier(SSLSocketFactory.STRICT_HOSTNAME_VERIFIER);

        HttpParams params = new BasicHttpParams();
        HttpProtocolParams.setVersion(params, HttpVersion.HTTP_1_1);
        HttpProtocolParams.setContentCharset(params, HTTP.UTF_8);

        SchemeRegistry registry = new SchemeRegistry();
        registry.register(new Scheme(""http"", PlainSocketFactory.getSocketFactory(), 80));
        registry.register(new Scheme(""https"", sf, 443));

        ClientConnectionManager ccm = new ThreadSafeClientConnManager(params, registry);
        return new DefaultHttpClient(ccm, params);
    } catch (Exception e) {
        return new DefaultHttpClient();
    }
}
",3,0,ae906c55963dc0df2a16024bc1c561b7a29a1653db3eacbbe4274ce5e8ddcf11
,"    String keyStoreType = KeyStore.getDefaultType();
    KeyStore keyStore = KeyStore.getInstance(keyStoreType);
    InputStream inputStream = context.getResources().openRawResource(R.raw.server);
    keyStore.load(inputStream, ""passwd"".toCharArray());

    String keyalg = KeyManagerFactory.getDefaultAlgorithm();
    kmf.init(keyStore, ""passwd"".toCharArray());

    KeyManagerFactory kmf = KeyManagerFactory.getInstance(keyalg);
    SSLContext context = SSLContext.getInstance(""TLS"");
    context.init(kmf.getKeyManagers(), null, null);
    SSLServerSocket ss = (SSLServerSocket) context.getServerSocketFactory().createServerSocket(4444);
    inputStream.close();

    ss.accept();
",3,0,9ad4ff488c452a44831971deb36ef8d704dbd4617672c18b55ba14934f526492
,"try {
            PackageInfo info = context.getPackageManager().getPackageInfo(
                    ""com.example.package"", PackageManager.GET_SIGNATURES); //Your package name here
            for (Signature signature : info.signatures) {
                MessageDigest md = MessageDigest.getInstance(""SHA"");
                md.update(signature.toByteArray());
                Log.v(""KeyHash:"", Base64.encodeToString(md.digest(), Base64.DEFAULT));
                }
        } catch (NameNotFoundException e) {
        } catch (NoSuchAlgorithmException e) {
        }
",3,0,45c98deabd66cbc609cd1583a5f1eaf4057ad139a754998977c0a5734bba690d
,"import java.io.IOException;
import java.util.HashMap;
import java.util.Map;
import java.util.logging.Logger;

import javax.security.sasl.Sasl;

import org.jivesoftware.smack.SASLAuthentication;
import org.jivesoftware.smack.XMPPException;
import org.jivesoftware.smack.sasl.SASLMechanism;
import org.jivesoftware.smack.util.Base64;

public class SALSGTalkOauthMechanism extends SASLMechanism {
    private static final Logger log = Logger.getLogger(SALSGTalkOauthMechanism.class.getName());
    public static final String NAME = ""X-OAUTH2"";


    /**
     * Constructor.
     */
    public SALSGTalkOauthMechanism(SASLAuthentication saslAuthentication) {
            super(saslAuthentication);
            log.info(""Creating SASL mechanism for GTalk (X-OAUTH2)"");
    }

    @Override
    public void authenticate(String username, String host, String accessToken) throws IOException, XMPPException {
        this.hostname = host;

        log.info(""Authenticating to host ""+host+"" with key ""+username);

        String[] mechanisms = { ""X-OAUTH2"" };
        Map&lt;String, String&gt; props = new HashMap&lt;String, String&gt;();
        this.sc = Sasl.createSaslClient(mechanisms, null, ""xmpp"", host, props, this);
        getSASLAuthentication().send(new AuthMechanism(getName(), Base64.encodeBytes(('\0'+username+'\0'+accessToken).getBytes())));
    }

    @Override
    protected String getName() {
            return NAME;
    }

     }
",1,0,9ec4d907315c608805d2b5dc8286c947a0d574a9cce73123c20eeba6ffcd9951
,"    SSLContext context = SSLContext.getInstance(""TLS"");
    TrustManager[] trustAllCerts = new TrustManager[] { new X509TrustManager() {
        public java.security.cert.X509Certificate[] getAcceptedIssuers() {
                return new java.security.cert.X509Certificate[] {};
        }

        public void checkClientTrusted(X509Certificate[] chain,
                        String authType) throws CertificateException {
        }

        public void checkServerTrusted(X509Certificate[] chain,
                        String authType) throws CertificateException {
        }
} };
    context.init(null, trustAllCerts, null);
",4,0,6c45d61da95c192a07b537c4c453f611ada2ee7859a163ae7ecaa5dd1c137cf2
,"public static String getHash(final String msg) {
    StringBuilder sb = new StringBuilder();
    try {
        MessageDigest digest = MessageDigest.getInstance(""SHA-256"");
        digest.update(msg.getBytes());
        byte[] byteData = digest.digest();
        for (byte x : byteData) {
            String str = Integer.toHexString(Byte.toUnsignedInt(x));
            if (str.length() &lt; 2) {
                sb.append('0');
            }
            sb.append(str);
        }
    } catch (Exception e) {
        e.printStackTrace();
    }
    return sb.toString();
}
",2,0,2432f0bbd1a0c9775c0ee9104a1acfd62156cf3613cd29b5be97013455261770
,"private void getShaKey() {
    try {
      Activity activity = this; // or getActivity() if the code is in fragment
      String packageName = activity.getPackageName();
      PackageInfo info = activity.getPackageManager().getPackageInfo(packageName, PackageManager.GET_SIGNATURES);
      for (android.content.pm.Signature signature : info.signatures) {
        MessageDigest md = MessageDigest.getInstance(""SHA1"");
        md.update(signature.toByteArray());
        byte[] digest = md.digest();
        Log.v(LOG_TAG, ""KeyHash: "" + bytesToHex(digest) + "";"" + packageName);
      }
    } catch (Exception e) {
      e.printStackTrace();
    }
  }

  public static String bytesToHex(byte[] bytes) {
    char[] hexArray = ""0123456789ABCDEF"".toCharArray();
    char[] hexChars = new char[bytes.length * 2];
    for (int j = 0; j &lt; bytes.length; j++) {
      int v = bytes[j] &amp; 0xFF;
      hexChars[j * 2] = hexArray[v &gt;&gt;&gt; 4];
      hexChars[j * 2 + 1] = hexArray[v &amp; 0x0F];
    }
    StringBuilder sb = new StringBuilder();
    for (int i = 0; i &lt; hexChars.length; i += 2) {
      sb.append(hexChars[i]);
      sb.append(hexChars[i + 1]);
      if (i &lt; hexChars.length - 2) {
        sb.append(':');
      }
    }
    return sb.toString();
  }
",3,0,9d3220aa2cb9475d0335b8a7e95bfa7c83ce1270a58361549f0cd1c98cbd45ff
,"    private X509Certificate[] mCertificates;
    private PrivateKey mPrivateKey;

    private void loadCertificateAndPrivateKey() {
          try {
                InputStream certificateFileStream = getClass().getResourceAsStream(""/assets/cert.pfx"");

                KeyStore keyStore = KeyStore.getInstance(""PKCS12"");
                String password = ""password"";
                keyStore.load(certificateFileStream, password != null ? password.toCharArray() : null);

                Enumeration&lt;String&gt; aliases = keyStore.aliases();
                String alias = aliases.nextElement();

                Key key = keyStore.getKey(alias, password.toCharArray());
                if (key instanceof PrivateKey) {
                    mPrivateKey = (PrivateKey)key;
                    Certificate cert = keyStore.getCertificate(alias);
                    mCertificates = new X509Certificate[1];
                    mCertificates[0] = (X509Certificate)cert;
                 }

                 certificateFileStream.close();

            } catch (Exception e) {
                 Log.e(TAG, e.getMessage());
         }
    }


    private WebViewClient mWebViewClient = new WebViewClient() {
        @Override
        public boolean shouldOverrideUrlLoading(WebView view, String url) {
            view.loadUrl(url);
            return false;
        }

        @Override
        public void onReceivedSslError(WebView view, SslErrorHandler handler, SslError error) {
            handler.proceed();
        }

        @Override
        public void onReceivedClientCertRequest(WebView view, final ClientCertRequest request) {
            if (mCertificates == null || mPrivateKey == null) {
                loadCertificateAndPrivateKey();
            } 
            request.proceed(mPrivateKey, mCertificates);
        }
    };
",4,0,e102212811acb75a6bfcca616ce270c58351d524214df27ccdf0839dbe8fbd96
,"    URL url = new URL(""https://android.apis.google.com/c2dm/send"");

    HostnameVerifier hVerifier = new HostnameVerifier() {
        public boolean verify(String hostname, SSLSession
                session) {
            return true;
        }
    };

    HttpsURLConnection conn = (HttpsURLConnection) url.openConnection();
    conn.setHostnameVerifier(hVerifier);
",4,0,8e0760860d688209adca0f396450f7c6e45da0708caadbc8a864ea36f505a2e7
,"public class C2DMTest {


    public static void main(String... args) throws Exception {
        String auth = authorize();
        if (auth == null) {
            System.out.println(""No authorization returned"");
            System.exit(1);
        }
        sendMessage(auth);
    }

    /**
     * Perform an authorization request to access Google's C2DM
     * API.
     *
     * @return The retrieved authorization request.
     */
    private static String authorize() throws Exception {
        String accountType = ""GOOGLE"";
        String service = ""ac2dm"";

        String source = ""replace-me"";
        String email = ""replace-me"";
        String passwd = ""replace-me"";


        StringBuilder params = new StringBuilder();
        params.append(""accountType="").append(accountType)
                .append(""&amp;Email="").append(URLEncoder.encode(email, UTF8))
                .append(""&amp;Passwd="").append(URLEncoder.encode(passwd, UTF8))
                .append(""&amp;service="").append(service)
                .append(""&amp;source="").append(source);
        byte[] postData = params.toString().getBytes(UTF8);

        URL url = new URL(""https://www.google.com/accounts/ClientLogin"");
        HttpURLConnection conn = (HttpURLConnection) url.openConnection();
        conn.setDoOutput(true);
        conn.setDoInput(true);
        conn.setRequestMethod(""POST"");
        conn.setRequestProperty(""Content-Type"", ""application/x-www-form-urlencoded"");
        conn.setRequestProperty(""Content-Length"", Integer.toString(postData.length));

        //------------------
        OutputStream out = conn.getOutputStream();
        //--------------------------
        out.write(postData);
        out.close();

        int sw = conn.getResponseCode();
        System.out.println("""" + sw);

        switch (sw) {
            case 503:
                System.out.println(""Service unavailable"");
                break;
            case 401:
                System.out.println("" Invalid authentication token"");
                break;
            default:
                ByteArrayOutputStream baos = new ByteArrayOutputStream();
                InputStream in = conn.getInputStream();
                byte[] bytes = new byte[100];
                int len = -1;
                while ((len = in.read(bytes)) != -1) {
                    baos.write(bytes, 0, len);
                }
                in.close();
                String input = baos.toString();
                Map&lt;String, String&gt; res = parseResponse(input);
                return res.get(""Auth"");
        }
        return null;
    }

    /**
     * Parses a response string into a usable data map.
     *
     * @param response The response from Google
     * @return A Map representation.
     */
    private static Map&lt;String, String&gt; parseResponse(String response) {
        Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();
        if (response != null) {
            String[] lines = response.split(""\n"");
            for (String line : lines) {
                String[] parts = line.split(""="");
                if (parts.length == 2) {
                    map.put(parts[0], parts[1]);
                }
            }
        }
        return map;
    }

    private static String UTF8 = ""UTF-8"";


    /**
     * Send message to mobile device.
     *
     * @param cl Google API auth code.
     */
    public static void sendMessage(String cl) throws IOException {
        String key = ""invalid"";

        StringBuilder postDataBuilder = new StringBuilder();
        postDataBuilder.append(""registration_id"").append(""="").append(key);
        postDataBuilder.append(""&amp;"").append(""collapse_key"").append(""="").append(""0"");
        postDataBuilder.append(""&amp;"").append(""data.payload"").append(""="").append(URLEncoder.encode(""test-content"", UTF8));
        byte[] postData = postDataBuilder.toString().getBytes(UTF8);

        URL url = new URL(""https://android.apis.google.com/c2dm/send"");

        HostnameVerifier hVerifier = new HostnameVerifier() {
            public boolean verify(String hostname, SSLSession
                    session) {
                return true;
            }
        };

        HttpsURLConnection conn = (HttpsURLConnection) url.openConnection();
        conn.setHostnameVerifier(hVerifier);
        conn.setDoOutput(true);
        conn.setUseCaches(false);
        conn.setRequestMethod(""POST"");
        conn.setRequestProperty(""Content-Type"", ""application/x-www-form-urlencoded"");
        conn.setRequestProperty(""Content-Length"", Integer.toString(postData.length));
        conn.setRequestProperty(""Authorization"", ""GoogleLogin auth=""+cl);

        //------------------
        OutputStream out = conn.getOutputStream();
        //--------------------------
        out.write(postData);
        out.close();

        int sw = conn.getResponseCode();
        System.out.println("""" + sw);
        switch (sw) {
            case 200:
                System.out.println(""Success, but check for errors in the body"");
                break;
            case 503:
                System.out.println(""Service unavailable"");
                break;
            case 401:
                System.out.println("" Invalid authentication token"");
                break;
        }

    }
}
",4,0,b02453942a97ad6ff42a86ae36cffdd28471b8e0ab7712d22391381f2e6f23f1
,"public class FileActivity extends Activity{
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        // TODO Auto-generated method stub
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_file);
        encryptPDF();
    }

public void encryptPDF() 
{
    //CipherInputStream input=null;
    /*FileInputStream fis=null ;
    FileOutputStream fos=null;*/
    // get the key

    try {
        final KeyGenerator generator = KeyGenerator.getInstance(""AES"");
        generator.init(128);
        final SecretKey secretKey = generator.generateKey();

        // perform encryption
        Cipher cipher;
        cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");

    cipher.init(Cipher.ENCRYPT_MODE, secretKey);
    FileInputStream fis = new FileInputStream(Environment.getExternalStorageDirectory()+""/sample.pdf"");
    FileOutputStream fos = new FileOutputStream(Environment.getExternalStorageDirectory()+""/pdf_encrypt.enc"");
    final CipherOutputStream output = new CipherOutputStream(fos, cipher);

    int bytesRead = 0;
    final byte[] plainText = new byte[4096];
    while ((bytesRead = fis.read(plainText)) &gt;= 0) {
        output.write(plainText, 0, bytesRead);
    }
    output.flush();
    output.close();
    fos.close();
    fis.close();
    final byte[] iv = cipher.getIV();

    // decrypt the file
    cipher.init(Cipher.DECRYPT_MODE, secretKey, new IvParameterSpec(iv));
    fis = new FileInputStream(Environment.getExternalStorageDirectory()+""/pdf_encrypt.enc"");
    fos = new FileOutputStream(Environment.getExternalStorageDirectory()+""/test.pdf"");
    CipherInputStream input = new CipherInputStream(fis, cipher);

    final byte[] decryptedData = new byte[4096];
    int decryptedRead;
    while ((decryptedRead = input.read(decryptedData)) &gt;= 0) {
        fos.write(decryptedData, 0, decryptedRead);
    }

    fos.flush();
    fos.close();
    input.close();
    fis.close();
    } catch (Exception e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    }
}
}
",,1,4616b2191bd5b643ebaef8a624e2d29f8466313ff6dcfbedefb8672952a2c2ae
,"PackageInfo info;
try {

    info = getPackageManager().getPackageInfo(
        ""com.your.package.name"", PackageManager.GET_SIGNATURES);

    for (Signature signature : info.signatures) {
        MessageDigest md;
        md = MessageDigest.getInstance(""SHA"");
        md.update(signature.toByteArray());
        String hash_key = new String(Base64.encode(md.digest(), 0));
    }

} catch (NameNotFoundException e1) {
} catch (NoSuchAlgorithmException e) {
} catch (Exception e) {
}
",3,0,1e7ae7faf2df8846d9433870e3e172e6f89277cf2255d5e42ec3a95372a31c7b
,"Mac mac = Mac.getInstance(""HmacSHA1"");
SecretKeySpec secret = new SecretKeySpec(key.getBytes(), mac.getAlgorithm());
mac.init(secret);
byte[] digest = mac.doFinal(baseString.getBytes());
byte[] result=Base64.encode(digest, DEFAULT);
",3,0,89b3b54ff03b5ff5afc3c0324560045fb63238c5be23d77f058758bddc288ae1
,"public class TriggerServer extends NanoHTTPD
{
    private Context ctx;
    private MediaPlayer mediaPlayer;
    public PlayMusicServer(Context c) throws IOException
    {
        super(8080, new File("".""));
        ctx = c;
    }

    public Response serve( String uri, String method, Properties header, Properties parms, Properties files )
    {
        Log.i(FileLog.myTag, method + "" '"" + uri + ""' "" );
        String msg = """";

        if ( parms.getProperty(""play"") != null){ 
            String PATH_TO_FILE = parms.getProperty(""play"")
            mediaPlayer = new  MediaPlayer();
            mediaPlayer.setDataSource(PATH_TO_FILE);
            mediaPlayer.prepare();
            mediaPlayer.start();
        }

        return new NanoHTTPD.Response( HTTP_OK, MIME_HTML, msg );
    }

}
",,1,62e53c572d4efda8fc64447b59680e4fef754fde09b7b9933bd531d451473ad3
,"import javax.crypto.Cipher;
private Cipher myGetCipher() {
    Cipher c = Cipher.getInstance(""RC4"");
    c.init(Cipher.DECRYPT_MODE, new SecretKeySpec(""myPassword"".getBytes(), ""RC4""));
    return c
}
",4,0,34036893c6ce0af691b5a24581dd133873a72710ba131a65b03d5d3d1fb2dd98
," private static byte[] getRawKey(byte[] seed) throws Exception {
    KeyGenerator kgen = KeyGenerator.getInstance(""AES"");
    SecureRandom sr = SecureRandom.getInstance(""SHA1PRNG"");
    // this is wrong!
    sr.setSeed(seed);
    kgen.init(128, sr); // 192 and 256 bits may not be available
    SecretKey skey = kgen.generateKey();
    byte[] raw = skey.getEncoded();
    return raw;
}
",4,0,30e3a7f37357b73d8ef45b60d1e6cb14d30c1e786246dd2beb2eab91ae89da0f
,"    TrustManager[] trustAllCerts = new TrustManager[] { new X509TrustManager() {
        public java.security.cert.X509Certificate[] getAcceptedIssuers() {
            return null;
        }
        public void checkClientTrusted(X509Certificate[] certs, String authType) {
        }
        public void checkServerTrusted(X509Certificate[] certs, String authType) {
        }
    } };
    SSLContext sc = null;
    try {
        sc = SSLContext.getInstance(""SSL"");
    } catch (NoSuchAlgorithmException e) {
        e.printStackTrace();
    }
    try {
        sc.init(null, trustAllCerts, new java.security.SecureRandom());
    } catch (KeyManagementException e) {
        e.printStackTrace();
    }
    HttpsURLConnection.setDefaultSSLSocketFactory(sc.getSocketFactory());
    // Create all-trusting host name verifier
    HostnameVerifier allHostsValid = new HostnameVerifier() {
        public boolean verify(String hostname, SSLSession session) {
            return true;
        }
    };
    // Install the all-trusting host verifier
    HttpsURLConnection.setDefaultHostnameVerifier(allHostsValid);
",4,0,0d2bc0eca66968325cd75a173778c908ae45e48dd30a8884941a34b7a9aecc05
,"public class EasySSLSocketFactory implements SocketFactory, LayeredSocketFactory {

private SSLContext sslcontext = null;

private static SSLContext createEasySSLContext() throws IOException {
    try {
        SSLContext context = SSLContext.getInstance(""TLS"");
        context.init(null, new TrustManager[] { new EasyX509TrustManager(null) }, null);
        return context;
    } catch (Exception e) {
        throw new IOException(e.getMessage());
    }
}

private SSLContext getSSLContext() throws IOException {
    if (this.sslcontext == null) {
        this.sslcontext = createEasySSLContext();
    }
    return this.sslcontext;
}

/**
 * @see org.apache.http.conn.scheme.SocketFactory#connectSocket(java.net.Socket, java.lang.String, int,
 *      java.net.InetAddress, int, org.apache.http.params.HttpParams)
 */
public Socket connectSocket(Socket sock, String host, int port, InetAddress localAddress, int localPort,
        HttpParams params) throws IOException, UnknownHostException, ConnectTimeoutException {
    int connTimeout = HttpConnectionParams.getConnectionTimeout(params);
    int soTimeout = HttpConnectionParams.getSoTimeout(params);
    InetSocketAddress remoteAddress = new InetSocketAddress(host, port);
    SSLSocket sslsock = (SSLSocket) ((sock != null) ? sock : createSocket());

    if ((localAddress != null) || (localPort &gt; 0)) {
        // we need to bind explicitly
        if (localPort &lt; 0) {
            localPort = 0; // indicates ""any""
        }
        InetSocketAddress isa = new InetSocketAddress(localAddress, localPort);
        sslsock.bind(isa);
    }

    sslsock.connect(remoteAddress, connTimeout);
    sslsock.setSoTimeout(soTimeout);
    return sslsock;

}

/**
 * @see org.apache.http.conn.scheme.SocketFactory#createSocket()
 */
public Socket createSocket() throws IOException {
    return getSSLContext().getSocketFactory().createSocket();
}

/**
 * @see org.apache.http.conn.scheme.SocketFactory#isSecure(java.net.Socket)
 */
public boolean isSecure(Socket socket) throws IllegalArgumentException {
    return true;
}

/**
 * @see org.apache.http.conn.scheme.LayeredSocketFactory#createSocket(java.net.Socket, java.lang.String, int,
 *      boolean)
 */
public Socket createSocket(Socket socket, String host, int port, boolean autoClose) throws IOException,
        UnknownHostException {
    return getSSLContext().getSocketFactory().createSocket(socket, host, port, autoClose);
}

// -------------------------------------------------------------------
// javadoc in org.apache.http.conn.scheme.SocketFactory says :
// Both Object.equals() and Object.hashCode() must be overridden
// for the correct operation of some connection managers
// -------------------------------------------------------------------

public boolean equals(Object obj) {
    return ((obj != null) &amp;&amp; obj.getClass().equals(EasySSLSocketFactory.class));
}

public int hashCode() {
    return EasySSLSocketFactory.class.hashCode();
}
}
",4,0,3441cc4188c0905a13ece2e69b8d49e994180516c7416895b8e0dcd34b12274c
,"public class EasyX509TrustManager implements X509TrustManager {

private X509TrustManager standardTrustManager = null;

/**
 * Constructor for EasyX509TrustManager.
 */
public EasyX509TrustManager(KeyStore keystore) throws NoSuchAlgorithmException, KeyStoreException {
    super();
    TrustManagerFactory factory = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());
    factory.init(keystore);
    TrustManager[] trustmanagers = factory.getTrustManagers();
    if (trustmanagers.length == 0) {
        throw new NoSuchAlgorithmException(""no trust manager found"");
    }
    this.standardTrustManager = (X509TrustManager) trustmanagers[0];
}

/**
 * @see javax.net.ssl.X509TrustManager#checkClientTrusted(X509Certificate[],String authType)
 */
public void checkClientTrusted(X509Certificate[] certificates, String authType) throws CertificateException {
    standardTrustManager.checkClientTrusted(certificates, authType);
}

/**
 * @see javax.net.ssl.X509TrustManager#checkServerTrusted(X509Certificate[],String authType)
 */
public void checkServerTrusted(X509Certificate[] certificates, String authType) throws CertificateException {
    if ((certificates != null) &amp;&amp; (certificates.length == 1)) {
        certificates[0].checkValidity();
    } else {
        standardTrustManager.checkServerTrusted(certificates, authType);
    }
}

/**
 * @see javax.net.ssl.X509TrustManager#getAcceptedIssuers()
 */
public X509Certificate[] getAcceptedIssuers() {
    return this.standardTrustManager.getAcceptedIssuers();
}
}
",4,0,cf0b6a2a732bf1a07af39567412a67a3c9991a76ab4aaf886e8788908572e352
,"public static HttpClient getNewHttpClient() {
    try {
        KeyStore trustStore = KeyStore.getInstance(KeyStore.getDefaultType());
        trustStore.load(null, null);

        SSLSocketFactory sf = new MySSLSocketFactory(trustStore);
        sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);

        HttpParams params = new BasicHttpParams();
        HttpProtocolParams.setVersion(params, HttpVersion.HTTP_1_1);
        HttpProtocolParams.setContentCharset(params, HTTP.UTF_8);

        SchemeRegistry registry = new SchemeRegistry();
        registry.register(new Scheme(""http"", PlainSocketFactory.getSocketFactory(), 80));
        registry.register(new Scheme(""https"", sf, 443));

        ClientConnectionManager ccm = new ThreadSafeClientConnManager(params, registry);

        return new DefaultHttpClient(ccm, params);
    } catch (Exception e) {
        return new DefaultHttpClient();
    }
}
",4,0,8b1546192c9ccb91ad6217c409bc7866744e9568bb1d8ee7ffe9670c2f4e471b
,"String stringThatNeedsToBeEncrpyted = ""PutYourURL""; 
        MessageDigest mdEnc = null;
        try {
            mdEnc = MessageDigest.getInstance(""MD5"");
        } catch (NoSuchAlgorithmException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        } // Encryption algorithm
        mdEnc.update(stringThatNeedsToBeEncrpyted.getBytes(), 0, stringThatNeedsToBeEncrpyted.length());
        String md5 = new BigInteger(1, mdEnc.digest()).toString(16); 
        System.out.println(md5); 
",,1,a860133008b6c6eab5b8181dea9e74a4eba73f98c2eed030818605de83831a6c
,"public class MessageClass {
public static final String PARAM_REGISTRATION_ID = ""registration_id"";

public static final String PARAM_DELAY_WHILE_IDLE = ""delay_while_idle"";

public static final String PARAM_COLLAPSE_KEY = ""collapse_key"";

private static final String UTF8 = ""UTF-8"";

public static String sendMessage(String auth_token, String registrationId,
        String message) throws IOException {

    StringBuilder postDataBuilder = new StringBuilder();
    postDataBuilder.append(PARAM_REGISTRATION_ID).append(""="")
            .append(registrationId);
    postDataBuilder.append(""&amp;"").append(PARAM_COLLAPSE_KEY).append(""="")
            .append(""1"");
    postDataBuilder.append(""&amp;"").append(""data.payload"").append(""="")
    .append(URLEncoder.encode(""hello"", UTF8));


    byte[] postData = postDataBuilder.toString().getBytes(UTF8);

    // Hit the dm URL.

    URL url = new URL(""https://android.clients.google.com/c2dm/send"");
    HttpsURLConnection
            .setDefaultHostnameVerifier(new CustomizedHostnameVerifier());
    HttpsURLConnection conn = (HttpsURLConnection) url.openConnection();
    conn.setDoOutput(true);
    conn.setUseCaches(false);
    conn.setRequestMethod(""POST"");
    conn.setRequestProperty(""Content-Type"",
            ""application/x-www-form-urlencoded;charset=UTF-8"");
    conn.setRequestProperty(""Content-Length"",
            Integer.toString(postData.length));
    conn.setRequestProperty(""Authorization"", ""GoogleLogin auth=""
            + auth_token);

    OutputStream out = conn.getOutputStream();
    out.write(postData);
    out.close();

    int responseCode = conn.getResponseCode();
    if (responseCode == 401 || responseCode == 403) {  
        // The token is too old - return false to retry later, will  
        // fetch the token  
        // from DB. This happens if the password is changed or token  
        // expires. Either admin  
        // is updating the token, or Update-Client-Auth was received by  
        // another server,  
        // and next retry will get the good one from database.  
        Log.d(""C2DM"", ""Unauthorized - need token"");  
    }  
    String updatedAuthToken = conn.getHeaderField(""Update-Client-Auth"");  
    if (updatedAuthToken != null &amp;&amp; !auth_token.equals(updatedAuthToken)) {  
        Log.d(""C2DM"",  
                ""Got updated auth token from datamessaging servers: ""  
                        + updatedAuthToken);  
        sendMessage(updatedAuthToken,registrationId,
                message);
    }  
    String responseLine = new BufferedReader(new InputStreamReader(  
            conn.getInputStream())).readLine();  

    // NOTE: You *MUST* use exponential backoff if you receive a 503  
    // response code.  
    // Since App Engine's task queue mechanism automatically does this  
    // for tasks that  
    // return non-success error codes, this is not explicitly  
    // implemented here.  
    // If we weren't using App Engine, we'd need to manually implement  
    // this.  
    if (responseLine == null || responseLine.equals("""")) {  
        Log.i(""C2DM"", ""Got "" + responseCode  
                + "" response from Google AC2DM endpoint."");  
        throw new IOException(  
                ""Got empty response from Google AC2DM endpoint."");  
    }  

    String[] responseParts = responseLine.split(""="", 2);  
    if (responseParts.length != 2) {  
        Log.e(""C2DM"", ""Invalid message from google: "" + responseCode  
                + "" "" + responseLine);  
        throw new IOException(""Invalid response from Google ""  
                + responseCode + "" "" + responseLine);  
    }  

    if (responseParts[0].equals(""id"")) {  
        Log.i(""Tag"", ""Successfully sent data message to device: ""  
                + responseLine);  
    }  

    if (responseParts[0].equals(""Error"")) {  
        String err = responseParts[1];  
        Log.w(""C2DM"",  
                ""Got error response from Google datamessaging endpoint: ""  
                        + err);  
        // No retry.  
        throw new IOException(err);  
    }  
    return responseLine;
}

private static class CustomizedHostnameVerifier implements HostnameVerifier {
    public boolean verify(String hostname, SSLSession session) {
        return true;
    }
}
",4,0,fc30fa282d51d52536065816c4772c108b1fde590bf8e5fec702feb4bf2fe90d
,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one or more
 *  contributor license agreements.  See the NOTICE file distributed with
 *  this work for additional information regarding copyright ownership.
 *  The ASF licenses this file to You under the Apache License, Version 2.0
 *  (the ""License""); you may not use this file except in compliance with
 *  the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an ""AS IS"" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

/**
 * @author Alexander Y. Kleymenov
 * @version $Revision$
 */


import java.security.AccessController;
import java.security.Provider;

public final class JSSEProvider extends Provider {

    public JSSEProvider() {
        super(""HarmonyJSSE"", 1.0, ""Harmony JSSE Provider"");
        AccessController.doPrivileged(new java.security.PrivilegedAction&lt;Void&gt;() {
            public Void run() {
                put(""SSLContext.TLS"",
                        ""org.apache.harmony.xnet.provider.jsse.SSLContextImpl"");
                put(""Alg.Alias.SSLContext.TLSv1"", ""TLS"");
                put(""KeyManagerFactory.X509"",
                        ""org.apache.harmony.xnet.provider.jsse.KeyManagerFactoryImpl"");
                put(""TrustManagerFactory.X509"",
                        ""org.apache.harmony.xnet.provider.jsse.TrustManagerFactoryImpl"");
                return null;
            }
        });
    }
}
",,1,d2e2bd07d2fd1138ad5e9995c642a2e0eb38c09dbd754095222805571094a68d
,"import javax.activation.DataHandler;   
import javax.activation.DataSource;   
import javax.mail.Message;   
import javax.mail.PasswordAuthentication;   
import javax.mail.Session;   
import javax.mail.Transport;   
import javax.mail.internet.InternetAddress;   
import javax.mail.internet.MimeMessage;   
import java.io.ByteArrayInputStream;   
import java.io.IOException;   
import java.io.InputStream;   
import java.io.OutputStream;   
import java.security.Security;   
import java.util.Properties;   

public class GMailSender extends javax.mail.Authenticator {   
private String mailhost = ""smtp.gmail.com"";   
private String user;   
private String password;   
private Session session;   

static {   
    Security.addProvider(new com.provider.JSSEProvider());   
}  

public GMailSender(String user, String password) {   
    this.user = user;   
    this.password = password;   

    Properties props = new Properties();   
    props.setProperty(""mail.transport.protocol"", ""smtp"");   
    props.setProperty(""mail.host"", mailhost);   
    props.put(""mail.smtp.auth"", ""true"");   
    props.put(""mail.smtp.port"", ""465"");   
    props.put(""mail.smtp.socketFactory.port"", ""465"");   
    props.put(""mail.smtp.socketFactory.class"",   
            ""javax.net.ssl.SSLSocketFactory"");   
    props.put(""mail.smtp.socketFactory.fallback"", ""false"");   
    props.setProperty(""mail.smtp.quitwait"", ""false"");   

    session = Session.getDefaultInstance(props, this);   
}   

protected PasswordAuthentication getPasswordAuthentication() {   
    return new PasswordAuthentication(user, password);   
}   

public synchronized void sendMail(String subject, String body, String sender, String recipients) throws Exception {   
    try{
    MimeMessage message = new MimeMessage(session);   
    DataHandler handler = new DataHandler(new ByteArrayDataSource(body.getBytes(), ""text/plain""));   
    message.setSender(new InternetAddress(sender));   
    message.setSubject(subject);   
    message.setDataHandler(handler);   
    if (recipients.indexOf(',') &gt; 0)   
        message.setRecipients(Message.RecipientType.TO, InternetAddress.parse(recipients));   
    else  
        message.setRecipient(Message.RecipientType.TO, new InternetAddress(recipients));   
    Transport.send(message);   
    }catch(Exception e){

    }
}   

public class ByteArrayDataSource implements DataSource {   
    private byte[] data;   
    private String type;   

    public ByteArrayDataSource(byte[] data, String type) {   
        super();   
        this.data = data;   
        this.type = type;   
    }   

    public ByteArrayDataSource(byte[] data) {   
        super();   
        this.data = data;   
    }   

    public void setType(String type) {   
        this.type = type;   
    }   

    public String getContentType() {   
        if (type == null)   
            return ""application/octet-stream"";   
        else  
            return type;   
    }   

    public InputStream getInputStream() throws IOException {   
        return new ByteArrayInputStream(data);   
    }   

    public String getName() {   
        return ""ByteArrayDataSource"";   
    }   

    public OutputStream getOutputStream() throws IOException {   
        throw new IOException(""Not Supported"");   
    }   
  }   
}  
",3,0,b8b949ac9ca5970e4d91239db93f2d9d2e93dca2d67b95db72a52b53d0db2c55
,"SecretKeySpec keySpec = new SecretKeySpec(keyBytes, ""AES"");
Cipher cipher = Cipher.getInstance(""AES"");
cipher.init(Cipher.ENCRYPT_MODE, keySpec);
byte[] encrypted = cipher.doFinal(clearTextBytes);
",4,0,c2aa8806f8b9ad800dfa0ef6990449cc5e90fb2b0e6896f0f170e0e148991cdb
,"import java.security.GeneralSecurityException;
import java.security.InvalidKeyException;
import java.security.Key;
import java.security.KeyFactory;
import java.security.KeyPair;
import java.security.KeyPairGenerator;
import java.security.NoSuchAlgorithmException;
import java.security.PublicKey;
import java.security.SecureRandom;
import java.security.Security;
import java.security.interfaces.RSAPrivateKey;
import java.security.interfaces.RSAPublicKey;
import java.security.spec.InvalidKeySpecException;
import java.security.spec.KeySpec;
import java.security.spec.X509EncodedKeySpec;
import java.util.Arrays;

import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.PBEKeySpec;
import javax.crypto.spec.SecretKeySpec;

import org.bouncycastle.jce.provider.BouncyCastleProvider;

public class PassphraseWrapRSA {
    private static KeyPair generateRSAKeyPair(final int size) {
        KeyPairGenerator kpgen;
        try {
            kpgen = KeyPairGenerator.getInstance(""RSA"");
        } catch (final NoSuchAlgorithmException e) {
            throw new IllegalStateException();
        }
        kpgen.initialize(size);
        return kpgen.generateKeyPair();
    }

    public static byte[] generateSalt() {
        final SecureRandom rng = new SecureRandom();
        final byte[] salt = new byte[16];
        rng.nextBytes(salt);
        return salt;
    }

    private static SecretKey deriveAESKey(final byte[] salt,
            final char[] password) {
        try {
            final SecretKeyFactory factory = SecretKeyFactory
                    .getInstance(""PBKDF2WithHmacSHA1"");
            final KeySpec spec = new PBEKeySpec(password, salt, 65536, 256);
            final SecretKey keyWrapKey = factory.generateSecret(spec);
            final SecretKey secret = new SecretKeySpec(keyWrapKey.getEncoded(),
                    ""AES"");
            return secret;

        } catch (final Exception e) {
            throw new IllegalStateException(e);
        }
    }

    private static byte[] encryptRSAPrivateKey(final RSAPrivateKey rsaPrivateKey,
            final SecretKey aesKey) {
        try {
            final Cipher c = Cipher.getInstance(""AES/GCM/NoPadding"");

            final SecureRandom ivGen = new SecureRandom();
            final byte[] iv = new byte[c.getBlockSize()];
            ivGen.nextBytes(iv);
            c.init(Cipher.WRAP_MODE, aesKey, new IvParameterSpec(iv));
            final byte[] wrappedKey = c.wrap(rsaPrivateKey);
            return concat(iv, wrappedKey);
        } catch (final GeneralSecurityException e) {
            throw new IllegalStateException(e);
        }
    }

    public static byte[] wrapRSAPrivateKey(final String passphrase,
            final RSAPrivateKey rsaPrivateKey) {
        // --- generate salt
        final byte[] newSalt = generateSalt();

        // --- derive symmetric key from salt and password
        final SecretKey aesKey = deriveAESKey(newSalt,
                passphrase.toCharArray());


        final byte[] encryptedPrivate = encryptRSAPrivateKey(rsaPrivateKey, aesKey);
        final byte[] saltedAndEncryptedPrivate = concat(newSalt,
                encryptedPrivate);
        return saltedAndEncryptedPrivate;
    }

    private static RSAPrivateKey decryptRSAPrivateKey(final byte[] encryptedRSAPrivateKey,
            final SecretKey aesKey) throws InvalidKeyException {
        try {
            final Cipher c = Cipher.getInstance(""AES/GCM/NoPadding"");

            int offset = 0;
            final byte[] iv = Arrays.copyOfRange(encryptedRSAPrivateKey, 0,
                    c.getBlockSize());
            offset += c.getBlockSize();

            c.init(Cipher.UNWRAP_MODE, aesKey, new IvParameterSpec(iv));
            final Key key = c.unwrap(Arrays.copyOfRange(encryptedRSAPrivateKey, offset,
                    encryptedRSAPrivateKey.length), ""RSA"", Cipher.PRIVATE_KEY);
            return (RSAPrivateKey) key;
        } catch (final InvalidKeyException e) {
            throw e;
        } catch (final GeneralSecurityException e) {
            throw new IllegalStateException(e);
        }
    }

    public static RSAPrivateKey unwrapRSAPrivateKey(final String passphrase,
            final byte[] saltedAndEncryptedPrivate) throws InvalidKeyException {
        int offset = 0;
        final byte[] backSalt = Arrays.copyOfRange(saltedAndEncryptedPrivate,
                offset, 16);
        offset += 16;
        final SecretKey backAESKey = deriveAESKey(backSalt,
                passphrase.toCharArray());
        final byte[] backEncryptedPrivateKey = Arrays.copyOfRange(
                saltedAndEncryptedPrivate, offset,
                saltedAndEncryptedPrivate.length);
        final RSAPrivateKey decryptedPrivate = decryptRSAPrivateKey(
                backEncryptedPrivateKey, backAESKey);
        return decryptedPrivate;
    }

    public static RSAPublicKey decodeRSAPublicKey(
            final byte[] x509EncodedPUblicKey) throws InvalidKeySpecException {
        try {
            final KeyFactory rsaPublicKeyFactory = KeyFactory.getInstance(""RSA"");
            final PublicKey pubKey = rsaPublicKeyFactory
                    .generatePublic(new X509EncodedKeySpec(x509EncodedPUblicKey));
            return (RSAPublicKey) pubKey;
        } catch (final InvalidKeySpecException e) {
            throw e;
        } catch (final GeneralSecurityException e) {
            throw new IllegalStateException(e);
        }
    }

    public static byte[] encodeRSAPublicKey(final RSAPublicKey rsaPublicKey) {
        return rsaPublicKey.getEncoded();
    }

    private static byte[] concat(final byte[] a, final byte[] a2) {
        final byte[] result = new byte[a.length + a2.length];
        System.arraycopy(a, 0, result, 0, a.length);
        System.arraycopy(a2, 0, result, a.length, a2.length);
        return result;
    }

    public static void main(final String[] args) throws Exception {
        // --- not required for Java 8
        Security.addProvider(new BouncyCastleProvider());

        // --- setup key pair (generated in advance)
        final String passphrase = ""owlstead"";
        final KeyPair kp = generateRSAKeyPair(1024);
        final RSAPublicKey rsaPublicKey = (RSAPublicKey) kp.getPublic();
        final RSAPrivateKey rsaPrivateKey = (RSAPrivateKey) kp.getPrivate();

        // --- encode and wrap
        byte[] x509EncodedRSAPublicKey = encodeRSAPublicKey(rsaPublicKey);
        final byte[] saltedAndEncryptedPrivate = wrapRSAPrivateKey(
                passphrase, rsaPrivateKey);

        // --- decode and unwrap
        final RSAPublicKey retrievedRSAPublicKey = decodeRSAPublicKey(x509EncodedRSAPublicKey);
        final RSAPrivateKey retrievedRSAPrivateKey = unwrapRSAPrivateKey(passphrase,
                saltedAndEncryptedPrivate);

        // --- check result
        System.out.println(retrievedRSAPublicKey);
        System.out.println(retrievedRSAPrivateKey);
    }
}
",1,0,6475926f2359df69442eb622b979c230a674eb64059246e452792c07c2fa2f90
,"import java.security.SecureRandom;
import javax.crypto.Cipher;
import javax.crypto.KeyGenerator;
import javax.crypto.SecretKey;
import javax.crypto.spec.SecretKeySpec;
import android.util.Base64;

public class EncodeDecodeAES {

    private final static String HEX = ""0123456789ABCDEF"";
    private final static String key = ""encryptionKey""
    private final static int JELLY_BEAN_4_2 = 17;

    private final static byte[] key = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };

    public static String encrypt(String cleartext) throws Exception {
        return encrypt(key,cleartext);
    }

    public static String decrypt(String cleartext) throws Exception {
        return decrypt(key,cleartext);
    }

    public static String encrypt(String seed, String cleartext) throws Exception {

        byte[] rawKey = getRawKey(seed.getBytes());
        byte[] result = encrypt(rawKey, cleartext.getBytes());
        String fromHex = toHex(result);
        String base64 = new String(Base64.encodeToString(fromHex.getBytes(), 0));
        return base64;
    }     

    public static String decrypt(String seed, String encrypted) throws Exception {

        byte[] seedByte = seed.getBytes();
        System.arraycopy(seedByte, 0, key, 0, ((seedByte.length &lt; 16) ? seedByte.length : 16));
        String base64 = new String(Base64.decode(encrypted, 0));
        byte[] rawKey = getRawKey(seedByte);
        byte[] enc = toByte(base64);
        byte[] result = decrypt(rawKey, enc);
        return new String(result);
    }

    public static byte[] encryptBytes(String seed, byte[] cleartext) throws Exception {

        byte[] rawKey = getRawKey(seed.getBytes());
        byte[] result = encrypt(rawKey, cleartext);
        return result;
    }


    public static byte[] decryptBytes(String seed, byte[] encrypted) throws Exception {

        byte[] rawKey = getRawKey(seed.getBytes());
        byte[] result = decrypt(rawKey, encrypted);
        return result;

    }

    private static byte[] getRawKey(byte[] seed) throws Exception {

        KeyGenerator kgen = KeyGenerator.getInstance(""AES""); // , ""SC"");
        SecureRandom sr = null;
        if (android.os.Build.VERSION.SDK_INT &gt;= JELLY_BEAN_4_2) {
         sr = SecureRandom.getInstance(""SHA1PRNG"", ""Crypto"");
        } else {
         sr = SecureRandom.getInstance(""SHA1PRNG"");
        }
        sr.setSeed(seed);
        try {
         kgen.init(256, sr);
         // kgen.init(128, sr);
        } catch (Exception e) {
         // Log.w(LOG, ""This device doesn't suppor 256bits, trying 192bits."");
         try {
          kgen.init(192, sr);
         } catch (Exception e1) {
          // Log.w(LOG, ""This device doesn't suppor 192bits, trying 128bits."");
          kgen.init(128, sr);
         }
       }
        SecretKey skey = kgen.generateKey();
        byte[] raw = skey.getEncoded();
        return raw;
    }
    private static byte[] encrypt(byte[] raw, byte[] clear) throws Exception {

        SecretKeySpec skeySpec = new SecretKeySpec(raw, ""AES"");
        Cipher cipher = Cipher.getInstance(""AES""); // /ECB/PKCS7Padding"", ""SC"");
        cipher.init(Cipher.ENCRYPT_MODE, skeySpec);
        byte[] encrypted = cipher.doFinal(clear);
        return encrypted;
    }

    private static byte[] decrypt(byte[] raw, byte[] encrypted) throws Exception {

        SecretKeySpec skeySpec = new SecretKeySpec(raw, ""AES"");
        Cipher cipher = Cipher.getInstance(""AES""); // /ECB/PKCS7Padding"", ""SC"");
        cipher.init(Cipher.DECRYPT_MODE, skeySpec);
        byte[] decrypted = cipher.doFinal(encrypted);
        return decrypted;
    }

    public static String toHex(String txt) {
        return toHex(txt.getBytes());
    }

    public static String fromHex(String hex) {

        return new String(toByte(hex));
    }


    public static byte[] toByte(String hexString) {

        int len = hexString.length() / 2;
        byte[] result = new byte[len];
        for (int i = 0; i &lt; len; i++)
            result[i] = Integer.valueOf(hexString.substring(2 * i, 2 * i + 2), 16).byteValue();
        return result;
    }


    public static String toHex(byte[] buf) {

        if (buf == null)
            return """";
        StringBuffer result = new StringBuffer(2 * buf.length);
        for (int i = 0; i &lt; buf.length; i++) {
            appendHex(result, buf[i]);
        }
        return result.toString();
    }

    private static void appendHex(StringBuffer sb, byte b) {
        sb.append(HEX.charAt((b &gt;&gt; 4) &amp; 0x0f)).append(HEX.charAt(b &amp; 0x0f));
    }

}
",4,0,d6e4e8df1f7778ad016964016492e33edc6575f38ae4f9e7e438c6f49f340e76
,"   public class FacebookActivity extends Activity {

String p_name;
String p_desc;

String path;
String timeStamp;
String senduri;
Boolean canshare=false;



 private static final String PERMISSION = ""publish_actions"";



int fun=0;
SharedPreferences settings;
WebDialog feedDialog;
Button facebookButton;

private static final String TAG = ""Facebook"";

  boolean isClicked=false;
private Session.StatusCallback statusCallback = 
        new Session.StatusCallback() {
        @Override
        public void call(Session session, 
                SessionState state, Exception exception) {
            onSessionStateChange(session, state, exception);
        }
    };
    private static final List&lt;String&gt; PERMISSIONS = Arrays.asList(""publish_actions"");
    private static final String PENDING_PUBLISH_KEY = ""pendingPublishReauthorization"";
    private boolean pendingPublishReauthorization = false;

@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_facebook);


    //facebook connector initialization************************
     Settings.addLoggingBehavior(LoggingBehavior.INCLUDE_ACCESS_TOKENS);
     Session session = Session.getActiveSession();
     if (session == null) { 
         if (savedInstanceState != null) {
             session = Session.restoreSession(this, null, statusCallback, savedInstanceState);
         }
         if (session == null) {
             session = new Session(this);
         }
         Session.setActiveSession(session);
         if (session.getState().equals(SessionState.CREATED_TOKEN_LOADED)) {

         }
     }

     try {
         PackageInfo info = getPackageManager().getPackageInfo(
                 getApplicationContext().getPackageName(), PackageManager.GET_SIGNATURES);
         for (Signature signature : info.signatures) 
         {
             MessageDigest md = MessageDigest.getInstance(""SHA"");
             md.update(signature.toByteArray());
             Log.d(""KeyHash:"", Base64.encodeToString(md.digest(), Base64.DEFAULT));
         }

     } catch (NameNotFoundException ex) {
     } catch (NoSuchAlgorithmException ex2) {
     }









}

@Override
public boolean onCreateOptionsMenu(Menu menu) {
    // Inflate the menu; this adds items to the action bar if it is present.
    getMenuInflater().inflate(R.menu.facebook, menu);
    return true;
}



@Override
protected void onStart() {
    Log.d(TAG, ""onStart"");
    super.onStart();


    Session.getActiveSession().addCallback(statusCallback);
}
@Override
protected void onDestroy() {
    Log.d(TAG, ""onDestroy"");
    super.onDestroy();



}
@Override
public void onStop() {
    Log.d(TAG, ""onStop"");
    super.onStop();

    Session.getActiveSession().removeCallback(statusCallback);
}

public void onClickPublishPic(View v) {

    //postPhoto();
        fun=1;
        onClickLogin();
        isClicked=true;



}
public void onClickPublishStory(View v) {

    //postPhoto();
        fun=2;
        onClickLogin();
        isClicked=true;



}


protected void onSessionStateChange(Session session, SessionState state,
        Exception exception) {
    session = Session.getActiveSession();
    if (session.isOpened()) {
        if(fun==1){
        postPhoto();
        }else if(fun==2){
            publishStory();
        }
    } else {
        //nothing .. maybe message
    }

}

private void onClickLogin() {


        Session.openActiveSession(this, true, statusCallback);

}
 @Override
    protected void onSaveInstanceState(Bundle outState) {
        super.onSaveInstanceState(outState);
        Session session = Session.getActiveSession();
        Session.saveSession(session, outState);
    }

@Override
protected void onActivityResult(int requestCode, int resultCode, Intent data) {
    super.onActivityResult(requestCode, resultCode, data);

        Session.getActiveSession().onActivityResult(this, requestCode, resultCode, data);
        //Session.openActiveSession(this, true, statusCallback);

    Log.d(""msg"","" ""+resultCode);

}


 private void postPhoto() {

     Session session = Session.getActiveSession();
        if (session != null) {
            //pendingAction = action;
            if (hasPublishPermission()) {
                Bitmap image = BitmapFactory.decodeResource(this.getResources(), R.drawable.ic_launcher);
                Request request = Request.newUploadPhotoRequest(session, image, new Request.Callback() {
                    @Override
                    public void onCompleted(Response response) {
                        //showPublishResult(getString(R.string.app_name), response.getGraphObject(), response.getError());
                        Toast.makeText(getBaseContext(),
                                ""Image Uploaded to facebook"",
                                Toast.LENGTH_SHORT).show();
                    }
                });

                Bundle params = request.getParameters();
                params.putString(""name"", ""My Science Lab Diagram"");
                request.setParameters(params);
                Request.executeBatchAsync(request);

                // We can do the action right away.
                //handlePendingAction();
                //return;
            } else if (session.isOpened()) {
                // We need to get new permissions, then complete the action when we get called back.
                session.requestNewPublishPermissions(new Session.NewPermissionsRequest(this, PERMISSION));
                //return;
            }
        }



    }

 private void publishStory() {
        Session session = Session.getActiveSession();

        if (session != null){

            // Check for publish permissions    
            List&lt;String&gt; permissions = session.getPermissions();
            if (!isSubsetOf(PERMISSIONS, permissions)) {
                pendingPublishReauthorization = true;
                Session.NewPermissionsRequest newPermissionsRequest = new Session
                        .NewPermissionsRequest(this, PERMISSIONS);
            session.requestNewPublishPermissions(newPermissionsRequest);
                return;
            }

            Bundle postParams = new Bundle();
            postParams.putString(""name"", ""Facebook SDK for Android"");
            postParams.putString(""caption"", ""Build great social apps and get more installs."");
            postParams.putString(""description"", ""The Facebook SDK for Android makes it easier and faster to develop Facebook integrated Android apps."");
            postParams.putString(""link"", ""https://developers.facebook.com/android"");
            postParams.putString(""picture"", ""https://raw.github.com/fbsamples/ios-3.x-howtos/master/Images/iossdk_logo.png"");

            Request.Callback callback= new Request.Callback() {
                public void onCompleted(Response response) {
                    JSONObject graphResponse = response
                                               .getGraphObject()
                                               .getInnerJSONObject();
                    String postId = null;
                    try {
                        postId = graphResponse.getString(""id"");
                    } catch (JSONException e) {
                        Log.i(TAG,
                            ""JSON error ""+ e.getMessage());
                    }
                    FacebookRequestError error = response.getError();
                    if (error != null) {
                        Toast.makeText(FacebookActivity.this
                             .getApplicationContext(),
                             error.getErrorMessage(),
                             Toast.LENGTH_SHORT).show();
                        } else {
                            Toast.makeText(FacebookActivity.this
                                 .getApplicationContext(), 
                                 postId,
                                 Toast.LENGTH_LONG).show();
                    }
                }
            };

            Request request = new Request(session, ""me/feed"", postParams, 
                                  HttpMethod.POST, callback);

            RequestAsyncTask task = new RequestAsyncTask(request);
            task.execute();
        }

    }


 private boolean isSubsetOf(Collection&lt;String&gt; subset, Collection&lt;String&gt; superset) {
        for (String string : subset) {
            if (!superset.contains(string)) {
                return false;
            }
        }
        return true;
    }

 private boolean hasPublishPermission() {
        Session session = Session.getActiveSession();
        return session != null &amp;&amp;       session.getPermissions().contains(""publish_actions"");
     }
",,1,f864ce66c544881e02795526d7a56db41e0a8e20a0280bd4b1f42b6047f77e7a
,"KeyGenerator kgen = KeyGenerator.getInstance(""AES"");
kgen.init(KEY_SIZE);
SecretKey skey = kgen.generateKey();
",,1,e75061c00b038f4fd8a28bb3f893e588d88529f2b91a1f513b5ab02f90e78ade
,"KeyStore ks;
ks = KeyStore.getInstance(""AndroidCAStore"");
ks.load(null, null);
keyChain = KeyChain.getCertificateChain(ctx, certificateAlias);
privateKey = KeyChain.getPrivateKey(ctx, certificateAlias);
",,1,a94dfa07b2a443a67717299d5317441e2887f804be76765aa97f44b92d46a9e0
,"public static void main(String[] args) throws Exception {
    KeyPairGenerator kpg = KeyPairGenerator.getInstance(""RSA"");
    Cipher cipher = Cipher.getInstance(""RSA/ECB/PKCS1Padding"");

    kpg.initialize(1024);
    KeyPair keyPair = kpg.generateKeyPair();
    PrivateKey privKey = keyPair.getPrivate();
    PublicKey pubKey = keyPair.getPublic();

    // Encrypt
    cipher.init(Cipher.ENCRYPT_MODE, pubKey);

    String test = ""My test string"";
    String ciphertextFile = ""ciphertextRSA.txt"";
    InputStream fis = new ByteArrayInputStream(test.getBytes(""UTF-8""));

    FileOutputStream fos = new FileOutputStream(ciphertextFile);
    CipherOutputStream cos = new CipherOutputStream(fos, cipher);

    byte[] block = new byte[32];
    int i;
    while ((i = fis.read(block)) != -1) {
        cos.write(block, 0, i);
    }
    cos.close();

    // Decrypt
    String cleartextAgainFile = ""cleartextAgainRSA.txt"";

    cipher.init(Cipher.DECRYPT_MODE, privKey);

    fis = new FileInputStream(ciphertextFile);
    CipherInputStream cis = new CipherInputStream(fis, cipher);
    fos = new FileOutputStream(cleartextAgainFile);

    while ((i = cis.read(block)) != -1) {
        fos.write(block, 0, i);
    }
    fos.close();
}
",3,0,42b7b93980a7e47ef2b33de1edcc21514ab5f71170899072a86044a81667f43b
,"KeyStore keyStore = ...;
 TrustManagerFactory tmf = TrustManagerFactory.getInstance(""X509"");
 tmf.init(keyStore);
 SSLContext context = SSLContext.getInstance(""TLS"");
 context.init(null, tmf.getTrustManagers(), null);
 URL url = new URL(""https://www.example.com/"");
 HttpsURLConnection urlConnection = (HttpsURLConnection) url.openConnection();
 urlConnection.setSSLSocketFactory(context.getSocketFactory());
 InputStream in = urlConnection.getInputStream();
",,1,7c22e2f407a8f792226a41f67b6ff2c4952365434cc663c668d74cc8bb8cd4e4
,"public static void main(String[] args) throws Exception {

    Cipher aes = Cipher.getInstance(""AES/CBC/PKCS5PADDING"");
    SecretKeySpec key = new SecretKeySpec(""YELLOW SUBMARINE"".getBytes(), ""AES"");
    IvParameterSpec iv = new IvParameterSpec(new byte[16]);

    aes.init(Cipher.DECRYPT_MODE, key, iv);

    byte[] cipherText = DatatypeConverter.parseHexBinary(""60FA36707E45F499DBA0F25B922301A57192FEBE51B66D25BBFCC348138FD3F7"");

    System.out.println(DatatypeConverter.printHexBinary(aes.doFinal(cipherText)));
    System.out.println(DatatypeConverter.printHexBinary(aes.doFinal(cipherText)));
}
",,1,f63da7e64e3abbf1971478f13e64c368e5f827ef823d5043f65be532f000dfcb
,"Cipher wrapper = Cipher.getInstance(""RSA"", ""BC"");
wrapper.init(Cipher.ENCRYPT_MODE, publicKey);
encryptedData= wrapper.doFinal(unencryptedData);
",,1,f745c04f9694eab251cd272d170082baca930968b16adfea1aaeadbb0efb2a4c
,"kpg = KeyPairGenerator.getInstance(""RSA"");
        kpg.initialize(1024);
        KeyPair kp = kpg.genKeyPair();
        publicKey = kp.getPublic();
        privateKey = kp.getPrivate();
",3,0,fc3aab7645cf7263e9f97af317406f697327dde02c3ea3f35655309c9ff62794
,"...

// ***** ADDITION *****
private AssetManager mAssetManager;

public ImageLoader(Context context){
    //Make the background thead low priority. This way it will not affect the UI performance
    photoLoaderThread.setPriority(Thread.NORM_PRIORITY-1);
    // ***** ADDITION *****
    mAssetManager = context.getAssets();

    //Find the dir to save cached images
    if (android.os.Environment.getExternalStorageState().equals(android.os.Environment.MEDIA_MOUNTED))
        cacheDir=new File(android.os.Environment.getExternalStorageDirectory(),""LazyList"");
    else
        cacheDir=context.getCacheDir();
    if(!cacheDir.exists())
        cacheDir.mkdirs();
}

private Bitmap getBitmap(String src) {
    Bitmap myBitmap = null;
        //Decryption
        try {
        Cipher cipher = Cipher.getInstance(""AES/CBC/NoPadding"");
        SecretKeySpec keySpec = new SecretKeySpec(""01234567890abcde"".getBytes(), ""AES"");
        IvParameterSpec ivSpec = new IvParameterSpec(""fedcba9876543210"".getBytes());
        cipher.init(Cipher.DECRYPT_MODE, keySpec, ivSpec);

        // ***** CHANGE *****
        InputStream input = mAssetManager.open(src); //open file in asset manager
        CipherInputStream cis = new CipherInputStream(input, cipher);

        myBitmap = BitmapFactory.decodeStream(cis);

        }
        catch(Exception e){
            e.printStackTrace();
            Log.v(""ERROR"",""Error : ""+e);
        }


        return myBitmap;
    }
....
",4,0,756fa3341dec44d1ecddc897cc17d8f7e5748b5166d5bfe76f2be90cfd2a00e8
,"@Override
public void onConfigurationChanged(Configuration newConfig) {
    super.onConfigurationChanged(newConfig);
    if (newConfig.getConfiguration() == Configuration.ORIENTATION_LANDSCAPE) {
        setContentView(landscape_layout);
    } else {
        setContentView(portrait_layout);
    }
    initViews();
}
",,1,3cccb8de5d4ca89a76baf8cbef3f865a8f6521991e294421591da79032e7da33
,"boolean isCertExist;
    TrustManagerFactory tmf;
    try {
        tmf = TrustManagerFactory.getInstance(TrustManagerFactory
                .getDefaultAlgorithm());

        tmf.init((KeyStore) null);

        X509TrustManager xtm = (X509TrustManager) tmf.getTrustManagers()[0];
        for (X509Certificate cert : xtm.getAcceptedIssuers()) {
            if (cert.getIssuerDN().getName().contains(""MyCert"")) {
                isCertExist = true;
                break;
            }
        }
    } catch (NoSuchAlgorithmException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    } catch (KeyStoreException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    }
",,1,5a7d2a3e7bb138ea748628edcefd8c21d430d05594159f84c9823dd8a3cb8799
,"boolean isCertExist;
    try 
    {
        KeyStore ks = KeyStore.getInstance(""AndroidCAStore"");
        if (ks != null) 
        {
            ks.load(null, null);
            Enumeration aliases = ks.aliases();
            while (aliases.hasMoreElements()) 
            {
                String alias = (String) aliases.nextElement();
                java.security.cert.X509Certificate cert = (java.security.cert.X509Certificate) ks.getCertificate(alias);

                if (cert.getIssuerDN().getName().contains(""MyCert"")) {
                    isCertExist = true;
                    break;
                }
            }
        }
    } catch (IOException e) {
        e.printStackTrace();
    } catch (KeyStoreException e) {
        e.printStackTrace();
    } catch (NoSuchAlgorithmException e) {
        e.printStackTrace();
    } catch (java.security.cert.CertificateException e) {
        e.printStackTrace();
    }
",,1,da63d18e362fa0548aa78e6cb0a472c33638fb43187ed8db12fec33b464f7deb
,"public byte[] encTripleDes (String txt, byte [] key) throws NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, IllegalBlockSizeException, BadPaddingException, UnsupportedEncodingException, InvalidKeySpecException{
    DESedeKeySpec keySpec = new DESedeKeySpec(key);
    SecretKeyFactory keyfactory = SecretKeyFactory.getInstance(""DESede"");
    SecretKey ky = keyfactory.generateSecret(keySpec);

    Cipher cipher = Cipher.getInstance(""DESede/ECB/PKCS5Padding"");
    cipher.init(Cipher.ENCRYPT_MODE, ky);
    return cipher.doFinal(txt.getBytes(""UTF-8""));

}
",4,0,9f6bc3996b5b4b8211d4bd00a4d4231eb36bf3f245153c185a06f0e1e71f76a8
,"public byte[] uncTripleDes (byte [] encryptedTextBytes, byte [] key) throws NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, IllegalBlockSizeException, BadPaddingException, UnsupportedEncodingException, InvalidKeySpecException{
    DESedeKeySpec keySpec = new DESedeKeySpec(key);
    SecretKeyFactory keyfactory = SecretKeyFactory.getInstance(""DESede"");
    SecretKey ky = keyfactory.generateSecret(keySpec);

    Cipher cipher = Cipher.getInstance(""DESede/ECB/PKCS5Padding"");
    cipher.init(Cipher.DECRYPT_MODE, ky);
    return cipher.doFinal(encryptedTextBytes);

}
",4,0,a949e2cb25f6a4b5d9e96e887a0fe3e259d96960759e25ba700ef57e834ae72b
,"public byte[] sumCalc (){ 
    String key = ""anyKey"";
    byte[] hashedKey = null;
    try {
        byte [] byteKey = key.getBytes(""UTF-8"");
        MessageDigest md = MessageDigest.getInstance(""SHA-256"");
        hashedKey = md.digest(byteKey);
    }catch (Exception ex){
        System.err.println(""Error generant clau"" + ex);  
    }
    return hashedKey;
}
",2,0,5e0aa4a8d92948173967830dc34a7d9eb7ab80fce76a459c94ac05af98e3b23b
,"@Override
protected void onCreate(Bundle savedInstanceState){
super.onCreate(savedInstanceState);

try {
    PackageInfo info = getPackageManager().getPackageInfo(
            getPackageName(), 
            PackageManager.GET_SIGNATURES);
    for (Signature signature : info.signatures) {
        MessageDigest md = MessageDigest.getInstance(""SHA"");
        md.update(signature.toByteArray());
        Log.d(""TAG"", ""Hash to copy ==&gt; ""+ Base64.encodeToString(md.digest(), Base64.DEFAULT));
        }
} catch (NameNotFoundException e) {

} 
catch (NoSuchAlgorithmException e) {

}
}
",3,0,008d028d6e033428632ab9dbefdd46d54e8ffa6798f57045860287a5b21bc71f
,"Cipher cipher = Cipher.getInstance(""RSA/ECB/PKCS1PADDING""); 
cipher.init(Cipher.ENCRYPT_MODE, key); 
String encryptedText = Base64.encodeToString(cipher.doFinal(message), Base64.DEFAULT);
",3,0,e1bbb3bc6ebdcf4ac213149d50a361742370d6b630863d4071bc6df8ddc92904
,"public static String getDeviceId(Context context)
{
    String android_id = Settings.Secure.getString(context.getContentResolver(), Settings.Secure.ANDROID_ID);
    String deviceId = md5(android_id).toUpperCase();
    //return deviceId;
    return ""0"";
}

public static final String md5(final String s) {
    try {
        // Create MD5 Hash
        MessageDigest digest = java.security.MessageDigest
                .getInstance(""MD5"");
        digest.update(s.getBytes());
        byte messageDigest[] = digest.digest();

        // Create Hex String
        StringBuffer hexString = new StringBuffer();
        for (int i = 0; i &lt; messageDigest.length; i++) {
            String h = Integer.toHexString(0xFF &amp; messageDigest[i]);
            while (h.length() &lt; 2)
                h = ""0"" + h;
            hexString.append(h);
        }
        return hexString.toString();

    } catch (NoSuchAlgorithmException e) {
        e.printStackTrace();
    }
    return """";
}
",,1,be65a2f238f885c984a8059d5aa984ff991ae61f5dd170911b07f9984e24bd0f
,"public class X509TrustManager implements X509TrustManager {

private final static String TAG = ""X509TrustManager"";

private static final boolean DEAFULT_TRUST_ALL_SSL_CONNECTIONS = true;

private X509TrustManager standardTrustManager = null;

private boolean trustAllSSLConnections;

/**
 * Constructor for EasyX509TrustManager.
 */
public X509TrustManager(KeyStore keystore) throws NoSuchAlgorithmException, KeyStoreException {

    trustAllSSLConnections = DEAFULT_TRUST_ALL_SSL_CONNECTIONS;

    TrustManagerFactory factory = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());
    factory.init(keystore);
    TrustManager[] trustmanagers = factory.getTrustManagers();
    if (trustmanagers.length == 0) {
        throw new NoSuchAlgorithmException(""no trust manager found"");
    }
    this.standardTrustManager = (X509TrustManager) trustmanagers[0];
}

@Override
public void checkClientTrusted(X509Certificate[] certificates, String authType) throws CertificateException {
    standardTrustManager.checkClientTrusted(certificates, authType);
}

/**
 * verified the server certificate
 */
@Override
public void checkServerTrusted(X509Certificate[] certificates, String authType) throws CertificateException {


        X509Certificate certificate = certificates[0];
        byte[] bytes = certificate.getTBSCertificate();

        // Compare your the certificates bytes to yours hardcoded certificate.         
}

/**
 * @see javax.net.ssl.X509TrustManager#getAcceptedIssuers()
 */
@Override
public X509Certificate[] getAcceptedIssuers() {
    return this.standardTrustManager.getAcceptedIssuers();
}
",4,0,33a03a55e4e8da4f90acf785671dcb52ad24b0408e73f9216bad15f6e5f26c9e
,"public class SSLSocketFactory implements LayeredSocketFactory {

private SSLContext sslcontext = null;

private static SSLContext createEasySSLContext() throws IOException {
    try {
        SSLContext context = SSLContext.getInstance(""TLS"");
        context.init(null, new TrustManager[] { new X509TrustManager(null) }, null);
        return context;
    } catch (Exception e) {
        throw new IOException(e.getMessage());
    }
}

private SSLContext getSSLContext() throws IOException {
    if (this.sslcontext == null) {
        this.sslcontext = createEasySSLContext();
    }
    return this.sslcontext;
}

public Socket connectSocket(Socket sock, String host, int port, InetAddress localAddress, int localPort, HttpParams params)
        throws IOException, UnknownHostException, ConnectTimeoutException {
    int connTimeout = HttpConnectionParams.getConnectionTimeout(params);
    int soTimeout = HttpConnectionParams.getSoTimeout(params);

    InetSocketAddress remoteAddress = new InetSocketAddress(host, port);
    SSLSocket sslsock = (SSLSocket) ((sock != null) ? sock : createSocket());

    if ((localAddress != null) || (localPort &gt; 0)) {
        // we need to bind explicitly
        if (localPort &lt; 0) {
            localPort = 0; // indicates ""any""
        }
        InetSocketAddress isa = new InetSocketAddress(localAddress, localPort);
        sslsock.bind(isa);
    }

    sslsock.connect(remoteAddress, connTimeout);
    sslsock.setSoTimeout(soTimeout);
    return sslsock;

}

public Socket createSocket() throws IOException {
    return getSSLContext().getSocketFactory().createSocket();
}

public boolean isSecure(Socket socket) throws IllegalArgumentException {
    return true;
}

public Socket createSocket(Socket socket, String host, int port, boolean autoClose) throws IOException, UnknownHostException {
    return getSSLContext().getSocketFactory().createSocket(socket, host, port, autoClose);
}

// -------------------------------------------------------------------
// javadoc in org.apache.http.conn.scheme.SocketFactory says :
// Both Object.equals() and Object.hashCode() must be overridden
// for the correct operation of some connection managers
// -------------------------------------------------------------------

public boolean equals(Object obj) {
    return ((obj != null) &amp;&amp; obj.getClass().equals(SSLSocketFactory.class));
}

public int hashCode() {
    return SSLSocketFactory.class.hashCode();
}
",4,0,a9fa828da7c608c495fefab931333794e9ceaec67d504c51f3ec5db025dafd7f
,"public class EncryptionHelper {

// Encrypts string and encode in Base64
public static String encryptText(String plainText,String key, String IV) throws Exception {
   // ---- Use specified 3DES key and IV from other source --------------
    byte[] plaintext = plainText.getBytes();//input
    byte[] tdesKeyData = key.getBytes();// your encryption key

    byte[] myIV = IV.getBytes();// initialization vector

    Cipher c3des = Cipher.getInstance(""DESede/CBC/PKCS5Padding"");
    SecretKeySpec myKey = new SecretKeySpec(tdesKeyData, ""DESede"");
    IvParameterSpec ivspec = new IvParameterSpec(myIV);

    c3des.init(Cipher.ENCRYPT_MODE, myKey, ivspec);
    byte[] cipherText = c3des.doFinal(plaintext);
    String encryptedString = Base64.encodeToString(cipherText,
            Base64.DEFAULT);
    // return Base64Coder.encodeString(new String(cipherText));
    return encryptedString;
}
",4,0,d4aa71eb089b00969194ee97e4e52410742e2bc32b5c53c0099f7f1cb810dcb5
,"/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements. See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership. The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* ""License""); you may not use this file except in compliance
* with the License. You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied. See the License for the
* specific language governing permissions and limitations
* under the License.
*/

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.net.InetAddress;
import java.net.InetSocketAddress;
import java.net.Socket;
import java.net.UnknownHostException;
import java.security.cert.CertificateException;
import java.security.cert.X509Certificate;
import java.util.zip.GZIPInputStream;

import javax.net.ssl.SSLContext;
import javax.net.ssl.SSLSocket;
import javax.net.ssl.TrustManager;
import javax.net.ssl.X509TrustManager;

import org.apache.http.Header;
import org.apache.http.HeaderElement;
import org.apache.http.HttpEntity;
import org.apache.http.HttpException;
import org.apache.http.HttpRequest;
import org.apache.http.HttpRequestInterceptor;
import org.apache.http.HttpResponse;
import org.apache.http.HttpResponseInterceptor;
import org.apache.http.HttpVersion;
import org.apache.http.auth.AuthScope;
import org.apache.http.auth.UsernamePasswordCredentials;
import org.apache.http.client.ClientProtocolException;
import org.apache.http.client.methods.HttpGet;
import org.apache.http.conn.ClientConnectionManager;
import org.apache.http.conn.ConnectTimeoutException;
import org.apache.http.conn.scheme.LayeredSocketFactory;
import org.apache.http.conn.scheme.PlainSocketFactory;
import org.apache.http.conn.scheme.Scheme;
import org.apache.http.conn.scheme.SchemeRegistry;
import org.apache.http.conn.scheme.SocketFactory;
import org.apache.http.entity.HttpEntityWrapper;
import org.apache.http.impl.client.BasicCredentialsProvider;
import org.apache.http.impl.client.DefaultHttpClient;
import org.apache.http.impl.conn.tsccm.ThreadSafeClientConnManager;
import org.apache.http.params.BasicHttpParams;
import org.apache.http.params.HttpConnectionParams;
import org.apache.http.params.HttpParams;
import org.apache.http.params.HttpProtocolParams;
import org.apache.http.protocol.HttpContext;


/**
 * Easy to use Http and Https client, that transparently adds gzip compression
 * and ignores all Https certificates. It can also be used for using credentials
 * in your connection.
 *
 * This class was created for Android applications, where the appropriate apache libraries
 * are already available. If you are developing for another platform, make sure
 * to add the httpclient, httpcore and commons-logging libs to your buildpath.
 * They can be downloaded from http://hc.apache.org/downloads.cgi
 *
 * &lt;code&gt;&lt;br/&gt;
 EasyHttpClient client = new EasyHttpClient();&lt;br/&gt;
 System.out.println(client.get(""https://encrypted.google.com/""));&lt;br/&gt;
 * &lt;/code&gt;
 *
 * @author match2blue software development GmbH
 * @author Ren Fischer, Ulrich Scheller
 */
public class EasyHttpClient extends DefaultHttpClient {
    /**
     * Default http port
     */
    private final static int HTTP_PORT = 80;

    /**
     * Default https port
     */
    private final static int HTTPS_PORT = 443;

    protected int lastStatusCode;

    protected String lastReasonPhrase;

    /**
     * Default constructor that initializes gzip handling. It adds the
     * Accept-Encoding gzip flag and also decompresses the response from the server.
     */
    public EasyHttpClient() {
        addRequestInterceptor(new HttpRequestInterceptor() {
            public void process(final HttpRequest request,
                                final HttpContext context) throws HttpException, IOException {
                if (!request.containsHeader(""Accept-Encoding"")) {
                    request.addHeader(""Accept-Encoding"", ""gzip"");
                }
            }
        });

        addResponseInterceptor(new HttpResponseInterceptor() {
            public void process(final HttpResponse response, final HttpContext context) throws HttpException, IOException {
                HttpEntity entity = response.getEntity();
                Header ceheader = entity.getContentEncoding();
                if (ceheader != null) {
                    for (HeaderElement headerElement : ceheader.getElements()) {
                        if (headerElement.getName().equalsIgnoreCase(""gzip"")) {
                            response.setEntity(new GzipEntityWrapper(response.getEntity()));
                            lastStatusCode = response.getStatusLine().getStatusCode();
                            lastReasonPhrase = response.getStatusLine().getReasonPhrase();
                            return;
                        }
                    }
                }
            }
        });
    }

    /**
     * Constructor which handles credentials for the connection (only if username and password are set)
     *
     * param username
     * param password
     */
    public EasyHttpClient(String username, String password) {
        if(username != null &amp;&amp; password != null) {
            UsernamePasswordCredentials c = new UsernamePasswordCredentials(username,password);
            BasicCredentialsProvider cP = new BasicCredentialsProvider();
            cP.setCredentials(AuthScope.ANY, c);
            setCredentialsProvider(cP);
        }
    }

    /**
     * Function that creates a ClientConnectionManager which can handle http and https.
     * In case of https self signed or invalid certificates will be accepted.
     */
    @Override
    protected ClientConnectionManager createClientConnectionManager() {
        HttpParams params = new BasicHttpParams();
        HttpProtocolParams.setVersion(params, HttpVersion.HTTP_1_1);
        HttpProtocolParams.setContentCharset(params, ""utf-8"");
        params.setBooleanParameter(""http.protocol.expect-continue"", false);

        SchemeRegistry registry = new SchemeRegistry();
        registry.register(new Scheme(""http"", PlainSocketFactory.getSocketFactory(), HTTP_PORT));
        registry.register(new Scheme(""https"", new EasySSLSocketFactory(), HTTPS_PORT));
        ThreadSafeClientConnManager manager = new ThreadSafeClientConnManager(params, registry);

        return manager;
    }

    /**
     * Make a get request to the specified url
     * @param url
     * @return the response string, null if there was an error
     */
    public String get(String url) {
        HttpGet getReq = new HttpGet(url);
        InputStream content = null;
        try {
            content = execute(getReq).getEntity().getContent();
            ByteArrayOutputStream bout = new ByteArrayOutputStream();
            byte[] buf = new byte[1024];
            int len;
            while ((len = content.read(buf)) &gt; 0) {
                bout.write(buf, 0, len);
            }
            content.close();
            return bout.toString();
        } catch (IllegalStateException e) {
            e.printStackTrace();
        } catch (ClientProtocolException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        }
        return null;
    }

//    public static void main(String[] args) {
//        EasyHttpClient client = new EasyHttpClient();
//        System.out.println(client.get(""https://encrypted.google.com/""));
//    }
}

class GzipEntityWrapper extends HttpEntityWrapper {
    public GzipEntityWrapper(HttpEntity wrapped) {
        super(wrapped);
    }

    @Override
    public InputStream getContent() throws IOException, IllegalStateException {
        return new GZIPInputStream(wrappedEntity.getContent());
    }

    @Override
    public long getContentLength() {
        return -1; // unknown
    }
}


/**
 * This socket factory will create ssl socket that accepts self signed
 * certificate
 *
 * author olamy
 * version $Id: EasySSLSocketFactory.java 765355 2009-04-15 20:59:07Z evenisse$
 * since 1.2.3
 */
class EasySSLSocketFactory implements SocketFactory, LayeredSocketFactory {
    private SSLContext sslcontext = null;

    private static SSLContext createEasySSLContext() throws IOException {
        try {
            SSLContext context = SSLContext.getInstance(""TLS"");
            context.init(null,
                    new TrustManager[] { new TrivialTrustManager() }, null);
            return context;
        } catch (Exception e) {
            throw new IOException(e.getMessage());
        }
    }

    private SSLContext getSSLContext() throws IOException {
        if (this.sslcontext == null) {
            this.sslcontext = createEasySSLContext();
        }
        return this.sslcontext;
    }

    /**
     * @see SocketFactory#connectSocket(Socket,
     * String, int, InetAddress, int,
     * HttpParams)
     */
    public Socket connectSocket(Socket sock, String host, int port,
                                InetAddress localAddress, int localPort, HttpParams params)
            throws IOException, UnknownHostException, ConnectTimeoutException {
        int connTimeout = HttpConnectionParams.getConnectionTimeout(params);
        int soTimeout = HttpConnectionParams.getSoTimeout(params);

        InetSocketAddress remoteAddress = new InetSocketAddress(host, port);
        SSLSocket sslsock = (SSLSocket) ((sock != null) ? sock : createSocket());

        if ((localAddress != null) || (localPort &gt; 0)) {
// we need to bind explicitly
            if (localPort &lt; 0) {
                localPort = 0; // indicates ""any""
            }
            InetSocketAddress isa = new InetSocketAddress(localAddress,
                    localPort);
            sslsock.bind(isa);
        }

        sslsock.connect(remoteAddress, connTimeout);
        sslsock.setSoTimeout(soTimeout);
        return sslsock;
    }

    /**
     * @see SocketFactory#createSocket()
     */
    public Socket createSocket() throws IOException {
        return getSSLContext().getSocketFactory().createSocket();
    }

    /**
     * @see SocketFactory#isSecure(Socket)
     */
    public boolean isSecure(Socket socket) throws IllegalArgumentException {
        return true;
    }

    /**
     * @see LayeredSocketFactory#createSocket(Socket,
     * String, int, boolean)
     */
    public Socket createSocket(Socket socket, String host, int port,
                               boolean autoClose) throws IOException, UnknownHostException {
        return getSSLContext().getSocketFactory().createSocket(socket, host,
                port, autoClose);
    }

// -------------------------------------------------------------------
// javadoc in org.apache.http.conn.scheme.SocketFactory says :
// Both Object.equals() and Object.hashCode() must be overridden
// for the correct operation of some connection managers
// -------------------------------------------------------------------

    public boolean equals(Object obj) {
        return ((obj != null) &amp;&amp; obj.getClass() == EasyHttpClient.class.getClass());
    }

    public int hashCode() {
        return EasySSLSocketFactory.class.hashCode();
    }
}


class TrivialTrustManager implements X509TrustManager {
    public void checkClientTrusted(X509Certificate[] chain, String authType)
            throws CertificateException {
    }

    public void checkServerTrusted(X509Certificate[] chain, String authType)
            throws CertificateException {
    }

    public X509Certificate[] getAcceptedIssuers() {
        return new X509Certificate[0];
    }
}
",4,0,9d2f591ce2266cac0dd6f38a9236b0c49fbb6ccd4d99a7a50cf5f65d8741da42
,"PKCS8EncodedKeySpec privSpec = new PKCS8EncodedKeySpec(s_privateKeyIn1t);
KeyFactory keyFactory = KeyFactory.getInstance(""RSA"", ""BC"");
PrivateKey privateKey = keyFactory.generatePrivate(privSpec);
",2,0,7d593f1eba07e2cd3302d90bfeeb79a06a88977a0a857d61f13f4a86d9edafb3
,"TextView tv1; 
TextView tv2; 
TextView tv3; 
Button convert; 
String publicKeyFilename = null; 
String privateKeyFilename = null; 
String ST = ""Ebenezersawesome""; 

@Override public void onCreate(Bundle savedInstanceState) 
{ 
    super.onCreate(savedInstanceState); 
    setContentView(R.layout.main); 
    Log.d(""Ebz"", ""Made it to onCreate""); 
    tv1 = (TextView) findViewById(R.id.tv1); 
    tv2 = (TextView) findViewById(R.id.tv2); 
    tv3 = (TextView) findViewById(R.id.tv3); 
    convert = (Button) findViewById(R.id.button1); 

    try { 
                byte[]plainText = ""ST"".getBytes(""UTF8""); 
                Log.d(""Ebz"", ""made it to Try Block""); 
                KeyPairGenerator keyGen = 
                    KeyPairGenerator.getInstance(""RSA""); 
                keyGen.initialize(4096); 
                KeyPair key = keyGen.generateKeyPair(); 
                Cipher cipher = 
                    Cipher.getInstance(""RSA/ECB/PKCS1Padding""); 
                tv3.setText(cipher.getProvider().getInfo().toString()); 
                //tv3.setText(ST); 
                cipher.init(Cipher.ENCRYPT_MODE, key.getPublic()); 
                byte[]cipherText = cipher.doFinal(plainText); 
                tv1.setText(new String(cipherText, ""UTF8"").toString()); 
                //tv1.setText(ST); 
                byte[]newPlainText = cipher.doFinal(cipherText); 
                tv2.setText(new String(newPlainText, ""UTF8"").toString()); 
                //tv2.setText(ST); 
            } catch(Exception e) { 
                System.out.println(""error""); 
            }
    // tv2.setText(ST); 
    convert.setOnClickListener(new OnClickListener() { 
        public void onClick(View v) { 
            Log.d(""Ebz"", ""Made it to onCreate"");  
        } 
    }); 
}
",3,0,0c7cda2d6dad08b0e8b252674e98d4ba807d5c39e41255ef40e409d5d5ac18c1
,"public byte[] getMD5(String fileAContents) throws NoSuchAlgorithmException {
     MessageDigest messageDigest = MessageDigest.getInstance(""MD5"");
     messageDigest.update(fileAContents.getBytes());
     return messageDigest.digest();
}
",,1,038d661d38cc26de48905331a5299dc9d37dd77f6555bbb42b034d1606cbf6b5
,"public static String encodePassword(String password) throws NoSuchAlgorithmException, UnsupportedEncodingException {
        String result;
        MessageDigest md = MessageDigest.getInstance(""SHA-1"");
        md.update(password.getBytes(""iso-8859-1""), 0, password.length());
        byte[] sha1hash = md.digest();
        result = Base64.encodeToString(sha1hash, Base64.DEFAULT);
        result = result.substring(0, result.length()-1);
        return result;
    }
",3,0,8889d81b723a414d82dacc3a8bef8ead596d62795019fa818ba0dc4ec0619dd4
,"import com.example.Device;

import org.spongycastle.bcpg.ArmoredInputStream;
import org.spongycastle.bcpg.ArmoredOutputStream;
import org.spongycastle.bcpg.HashAlgorithmTags;
import org.spongycastle.bcpg.SymmetricKeyAlgorithmTags;
import org.spongycastle.bcpg.sig.Features;
import org.spongycastle.bcpg.sig.KeyFlags;
import org.spongycastle.crypto.generators.RSAKeyPairGenerator;
import org.spongycastle.crypto.params.RSAKeyGenerationParameters;
import org.spongycastle.openpgp.PGPCompressedData;
import org.spongycastle.openpgp.PGPCompressedDataGenerator;
import org.spongycastle.openpgp.PGPEncryptedData;
import org.spongycastle.openpgp.PGPEncryptedDataGenerator;
import org.spongycastle.openpgp.PGPEncryptedDataList;
import org.spongycastle.openpgp.PGPException;
import org.spongycastle.openpgp.PGPKeyPair;
import org.spongycastle.openpgp.PGPKeyRingGenerator;
import org.spongycastle.openpgp.PGPLiteralData;
import org.spongycastle.openpgp.PGPLiteralDataGenerator;
import org.spongycastle.openpgp.PGPObjectFactory;
import org.spongycastle.openpgp.PGPPrivateKey;
import org.spongycastle.openpgp.PGPPublicKey;
import org.spongycastle.openpgp.PGPPublicKeyEncryptedData;
import org.spongycastle.openpgp.PGPPublicKeyRing;
import org.spongycastle.openpgp.PGPSecretKey;
import org.spongycastle.openpgp.PGPSecretKeyRing;
import org.spongycastle.openpgp.PGPSignature;
import org.spongycastle.openpgp.PGPSignatureSubpacketGenerator;
import org.spongycastle.openpgp.PGPUtil;
import org.spongycastle.openpgp.operator.PBESecretKeyDecryptor;
import org.spongycastle.openpgp.operator.PBESecretKeyEncryptor;
import org.spongycastle.openpgp.operator.PGPDigestCalculator;
import org.spongycastle.openpgp.operator.bc.BcPBESecretKeyDecryptorBuilder;
import org.spongycastle.openpgp.operator.bc.BcPBESecretKeyEncryptorBuilder;
import org.spongycastle.openpgp.operator.bc.BcPGPContentSignerBuilder;
import org.spongycastle.openpgp.operator.bc.BcPGPDigestCalculatorProvider;
import org.spongycastle.openpgp.operator.bc.BcPGPKeyPair;
import org.spongycastle.openpgp.operator.bc.BcPublicKeyDataDecryptorFactory;
import org.spongycastle.openpgp.operator.jcajce.JcePGPDataEncryptorBuilder;
import org.spongycastle.openpgp.operator.jcajce.JcePublicKeyKeyEncryptionMethodGenerator;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.math.BigInteger;
import java.nio.charset.Charset;
import java.security.SecureRandom;
import java.util.Date;
import java.util.Iterator;

public class PgpUtils {
    private static final String PROVIDER = ""SC"";
    private static final String KEY_RING_ID = ""asdf@asdf.com"";

    public static String decrypt(String encryptedText, String password) throws Exception {
        byte[] encrypted = encryptedText.getBytes();
        InputStream in = new ByteArrayInputStream(encrypted);
        in = PGPUtil.getDecoderStream(in);
        PGPObjectFactory pgpF = new PGPObjectFactory(in);
        PGPEncryptedDataList enc;
        Object o = pgpF.nextObject();
        if (o instanceof PGPEncryptedDataList) {
            enc = (PGPEncryptedDataList) o;
        } else {
            enc = (PGPEncryptedDataList) pgpF.nextObject();
        }
        PGPPrivateKey sKey = null;
        PGPPublicKeyEncryptedData pbe = null;
        while (sKey == null &amp;&amp; enc.getEncryptedDataObjects().hasNext()) {
            pbe = (PGPPublicKeyEncryptedData)enc.getEncryptedDataObjects().next();
            sKey = getPrivateKey(getPGPSecretKeyRing(), pbe.getKeyID(), password.toCharArray());
        }
        if (pbe != null) {
            InputStream clear = pbe.getDataStream(new BcPublicKeyDataDecryptorFactory(sKey));
            PGPObjectFactory pgpFact = new PGPObjectFactory(clear);
            PGPCompressedData cData = (PGPCompressedData) pgpFact.nextObject();
            pgpFact = new PGPObjectFactory(cData.getDataStream());
            PGPLiteralData ld = (PGPLiteralData) pgpFact.nextObject();
            InputStream unc = ld.getInputStream();
            ByteArrayOutputStream out = new ByteArrayOutputStream();
            int ch;
            while ((ch = unc.read()) &gt;= 0) {
                out.write(ch);
            }
            byte[] returnBytes = out.toByteArray();
            out.close();
            return new String(returnBytes);
        }
        return null;
    }

    private static PGPPublicKey getPublicKey(PGPPublicKeyRing publicKeyRing) {
        Iterator&lt;?&gt; kIt = publicKeyRing.getPublicKeys();
        while (kIt.hasNext()) {
            PGPPublicKey k = (PGPPublicKey) kIt.next();
            if (k.isEncryptionKey()) {
                return k;
            }
        }
        return null;
    }

    private static PGPPrivateKey getPrivateKey(PGPSecretKeyRing keyRing, long keyID, char[] pass) throws PGPException {
        PGPSecretKey secretKey = keyRing.getSecretKey(keyID);
        PBESecretKeyDecryptor decryptor = new BcPBESecretKeyDecryptorBuilder(new BcPGPDigestCalculatorProvider()).build(pass);
        return secretKey.extractPrivateKey(decryptor);
    }

    public static String encrypt(String msgText) throws IOException, PGPException {
        byte[] clearData = msgText.getBytes();
        PGPPublicKey encKey = getPublicKey(getPGPPublicKeyRing());
        ByteArrayOutputStream encOut = new ByteArrayOutputStream();
        OutputStream out = new ArmoredOutputStream(encOut);
        ByteArrayOutputStream bOut = new ByteArrayOutputStream();
        PGPCompressedDataGenerator comData = new PGPCompressedDataGenerator(PGPCompressedDataGenerator.ZIP);
        OutputStream cos = comData.open(bOut);
        PGPLiteralDataGenerator lData = new PGPLiteralDataGenerator();
        OutputStream pOut = lData.open(cos, PGPLiteralData.BINARY, PGPLiteralData.CONSOLE, clearData.length, new Date());
        pOut.write(clearData);
        lData.close();
        comData.close();
        PGPEncryptedDataGenerator encGen =
                new PGPEncryptedDataGenerator(
                        new JcePGPDataEncryptorBuilder(PGPEncryptedData.AES_256).setWithIntegrityPacket(true).setSecureRandom(
                                new SecureRandom()).setProvider(PROVIDER));
        if (encKey != null) {
            encGen.addMethod(new JcePublicKeyKeyEncryptionMethodGenerator(encKey).setProvider(PROVIDER));
            byte[] bytes = bOut.toByteArray();
            OutputStream cOut = encGen.open(out, bytes.length);
            cOut.write(bytes);
            cOut.close();
        }
        out.close();
        return new String(encOut.toByteArray());
    }

    public final static PGPKeyRingGenerator generateKeyRingGenerator (char[] pass) throws PGPException{
        RSAKeyPairGenerator kpg = new RSAKeyPairGenerator();
        kpg.init(new RSAKeyGenerationParameters(BigInteger.valueOf(0x10001), new SecureRandom(), 2048, 12));
        PGPKeyPair rsakp_sign = new BcPGPKeyPair(PGPPublicKey.RSA_SIGN, kpg.generateKeyPair(), new Date());
        PGPKeyPair rsakp_enc = new BcPGPKeyPair(PGPPublicKey.RSA_ENCRYPT, kpg.generateKeyPair(), new Date());
        PGPSignatureSubpacketGenerator signhashgen = new PGPSignatureSubpacketGenerator();
        signhashgen.setKeyFlags(false, KeyFlags.SIGN_DATA|KeyFlags.CERTIFY_OTHER|KeyFlags.SHARED);
        signhashgen.setPreferredSymmetricAlgorithms(false, new int[]{SymmetricKeyAlgorithmTags.AES_256, SymmetricKeyAlgorithmTags.AES_192, SymmetricKeyAlgorithmTags.AES_128});
        signhashgen.setPreferredHashAlgorithms(false, new int[]{HashAlgorithmTags.SHA256, HashAlgorithmTags.SHA1, HashAlgorithmTags.SHA384, HashAlgorithmTags.SHA512, HashAlgorithmTags.SHA224});
        signhashgen.setFeature(false, Features.FEATURE_MODIFICATION_DETECTION);
        PGPSignatureSubpacketGenerator enchashgen = new PGPSignatureSubpacketGenerator();
        enchashgen.setKeyFlags(false, KeyFlags.ENCRYPT_COMMS | KeyFlags.ENCRYPT_STORAGE);
        PGPDigestCalculator sha1Calc = new BcPGPDigestCalculatorProvider().get(HashAlgorithmTags.SHA1);
        PGPDigestCalculator sha256Calc = new BcPGPDigestCalculatorProvider().get(HashAlgorithmTags.SHA256);
        PBESecretKeyEncryptor pske = (new BcPBESecretKeyEncryptorBuilder(PGPEncryptedData.AES_256, sha256Calc, 0xc0)).build(pass);
        PGPKeyRingGenerator keyRingGen = new PGPKeyRingGenerator (PGPSignature.POSITIVE_CERTIFICATION, rsakp_sign,
                KEY_RING_ID, sha1Calc, signhashgen.generate(), null, new BcPGPContentSignerBuilder(rsakp_sign.getPublicKey().getAlgorithm(),
                HashAlgorithmTags.SHA1), pske);
        keyRingGen.addSubKey(rsakp_enc, enchashgen.generate(), null);
        return keyRingGen;
    }

    private static PGPPublicKeyRing getPGPPublicKeyRing() throws IOException {
        ArmoredInputStream ais = new ArmoredInputStream(new ByteArrayInputStream(Device.getDevice().getPgpPublicKey().getBytes()));
        return (PGPPublicKeyRing) new PGPObjectFactory(ais).nextObject();
    }

    private static PGPSecretKeyRing getPGPSecretKeyRing() throws IOException {
        ArmoredInputStream ais = new ArmoredInputStream(new ByteArrayInputStream(Device.getDevice().getPgpSecretKey().getBytes()));
        return (PGPSecretKeyRing) new PGPObjectFactory(ais).nextObject();
    }

    public final static String genPGPPublicKey (PGPKeyRingGenerator krgen) throws IOException {
        ByteArrayOutputStream baosPkr = new ByteArrayOutputStream();
        PGPPublicKeyRing pkr = krgen.generatePublicKeyRing();
        ArmoredOutputStream armoredStreamPkr = new ArmoredOutputStream(baosPkr);
        pkr.encode(armoredStreamPkr);
        armoredStreamPkr.close();
        return new String(baosPkr.toByteArray(), Charset.defaultCharset());
    }

    public final static String genPGPPrivKey (PGPKeyRingGenerator krgen) throws IOException {
        ByteArrayOutputStream baosPriv = new ByteArrayOutputStream ();
        PGPSecretKeyRing skr = krgen.generateSecretKeyRing();
        ArmoredOutputStream armoredStreamPriv = new ArmoredOutputStream(baosPriv);
        skr.encode(armoredStreamPriv);
        armoredStreamPriv.close();
        return new String(baosPriv.toByteArray(), Charset.defaultCharset());
    }
}
",1,0,6bdf10231b1783d72a1ecd57fbf2d29f93951fac5bb7d95f7d515a044fee46a4
,"InputStream keyStoreStream = ontext.openFileInput ( filename );
KeyStore keyStore = KeyStore.getInstance ( KeyStore.getDefaultType ( ) );
keyStore.load ( keyStoreStream, oldPass );
FileOutputStream fileOutputStream = context.openFileOutput ( filename, Context.MODE_PRIVATE );
keystore.store ( fileOutputStream, newPassword );
fileOutputStream.close ( );
",,1,5b77be255b9982c700b44285631528cc74f20dbcaceb29cfdb94f22c1fb2dfb0
," /**
 * Set up a connection to myservice.domain using HTTPS. An entire function
 * is needed to do this because myservice.domain has a self-signed certificate.
 * 
 * The caller of the function would do something like:
 * HttpsURLConnection urlConnection = setUpHttpsConnection(""https://littlesvr.ca"");
 * InputStream in = urlConnection.getInputStream();
 * And read from that ""in"" as usual in Java
 * 
 * Based on code from:
 * https://developer.android.com/training/articles/security-ssl.html#SelfSigned
 */
public static HttpsURLConnection setUpHttpsConnection(String urlString)
{
    try
    {
        // Load CAs from an InputStream
        // (could be from a resource or ByteArrayInputStream or ...)
        CertificateFactory cf = CertificateFactory.getInstance(""X.509"");

        // My CRT file that I put in the assets folder
        // I got this file by following these steps:
        // * Go to https://littlesvr.ca using Firefox
        // * Click the padlock/More/Security/View Certificate/Details/Export
        // * Saved the file as littlesvr.crt (type X.509 Certificate (PEM))
        // The MainActivity.context is declared as:
        // public static Context context;
        // And initialized in MainActivity.onCreate() as:
        // MainActivity.context = getApplicationContext();
        InputStream caInput = new BufferedInputStream(MainActivity.context.getAssets().open(""littlesvr.crt""));
        Certificate ca = cf.generateCertificate(caInput);
        System.out.println(""ca="" + ((X509Certificate) ca).getSubjectDN());

        // Create a KeyStore containing our trusted CAs
        String keyStoreType = KeyStore.getDefaultType();
        KeyStore keyStore = KeyStore.getInstance(keyStoreType);
        keyStore.load(null, null);
        keyStore.setCertificateEntry(""ca"", ca);

        // Create a TrustManager that trusts the CAs in our KeyStore
        String tmfAlgorithm = TrustManagerFactory.getDefaultAlgorithm();
        TrustManagerFactory tmf = TrustManagerFactory.getInstance(tmfAlgorithm);
        tmf.init(keyStore);

        // Create an SSLContext that uses our TrustManager
        SSLContext context = SSLContext.getInstance(""TLS"");
        context.init(null, tmf.getTrustManagers(), null);

        // Tell the URLConnection to use a SocketFactory from our SSLContext
        URL url = new URL(urlString);
        HttpsURLConnection urlConnection = (HttpsURLConnection)url.openConnection();
        urlConnection.setSSLSocketFactory(context.getSocketFactory());

        return urlConnection;
    }
    catch (Exception ex)
    {
        Log.e(TAG, ""Failed to establish SSL connection to server: "" + ex.toString());
        return null;
    }
}
",3,0,048d83717448dc3454a4848ccec4d15fa05633e03ab8ff88ba098d7500b09818
,"        SocketFactory sf = SSLSocketFactory.getDefault();
        SSLSocket socket = (SSLSocket) sf.createSocket(""host-name"", 443);
        socket.setEnabledProtocols(new String[] { ""TLSv1""});
        socket.startHandshake();
",4,0,dd2c147fe16b42e4ab79fa350b80f29019cb8915de5dbebbe55beb0c2dd82302
,"public class FacebookHashKeyActivity extends Activity {

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_facebook_hash_key);
        try {
            PackageInfo info = getPackageManager().getPackageInfo(""your.package.name"", PackageManager.GET_SIGNATURES);
            for (Signature signature : info.signatures) {
                MessageDigest md = MessageDigest.getInstance(""SHA"");
                md.update(signature.toByteArray());
                Log.d(""KeyHash:"", Base64.encodeToString(md.digest(), Base64.DEFAULT));
            }
        } catch (NameNotFoundException e) {
            e.printStackTrace();
        } catch (NoSuchAlgorithmException e) {
            e.printStackTrace();
        }
    }
}
",3,0,eb14c04df155c6fba476344c29d59966e1b4dc950f11c4371ec624142f5d1fa2
,"String modulusElem = ""..."";
String dElem = ""..."";

byte[] modulusBytes = Base64.decode(modulusElem, Base64.DEFAULT);
byte[] dBytes = Base64.decode(dElem, Base64.DEFAULT);

BigInteger modulus = new BigInteger(1, modulusBytes);
BigInteger d = new BigInteger(1, dBytes);

String data = ""my data"";            

try {
        Signature signature = Signature.getInstance(""SHA1withRSA"");

        KeyFactory factory = KeyFactory.getInstance(""RSA"");

        RSAPrivateKeySpec privateKeySpec = new RSAPrivateKeySpec(modulus, d);

        PrivateKey privateKey = factory.generatePrivate(privateKeySpec);

        signature.initSign(privateKey);

        signature.update(data.getBytes(""UTF-8""));

        byte[] SignedByteData = signature.sign();

} catch(Exception e) {

}
",3,0,adb629fc588dc4c48d6afed98c3acdeaf2c094cb99cc21e4bce4ee406fe23383
,"import java.io.IOException;
import java.net.Socket;
import java.net.UnknownHostException;
import java.security.KeyManagementException;
import java.security.KeyStore;
import java.security.KeyStoreException;
import java.security.NoSuchAlgorithmException;
import java.security.UnrecoverableKeyException;
import java.security.cert.CertificateException;
import java.security.cert.X509Certificate;

import javax.net.ssl.HostnameVerifier;
import javax.net.ssl.SSLContext;
import javax.net.ssl.TrustManager;
import javax.net.ssl.X509TrustManager;

import org.apache.http.HttpVersion;
import org.apache.http.client.HttpClient;
import org.apache.http.client.params.HttpClientParams;
import org.apache.http.conn.ClientConnectionManager;
import org.apache.http.conn.scheme.PlainSocketFactory;
import org.apache.http.conn.scheme.Scheme;
import org.apache.http.conn.scheme.SchemeRegistry;
import org.apache.http.conn.ssl.SSLSocketFactory;
import org.apache.http.conn.ssl.X509HostnameVerifier;
import org.apache.http.impl.client.DefaultHttpClient;
import org.apache.http.impl.conn.tsccm.ThreadSafeClientConnManager;
import org.apache.http.params.BasicHttpParams;
import org.apache.http.params.HttpConnectionParams;
import org.apache.http.params.HttpParams;
import org.apache.http.params.HttpProtocolParams;
import org.apache.http.protocol.HTTP;

public class MySSLSocketFactory extends SSLSocketFactory {
    SSLContext sslContext = SSLContext.getInstance(""TLS"");
    public static int ConnectionTimeoutInSeconds = 45;
    public static boolean DisableSSLcertificateCheck = true;

    public MySSLSocketFactory(KeyStore truststore) throws NoSuchAlgorithmException, KeyManagementException, KeyStoreException, UnrecoverableKeyException {
        super(truststore);

        TrustManager tm = new X509TrustManager() {
            public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {
            }

            public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {
            }

            public java.security.cert.X509Certificate[] getAcceptedIssuers() {
                return null;
            }

        };

        sslContext.init(null, new TrustManager[] { tm }, null);
    }

    @Override
    public Socket createSocket(Socket socket, String host, int port, boolean autoClose) throws IOException, UnknownHostException {
        return sslContext.getSocketFactory().createSocket(socket, host, port, autoClose);
    }

    @Override
    public Socket createSocket() throws IOException {
        return sslContext.getSocketFactory().createSocket();
    }

    public static HttpClient getHttpClient() {
        try {

            HttpParams params = new BasicHttpParams();

            // Turn off stale checking.  Our connections break all the time anyway,
            // and it's not worth it to pay the penalty of checking every time.
            HttpConnectionParams.setStaleCheckingEnabled(params, false);

            // Default connection and socket timeout of 20 seconds.  Tweak to taste.
            HttpConnectionParams.setConnectionTimeout(params, ConnectionTimeoutInSeconds * 1000);
            HttpConnectionParams.setSoTimeout(params, ConnectionTimeoutInSeconds * 1000);
            HttpConnectionParams.setSocketBufferSize(params, 8192);

            // Don't handle redirects -- return them to the caller.  Our code
            // often wants to re-POST after a redirect, which we must do ourselves.
            HttpClientParams.setRedirecting(params, false);

            SSLSocketFactory mySSLSocketFactory = SSLSocketFactory.getSocketFactory();

            // disable ssl check on debug
            if (DisableSSLcertificateCheck ) {
                KeyStore trustStore = KeyStore.getInstance(KeyStore.getDefaultType());
                trustStore.load(null, null);
                mySSLSocketFactory = new MySSLSocketFactory(trustStore);
                HostnameVerifier hostnameVerifier = org.apache.http.conn.ssl.SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER;
                mySSLSocketFactory.setHostnameVerifier((X509HostnameVerifier) hostnameVerifier);
            }

            SchemeRegistry schemeRegistry = new SchemeRegistry();
            schemeRegistry.register(new Scheme(""http"", PlainSocketFactory.getSocketFactory(), 80));
            schemeRegistry.register(new Scheme(""https"", mySSLSocketFactory, 443));
            ClientConnectionManager manager = new ThreadSafeClientConnManager(params, schemeRegistry);

            return new DefaultHttpClient(manager, params);
        } catch (Exception e) {
            return new DefaultHttpClient();
        }
    }

}
",4,0,225bbfef78e2cbec872170c770430202c809c1304bbbdfef4db6796e4e554cc2
,"public class NetworkSSLSocketFactory implements LayeredSocketFactory {

    private SSLContext sslContext;
    private SSLSocketFactory socketFactory;
    private X509HostnameVerifier hostnameVerifier;

    /**
     * Creates a socket factory that will use the {@link SSLContext} and
     * {@link X509HostnameVerifier} specified. The SSLContext provided should
     * have the {@link NetworkTrustManager} associated with it.
     * 
     * @param sslContext
     * @param hostnameVerifier
     */
    public NetworkSSLSocketFactory(SSLContext sslContext,
            X509HostnameVerifier hostnameVerifier) {
        this.sslContext = sslContext;
        this.socketFactory = sslContext.getSocketFactory();
        this.hostnameVerifier = hostnameVerifier;
    }  
}
",,1,1a10dd83e3484288548e7f36be6e26fb64cae41b354a31ebf8b1e3b3edf5b316
,"    /**
     * Return the SSLContext for use with our HttpClient or create a new Context
     * if needed.
     * &lt;p&gt;
     * This context uses our {@link NetworkTrustManager}
     * 
     * @return an {@link SSLContext}
     */
    public SSLContext getSSLContext() {

        if (mSSLContextInstance != null)
            return mSSLContextInstance;

        try {
            mSSLContextInstance = SSLContext.getInstance(""TLS"");
            TrustManager trustManager = new NetworkTrustManager(getKeyStore());
            TrustManager[] tms = new TrustManager[] { trustManager };
            mSSLContextInstance.init(null, tms, new SecureRandom());
        } catch (NoSuchAlgorithmException e) {
            Log.e(TAG, e.getMessage());
        } catch (KeyManagementException e) {
            Log.e(TAG, e.getMessage());
        }

        return mSSLContextInstance;
    }
",,1,9fb7b6aa9a5d3bf6eee763ff851d41d9bcdd59555b001960a40ab36c0b1b906f
,"/**
 * Return an HttpClient using our {@link NetworkTrustManager} and
 * {@link NetworkHostnameVerifier}
 * 
 * @return an {@link HttpClient}
 */
public HttpClient getHttpClient() {

    if (mHttpClientInstance != null)
        return mHttpClientInstance;

    SSLContext sslContext = getSSLContext();

    // Now create our socket factory using our context.
    X509HostnameVerifier hostnameVerifier = new NetworkHostnameVerifier();
    NetworkSSLSocketFactory sslSocketFactory = new NetworkSSLSocketFactory(
            sslContext, hostnameVerifier);

    // Some services (like the KSOAP client) use the HttpsURLConnection
    // class
    // to establish SSL connections.
    HttpsURLConnection.setDefaultHostnameVerifier(hostnameVerifier);
    HttpsURLConnection.setDefaultSSLSocketFactory(sslContext
            .getSocketFactory());

    // Generate the Client for the Server
    mHttpClientInstance = AndroidHttpClient.newInstance(getAgent(),
            mContext);

    // Get the registry from the AndroidHttpClient and change the
    // HTTPS scheme to use our socket factory. This way we can
    // control the certificate authority and trust system.
    SchemeRegistry schemeRegistry = mHttpClientInstance
            .getConnectionManager().getSchemeRegistry();

    schemeRegistry.register(new Scheme(""https"", sslSocketFactory, 443));

    return mHttpClientInstance;
}
",,1,d87f562490d51941bae20f6ce9947ca79ac8caf33af03f19e370d9401c02464a
,"    /**
     * Get the current KeyStore or if not yet created, create a new one. This
     * will &lt;b&gt;NOT&lt;/b&gt; load the KeyStore file identified by
     * {@link #KEYSTORE_NAME}. To load the KeyStore file, use the function
     * {@link #loadKeyStore()} which will automatically call this function (so
     * you don't need to).
     * &lt;p&gt;
     * 
     * @return a {@link KeyStore}
     */
    public KeyStore getKeyStore() {

        if (mKeyStore != null)
            return mKeyStore;

        try {
            String defaultType = KeyStore.getDefaultType();
            mKeyStore = KeyStore.getInstance(defaultType);
            mKeyStore.load(null, null);
        } catch (Exception e) {
            Log.w(TAG, e.getMessage());
        }

        return mKeyStore;
    }
",,1,69fd9fa57375da3d6fd9834f4448df353eb0a60cba4f31735fa6da0c70722af8
,"if(frag instanceof Refreshable)
    ((Refreshable)frag).refresh();
}
",,1,01a27fbb12b8cf83abcd401b09acba0643560974e82e5ff07bf7233cdeac8f3c
,"import java.io.InputStream;
import java.security.KeyStore;
import org.apache.http.conn.ClientConnectionManager;
import org.apache.http.conn.scheme.PlainSocketFactory;
import org.apache.http.conn.scheme.Scheme;
import org.apache.http.conn.scheme.SchemeRegistry;
import org.apache.http.conn.ssl.SSLSocketFactory;
import org.apache.http.impl.client.DefaultHttpClient;
import org.apache.http.impl.conn.SingleClientConnManager;
import org.apache.http.params.BasicHttpParams;
import org.apache.http.params.HttpConnectionParams;
import org.apache.http.params.HttpParams;

import com.futureconcepts.anonymous.R;
import android.content.Context;


public class Client extends  DefaultHttpClient   {
final Context context;
  public Client(Context context) {
      this.context = context;
  }

  @Override
  protected ClientConnectionManager createClientConnectionManager() {
      SchemeRegistry registry = new SchemeRegistry();
      registry.register(new Scheme(""http"", 
      PlainSocketFactory.getSocketFactory(), 80));
      // Register for port 443 our SSLSocketFactory with our keystore
      // to the ConnectionManager
      registry.register(new Scheme(""https"", newSslSocketFactory(),443));

    HttpParams httpParams = new BasicHttpParams();
     HttpConnectionParams.setConnectionTimeout(httpParams,9000);
     HttpConnectionParams.setSoTimeout(httpParams, 9000);

      return new SingleClientConnManager(httpParams, registry);
  }


  private SSLSocketFactory newSslSocketFactory() {
      try {

          // Get an instance of the Bouncy Castle KeyStore format
            KeyStore trusted = KeyStore.getInstance(""BKS"");//put BKS literal  
            // Get the raw resource, which contains the keystore with
            // your trusted certificates (root and any intermediate certs)
            InputStream in =context.getResources().openRawResource(R.raw.keystore);
            try {
                // Initialize the keystore with the provided trusted certificates
                // Also provide the password of the keystore
                trusted.load(in, ""mysecret"".toCharArray());
            } finally {
                in.close();
            }
          // Pass the keystore to the SSLSocketFactory. The factory is responsible
          // for the verification of the server certificate.
          SSLSocketFactory sf = new SSLSocketFactory(trusted);
          // Hostname verification from certificate

           sf.setHostnameVerifier(SSLSocketFactory.STRICT_HOSTNAME_VERIFIER);
          return sf;
      } catch (Exception e) {
          throw new AssertionError(e);
      }
  }

}
",3,0,79341a9cd9f2e297d03fbc0f76002ccd45aac77a503a8103456ce5164f06ccc0
,"import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;

import android.os.Bundle;
import android.app.Activity;
import android.content.pm.PackageInfo;
import android.content.pm.PackageManager;
import android.content.pm.PackageManager.NameNotFoundException;
import android.content.pm.Signature;
import android.text.Editable;
import android.util.Base64;
import android.util.Log;
import android.view.Menu;
import android.view.View;
import android.view.View.OnClickListener;
import android.widget.Button;
import android.widget.EditText;

public class MainActivity extends Activity {

    Button btn;
    EditText et;
    PackageInfo info;
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        btn=(Button)findViewById(R.id.button1);
        et=(EditText)findViewById(R.id.editText1);
        btn.setOnClickListener(new OnClickListener() {

            @Override
            public void onClick(View v) {
                // TODO Auto-generated method stub

                try {
                    info = getPackageManager().getPackageInfo(""com.example.id"", PackageManager.GET_SIGNATURES);
                    for (Signature signature : info.signatures) {
                        MessageDigest md;
                        md = MessageDigest.getInstance(""SHA"");
                        md.update(signature.toByteArray());
                        String something = new String(Base64.encode(md.digest(), 0));
                        //String something = new String(Base64.encodeBytes(md.digest()));
                        et.setText("""" + something);
                        Log.e(""hash key"", something);
                    }
                } catch (NameNotFoundException e1) {
                    Log.e(""name not found"", e1.toString());
                } catch (NoSuchAlgorithmException e) {
                    Log.e(""no such an algorithm"", e.toString());
                } catch (Exception e) {
                    Log.e(""exception"", e.toString());
                }
            }
        });
    }



}
",3,0,68b34254a1bcf591dbceb1e9f1778cf48c888e39d5aa2c54bdd18265f47cefbf
,"public class CustomSSLSocketFactory extends SSLSocketFactory {

    SSLContext sslContext = SSLContext.getInstance(""TLS"");

    public CustomSSLSocketFactory(KeyStore truststore)
            throws NoSuchAlgorithmException, KeyManagementException,
            KeyStoreException, UnrecoverableKeyException {
        super(truststore);

        TrustManager tm = new CustomX509TrustManager();

        sslContext.init(null, new TrustManager[] { tm }, null);
    }

    public CustomSSLSocketFactory(SSLContext context)
            throws KeyManagementException, NoSuchAlgorithmException,
            KeyStoreException, UnrecoverableKeyException {
        super(null);
        sslContext = context;
    }

    @Override
    public Socket createSocket(Socket socket, String host, int port,
                               boolean autoClose) throws IOException, UnknownHostException {
        Socket newSocket =  sslContext.getSocketFactory().createSocket(socket, host, port,
                autoClose);
        ((SSLSocket) newSocket).setEnabledCipherSuites(((SSLSocket) newSocket).getSupportedCipherSuites());
        AdjustSocket(newSocket);
        return newSocket;
    }

    @Override
    public Socket createSocket() throws IOException {
        Socket socket = sslContext.getSocketFactory().createSocket();
        ((SSLSocket) socket).setEnabledCipherSuites(((SSLSocket) socket).getSupportedCipherSuites());
        adjustSocket(socket);
        return socket;
    }

    private void adjustSocket(Socket socket)
    {
        String[] cipherSuites = ((SSLSocket) socket).getSSLParameters().getCipherSuites();
        ArrayList&lt;String&gt; cipherSuiteList = new ArrayList&lt;String&gt;(Arrays.asList(cipherSuites));

        cipherSuiteList.add(""TLS_RSA_WITH_3DES_EDE_CBC_SHA"");
        cipherSuites = cipherSuiteList.toArray(new String[cipherSuiteList.size()]);
        ((SSLSocket) socket).getSSLParameters().setCipherSuites(cipherSuites);

        String[] protocols = ((SSLSocket) socket).getSSLParameters().getProtocols();
        ArrayList&lt;String&gt; protocolList = new ArrayList&lt;String&gt;(Arrays.asList(protocols));

        for (int ii = protocolList.size() - 1; ii &gt;= 0; --ii )
        {
            if ((protocolList.get(ii).contains(""SSLv3"")) || (protocolList.get(ii).contains(""TLSv1.1"")) || (protocolList.get(ii).contains(""TLSv1.2"")))
                protocolList.remove(ii);
        }

        protocols = protocolList.toArray(new String[protocolList.size()]);
        ((SSLSocket)socket).setEnabledProtocols(protocols);
    }
}
",4,0,6fbb7f1dd50854fc162e56582f05cf2737de873f8ab4668cbc82de7e04e3fbfd
,"public HttpClient createHttpClient(){
            try {
                KeyStore trustStore = KeyStore.getInstance(KeyStore.getDefaultType());
                trustStore.load(null, null);

                CustomSSLSocketFactory sf = new CustomSSLSocketFactory(trustStore);
                sf.setHostnameVerifier(CustomSSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);

                HttpParams params = new BasicHttpParams();
                HttpConnectionParams.setConnectionTimeout(params, 15000);
                HttpConnectionParams.setSoTimeout(params, 5000);

                SchemeRegistry registry = new SchemeRegistry();
                registry.register(new Scheme(""http"", PlainSocketFactory.getSocketFactory(), 80));
                registry.register(new Scheme(""https"", sf, 443));

                ClientConnectionManager ccm = new ThreadSafeClientConnManager(params, registry);

                return new DefaultHttpClient(ccm, params);
            } catch (Exception e) {
                return new DefaultHttpClient();
            }
",4,0,a401c46b99270974273d134a4dbaf75059e2c05ae638a75a4c3c2fec098821b4
,"static final String GetKey(Context context)
{
    String KeyHash = """";
    PackageInfo info;
    try {
        info = context.getPackageManager().getPackageInfo(context.getPackageName(),  PackageManager.GET_SIGNATURES);

        for (Signature signature : info.signatures)
        {
            MessageDigest md = MessageDigest.getInstance(""SHA"");
            md.update(signature.toByteArray());
            KeyHash = Base64.encodeToString(md.digest(), Base64.DEFAULT);
        }

    } catch (NameNotFoundException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    } catch (NoSuchAlgorithmException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    }

    return KeyHash;
}
",3,0,0fb9c8c9c720ae6f59cf4e42d69481e78aa39271aeec8d2c5a835e1edc6faea2
,"private static final String ALGO = ""AES"";
private static final byte[] keyValue = new byte[] { 'o', 'n', 'e', 'n','e', 't', 'e','d', 'o', 'c', 'e', 'i', 'r', 's', 'r', 'p' };
    public static String decrypt(String encryptedData){
        String decryptedValue = null;
        try{
        Key key = generateKey();
        Cipher c = Cipher.getInstance(ALGO);
        c.init(Cipher.DECRYPT_MODE, key);
        byte[] decordedValue = new BASE64Decoder().decodeBuffer(encryptedData);
        byte[] decValue = c.doFinal(decordedValue);
        decryptedValue = new String(decValue);
    }catch(Exception e){
        //LOGGER.error(""In TD:"" + e);
        //Teneno_StartupService.loadForConnectionFailed();
    }
    return decryptedValue;
}
private static Key generateKey(){
    Key key = new SecretKeySpec(keyValue, ALGO);
    return key;
}
",4,0,00e2ef64eb4dbe9045cb767fea003ae321c05cf83c3f46c10fc9259cd5c51d16
,"  static {   
          Security.addProvider(new PACKED-NAME.JSSEProvider());   
         }  
",,1,d1c00a054e696c092ba24bfa3bdf09793920be6cbbc670f845995fbc366fb115
,"public class ImageCache {
    private static final String TAG = ""ImageCache"";

    // Default memory cache size
    private static final int DEFAULT_MEM_CACHE_SIZE = 1024 * 1024 * 5; // 5MB

    // Default disk cache size
    private static final int DEFAULT_DISK_CACHE_SIZE = 1024 * 1024 * 10; // 10MB

    // Compression settings when writing images to disk cache
    private static final CompressFormat DEFAULT_COMPRESS_FORMAT = CompressFormat.JPEG;
    private static final int DEFAULT_COMPRESS_QUALITY = 70;
    private static final int DISK_CACHE_INDEX = 0;

    // Constants to easily toggle various caches
    private static final boolean DEFAULT_MEM_CACHE_ENABLED = true;
    private static final boolean DEFAULT_DISK_CACHE_ENABLED = true;
    private static final boolean DEFAULT_CLEAR_DISK_CACHE_ON_START = false;
    private static final boolean DEFAULT_INIT_DISK_CACHE_ON_CREATE = false;

    private DiskLruCache mDiskLruCache;
    private LruCache&lt;String, Bitmap&gt; mMemoryCache;
    private ImageCacheParams mCacheParams;
    private final Object mDiskCacheLock = new Object();
    private boolean mDiskCacheStarting = true;

    /**
     * Creating a new ImageCache object using the specified parameters.
     *
     * @param cacheParams The cache parameters to use to initialize the cache
     */
    public ImageCache(ImageCacheParams cacheParams) {
        init(cacheParams);
    }

    /**
     * Creating a new ImageCache object using the default parameters.
     *
     * @param context The context to use
     * @param uniqueName A unique name that will be appended to the cache directory
     */
    public ImageCache(Context context, String uniqueName) {
        init(new ImageCacheParams(context, uniqueName));
    }

    /**
     * Find and return an existing ImageCache stored in a {@link RetainFragment}, if not found a new
     * one is created using the supplied params and saved to a {@link RetainFragment}.
     *
     * @param fragmentManager The fragment manager to use when dealing with the retained fragment.
     * @param cacheParams The cache parameters to use if creating the ImageCache
     * @return An existing retained ImageCache object or a new one if one did not exist
     */
    public static ImageCache findOrCreateCache(
            FragmentManager fragmentManager, ImageCacheParams cacheParams) {

        // Search for, or create an instance of the non-UI RetainFragment
        final RetainFragment mRetainFragment = findOrCreateRetainFragment(fragmentManager);

        // See if we already have an ImageCache stored in RetainFragment
        ImageCache imageCache = (ImageCache) mRetainFragment.getObject();

        // No existing ImageCache, create one and store it in RetainFragment
        if (imageCache == null) {
            imageCache = new ImageCache(cacheParams);
            mRetainFragment.setObject(imageCache);
        }

        return imageCache;
    }

    /**
     * Initialize the cache, providing all parameters.
     *
     * @param cacheParams The cache parameters to initialize the cache
     */
    private void init(ImageCacheParams cacheParams) {
        mCacheParams = cacheParams;

        // Set up memory cache
        if (mCacheParams.memoryCacheEnabled) {
            if (BuildConfig.DEBUG) {
                Log.d(TAG, ""Memory cache created (size = "" + mCacheParams.memCacheSize + "")"");
            }
            mMemoryCache = new LruCache&lt;String, Bitmap&gt;(mCacheParams.memCacheSize) {
                /**
                 * Measure item size in bytes rather than units which is more practical
                 * for a bitmap cache
                 */
                @Override
                protected int sizeOf(String key, Bitmap bitmap) {
                    return getBitmapSize(bitmap);
                }
            };
        }

        // By default the disk cache is not initialized here as it should be initialized
        // on a separate thread due to disk access.
        if (cacheParams.initDiskCacheOnCreate) {
            // Set up disk cache
            initDiskCache();
        }
    }

    /**
     * Initializes the disk cache.  Note that this includes disk access so this should not be
     * executed on the main/UI thread. By default an ImageCache does not initialize the disk
     * cache when it is created, instead you should call initDiskCache() to initialize it on a
     * background thread.
     */
    public void initDiskCache() {
        // Set up disk cache
        synchronized (mDiskCacheLock) {
            if (mDiskLruCache == null || mDiskLruCache.isClosed()) {
                File diskCacheDir = mCacheParams.diskCacheDir;
                if (mCacheParams.diskCacheEnabled &amp;&amp; diskCacheDir != null) {
                    if (!diskCacheDir.exists()) {
                        diskCacheDir.mkdirs();
                    }
                    if (getUsableSpace(diskCacheDir) &gt; mCacheParams.diskCacheSize) {
                        try {
                            mDiskLruCache = DiskLruCache.open(
                                    diskCacheDir, 1, 1, mCacheParams.diskCacheSize);
                            if (BuildConfig.DEBUG) {
                                Log.d(TAG, ""Disk cache initialized"");
                            }
                        } catch (final IOException e) {
                            mCacheParams.diskCacheDir = null;
                            Log.e(TAG, ""initDiskCache - "" + e);
                        }
                    }
                }
            }
            mDiskCacheStarting = false;
            mDiskCacheLock.notifyAll();
        }
    }

    /**
     * Adds a bitmap to both memory and disk cache.
     * @param data Unique identifier for the bitmap to store
     * @param bitmap The bitmap to store
     */
    public void addBitmapToCache(String data, Bitmap bitmap) {
        if (data == null || bitmap == null) {
            return;
        }

        // Add to memory cache
        if (mMemoryCache != null &amp;&amp; mMemoryCache.get(data) == null) {
            mMemoryCache.put(data, bitmap);
        }

        synchronized (mDiskCacheLock) {
            // Add to disk cache
            if (mDiskLruCache != null) {
                final String key = hashKeyForDisk(data);
                OutputStream out = null;
                try {
                    DiskLruCache.Snapshot snapshot = mDiskLruCache.get(key);
                    if (snapshot == null) {
                        final DiskLruCache.Editor editor = mDiskLruCache.edit(key);
                        if (editor != null) {
                            out = editor.newOutputStream(DISK_CACHE_INDEX);
                            bitmap.compress(
                                    mCacheParams.compressFormat, mCacheParams.compressQuality, out);
                            editor.commit();
                            out.close();
                        }
                    } else {
                        snapshot.getInputStream(DISK_CACHE_INDEX).close();
                    }
                } catch (final IOException e) {
                    Log.e(TAG, ""addBitmapToCache - "" + e);
                } catch (Exception e) {
                    Log.e(TAG, ""addBitmapToCache - "" + e);
                } finally {
                    try {
                        if (out != null) {
                            out.close();
                        }
                    } catch (IOException e) {}
                }
            }
        }
    }

    /**
     * Get from memory cache.
     *
     * @param data Unique identifier for which item to get
     * @return The bitmap if found in cache, null otherwise
     */
    public Bitmap getBitmapFromMemCache(String data) {
        if (mMemoryCache != null) {
            final Bitmap memBitmap = mMemoryCache.get(data);
            if (memBitmap != null) {
                if (BuildConfig.DEBUG) {
                    Log.d(TAG, ""Memory cache hit"");
                }
                return memBitmap;
            }
        }
        return null;
    }

    /**
     * Get from disk cache.
     *
     * @param data Unique identifier for which item to get
     * @return The bitmap if found in cache, null otherwise
     */
    public Bitmap getBitmapFromDiskCache(String data) {
        final String key = hashKeyForDisk(data);
        synchronized (mDiskCacheLock) {
            while (mDiskCacheStarting) {
                try {
                    mDiskCacheLock.wait();
                } catch (InterruptedException e) {}
            }
            if (mDiskLruCache != null) {
                InputStream inputStream = null;
                try {
                    final DiskLruCache.Snapshot snapshot = mDiskLruCache.get(key);
                    if (snapshot != null) {
                        if (BuildConfig.DEBUG) {
                            Log.d(TAG, ""Disk cache hit"");
                        }
                        inputStream = snapshot.getInputStream(DISK_CACHE_INDEX);
                        if (inputStream != null) {
                            final Bitmap bitmap = BitmapFactory.decodeStream(inputStream);
                            return bitmap;
                        }
                    }
                } catch (final IOException e) {
                    Log.e(TAG, ""getBitmapFromDiskCache - "" + e);
                } finally {
                    try {
                        if (inputStream != null) {
                            inputStream.close();
                        }
                    } catch (IOException e) {}
                }
            }
            return null;
        }
    }

    /**
     * Clears both the memory and disk cache associated with this ImageCache object. Note that
     * this includes disk access so this should not be executed on the main/UI thread.
     */
    public void clearCache() {
        if (mMemoryCache != null) {
            mMemoryCache.evictAll();
            if (BuildConfig.DEBUG) {
                Log.d(TAG, ""Memory cache cleared"");
            }
        }

        synchronized (mDiskCacheLock) {
            mDiskCacheStarting = true;
            if (mDiskLruCache != null &amp;&amp; !mDiskLruCache.isClosed()) {
                try {
                    mDiskLruCache.delete();
                    if (BuildConfig.DEBUG) {
                        Log.d(TAG, ""Disk cache cleared"");
                    }
                } catch (IOException e) {
                    Log.e(TAG, ""clearCache - "" + e);
                }
                mDiskLruCache = null;
                initDiskCache();
            }
        }
    }

    /**
     * Flushes the disk cache associated with this ImageCache object. Note that this includes
     * disk access so this should not be executed on the main/UI thread.
     */
    public void flush() {
        synchronized (mDiskCacheLock) {
            if (mDiskLruCache != null) {
                try {
                    mDiskLruCache.flush();
                    if (BuildConfig.DEBUG) {
                        Log.d(TAG, ""Disk cache flushed"");
                    }
                } catch (IOException e) {
                    Log.e(TAG, ""flush - "" + e);
                }
            }
        }
    }

    /**
     * Closes the disk cache associated with this ImageCache object. Note that this includes
     * disk access so this should not be executed on the main/UI thread.
     */
    public void close() {
        synchronized (mDiskCacheLock) {
            if (mDiskLruCache != null) {
                try {
                    if (!mDiskLruCache.isClosed()) {
                        mDiskLruCache.close();
                        mDiskLruCache = null;
                        if (BuildConfig.DEBUG) {
                            Log.d(TAG, ""Disk cache closed"");
                        }
                    }
                } catch (IOException e) {
                    Log.e(TAG, ""close - "" + e);
                }
            }
        }
    }

    /**
     * A holder class that contains cache parameters.
     */
    public static class ImageCacheParams {
        public int memCacheSize = DEFAULT_MEM_CACHE_SIZE;
        public int diskCacheSize = DEFAULT_DISK_CACHE_SIZE;
        public File diskCacheDir;
        public CompressFormat compressFormat = DEFAULT_COMPRESS_FORMAT;
        public int compressQuality = DEFAULT_COMPRESS_QUALITY;
        public boolean memoryCacheEnabled = DEFAULT_MEM_CACHE_ENABLED;
        public boolean diskCacheEnabled = DEFAULT_DISK_CACHE_ENABLED;
        public boolean clearDiskCacheOnStart = DEFAULT_CLEAR_DISK_CACHE_ON_START;
        public boolean initDiskCacheOnCreate = DEFAULT_INIT_DISK_CACHE_ON_CREATE;

        public ImageCacheParams(Context context, String uniqueName) {
            diskCacheDir = getDiskCacheDir(context, uniqueName);
        }

        public ImageCacheParams(File diskCacheDir) {
            this.diskCacheDir = diskCacheDir;
        }

        /**
         * Sets the memory cache size based on a percentage of the device memory class.
         * Eg. setting percent to 0.2 would set the memory cache to one fifth of the device memory
         * class. Throws {@link IllegalArgumentException} if percent is &lt; 0.05 or &gt; .8.
         *
         * This value should be chosen carefully based on a number of factors
         * Refer to the corresponding Android Training class for more discussion:
         * http://developer.android.com/training/displaying-bitmaps/
         *
         * @param context Context to use to fetch memory class
         * @param percent Percent of memory class to use to size memory cache
         */
        public void setMemCacheSizePercent(Context context, float percent) {
            if (percent &lt; 0.05f || percent &gt; 0.8f) {
                throw new IllegalArgumentException(""setMemCacheSizePercent - percent must be ""
                        + ""between 0.05 and 0.8 (inclusive)"");
            }
            memCacheSize = Math.round(percent * getMemoryClass(context) * 1024 * 1024);
        }

        private static int getMemoryClass(Context context) {
            return ((ActivityManager) context.getSystemService(
                    Context.ACTIVITY_SERVICE)).getMemoryClass();
        }
    }

    /**
     * Get a usable cache directory (external if available, internal otherwise).
     *
     * @param context The context to use
     * @param uniqueName A unique directory name to append to the cache dir
     * @return The cache dir
     */
    public static File getDiskCacheDir(Context context, String uniqueName) {
        // Check if media is mounted or storage is built-in, if so, try and use external cache dir
        // otherwise use internal cache dir
        final String cachePath =
                Environment.MEDIA_MOUNTED.equals(Environment.getExternalStorageState()) ||
                        !isExternalStorageRemovable() ? getExternalCacheDir(context).getPath() :
                                context.getCacheDir().getPath();

        return new File(cachePath + File.separator + uniqueName);
    }

    /**
     * A hashing method that changes a string (like a URL) into a hash suitable for using as a
     * disk filename.
     */
    public static String hashKeyForDisk(String key) {
        String cacheKey;
        try {
            final MessageDigest mDigest = MessageDigest.getInstance(""MD5"");
            mDigest.update(key.getBytes());
            cacheKey = bytesToHexString(mDigest.digest());
        } catch (NoSuchAlgorithmException e) {
            cacheKey = String.valueOf(key.hashCode());
        }
        return cacheKey;
    }

    private static String bytesToHexString(byte[] bytes) {
        // http://stackoverflow.com/questions/332079
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i &lt; bytes.length; i++) {
            String hex = Integer.toHexString(0xFF &amp; bytes[i]);
            if (hex.length() == 1) {
                sb.append('0');
            }
            sb.append(hex);
        }
        return sb.toString();
    }

    /**
     * Get the size in bytes of a bitmap.
     * @param bitmap
     * @return size in bytes
     */
    @TargetApi(12)
    public static int getBitmapSize(Bitmap bitmap) {
        if (Utils.hasHoneycombMR1()) {
            return bitmap.getByteCount();
        }
        // Pre HC-MR1
        return bitmap.getRowBytes() * bitmap.getHeight();
    }

    /**
     * Check if external storage is built-in or removable.
     *
     * @return True if external storage is removable (like an SD card), false
     *         otherwise.
     */
    @TargetApi(9)
    public static boolean isExternalStorageRemovable() {
        if (Utils.hasGingerbread()) {
            return Environment.isExternalStorageRemovable();
        }
        return true;
    }

    /**
     * Get the external app cache directory.
     *
     * @param context The context to use
     * @return The external cache dir
     */
    @TargetApi(8)
    public static File getExternalCacheDir(Context context) {
        if (Utils.hasFroyo()) {
            return context.getExternalCacheDir();
        }

        // Before Froyo we need to construct the external cache dir ourselves
        final String cacheDir = ""/Android/data/"" + context.getPackageName() + ""/cache/"";
        return new File(Environment.getExternalStorageDirectory().getPath() + cacheDir);
    }

    /**
     * Check how much usable space is available at a given path.
     *
     * @param path The path to check
     * @return The space available in bytes
     */
    @TargetApi(9)
    public static long getUsableSpace(File path) {
        if (Utils.hasGingerbread()) {
            return path.getUsableSpace();
        }
        final StatFs stats = new StatFs(path.getPath());
        return (long) stats.getBlockSize() * (long) stats.getAvailableBlocks();
    }

    /**
     * Locate an existing instance of this Fragment or if not found, create and
     * add it using FragmentManager.
     *
     * @param fm The FragmentManager manager to use.
     * @return The existing instance of the Fragment or the new instance if just
     *         created.
     */
    public static RetainFragment findOrCreateRetainFragment(FragmentManager fm) {
        // Check to see if we have retained the worker fragment.
        RetainFragment mRetainFragment = (RetainFragment) fm.findFragmentByTag(TAG);

        // If not retained (or first time running), we need to create and add it.
        if (mRetainFragment == null) {
            mRetainFragment = new RetainFragment();
            fm.beginTransaction().add(mRetainFragment, TAG).commitAllowingStateLoss();
        }

        return mRetainFragment;
    }

    /**
     * A simple non-UI Fragment that stores a single Object and is retained over configuration
     * changes. It will be used to retain the ImageCache object.
     */
    public static class RetainFragment extends Fragment {
        private Object mObject;

        /**
         * Empty constructor as per the Fragment documentation
         */
        public RetainFragment() {}

        @Override
        public void onCreate(Bundle savedInstanceState) {
            super.onCreate(savedInstanceState);

            // Make sure this Fragment is retained over a configuration change
            setRetainInstance(true);
        }

        /**
         * Store a single object in this Fragment.
         *
         * @param object The object to store
         */
        public void setObject(Object object) {
            mObject = object;
        }

        /**
         * Get the stored object.
         *
         * @return The stored object
         */
        public Object getObject() {
            return mObject;
        }
    }

}
",,1,0beef37e965cef628336cd360740be8a90f2065700022bf72698db9e5cbe324f
,"    String Verify_Mobile_URL =""https://www.sample.php"";
                        try 
                        {

                            StringBuilder postDataBuilder = new StringBuilder();
                            postDataBuilder.append(""param1"").append(""="").append(""paramvalue"");
                            postDataBuilder.append(""&amp;"").append(""param2"").append(""="").append(""paramvalue"");


                            byte[] postData = postDataBuilder.toString().getBytes();

                            // Hit the dm URL.

                            URL url = new URL(Verify_Mobile_URL);
                            HttpsURLConnection.setDefaultHostnameVerifier(new AllVerifier());
                            SSLContext sslContext = SSLContext.getInstance(""TLS"");
                            sslContext.init(null, new TrustManager[] { new AllTrustManager() }, null);
                            HttpsURLConnection.setDefaultSSLSocketFactory(sslContext.getSocketFactory());
                            HttpsURLConnection conn = (HttpsURLConnection) url.openConnection();        
                            conn.setReadTimeout(60000);
                            conn.setConnectTimeout(35000);
                            conn.setDoOutput(true);
                            conn.setUseCaches(false);
                            conn.setRequestMethod(""POST"");
                            conn.setRequestProperty(""Content-Type"", ""application/x-www-form-urlencoded"");
                            conn.setRequestProperty(""Content-Length"",Integer.toString(postData.length));

                            OutputStream out = conn.getOutputStream();
                            out.write(postData);
                            out.close();

                            int responseCode = conn.getResponseCode();
                            if(responseCode==200)
                            {
                                InputStream inputstream=conn.getInputStream();  
                                String result=streamToString(inputstream);   // here you will will get result from

                            }
                            catch(Exception e)
                            {
                            }







/**
     * This method convert inputstream to string
     * @param is - inputtream to be converted
     * @return String - converted string 
     */
    public static String streamToString(InputStream is)
    {
        DataInputStream din = new DataInputStream(is);
        StringBuffer sb = new StringBuffer();
        try {
            String line = null;
            while ((line = din.readLine()) != null) 
            {
                sb.append(line + ""\n"");
            }

        } 
        catch (Exception ex) 
        {}      

        finally 
        {
            try 
            {  if(is!=null)
                {
                    din.close();
                    is.close();
                }
            } 
            catch (Exception ex) 
            {}

        }
        return sb.toString();

    }
















public class AllTrustManager implements X509TrustManager {

    @Override
    public void checkClientTrusted(X509Certificate[] chain, String authType)
            throws CertificateException {
        // TODO Auto-generated method stub

    }

    @Override
    public void checkServerTrusted(X509Certificate[] chain, String authType)
            throws CertificateException {
        // TODO Auto-generated method stub

    }

    @Override
    public X509Certificate[] getAcceptedIssuers() {
        // TODO Auto-generated method stub
        return new X509Certificate[0];
    }

}





public class AllVerifier implements HostnameVerifier {

    @Override
    public boolean verify(String hostname, SSLSession session) {
        // TODO Auto-generated method stub
        return true;
    }

}
",4,0,fe6a866c724f4ab234dd5d4d71b703107998edc8e348efecd71ff2df97637436
,"public class Cryptos {

private static final String ME = Cryptos.class.getSimpleName();
private static String strEncoding = ""UTF-8"";
private static String STATIC_STRING_IV_16 = ""1234567890123456"";
private String iv;
private String key;
private IvParameterSpec mIvParameterSpec;
private SecretKeySpec mSecretKeySpec;
private Cipher mCipher;

public Cryptos(String key) {
    this(STATIC_STRING_IV_16,key);
}

public Cryptos(String iv, String key) {
    this.iv = cut(iv, 16);
    this.key = key;

    mIvParameterSpec = new IvParameterSpec(this.iv.getBytes());
    mSecretKeySpec = new SecretKeySpec(this.key.getBytes(), ""AES"");

    try {
        mCipher = Cipher.getInstance(""AES/CBC/NoPadding"");
    } catch (NoSuchAlgorithmException e) {
        App.log.e(ME, ""Got Exception while initializing mCipher: "" + e.toString(), e);
    } catch (NoSuchPaddingException e) {
        App.log.e(ME, ""Got Exception while initializing mCipher: "" + e.toString(), e);
    }
}


public byte[] decryptHex(String hexString) throws Exception {
    if(hexString == null || hexString.length() == 0) {
        throw new Exception(""Emtpy string given"");
    }
    return byteTrim(decrypt(hexToBytes(hexString)));
}

public byte[] decrypt(byte[] input){
    try {
        mCipher.init(Cipher.DECRYPT_MODE, mSecretKeySpec, mIvParameterSpec);
        byte[] decrypted = new byte[mCipher.getOutputSize(input.length)];
        int dec_len = mCipher.update(input, 0, input.length, decrypted, 0);
        dec_len += mCipher.doFinal(decrypted, dec_len);
        return ARRAY.copyOf(decrypted, dec_len);
    } catch (ShortBufferException e) {
        e.printStackTrace();
    } catch (IllegalBlockSizeException e) {
        e.printStackTrace();
    } catch (BadPaddingException e) {
        e.printStackTrace();
    } catch (InvalidKeyException e) {
        e.printStackTrace();
    } catch (InvalidAlgorithmParameterException e) {
        e.printStackTrace();
    }
    return null;
}



public byte[] encrypt(String text) throws Exception{
    if(text == null || text.length() == 0) throw new Exception(""Empty string"");
    return encrypt(text.getBytes(strEncoding));
}

public byte[] encrypt(byte[] data){
    if(data==null) return null;

    try {
        int bts = data.length;
        byte[] alignData = ARRAY.copyOf(data, bts+(16-bts%16));
        data = alignData;
        mCipher.init(Cipher.ENCRYPT_MODE, mSecretKeySpec, mIvParameterSpec);
        byte[] encrypted = new byte[mCipher.getOutputSize(data.length)];
        int enc_len = mCipher.update(data, 0, data.length, encrypted, 0);
        enc_len += mCipher.doFinal(encrypted, enc_len);
        return ARRAY.copyOf(encrypted, enc_len);
    } catch (ShortBufferException e) {
        e.printStackTrace();
    } catch (IllegalBlockSizeException e) {
        e.printStackTrace();
    } catch (BadPaddingException e) {
        e.printStackTrace();
    } catch (InvalidKeyException e) {
        e.printStackTrace();
    } catch (InvalidAlgorithmParameterException e) {
        e.printStackTrace();
    }
    return null;
}

public static String bytesToHex(byte[] b){
    StringBuffer buf = new StringBuffer();
    int len = b.length;
    for (int j=0; j&lt;len; j++)
        buf.append(byteToHex(b[j]));
    return buf.toString();
}

public static String byteToHex(byte b){
    char hexDigit[] = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'};
    char[] a = { hexDigit[(b &gt;&gt; 4) &amp; 0x0f], hexDigit[b &amp; 0x0f] };
    return new String(a);
}

public static byte[] hexToBytes(String str) {
    if (str==null) {
        return null;
    } else if (str.length() &lt; 2) {
        return null;
    } else {
        int len = str.length() / 2;
        byte[] buffer = new byte[len];
        for (int i=0; i&lt;len; i++) {
            buffer[i] = (byte) Integer.parseInt(str.substring(i*2,i*2+2),16);
        }
        return buffer;
    }
}


private byte[] byteTrim(byte[] bytes){
    if( bytes.length &gt; 0){
        int trim = 0;
        for( int i = bytes.length - 1; i &gt;= 0; i-- ){
            if( bytes[i] == 0 ){
                trim++;
            }else{
                break;
            }
        }
        if( trim &gt; 0 ){
            byte[] newArray = new byte[bytes.length - trim];
            System.arraycopy(bytes, 0, newArray, 0, bytes.length - trim);
            return newArray;
        }
    }
    return bytes;
}

private String cut(String s, int n) {
    byte[] sBytes = s.getBytes();
    if(sBytes.length &lt; n) {
        n = sBytes.length;
    }
    boolean extraLong = false;
    int i = 0, n16 = 0;
    while(i &lt; n) {
        n16 += (extraLong) ? 2 : 1;
        extraLong = false;
        if((sBytes[i] &amp; 0x80) == 0) {
            i += 1;
        } else if((sBytes[i] &amp; 0xC0) == 0x80) {
            i += 2;
        } else if((sBytes[i] &amp; 0xE0) == 0xC0) {
            i += 3;
        } else {
            i += 4;
            extraLong = true;
        }
    }
    return s.substring(0, n16);
}

public static String encBase64(byte[] bytes){
    return Base64.encodeToString(bytes, Base64.DEFAULT);
}

public static byte[] decBase64(String data){
    return Base64.decode(data, Base64.DEFAULT);
}   
}
",4,0,bfa12f73f65a56401c931f0031a5ce12478fc501632217ab0bc2464ba58306e9
,"MessageDigest md5Hash = MessageDigest.getInstance(""MD5"");
mDigest = md5Hash.digest(password.getBytes());
String hashedMessage = new String(Hex.encodeHex(mDigest));
",4,0,35f445b178486bdbf5c25b635bee60fa7b087603af216731fa205b4ccde0feda
,"import java.math.*;
import java.security.*;

public class testMain {

    /**
     * @param args
     */
    public static void main(String[] args) {

        String stringThatNeedsToBeEncrpyted = ""yourURL""; // Value to encrypt
        MessageDigest mdEnc = null;
        try {
            mdEnc = MessageDigest.getInstance(""MD5"");
        } catch (NoSuchAlgorithmException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        } // Encryption algorithm
        mdEnc.update(stringThatNeedsToBeEncrpyted.getBytes(), 0, stringThatNeedsToBeEncrpyted.length());
        String md5 = new BigInteger(1, mdEnc.digest()).toString(16); //Make the Encrypted string
        System.out.println(md5); //print the string in the console

    }   
}
",,1,81b7211aeaf7c1264a2a357e020f6900d5b8b02506a6544436f1eb78927acb05
,"KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());
kmf.init(null, null);
KeyManager km = kmf.getKeyManagers()[0];

ftpsClient = new FTPSClient(""SSL"");
ftpsClient.setKeyManager(km);
",,1,7c3e1c2afe3515649f597f61e69ae2ce502791d02d444761ad81a151c2f77012
,"/**
 * A strengthener that can be used to generate and re-seed random number
 * generators that do not seed themselves appropriately.
 * 
 * @author owlstead
 */
public class SecureRandomStrengthener {
    private static final String DEFAULT_PSEUDO_RANDOM_NUMBER_GENERATOR = ""SHA1PRNG"";

    private static final EntropySource TIME_ENTROPY_SOURCE = new EntropySource() {

        final ByteBuffer timeBuffer = ByteBuffer.allocate(Long.SIZE / Byte.SIZE
                * 2);

        @Override
        public ByteBuffer provideEntropy() {
            this.timeBuffer.clear();
            this.timeBuffer.putLong(System.currentTimeMillis());
            this.timeBuffer.putLong(System.nanoTime());
            this.timeBuffer.flip();
            return this.timeBuffer;
        }
    };

    private final String algorithm;
    private final List&lt;EntropySource&gt; entropySources = new LinkedList&lt;EntropySource&gt;();
    private final MessageDigest digest;
    private final ByteBuffer seedBuffer;

    /**
     * Generates an instance of a {@link SecureRandomStrengthener} that
     * generates and re-seeds instances of {@code ""SHA1PRNG""}.
     * 
     * @return the strengthener, never null
     */
    public static SecureRandomStrengthener getInstance() {
        return new SecureRandomStrengthener(
                DEFAULT_PSEUDO_RANDOM_NUMBER_GENERATOR);
    }

    /**
     * Generates an instance of a {@link SecureRandomStrengthener} that
     * generates instances of the given argument. Note that the availability of
     * the given algorithm arguments in not tested until generation.
     * 
     * @param algorithm
     *            the algorithm indicating the {@link SecureRandom} instance to
     *            use
     * @return the strengthener, never null
     */
    public static SecureRandomStrengthener getInstance(final String algorithm) {
        return new SecureRandomStrengthener(algorithm);
    }

    private SecureRandomStrengthener(final String algorithm) {
        if (algorithm == null || algorithm.length() == 0) {
            throw new IllegalArgumentException(
                    ""Please provide a PRNG algorithm string such as SHA1PRNG"");
        }

        this.algorithm = algorithm;
        try {
            this.digest = MessageDigest.getInstance(""SHA1"");
        } catch (final NoSuchAlgorithmException e) {
            throw new IllegalStateException(
                    ""MessageDigest to create seed not available"", e);
        }
        this.seedBuffer = ByteBuffer.allocate(this.digest.getDigestLength());
    }

    /**
     * Add an entropy source, which will be called for each generation and
     * re-seeding of the given random number generator.
     * 
     * @param source
     *            the source of entropy
     */
    public void addEntropySource(final EntropySource source) {
        if (source == null) {
            throw new IllegalArgumentException(
                    ""EntropySource should not be null"");
        }
        this.entropySources.add(source);
    }

    /**
     * Generates and seeds a random number generator of the configured
     * algorithm. Calls the {@link EntropySource#provideEntropy()} method of all
     * added sources of entropy.
     * 
     * @return the random number generator
     */
    public SecureRandom generateAndSeedRandomNumberGenerator() {
        final SecureRandom secureRandom;
        try {
            secureRandom = SecureRandom.getInstance(this.algorithm);
        } catch (final NoSuchAlgorithmException e) {
            throw new IllegalStateException(""PRNG is not available"", e);
        }

        reseed(secureRandom);
        return secureRandom;
    }

    /**
     * Re-seeds the random number generator. Calls the
     * {@link EntropySource#provideEntropy()} method of all added sources of
     * entropy.
     * 
     * @param secureRandom
     *            the random number generator to re-seed
     */
    public void reseed(final SecureRandom secureRandom) {
        this.seedBuffer.clear();
        secureRandom.nextBytes(this.seedBuffer.array());

        for (final EntropySource source : this.entropySources) {
            final ByteBuffer entropy = source.provideEntropy();
            if (entropy == null) {
                continue;
            }

            final ByteBuffer wipeBuffer = entropy.duplicate();
            this.digest.update(entropy);
            wipe(wipeBuffer);
        }

        this.digest.update(TIME_ENTROPY_SOURCE.provideEntropy());
        this.digest.update(this.seedBuffer);
        this.seedBuffer.clear();
        // remove data from seedBuffer so it won't be retrievable

        // reuse

        try {
            this.digest.digest(this.seedBuffer.array(), 0,
                    this.seedBuffer.capacity());
        } catch (final DigestException e) {
            throw new IllegalStateException(
                    ""DigestException should not be thrown"", e);
        }
        secureRandom.setSeed(this.seedBuffer.array());

        wipe(this.seedBuffer);
    }

    private void wipe(final ByteBuffer buf) {
        while (buf.hasRemaining()) {
            buf.put((byte) 0);
        }
    }
}
",1,0,13f74cb5439923d4f2a5fb1575264f6e332c48b0fb886e23cbf5d631ee16b84f
,"public static String getMD5Hash(String s) throws NoSuchAlgorithmException {

String result = s;
if (s != null) {
    MessageDigest md = MessageDigest.getInstance(""MD5""); // or ""SHA-1""
    md.update(s.getBytes());
    BigInteger hash = new BigInteger(1, md.digest());
    result = hash.toString(16);
    while (result.length() &lt; 32) { // 40 for SHA-1
        result = ""0"" + result;
    }
}
return result; }
",,1,c6befa15e9d9dde57dabebc9cd6e33534b40bdcb0aeb7f385aab71d82c0a4b74
,"CertificateFactory factory = CertificateFactory.getInstance(""X.509"");
X509Certificate x509Server;
ByteArrayInputStream bias = new ByteArrayInputStream(certBytes);
x509Server= (X509Certificate) factory.generateCertificate(bias);
",,1,2c3979a80f30894bbc6ebb67b29104cde3432a9c9b5cc1157ec9a05f568c5302
,"private static char[] hextable = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' };

private static String md5(String s)
{
    MessageDigest digest;
    try
    {
        digest = MessageDigest.getInstance(""MD5"");
        digest.update(s.getBytes(), 0, s.length());
        byte[] bytes = digest.digest();

        String hash = """";
        for (int i = 0; i &lt; bytes.length; ++i)
        {
            int di = (bytes[i] + 256) &amp; 0xFF;
            hash = hash + hextable[(di &gt;&gt; 4) &amp; 0xF] + hextable[di &amp; 0xF];
        }

        return hash;
    }
    catch (NoSuchAlgorithmException e)
    {
    }

    return """";
}
",3,0,fb3665d0e8e2de8026884f796f931ec988caa32c2fd8de7bc7b3b2a630287ae2
,"PackageInfo packageInfo = context.getPackageManager().getPackageInfo(
    context.getPackageName(), PackageManager.GET_SIGNATURES);

for (Signature signature : packageInfo.signatures) {
    byte[] signatureBytes = signature.toByteArray();
    MessageDigest md = MessageDigest.getInstance(""SHA"");
    md.update(signature.toByteArray());
    final String currentSignature = Base64.encodeToString(md.digest(), Base64.DEFAULT);
    if (SIGNATURE.equals(currentSignature)){
      return true;
    }
}
return fals;
",3,0,e3178f00dab1fea55233a6d122f730bcd155d1788a0e8e391ff6d0fb76c88bcf
,"try {
            PackageInfo info = getPackageManager().getPackageInfo(
                    ""com.org.package"", PackageManager.GET_SIGNATURES);
            for (Signature signature : info.signatures) {
                MessageDigest md = MessageDigest.getInstance(""SHA"");
                md.update(signature.toByteArray());
                String sign = Base64
                        .encodeToString(md.digest(), Base64.DEFAULT);

                    Log.e(""MY KEY HASH:"", sign);

            }
        } catch (NameNotFoundException e) {
        } catch (NoSuchAlgorithmException e) {
        }
",3,0,8c166243a392f59cc38396315a6d86d554a4b8c42bf7db0b590bbf4489b8a687
,"try {
    PackageInfo info = getPackageManager().getPackageInfo(pkgName, PackageManager.GET_SIGNATURES);
    Signature[] sigs = info.signatures;
    for (Signature sig : sigs) {
        CertificateFactory certFactory = CertificateFactory.getInstance(""X.509"");
        ByteArrayInputStream in = new ByteArrayInputStream(sig.toByteArray());
        X509Certificate cert = (X509Certificate) certFactory.generateCertificate(in);
        // Verify or inspect cert here
    }
} catch (...) {
    //...
}
",,1,e3f17980a6fc2049a06806c8c7611fee4669e2b8968d80396521814abaf8bce5
,"public void buttonAppClick() {
    final PackageManager pm = getActivity().getPackageManager();
    //get a list of installed apps.
    List&lt;ApplicationInfo&gt; packages = pm.getInstalledApplications(PackageManager.GET_META_DATA);
    outputTextView.setText("""");
    for (ApplicationInfo packageInfo : packages) {
        try {
            String packageName = packageInfo.packageName;
            outputTextView.append(""Apk Path : "" + packageInfo.sourceDir + ""\n"");
            PackageInfo pi = pm.getPackageInfo(packageName, PackageManager.GET_SIGNATURES);

            Signature sig = pi.signatures[0];
            String md5Fingerprint = doFingerprint(sig.toByteArray(), ""MD5"");
            Log.d(TAG_HOME, ""MD5 : "" + packageInfo.sourceDir + md5Fingerprint);
            outputTextView.append(""MD5 : "" + md5Fingerprint + ""\n"");
            outputTextView.append(""\n"");
        }
        catch (Exception e) {
            Log.e(TAG_HOME, e.getMessage());
        }
    }
}

protected static String doFingerprint(byte[] certificateBytes, String algorithm)
        throws Exception {
    MessageDigest md = MessageDigest.getInstance(algorithm);
    md.update(certificateBytes);
    byte[] digest = md.digest();

    String toRet = """";
    for (int i = 0; i &lt; digest.length; i++) {
        if (i != 0)
            toRet += "":"";
        int b = digest[i] &amp; 0xff;
        String hex = Integer.toHexString(b);
        if (hex.length() == 1)
            toRet += ""0"";
        toRet += hex;
    }
    return toRet;
}
",,1,e3dddfeeb1e53d6aa7b415ed4e55e8f5e56798e8a142a9f58b1b872cbac2f1fe
,"package com.infovale.cripto;

import java.io.UnsupportedEncodingException;
import java.math.BigInteger;
import java.security.InvalidKeyException;
import java.security.KeyPair;
import java.security.KeyPairGenerator;
import java.security.NoSuchAlgorithmException;
import java.security.PrivateKey;
import java.security.PublicKey;
import java.util.Arrays;

import javax.crypto.BadPaddingException;
import javax.crypto.Cipher;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.NoSuchPaddingException;

public class RSA {

KeyPairGenerator kpg;
KeyPair kp;
PublicKey publicKey;
PrivateKey privateKey;
byte[] encryptedBytes, decryptedBytes;
Cipher cipher, cipher1;
String encrypted, decrypted;

public String Encrypt (String plain) throws NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, IllegalBlockSizeException, BadPaddingException 
{
    kpg = KeyPairGenerator.getInstance(""RSA"");
    kpg.initialize(1024);
    kp = kpg.genKeyPair();
    publicKey = kp.getPublic();
    privateKey = kp.getPrivate();

    cipher = Cipher.getInstance(""RSA"");
    cipher.init(Cipher.ENCRYPT_MODE, publicKey);
    encryptedBytes = cipher.doFinal(plain.getBytes());

    encrypted = bytesToString(encryptedBytes);
    return encrypted;

}

public String Decrypt (String result) throws NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, IllegalBlockSizeException, BadPaddingException 
{           

    cipher1=Cipher.getInstance(""RSA"");
    cipher1.init(Cipher.DECRYPT_MODE, privateKey);
    decryptedBytes = cipher1.doFinal(stringToBytes(result));
    decrypted = new String(decryptedBytes);
    return decrypted;

}

public  String bytesToString(byte[] b) {
    byte[] b2 = new byte[b.length + 1];
    b2[0] = 1;
    System.arraycopy(b, 0, b2, 1, b.length);
    return new BigInteger(b2).toString(36);
}

public  byte[] stringToBytes(String s) {
    byte[] b2 = new BigInteger(s, 36).toByteArray();
    return Arrays.copyOfRange(b2, 1, b2.length);
}
}
",3,0,9f56c4b6f3b7767f6f7ddf87ab7daa1ebaa91bda94d9fd51325572018abc6a36
,"private static final char[] HEX_ARRAY = (""0123456789ABCDEF"").toCharArray();

public static String getSHA512HahsOfString(String toHash) throws NoSuchAlgorithmException, UnsupportedEncodingException {
    String hash = null;

    MessageDigest digest = MessageDigest.getInstance(""SHA-512"");
    byte[] bytes = toHash.getBytes(""UTF-8"");

    digest.update(bytes, 0, bytes.length);
    bytes = digest.digest();
    hash = bytesToHex(bytes);

    return hash;
}

public static String bytesToHex(byte[] bytes) {
    char[] hexChars = new char[bytes.length * 2];

    for (int j = 0; j &lt; bytes.length; j++) {
        int v = bytes[j] &amp; 0xFF;
        hexChars[j * 2] = HEX_ARRAY[v &gt;&gt;&gt; 4];
        hexChars[j * 2 + 1] = HEX_ARRAY[v &amp; 0x0F];
    }

    return new String(hexChars);
}
",2,0,9cab5571196425ced1def5bc3c1132aac4f0107614b788bfb60dc5c801f43062
,"public static String printKeyHash(Activity context) {
    PackageInfo packageInfo;
    String key = null;
    try {

        //getting application package name, as defined in manifest
        String packageName = context.getApplicationContext().getPackageName();

        //Retriving package info
        packageInfo = context.getPackageManager().getPackageInfo(packageName,
                PackageManager.GET_SIGNATURES);

        Log.e(""Package Name="", context.getApplicationContext().getPackageName());

        for (Signature signature : packageInfo.signatures) {
            MessageDigest md = MessageDigest.getInstance(""SHA"");
            md.update(signature.toByteArray());
            key = new String(Base64.encode(md.digest(), 0));

            // String key = new String(Base64.encodeBytes(md.digest()));
            //Log.e(""Key Hash="", key);
             Toast.makeText(TAG, ""Keyhash: "" + key, 1).show();

        }
    } catch (NameNotFoundException e1) {
        Log.e(""Name not found"", e1.toString());
    }

    catch (NoSuchAlgorithmException e) {
        Log.e(""No such an algorithm"", e.toString());
    } catch (Exception e) {
        Log.e(""Exception"", e.toString());
    }

    return key;
}
",3,0,ca27149909b47fe7848ba2c86eb67bd9d6b3f457e2b7eee320ea5f0fd4e9dad1
,"byte[] iv = ""87654321"".getBytes(""US-ASCII"");
byte[] key = ""SampleKey"".getBytes(""US-ASCII"");
byte[] data = new byte[30]; // for example

SecretKeySpec skeySpec = new SecretKeySpec(key, ""RC2"");

RC2ParameterSpec ivSpec = new RC2ParameterSpec(key.length * 8, iv);

Cipher cipher = Cipher.getInstance(""RC2/CBC/PKCS5Padding"");
cipher.init(Cipher.ENCRYPT_MODE, skeySpec, ivSpec);
byte[] encrypted = cipher.doFinal(data);

// ....
",4,0,aba65c293ae37cd11feac3d04743f059251af0748bcd72e50947c6cd996123aa
,"public static byte[] createChecksum(byte[] b){
    MessageDigest md = null;
    try {
        md = MessageDigest.getInstance(""MD5"");


    } catch (NoSuchAlgorithmException e) {

        e.printStackTrace();
    }
    md.update(b,0,b.length);
    byte[] checksum = md.digest();
    return checksum;
}
",,1,f7187df4eb9a4d03f1d4cd2851282d38e443b2a1532ef80545c5f9849288e257
,"public String encryptString(String string, String key)
{
    byte[] aesData;
    String base64="""";

    try 
    {
        aesData = encrypt(key, string.getBytes(""UTF8""));
        base64 = Base64.encodeToString(aesData, Base64.DEFAULT);
    } 
    catch (Exception e) 
    {
        e.printStackTrace();
    }       

    return base64;
}

public String decryptString(String string, String key)
{
    byte[] debase64 = null;
    String result="""";

    try 
    {
        debase64=Base64.decode(string, Base64.DEFAULT);
        byte[] aesDecrypted = decrypt(key, debase64);;

        result = new String(aesDecrypted, ""UTF8"");
    } 
    catch (Exception e) 
    {
        e.printStackTrace();
    }       

    return result;
}

private byte[] decrypt(String k, byte[] plainBytes) throws Exception 
{
    // convert key to bytes
    byte[] keyBytes = k.getBytes(""UTF-8"");
    // Use the first 16 bytes (or even less if key is shorter)
    byte[] keyBytes16 = new byte[16];
    System.arraycopy(keyBytes, 0, keyBytes16, 0, Math.min(keyBytes.length, 16));

    // setup cipher
    SecretKeySpec skeySpec = new SecretKeySpec(keyBytes16, ""AES"");
    Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
    byte[] iv = new byte[16]; // initialization vector with all 0
    cipher.init(Cipher.DECRYPT_MODE, skeySpec, new IvParameterSpec(iv));

    // encrypt
    byte[] encrypted = cipher.doFinal(plainBytes);

    return encrypted;
}

private byte[] encrypt(String k, byte[] plainBytes) throws Exception 
{
    // convert key to bytes
    byte[] keyBytes = k.getBytes(""UTF-8"");
    // Use the first 16 bytes (or even less if key is shorter)
    byte[] keyBytes16 = new byte[16];
    System.arraycopy(keyBytes, 0, keyBytes16, 0, Math.min(keyBytes.length, 16));

    // setup cipher
    SecretKeySpec skeySpec = new SecretKeySpec(keyBytes16, ""AES"");
    Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
    byte[] iv = new byte[16]; // initialization vector with all 0
    cipher.init(Cipher.ENCRYPT_MODE, skeySpec, new IvParameterSpec(iv));

    // encrypt
    byte[] encrypted = cipher.doFinal(plainBytes);

    return encrypted;
}
",4,0,3884ca1137e4838f055c4db0c001c3c76ca7df54dac5052ad23b07235abff2ef
,"byte[] keyBytes = new byte[] { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09,
    0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17 }; //Choose a key wisely

SecretKeySpec key = new SecretKeySpec(keyBytes, ""AES"");

Cipher cipher = Cipher.getInstance(""AES/ECB/PKCS7Padding"", ""BC"");

fis = new FileInputStream(""some_img.png"");
cis = new CipherInputStream(fis, cipher);
fos = new FileOutputStream(""encrypted_img.enc"");
byte[] b = new byte[8];
int i = cis.read(b);
while (i != -1) {
    fos.write(b, 0, i);
    i = cis.read(b);
}
fos.close();
",4,0,f7188784b944b535683a3ff51e8713ca898db51af0c76747fe4b0c3e62a44ac3
,"package me.gilo.a55thavenue.data;

import android.util.Base64;
import android.util.Log;

import com.squareup.okhttp.HttpUrl;
import com.squareup.okhttp.Interceptor;
import com.squareup.okhttp.OkHttpClient;
import com.squareup.okhttp.Request;
import com.squareup.okhttp.Response;

import org.apache.http.NameValuePair;
import org.apache.http.client.utils.URLEncodedUtils;
import org.apache.http.message.BasicNameValuePair;

import java.io.IOException;
import java.io.UnsupportedEncodingException;
import java.net.URLEncoder;
import java.security.InvalidKeyException;
import java.security.NoSuchAlgorithmException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;

import javax.crypto.Mac;
import javax.crypto.spec.SecretKeySpec;

import retrofit.GsonConverterFactory;
import retrofit.Retrofit;
import retrofit.RxJavaCallAdapterFactory;

/**
 * Created by Aron on 10/31/2015.
 */
public class PostRestAdapter {

    static String oauth_nonce = """";
    static String oauth_timestamp = """";
    static String oauth_signature_method = ""HMAC-SHA1"";

    static ArrayList&lt;NameValuePair&gt; params;

    public static API createAPI(final String endpoint) {

        setParams(endpoint);

        // Define the interceptor, add authentication headers
        Interceptor interceptor = new Interceptor() {
            @Override
            public Response intercept(Chain chain) throws IOException {

                HttpUrl.Builder builder = chain.request().httpUrl().newBuilder();
                for (NameValuePair entry : params) {
                    builder.addQueryParameter(entry.getName(), entry.getValue());
                }

                Request newRequest = chain.request()
                        .newBuilder()
                        .url(builder.build())
                        .build();

                return chain.proceed(newRequest);
            }
        };


        // Add the interceptor to OkHttpClient
        OkHttpClient client = new OkHttpClient();
        client.interceptors().add(interceptor);


        Retrofit retrofit = new Retrofit.Builder()
                .baseUrl(API.BASE_URL)
                .addCallAdapterFactory(RxJavaCallAdapterFactory.create())
                .addConverterFactory(GsonConverterFactory.create())
                .client(client)
                .build();
        return retrofit.create(API.class);
    }

    public static ArrayList&lt;NameValuePair&gt; setParams(String endpoint) {

        final String uri = API.BASE_URL + endpoint;

        oauth_nonce = getOauth_nonce();
        oauth_timestamp = getOauth_timestamp();

        params = new ArrayList&lt;&gt;();
        params.add(new BasicNameValuePair(""oauth_consumer_key"", API.CONSUMER_KEY));
        params.add(new BasicNameValuePair(""oauth_nonce"", oauth_nonce));
        params.add(new BasicNameValuePair(""oauth_timestamp"", oauth_timestamp));
        params.add(new BasicNameValuePair(""oauth_signature_method"", oauth_signature_method));

        Collections.sort(params, new SortParams());

        String encodedParams = URLEncodedUtils.format(params, ""utf-8"");
        Log.d(""encodedParamString"", encodedParams);

        String string_to_sign = """";
        try {
            string_to_sign = (new StringBuilder(""POST&amp;"")).append(URLEncoder.encode(uri, ""utf-8"")).append(""&amp;"").append(URLEncoder.encode(encodedParams, ""utf-8"")).toString();
        } catch (UnsupportedEncodingException e) {
            e.printStackTrace();
        }

        Log.d(""string to sign"", string_to_sign);

        try {
            Mac mac = Mac.getInstance(""HMAC-SHA1"");
            String secret = API.CONSUMER_SECRET;
            if (API.WP_API_VERSION.equals(""3"")) {
                secret = API.CONSUMER_SECRET + ""&amp;"";
            }
            mac.init(new SecretKeySpec(secret.getBytes(""utf-8""), ""HMAC-SHA1""));
            String signature = Base64.encodeToString(mac.doFinal(string_to_sign.getBytes(""utf-8"")), 0).trim();
            Log.d(""signature"", signature);
            params.add(new BasicNameValuePair(""oauth_signature"", signature));
        } catch (NoSuchAlgorithmException | InvalidKeyException | UnsupportedEncodingException e) {
            e.printStackTrace();
        }

        return params;
    }

    public static String getOauth_nonce() {
        return (new StringBuilder(String.valueOf(Math.random() * 100000000D))).toString();
    }

    public static String getOauth_timestamp() {
        long stamp = (long) (System.currentTimeMillis() / 1000D);
        Log.d(""stamp"", stamp + """");
        return (new StringBuilder(String.valueOf(stamp))).toString();
    }

    static class SortParams implements Comparator&lt;NameValuePair&gt; {

        @Override
        public int compare(NameValuePair nameValuePair1, NameValuePair nameValuePair2) {
            return nameValuePair1.getName().compareTo(nameValuePair2.getName());
        }
    }
}
",3,0,06ea5b6b744327c5a94d50dde70548e05f9cc78f82817b3db885ec8e036a60a1
,"private final static String AUTH = ""authentication"";

    private static final String UPDATE_CLIENT_AUTH = ""Update-Client-Auth"";

    public static final String PARAM_REGISTRATION_ID = ""registration_id"";

    public static final String PARAM_DELAY_WHILE_IDLE = ""delay_while_idle"";

    public static final String PARAM_COLLAPSE_KEY = ""collapse_key"";

    private static final String UTF8 = ""UTF-8"";

    public static int sendMessage(String auth_token, String registrationId,
            String message) throws IOException {

        StringBuilder postDataBuilder = new StringBuilder();
        postDataBuilder.append(PARAM_REGISTRATION_ID).append(""="")
                .append(registrationId);
        postDataBuilder.append(""&amp;"").append(PARAM_COLLAPSE_KEY).append(""="")
                .append(""0"");
        postDataBuilder.append(""&amp;"").append(""data.payload"").append(""="")
                .append(URLEncoder.encode(message, UTF8));

        byte[] postData = postDataBuilder.toString().getBytes(UTF8);

        // Hit the dm URL.

        URL url = new URL(""https://android.clients.google.com/c2dm/send"");
        HttpsURLConnection
                .setDefaultHostnameVerifier(new CustomizedHostnameVerifier());
        HttpsURLConnection conn = (HttpsURLConnection) url.openConnection();
        conn.setDoOutput(true);
        conn.setUseCaches(false);
        conn.setRequestMethod(""POST"");
        conn.setRequestProperty(""Content-Type"",
                ""application/x-www-form-urlencoded;charset=UTF-8"");
        conn.setRequestProperty(""Content-Length"",
                Integer.toString(postData.length));
        conn.setRequestProperty(""Authorization"", ""GoogleLogin auth=""
                + auth_token);

        OutputStream out = conn.getOutputStream();
        out.write(postData);
        out.close();

        int responseCode = conn.getResponseCode();
        return responseCode;
    }
",,1,3205c72f2ed42dede6d5e41f995f0f758e7bfa13989a2ad78766ffd84470d550
,"try {   
                   GmailSender sender = new GmailSender(""gmailusername"", ""gmailpassword"","""");
                   sender.sendMail(""Registration to Model Apps:"",""username=""+username+""\n password=""+password,""gmailusername"",""gmailusername"");   
                } 
             catch (Exception e) 
               {   
                   Log.e(""SendMail"", e.getMessage(), e);   
               }



and create class  GmailSender

package com.example.ur;//write ur pakage

import javax.activation.DataHandler;   
import javax.activation.DataSource;   
import javax.activation.FileDataSource;
import javax.mail.BodyPart;
import javax.mail.Message;   
import javax.mail.PasswordAuthentication;   
import javax.mail.Session;   
import javax.mail.Transport;   
import javax.mail.internet.InternetAddress;   
import javax.mail.internet.MimeBodyPart;
import javax.mail.internet.MimeMessage;   
import javax.mail.internet.MimeMultipart;

import android.util.Log;

import java.io.ByteArrayInputStream;   
import java.io.IOException;   
import java.io.InputStream;   
import java.io.OutputStream;   
import java.security.Security;   
import java.util.Properties;   

public class GmailSender extends javax.mail.Authenticator {   
    private String mailhost = ""smtp.gmail.com"",imagePath;   
    private String user;   
    private String password;   
    private Session session;   

    static 
    {   
        Security.addProvider(new com.example.model.JSSEProvider());   
    }  

    public GmailSender(String user, String password,String imagePath) {   
        this.user = user;   
        this.password = password;   
        this.imagePath=imagePath;
        Properties props = new Properties();   
        props.setProperty(""mail.transport.protocol"", ""smtp"");   
        props.setProperty(""mail.host"", mailhost);   
        props.put(""mail.smtp.auth"", ""true"");   


        props.put(""mail.smtp.port"", ""465"");   
        props.put(""mail.smtp.socketFactory.port"", ""465"");   
        props.put(""mail.smtp.socketFactory.class"",   
                ""javax.net.ssl.SSLSocketFactory"");   
        props.put(""mail.smtp.socketFactory.fallback"", ""false"");   
        props.setProperty(""mail.smtp.quitwait"", ""false"");   

        session = Session.getDefaultInstance(props, this);   
    }   

    protected PasswordAuthentication getPasswordAuthentication() {   
        return new PasswordAuthentication(user, password);   
    }   

    public synchronized void sendMail(String subject, String body, String sender, String recipients) throws Exception {   
        try{


             Transport transport = session.getTransport();  

             MimeMessage message = new MimeMessage(session);  
             message.setSubject(subject);  
             message.setFrom(new InternetAddress(sender));  
             message.addRecipient(Message.RecipientType.TO, new InternetAddress(recipients));  

             //  
             // This HTML mail have to 2 part, the BODY and the embedded image  
             //  
             MimeMultipart multipart = new MimeMultipart(""related"");  

             // first part  (the html)  
             BodyPart messageBodyPart = new MimeBodyPart();  
             String htmlText = ""&lt;H1&gt;""+body+""&lt;/H1&gt;"";  
             messageBodyPart.setContent(htmlText, ""text/html"");  

             // add it  
             multipart.addBodyPart(messageBodyPart);  

             // second part (the image)  
          //   messageBodyPart = new MimeBodyPart();  
         //    DataSource fds = new FileDataSource(imagePath);  
         //    messageBodyPart.setDataHandler(new DataHandler(fds));  
         //    messageBodyPart.setHeader(""Content-ID"",imagePath);  

             // add it  
           //  multipart.addBodyPart(messageBodyPart);  

             // put everything together  
             message.setContent(multipart);  

             transport.connect();  
             transport.sendMessage(message,message.getRecipients(Message.RecipientType.TO));  
             transport.close();  
        }catch(Exception e){
            Log.e("""", ""FILE NOT FOUND EXCEPTION ""+e.getMessage());
        }
    }   

    public class ByteArrayDataSource implements DataSource {   
        private byte[] data;   
        private String type;   

        public ByteArrayDataSource(byte[] data, String type) {   
            super();   
            this.data = data;   
            this.type = type;   
        }   

        public ByteArrayDataSource(byte[] data) {   
            super();   
            this.data = data;   
        }   

        public void setType(String type) {   
            this.type = type;   
        }   

        public String getContentType() {   
            if (type == null)   
                return ""application/octet-stream"";   
            else  
                return type;   
        }   

        public InputStream getInputStream() throws IOException {   
            return new ByteArrayInputStream(data);   
        }   

        public String getName() {   
            return ""ByteArrayDataSource"";   
        }   

        public OutputStream getOutputStream() throws IOException {   
            throw new IOException(""Not Supported"");   
        }   
    }   
}  
",3,0,7a3f624a91f0efa1a937e7d6ba99efa5a4f358e44fdbde6d32eed9ccc1fee018
,"    package com.example.model;


    import java.security.AccessController;
    import java.security.Provider;

    public final class JSSEProvider extends Provider {

        public JSSEProvider() {
            super(""HarmonyJSSE"", 1.0, ""Harmony JSSE Provider"");
            AccessController.doPrivileged(new java.security.PrivilegedAction&lt;Void&gt;() {
                public Void run() {
                    put(""SSLContext.TLS"",
                            ""org.apache.harmony.xnet.provider.jsse.SSLContextImpl"");
                    put(""Alg.Alias.SSLContext.TLSv1"", ""TLS"");
                    put(""KeyManagerFactory.X509"",
                            ""org.apache.harmony.xnet.provider.jsse.KeyManagerFactoryImpl"");
                    put(""TrustManagerFactory.X509"",
                            ""org.apache.harmony.xnet.provider.jsse.TrustManagerFactoryImpl"");
                    return null;
                }
            });
        }

 }
",3,0,080f8b2c53659286b1d762a4450740fe598f9073e5c403ed79104057add5932a
,"protected static Certificate ca;

/**
     * set self signed certificate to trust
     */
    public static void trustSelfSignedSSL() {

        try {
            // set hostname verifier to check hostname validity
            HttpsURLConnection.setDefaultHostnameVerifier(new HostnameVerifier() {
                public boolean verify(String hostname, SSLSession session) {
                    return hostname.equals(Config.HTTPS_CERTIFICATE_URL) || hostname.equals(Config.HTTPS_GOOGLE_URL);
                }
            });

            // load certificate
            hbgCa = getCert();

            // add certificate to key store
            if (null != hbgCa) {
                String keyStoreType = KeyStore.getDefaultType();
                KeyStore keyStore = KeyStore.getInstance(keyStoreType);
                keyStore.load(null, null);
                keyStore.setCertificateEntry(""hbgCa"", hbgCa);

                String tmfAlgorithm = TrustManagerFactory.getDefaultAlgorithm();
                TrustManagerFactory tmf = TrustManagerFactory.getInstance(tmfAlgorithm);
                tmf.init(keyStore);

                SSLContext context = SSLContext.getInstance(""TLS"");
                context.init(null, tmf.getTrustManagers(), null);
//          HttpsURLConnection.setDefaultSSLSocketFactory(context.getSocketFactory());
                HttpsURLConnection.setDefaultSSLSocketFactory(createSslSocketFactory());
            }
        } catch (Exception e) { // should never happen
            e.printStackTrace();
        }
    }


    /**
     * create a custom sslsocketfactory to trust server connections
     *
     * @return
     * @throws Exception
     */
    private static SSLSocketFactory createSslSocketFactory() throws Exception {
        TrustManager[] byPassTrustManagers = new TrustManager[]{new X509TrustManager() {
            public X509Certificate[] getAcceptedIssuers() {
                return new X509Certificate[0];
            }

            public void checkClientTrusted(X509Certificate[] chain, String authType) {
            }

            public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {

                // Loading the CA cert
                if (null == ca) {
                    ca = getCert();
                }

                for (X509Certificate cert : chain) {

                    // check if the certificate is the selfsigned trusted one
                    if (verifiyCertificate(ca, cert)) {
                        return;
                    }
                    // check if current certificate belongs to google
                    if (cert.getIssuerX500Principal().getName().equals(""CN=Google Internet Authority G2,O=Google Inc,C=US"")) {
                        return;
                    }
                }

        // if none certificate trusted throw certificate exception to tell to not trust connection
                throw new CertificateException();
            }
        }
        };

        SSLContext sslContext = SSLContext.getInstance(""TLS"");
        sslContext.init(null, byPassTrustManagers, new SecureRandom());
        return sslContext.getSocketFactory();
    }


    /**
     * verifiy a certificate against the other
     */
    private static boolean verifiyCertificate(Certificate cert1, Certificate cert2) {
        try {
            cert1.verify(cert2.getPublicKey());
            return true;
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }
    }

    /**
     * load and return selfsigned local cert
     *
     * @return
     */
    private static Certificate getCert() {

        try {
            CertificateFactory cf = CertificateFactory.getInstance(""X.509"");
            Context appContext = HBGApplication.getWrapperContext();
            AssetManager assets = appContext.getAssets();
            InputStream caInput = assets.open(Config.HTTPS_CERTIFICATE_ASSETS_FILE);
            Certificate ca;

            try {
                return cf.generateCertificate(caInput);
            } catch (CertificateException e) {
                e.printStackTrace();
            } finally {
                caInput.close();
            }

            return null;
        } catch (Exception e) {
            e.printStackTrace();
            return null;
        }
    }
",4,0,8c34ef90aa0a8292a2e1d6905683dcbe16510180902666115d686350f13cc8f9
,"try
{
    //paste Your package name at the first parameter
    PackageInfo info = getPackageManager().getPackageInfo(""PUT_YOUR_PACKAGE_NAME_HERE"",
            PackageManager.GET_SIGNATURES);
    for (android.content.pm.Signature signature : info.signatures)
    {
        MessageDigest md = MessageDigest.getInstance(""SHA"");
        md.update(signature.toByteArray());
        String sign = Base64.encodeToString(md.digest(), Base64.DEFAULT);
        Log.e(""MY KEY HASH:"", sign);
        Toast.makeText(getApplicationContext(), sign, Toast.LENGTH_LONG).show();
    }
}
catch (PackageManager.NameNotFoundException e)
{
}
catch (NoSuchAlgorithmException e)
{
}
",3,0,57bb1b3e3f1cf4a50529cbd1cb33539607174f71b3ba362a64e45db7de459b12
,"        package com.yourapp.android.crypto;

        import java.security.InvalidAlgorithmParameterException;
        import java.security.InvalidKeyException;
        import java.security.NoSuchAlgorithmException;
        import javax.crypto.BadPaddingException;
        import javax.crypto.Cipher;
        import javax.crypto.IllegalBlockSizeException;
        import javax.crypto.NoSuchPaddingException;
        import javax.crypto.spec.IvParameterSpec;
        import javax.crypto.spec.SecretKeySpec;
        import android.content.Context;
        import android.util.Base64;

        public class Crypto {

           private static final String engine = ""AES"";
           private static final String crypto = ""AES/CBC/PKCS5Padding"";
           private static Context ctx;
           public Crypto(Context cntx) {
             ctx = cntx;
           }

           public byte[] cipher(byte[] data, int mode) throws NoSuchAlgorithmException,NoSuchPaddingException,InvalidKeyException,IllegalBlockSizeException,BadPaddingException,InvalidAlgorithmParameterException {
             KeyManager km = new KeyManager(ctx);
             SecretKeySpec sks = new SecretKeySpec(km.getId(), engine);
             IvParameterSpec iv = new IvParameterSpec(km.getIv());
             Cipher c = Cipher.getInstance(crypto);
             c.init(mode, sks, iv);
             return c.doFinal(data);
           }

           public byte[] encrypt(byte[] data) throws InvalidKeyException,
        NoSuchAlgorithmException, NoSuchPaddingException,
        IllegalBlockSizeException, BadPaddingException,
        InvalidAlgorithmParameterException {
             return cipher(data, Cipher.ENCRYPT_MODE);
           }

           public byte[] decrypt(byte[] data) throws InvalidKeyException,
        NoSuchAlgorithmException, NoSuchPaddingException,
        IllegalBlockSizeException, BadPaddingException,
        InvalidAlgorithmParameterException {
             return cipher(data, Cipher.DECRYPT_MODE);
           }

        public String armorEncrypt(byte[] data) throws InvalidKeyException,NoSuchAlgorithmException,
    NoSuchPaddingException,IllegalBlockSizeException,
    BadPaddingException,InvalidAlgorithmParameterException {
                 return Base64.encodeToString(encrypt(data), Base64.DEFAULT);
               }

         public String armorDecrypt(String data) throws InvalidKeyException,NoSuchAlgorithmException,
    NoSuchPaddingException,IllegalBlockSizeException,
    BadPaddingException,InvalidAlgorithmParameterException {
                 return new String(decrypt(Base64.decode(data, Base64.DEFAULT)));
               }
}
",1,0,485ecceeb154c88aeb7c833183d4a850bed3752653a8c112646ecf692bb75010
,"package com.yourapp.android.crypto;

import java.security.InvalidAlgorithmParameterException;
import java.security.InvalidKeyException;
import java.security.NoSuchAlgorithmException;

import javax.crypto.BadPaddingException;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.NoSuchPaddingException;

import android.os.Bundle;
import android.app.Activity;
import android.content.Context;
import android.util.Log;
import android.view.View;
import android.view.View.OnClickListener;
import android.widget.Button;
import android.widget.EditText;
import android.widget.TextView;


public class MainActivity extends Activity {
    TextView encryptedDataView;
    EditText editInputData;
    private Context cntx;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        this.cntx = getApplicationContext();
        Button btnEncrypt = (Button) findViewById(R.id.buttonEncrypt);
        Button btnDecrypt = (Button) findViewById(R.id.buttonDecrypt);
        Button btnDelete = (Button) findViewById(R.id.buttonDelete);
        editInputData = (EditText)findViewById(R.id.editInputData) ;
        encryptedDataView = (TextView) findViewById(R.id.encryptView);

        /**********************************************/
            /** INITIALIZE KEY AND INITIALIZATION VECTOR **/
        String key = ""12345678909876543212345678909876"";
        String iv = ""1234567890987654"";
        KeyManager km = new KeyManager(getApplicationContext());
        km.setIv(iv.getBytes());
        km.setId(key.getBytes());
        /**********************************************/

        btnEncrypt.setOnClickListener(new OnClickListener() {
            @Override
            public void onClick(View v) {
                String Data = editInputData.getText().toString();
                String Encrypted_Data = ""data"";
                try {
                    Crypto crypto = new Crypto(cntx);
                    Encrypted_Data = crypto.armorEncrypt(Data.getBytes());
                }   catch (InvalidKeyException e) {
                    Log.e(""SE3"", ""Exception in StoreData: "" + e.getMessage());
                    } catch (NoSuchAlgorithmException e) {
                    Log.e(""SE3"", ""Exception in StoreData: "" + e.getMessage());
                    } catch (NoSuchPaddingException e) {
                    Log.e(""SE3"", ""Exception in StoreData: "" + e.getMessage());
                    } catch (IllegalBlockSizeException e) {
                    Log.e(""SE3"", ""Exception in StoreData: "" + e.getMessage());
                    } catch (BadPaddingException e) {
                    Log.e(""SE3"", ""Exception in StoreData: "" + e.getMessage());
                    } catch (InvalidAlgorithmParameterException e) {
                    Log.e(""SE3"", ""Exception in StoreData: "" + e.getMessage());
                    }
                encryptedDataView.setText(Encrypted_Data);
            }
        });

        btnDecrypt.setOnClickListener(new OnClickListener() {
            @Override
            public void onClick(View v) {
                String Data = encryptedDataView.getText().toString();
                String Decrypted_Data = ""data"";
                try {
                    Crypto crypto = new Crypto(cntx);
                    Decrypted_Data = crypto.armorDecrypt(Data);
                }   catch (InvalidKeyException e) {
                    Log.e(""SE3"", ""Exception in StoreData: "" + e.getMessage());
                    } catch (NoSuchAlgorithmException e) {
                    Log.e(""SE3"", ""Exception in StoreData: "" + e.getMessage());
                    } catch (NoSuchPaddingException e) {
                    Log.e(""SE3"", ""Exception in StoreData: "" + e.getMessage());
                    } catch (IllegalBlockSizeException e) {
                    Log.e(""SE3"", ""Exception in StoreData: "" + e.getMessage());
                    } catch (BadPaddingException e) {
                    Log.e(""SE3"", ""Exception in StoreData: "" + e.getMessage());
                    } catch (InvalidAlgorithmParameterException e) {
                    Log.e(""SE3"", ""Exception in StoreData: "" + e.getMessage());
                    }
                encryptedDataView.setText(Decrypted_Data);
            }
        });

        btnDelete.setOnClickListener(new OnClickListener() {
            @Override
            public void onClick(View v) {
                encryptedDataView.setText("" Deleted "");
            }
        });

    }

}
",4,0,02773f228f56e6bb9e7ce3f63f5c93530dc31409257dbb85912fe7477b147b7f
,"Key prvkey = keyStore.getKey(_alias,_keypass.toCharArray());
PublicKey pubkey = certificate.getPublicKey();
KeyPair keypair = new KeyPair(pubkey, (PrivateKey)prvkey);
PrivateKey privKewy = keypair.getPrivate();
",,1,8a89376ff0a13630965bba90c18917171d69d32c6d526546e65e0a7ac2d33384
,"final Charset charset = Charset.forName(""UTF-8"");
final MessageDigest digest = MessageDigest
        .getInstance(""SHA-512"");
final byte[] hashData = digest
        .digest(json.getBytes(charset));
final String hash = new String(hashData, charset);
nameValuePairs.add(new BasicNameValuePair(""credit_card"", hash));
",2,0,477ff89ed27d7c762514ca69cec4e4422f5a572cf09f299f90bb58904087be8e
,"private String getShortenedKey(String key) {
    String shortenedKey=null;
    MessageDigest md = null;
    LogUtils.LOGD(HASH_ALGO, ""before key: ""+ System.currentTimeMillis());
    try {
        md = MessageDigest.getInstance(""MD5"");

        md.update(key.getBytes());
        byte[] shortenedBytes = md.digest();
        shortenedKey = Base64.encodeToString(shortenedBytes, Base64.NO_WRAP);
    } catch (NoSuchAlgorithmException e) {
        e.printStackTrace();
        shortenedKey = key;
    }
    LogUtils.LOGD(HASH_ALGO, ""after key: ""+ System.currentTimeMillis());

    return shortenedKey;
}
",2,0,38a6fad02d29574d548d783e812c154cc01e01e211ce9206c0ff555fef80b436
,"public class MainActivity extends AppCompatActivity {

private TextView mTextView;

@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_main);

    mTextView = (TextView) findViewById(R.id.textView);

    String url = ""https://192.168.1.100/testvolley"";

    HurlStack hurlStack = new HurlStack() {
        @Override
        protected HttpURLConnection createConnection(URL url) throws IOException {
            HttpsURLConnection httpsURLConnection = (HttpsURLConnection) super.createConnection(url);
            try {
                httpsURLConnection.setSSLSocketFactory(getSSLSocketFactory());
                httpsURLConnection.setHostnameVerifier(getHostnameVerifier());
            } catch (Exception e) {
                e.printStackTrace();
            }
            return httpsURLConnection;
        }
    };

    final JsonObjectRequest jsonObjectRequest = new JsonObjectRequest(Request.Method.GET, url, new Response.Listener&lt;JSONObject&gt;() {
        @Override
        public void onResponse(JSONObject response) {
            try {
                mTextView.setText(response.toString(5));
            } catch (JSONException e) {
                mTextView.setText(e.toString());
            }
        }
    }, new Response.ErrorListener() {
        @Override
        public void onErrorResponse(VolleyError error) {
            mTextView.setText(error.toString());
        }
    });

    final RequestQueue requestQueue = Volley.newRequestQueue(this, hurlStack);

    requestQueue.add(jsonObjectRequest);
}

// Let's assume your server app is hosting inside a server machine
// which has a server certificate in which ""Issued to"" is ""localhost"",for example.
// Then, inside verify method you can verify ""localhost"". 
// If not, you can temporarily return true
private HostnameVerifier getHostnameVerifier() {
    return new HostnameVerifier() {
        @Override
        public boolean verify(String hostname, SSLSession session) {
            //return true;
            HostnameVerifier hv = HttpsURLConnection.getDefaultHostnameVerifier();
            return hv.verify(""localhost"", session);
        }
    };
}

private TrustManager[] getWrappedTrustManagers(TrustManager[] trustManagers) {
    final X509TrustManager originalTrustManager = (X509TrustManager) trustManagers[0];
    return new TrustManager[]{
            new X509TrustManager() {
                public X509Certificate[] getAcceptedIssuers() {
                    return originalTrustManager.getAcceptedIssuers();
                }

                public void checkClientTrusted(X509Certificate[] certs, String authType) {
                    try {
                        originalTrustManager.checkClientTrusted(certs, authType);
                    } catch (CertificateException ignored) {
                    }
                }

                public void checkServerTrusted(X509Certificate[] certs, String authType) {
                    try {
                        originalTrustManager.checkServerTrusted(certs, authType);
                    } catch (CertificateException ignored) {
                    }
                }
            }
    };
}

private SSLSocketFactory getSSLSocketFactory()
        throws CertificateException, KeyStoreException, IOException, NoSuchAlgorithmException, KeyManagementException {
    CertificateFactory cf = CertificateFactory.getInstance(""X.509"");
    InputStream caInput = getResources().openRawResource(R.raw.my_cert); // this cert file stored in \app\src\main\res\raw folder path

    Certificate ca = cf.generateCertificate(caInput);
    caInput.close();

    KeyStore keyStore = KeyStore.getInstance(""BKS"");
    keyStore.load(null, null);
    keyStore.setCertificateEntry(""ca"", ca);

    String tmfAlgorithm = TrustManagerFactory.getDefaultAlgorithm();
    TrustManagerFactory tmf = TrustManagerFactory.getInstance(tmfAlgorithm);
    tmf.init(keyStore);

    TrustManager[] wrappedTrustManagers = getWrappedTrustManagers(tmf.getTrustManagers());

    SSLContext sslContext = SSLContext.getInstance(""TLS"");
    sslContext.init(null, wrappedTrustManagers, null);

    return sslContext.getSocketFactory();
}
}
",4,0,ebcdc857312f7ee77ccac1f450d29cc00944336fc31d22f85adab6d33c046b0e
,"import javax.activation.DataHandler;
import javax.activation.DataSource;
import javax.mail.Message;
import javax.mail.PasswordAuthentication;
import javax.mail.Session;
import javax.mail.Transport;
import javax.mail.internet.InternetAddress;
import javax.mail.internet.MimeMessage;
import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.security.Security;
import java.util.Properties;

public class GMailSender extends javax.mail.Authenticator {
private String mailhost = ""smtp.gmail.com"";
private String user;
private String password;
private Session session;

static {
Security.addProvider(new JSSEProvider());
}

public GMailSender(String user, String password) {
this.user = user;
this.password = password;

Properties props = new Properties();
props.setProperty(""mail.transport.protocol"", ""smtp"");
props.setProperty(""mail.host"", mailhost);
props.put(""mail.smtp.auth"", ""true"");
props.put(""mail.smtp.port"", ""465"");
props.put(""mail.smtp.socketFactory.port"", ""465"");
props.put(""mail.smtp.socketFactory.class"",
""javax.net.ssl.SSLSocketFactory"");
props.put(""mail.smtp.socketFactory.fallback"", ""false"");
props.setProperty(""mail.smtp.quitwait"", ""false"");

session = Session.getDefaultInstance(props, this);
}

protected PasswordAuthentication getPasswordAuthentication() {
return new PasswordAuthentication(user, password);
}

public synchronized void sendMail(String subject, String body, String sender, String recipients) throws Exception {
try{
MimeMessage message = new MimeMessage(session);
DataHandler handler = new DataHandler(new ByteArrayDataSource(body.getBytes(), ""text/plain""));
message.setSender(new InternetAddress(sender));
message.setSubject(subject);
message.setDataHandler(handler);
if (recipients.indexOf(',') &gt; 0)
message.setRecipients(Message.RecipientType.TO, InternetAddress.parse(recipients));
else
message.setRecipient(Message.RecipientType.TO, new InternetAddress(recipients));
Transport.send(message);
}catch(Exception e){

}
}

public class ByteArrayDataSource implements DataSource {
private byte[] data;
private String type;

public ByteArrayDataSource(byte[] data, String type) {
super();
this.data = data;
this.type = type;
}

public ByteArrayDataSource(byte[] data) {
super();
this.data = data;
}

public void setType(String type) {
this.type = type;
}

public String getContentType() {
if (type == null)
return ""application/octet-stream"";
else
return type;
}

public InputStream getInputStream() throws IOException {
return new ByteArrayInputStream(data);
}

public String getName() {
return ""ByteArrayDataSource"";
}

public OutputStream getOutputStream() throws IOException {
throw new IOException(""Not Supported"");
}
}
}
",3,0,9c9f81400d19ce38eb6fba4a743fdbb89a2e0f265ebbd569d0cf56347e7bac8c
," 136         // Clean up the certificates chain and build a new one.
 137         // Theoretically, we shouldn't have to do this, but various web servers
 138         // in practice are mis-configured to have out-of-order certificates or
 139         // expired self-issued root certificate.
 140         int chainLength = serverCertificates.length;
 141         if (serverCertificates.length &gt; 1) {
 142           // 1. we clean the received certificates chain.
 143           // We start from the end-entity certificate, tracing down by matching
 144           // the ""issuer"" field and ""subject"" field until we can't continue.
 145           // This helps when the certificates are out of order or
 146           // some certificates are not related to the site.
 147           int currIndex;
 148           for (currIndex = 0; currIndex &lt; serverCertificates.length; ++currIndex) {
 149             boolean foundNext = false;
 150             for (int nextIndex = currIndex + 1;
 151                  nextIndex &lt; serverCertificates.length;
 152                  ++nextIndex) {
 153               if (serverCertificates[currIndex].getIssuerDN().equals(
 154                   serverCertificates[nextIndex].getSubjectDN())) {
 155                 foundNext = true;
 156                 // Exchange certificates so that 0 through currIndex + 1 are in proper order
 157                 if (nextIndex != currIndex + 1) {
 158                   X509Certificate tempCertificate = serverCertificates[nextIndex];
 159                   serverCertificates[nextIndex] = serverCertificates[currIndex + 1];
 160                   serverCertificates[currIndex + 1] = tempCertificate;
 161                 }
 162                 break;
 163               }
 164             }
 165             if (!foundNext) break;
 166           }
 167 
 168           // 2. we exam if the last traced certificate is self issued and it is expired.
 169           // If so, we drop it and pass the rest to checkServerTrusted(), hoping we might
 170           // have a similar but unexpired trusted root.
 171           chainLength = currIndex + 1;
 172           X509Certificate lastCertificate = serverCertificates[chainLength - 1];
 173           Date now = new Date();
 174           if (lastCertificate.getSubjectDN().equals(lastCertificate.getIssuerDN())
 175               &amp;&amp; now.after(lastCertificate.getNotAfter())) {
 176             --chainLength;
 177           }
 178         }
",,1,2efae24a5eb6fbf70e7225ef6c64b890c2eecf12b338e7d9ba66c83fda1d02aa
,"import java.io.IOException;
import java.net.URLEncoder;
import java.util.GregorianCalendar;
import java.util.HashMap;
import java.util.Map;

import org.apache.harmony.javax.security.auth.callback.CallbackHandler;
import org.apache.harmony.javax.security.sasl.Sasl;
import org.jivesoftware.smack.SASLAuthentication;
import org.jivesoftware.smack.XMPPException;
import org.jivesoftware.smack.sasl.SASLMechanism;
import org.jivesoftware.smack.util.Base64;

public class SASLXFacebookPlatformMecha extends SASLMechanism {

private static final String NAME = ""X-FACEBOOK-PLATFORM"";

private String apiKey = """";
private String access_token = """";

/**
 * Constructor.
 */
public SASLXFacebookPlatformMecha(SASLAuthentication saslAuthentication) {
    super(saslAuthentication);
}

@Override
protected void authenticate() throws IOException, XMPPException {

    getSASLAuthentication().send(new AuthMechanism(NAME, """"));
}

@Override
public void authenticate(String apiKey, String host, String acces_token)
        throws IOException, XMPPException {
    if (apiKey == null || acces_token == null) {
        throw new IllegalArgumentException(""Invalid parameters"");
    }

    this.access_token = acces_token;
    this.apiKey = apiKey;
    this.hostname = host;

    String[] mechanisms = { NAME };
    Map&lt;String, String&gt; props = new HashMap&lt;String, String&gt;();
    this.sc = Sasl.createSaslClient(mechanisms, null, ""xmpp"", host, props,
            this);
    authenticate();
}

@Override
public void authenticate(String username, String host, CallbackHandler cbh)
        throws IOException, XMPPException {
    String[] mechanisms = { NAME };
    Map&lt;String, String&gt; props = new HashMap&lt;String, String&gt;();
    this.sc = Sasl.createSaslClient(mechanisms, null, ""xmpp"", host, props,
            cbh);
    authenticate();
}

@Override
protected String getName() {
    return NAME;
}

@Override
public void challengeReceived(String challenge) throws IOException {
    byte[] response = null;

    if (challenge != null) {
        String decodedChallenge = new String(Base64.decode(challenge));
        Map&lt;String, String&gt; parameters = getQueryMap(decodedChallenge);

        String version = ""1.0"";
        String nonce = parameters.get(""nonce"");
        String method = parameters.get(""method"");

        long callId = new GregorianCalendar().getTimeInMillis();

        String composedResponse = ""api_key=""
                + URLEncoder.encode(apiKey, ""utf-8"") + ""&amp;call_id="" + callId
                + ""&amp;method="" + URLEncoder.encode(method, ""utf-8"")
                + ""&amp;nonce="" + URLEncoder.encode(nonce, ""utf-8"")
                + ""&amp;access_token=""
                + URLEncoder.encode(access_token, ""utf-8"") + ""&amp;v=""
                + URLEncoder.encode(version, ""utf-8"");

        response = composedResponse.getBytes(""utf-8"");
    }

    String authenticationText = """";

    if (response != null) {
        authenticationText = Base64.encodeBytes(response,
                Base64.DONT_BREAK_LINES);
    }

    // Send the authentication to the server
    getSASLAuthentication().send(new Response(authenticationText));
}

private Map&lt;String, String&gt; getQueryMap(String query) {
    Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();
    String[] params = query.split(""\\&amp;"");

    for (String param : params) {
        String[] fields = param.split(""="", 2);
        map.put(fields[0], (fields.length &gt; 1 ? fields[1] : null));
    }

    return map;
}
}
",1,0,9f35f1ad9e5e86b82c41dc3f189fd5dbbb2c4425ec2072d7fc447ec2da8d1537
,"import java.io.IOException;
import java.io.UnsupportedEncodingException; 
import java.net.URLEncoder; 
import java.security.MessageDigest; 
import java.security.NoSuchAlgorithmException; 
import java.util.GregorianCalendar; 
import java.util.HashMap; 
import java.util.Map;  
import org.apache.harmony.javax.security.auth.callback.CallbackHandler; 
import org.apache.harmony.javax.security.sasl.Sasl; 
import org.jivesoftware.smack.SASLAuthentication; 
import org.jivesoftware.smack.XMPPException; 
import org.jivesoftware.smack.sasl.SASLMechanism; 
import org.jivesoftware.smack.util.Base64;

public class SASLXFacebookPlatformMechanism extends SASLMechanism 
{      
    private static final String NAME              = ""X-FACEBOOK-PLATFORM"";      
    private String              apiKey            = """";     
    private String              applicationSecret = """";     
    private String              sessionKey        = """";      
    /**      * Constructor.      */     
    public SASLXFacebookPlatformMechanism(SASLAuthentication saslAuthentication)     
    {         
        super(saslAuthentication);     
    }      
    @Override     
    protected void authenticate() throws IOException, XMPPException     
    {          
        getSASLAuthentication().send(new AuthMechanism(NAME, """"));     
    }      
    @Override     
    public void authenticate(String apiKeyAndSessionKey, String host,             String applicationSecret) throws IOException, XMPPException     
    {         
        if (apiKeyAndSessionKey == null || applicationSecret == null)         
        {             
            throw new IllegalArgumentException(""Invalid parameters"");         
        }          
        String[] keyArray = apiKeyAndSessionKey.split(""\\|"", 2);         
        if (keyArray.length &lt; 2)         
        {             
            throw new IllegalArgumentException(                     ""API key or session key is not present"");         }          
            this.apiKey = keyArray[0];         
            this.applicationSecret = applicationSecret;         
            this.sessionKey = keyArray[1];          
            this.authenticationId = sessionKey;         
            this.password = applicationSecret;         
            this.hostname = host;          
            String[] mechanisms = { ""DIGEST-MD5"" };         

            Map&lt;String, String&gt; props = new HashMap&lt;String, String&gt;();         
            this.sc = Sasl.createSaslClient(mechanisms, null, ""xmpp"", host, props,this);        
            authenticate();
        }      
        @Override     
        public void authenticate(String username, String host, CallbackHandler cbh)throws IOException, XMPPException     
        {         
            String[] mechanisms = { ""DIGEST-MD5"" };         
            Map&lt;String, String&gt; props = new HashMap&lt;String, String&gt;();         
            this.sc = Sasl.createSaslClient(mechanisms, null, ""xmpp"", host, props,cbh);         
            authenticate();
        }      @Override     protected String getName()

        {        
            return NAME;     
        }      
        @Override     
        public void challengeReceived(String challenge) throws IOException     
        {         
            byte[] response = null;          
            if (challenge != null)         
            {             
                String decodedChallenge = new String(Base64.decode(challenge));             
                Map&lt;String, String&gt; parameters = getQueryMap(decodedChallenge);              
                String version = ""1.0"";             
                String nonce = parameters.get(""nonce"");             
                String method = parameters.get(""method"");              
                long callId = new GregorianCalendar().getTimeInMillis();              
                String sig = ""api_key="" + apiKey + ""call_id="" + callId + ""method="" + method + ""nonce="" + nonce + ""session_key="" + sessionKey + ""v="" + version + applicationSecret;
                try             
                {                 
                    sig = md5(sig);             
                } 
                catch (NoSuchAlgorithmException e)             
                {                 
                    throw new IllegalStateException(e);             
                }              
                String composedResponse = ""api_key="" + URLEncoder.encode(apiKey, ""utf-8"") + ""&amp;call_id="" + callId + ""&amp;method=""+ URLEncoder.encode(method, ""utf-8"") + ""&amp;nonce=""+ URLEncoder.encode(nonce, ""utf-8"")+ ""&amp;session_key=""+ URLEncoder.encode(sessionKey, ""utf-8"") + ""&amp;v=""+ URLEncoder.encode(version, ""utf-8"") + ""&amp;sig=""+ URLEncoder.encode(sig, ""utf-8"");response = composedResponse.getBytes(""utf-8"");
                }          
                String authenticationText = """";          
                if (response != null)         
                {             
                    authenticationText = Base64.encodeBytes(response, Base64.DONT_BREAK_LINES);         
                }          

                // Send the authentication to the server         
                getSASLAuthentication().send(new Response(authenticationText));     
                }      
        private Map&lt;String, String&gt; getQueryMap(String query)     
        {         
            Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();         
            String[] params = query.split(""\\&amp;"");          
            for (String param : params)         
            {             
                String[] fields = param.split(""="", 2);             
                map.put(fields[0], (fields.length &gt; 1 ? fields[1] : null));         
            }          
            return map;     
            }      
        private String md5(String text) throws NoSuchAlgorithmException,UnsupportedEncodingException     
        {         
            MessageDigest md = MessageDigest.getInstance(""MD5"");         
            md.update(text.getBytes(""utf-8""), 0, text.length());         
            return convertToHex(md.digest());     
        }      
        private String convertToHex(byte[] data)     
        {         
            StringBuilder buf = new StringBuilder();         
            int len = data.length;          
            for (int i = 0; i &lt; len; i++)         
            {             
                int halfByte = (data[i] &gt;&gt;&gt; 4) &amp; 0xF;             
                int twoHalfs = 0;              
                do             
                {                 
                    if (0 &lt;= halfByte &amp;&amp; halfByte &lt;= 9)                 
                    {                     
                        buf.append((char) ('0' + halfByte));                 
                    }                 
                    else                 
                    {                     
                        buf.append((char) ('a' + halfByte - 10));                 
                    }                 
                    halfByte = data[i] &amp; 0xF;             
                } 
                while (twoHalfs++ &lt; 1);         
            }          
            return buf.toString();     
            } 
        }
",3,0,ed37406d7bc70d99c2222434a6a84bc916fba2dd26ac9f488596bc2a99e614c1
,"package com.avilyne.android;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.net.InetAddress;
import java.net.InetSocketAddress;
import java.net.Socket;
import java.net.UnknownHostException;
import java.security.KeyStore;
import java.security.KeyStoreException;
import java.security.NoSuchAlgorithmException;
import java.security.cert.CertificateException;
import java.security.cert.X509Certificate;
import java.util.ArrayList;

import javax.net.ssl.SSLContext;
import javax.net.ssl.SSLSocket;
import javax.net.ssl.TrustManager;
import javax.net.ssl.TrustManagerFactory;
import javax.net.ssl.X509TrustManager;

import org.apache.http.HttpResponse;
import org.apache.http.HttpVersion;
import org.apache.http.NameValuePair;
import org.apache.http.client.entity.UrlEncodedFormEntity;
import org.apache.http.client.methods.HttpGet;
import org.apache.http.client.methods.HttpPost;
import org.apache.http.conn.ClientConnectionManager;
import org.apache.http.conn.ConnectTimeoutException;
import org.apache.http.conn.params.ConnManagerPNames;
import org.apache.http.conn.params.ConnPerRouteBean;
import org.apache.http.conn.scheme.LayeredSocketFactory;
import org.apache.http.conn.scheme.PlainSocketFactory;
import org.apache.http.conn.scheme.Scheme;
import org.apache.http.conn.scheme.SchemeRegistry;
import org.apache.http.impl.client.DefaultHttpClient;
import org.apache.http.impl.conn.SingleClientConnManager;
import org.apache.http.message.BasicNameValuePair;
import org.apache.http.params.BasicHttpParams;
import org.apache.http.params.HttpConnectionParams;
import org.apache.http.params.HttpParams;
import org.apache.http.params.HttpProtocolParams;
import org.json.JSONObject;

import android.app.Activity;
import android.app.ProgressDialog;
import android.content.Context;
import android.os.AsyncTask;
import android.os.Bundle;
import android.util.Log;
import android.view.Menu;
import android.view.View;
import android.view.inputmethod.InputMethodManager;
import android.widget.EditText;
import android.widget.Toast;

public class MainActivity extends Activity {

    private static final String SERVICE_URL =
    ""https://192.168.2.101:8443/RestWebServiceDemo/rest/person"";

    private static final String TAG = ""AndroidRESTClientActivity"";

    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
    }

    public void retrieveSampleData(View vw) {

        String sampleURL = SERVICE_URL + ""/sample"";

        WebServiceTask wst = new WebServiceTask(WebServiceTask.GET_TASK, this,
                ""GETting data..."");

        wst.execute(new String[] { sampleURL });

    }

    public void clearControls(View vw) {

        EditText edFirstName = (EditText) findViewById(R.id.first_name);
        EditText edLastName = (EditText) findViewById(R.id.last_name);
        EditText edEmail = (EditText) findViewById(R.id.email);

        edFirstName.setText("""");
        edLastName.setText("""");
        edEmail.setText("""");

    }

    public void postData(View vw) {

        EditText edFirstName = (EditText) findViewById(R.id.first_name);
        EditText edLastName = (EditText) findViewById(R.id.last_name);
        EditText edEmail = (EditText) findViewById(R.id.email);

        String firstName = edFirstName.getText().toString();
        String lastName = edLastName.getText().toString();
        String email = edEmail.getText().toString();

        if (firstName.equals("""") || lastName.equals("""") || email.equals("""")) {
            Toast.makeText(this, ""Please enter in all required fields."",
                    Toast.LENGTH_LONG).show();
            return;
        }

        WebServiceTask wst = new WebServiceTask(WebServiceTask.POST_TASK, this,
                ""Posting data..."");

        wst.addNameValuePair(""firstName"", firstName);
        wst.addNameValuePair(""lastName"", lastName);
        wst.addNameValuePair(""email"", email);

        // the passed String is the URL we will POST to
        wst.execute(new String[] { SERVICE_URL });

    }

    public void handleResponse(String response) {

        EditText edFirstName = (EditText) findViewById(R.id.first_name);
        EditText edLastName = (EditText) findViewById(R.id.last_name);
        EditText edEmail = (EditText) findViewById(R.id.email);

        edFirstName.setText("""");
        edLastName.setText("""");
        edEmail.setText("""");

        try {

            JSONObject jso = new JSONObject(response);

            String firstName = jso.getString(""firstName"");
            String lastName = jso.getString(""lastName"");
            String email = jso.getString(""email"");

            edFirstName.setText(firstName);
            edLastName.setText(lastName);
            edEmail.setText(email);

        } catch (Exception e) {
            Log.e(TAG, e.getLocalizedMessage(), e);
        }

    }

    private void hideKeyboard() {

        InputMethodManager inputManager = (InputMethodManager) MainActivity.this
                .getSystemService(Context.INPUT_METHOD_SERVICE);

        inputManager.hideSoftInputFromWindow(MainActivity.this
                .getCurrentFocus().getWindowToken(),
                InputMethodManager.HIDE_NOT_ALWAYS);
    }

    @Override
    public boolean onCreateOptionsMenu(Menu menu) {
        getMenuInflater().inflate(R.menu.activity_main, menu);
        return true;
    }

    private class WebServiceTask extends AsyncTask&lt;String, Integer, String&gt; {

        public static final int POST_TASK = 1;
        public static final int GET_TASK = 2;

        private static final String TAG = ""WebServiceTask"";

        // connection timeout, in milliseconds (waiting to connect)
        // private static final int CONN_TIMEOUT = 3000;

        // socket timeout, in milliseconds (waiting for data)
        // private static final int SOCKET_TIMEOUT = 5000;

        private int taskType = GET_TASK;
        private Context mContext = null;
        private String processMessage = ""Processing..."";

        private ArrayList&lt;NameValuePair&gt; params = new ArrayList&lt;NameValuePair&gt;();

        private ProgressDialog pDlg = null;

        public WebServiceTask(int taskType, Context mContext,
                String processMessage) {

            this.taskType = taskType;
            this.mContext = mContext;
            this.processMessage = processMessage;
        }

        public void addNameValuePair(String name, String value) {

            params.add(new BasicNameValuePair(name, value));
        }

        private void showProgressDialog() {

            pDlg = new ProgressDialog(mContext);
            pDlg.setMessage(processMessage);
            pDlg.setProgressDrawable(mContext.getWallpaper());
            pDlg.setProgressStyle(ProgressDialog.STYLE_SPINNER);
            pDlg.setCancelable(false);
            pDlg.show();

        }

        @Override
        protected void onPreExecute() {

            hideKeyboard();
            showProgressDialog();

        }

        protected String doInBackground(String... urls) {

            String url = urls[0];
            String result = """";

            HttpResponse response = doResponse(url);

            if (response == null) {
                return result;
            } else {

                try {

                    result = inputStreamToString(response.getEntity()
                            .getContent());

                } catch (IllegalStateException e) {
                    Log.e(TAG, e.getLocalizedMessage(), e);

                } catch (IOException e) {
                    Log.e(TAG, e.getLocalizedMessage(), e);
                }

            }

            return result;
        }

        @Override
        protected void onPostExecute(String response) {

            handleResponse(response);
            pDlg.dismiss();

        }

        // Establish connection and socket (data retrieval) timeouts
        /*
         * private HttpParams getHttpParams() {
         * 
         * HttpParams htpp = new BasicHttpParams();
         * 
         * HttpConnectionParams.setConnectionTimeout(htpp, CONN_TIMEOUT);
         * HttpConnectionParams.setSoTimeout(htpp, SOCKET_TIMEOUT);
         * 
         * return htpp; }
         */

        private HttpResponse doResponse(String url) {

            // Use our connection and data timeouts as parameters for our
            // DefaultHttpClient
            // HttpClient httpclient = new DefaultHttpClient(getHttpParams());

            DefaultHttpClient httpsclient = httpsClient();

            HttpResponse response = null;

            try {
                switch (taskType) {

                case POST_TASK:
                    HttpPost httppost = new HttpPost(url);
                    // Add parameters
                    httppost.setEntity(new UrlEncodedFormEntity(params));

                    response = httpsclient.execute(httppost); // httpclient.execute(httppost);
                    break;
                case GET_TASK:
                    HttpGet httpget = new HttpGet(url);
                    response = httpsclient.execute(httpget); // httpclient.execute(httpget);
                    break;
                }
            } catch (Exception e) {

                Log.e(TAG, e.getLocalizedMessage(), e);

            }

            return response;
        }

        private String inputStreamToString(InputStream is) {

            String line = """";
            StringBuilder total = new StringBuilder();

            // Wrap a BufferedReader around the InputStream
            BufferedReader rd = new BufferedReader(new InputStreamReader(is));

            try {
                // Read response until the end
                while ((line = rd.readLine()) != null) {
                    total.append(line);
                }
            } catch (IOException e) {
                Log.e(TAG, e.getLocalizedMessage(), e);
            }

            // Return full string
            return total.toString();
        }

    }

    private DefaultHttpClient httpsClient() {
        SchemeRegistry schemeRegistry = new SchemeRegistry();
        schemeRegistry.register(new Scheme(""http"", PlainSocketFactory
                .getSocketFactory(), 80));
        schemeRegistry.register(new Scheme(""https"", new EasySSLSocketFactory(),
                443));

        HttpParams httpParams = new BasicHttpParams();
        httpParams.setParameter(ConnManagerPNames.MAX_TOTAL_CONNECTIONS, 30);
        httpParams.setParameter(ConnManagerPNames.MAX_CONNECTIONS_PER_ROUTE,
                new ConnPerRouteBean(30));
        httpParams.setParameter(HttpProtocolParams.USE_EXPECT_CONTINUE, false);
        HttpProtocolParams.setVersion(httpParams, HttpVersion.HTTP_1_1);

        ClientConnectionManager cm = new SingleClientConnManager(httpParams,
                schemeRegistry);
        return new DefaultHttpClient(cm, httpParams);
    }

    private class EasySSLSocketFactory implements LayeredSocketFactory {
        private SSLContext sslcontext = null;

        private SSLContext createEasySSLContext() throws IOException {
            try {
                SSLContext context = SSLContext.getInstance(""TLS"");
                context.init(null,
                        new TrustManager[] { new EasyX509TrustManager(null) },
                        null);
                return context;
            } catch (Exception e) {
                throw new IOException(e.getMessage());
            }
        }

        private SSLContext getSSLContext() throws IOException {
            if (this.sslcontext == null) {
                this.sslcontext = createEasySSLContext();
            }
            return this.sslcontext;
        }

        /**
         * @see org.apache.http.conn.scheme.SocketFactory#connectSocket(java.net.Socket,
         *      java.lang.String, int, java.net.InetAddress, int,
         *      org.apache.http.params.HttpParams)
         */
        public Socket connectSocket(Socket sock, String host, int port,
                InetAddress localAddress, int localPort, HttpParams params)
                throws IOException, UnknownHostException,
                ConnectTimeoutException {
            int connTimeout = HttpConnectionParams.getConnectionTimeout(params);
            int soTimeout = HttpConnectionParams.getSoTimeout(params);

            InetSocketAddress remoteAddress = new InetSocketAddress(host, port);
            SSLSocket sslsock = (SSLSocket) ((sock != null) ? sock
                    : createSocket());

            if ((localAddress != null) || (localPort &gt; 0)) {
                // we need to bind explicitly
                if (localPort &lt; 0) {
                    localPort = 0; // indicates ""any""
                }
                InetSocketAddress isa = new InetSocketAddress(localAddress,
                        localPort);
                sslsock.bind(isa);
            }

            sslsock.connect(remoteAddress, connTimeout);
            sslsock.setSoTimeout(soTimeout);
            return sslsock;

        }

        /**
         * @see org.apache.http.conn.scheme.SocketFactory#createSocket()
         */
        public Socket createSocket() throws IOException {
            return getSSLContext().getSocketFactory().createSocket();
        }

        /**
         * @see org.apache.http.conn.scheme.SocketFactory#isSecure(java.net.Socket)
         */
        public boolean isSecure(Socket socket) throws IllegalArgumentException {
            return true;
        }

        /**
         * @see org.apache.http.conn.scheme.LayeredSocketFactory#createSocket(java.net.Socket,
         *      java.lang.String, int, boolean)
         */
        public Socket createSocket(Socket socket, String host, int port,
                boolean autoClose) throws IOException, UnknownHostException {
            // return getSSLContext().getSocketFactory().createSocket(socket,
            // host, port, autoClose);
            return getSSLContext().getSocketFactory().createSocket(socket,
                    host, port, autoClose);
        }

        // -------------------------------------------------------------------
        // javadoc in org.apache.http.conn.scheme.SocketFactory says :
        // Both Object.equals() and Object.hashCode() must be overridden
        // for the correct operation of some connection managers
        // -------------------------------------------------------------------

        public boolean equals(Object obj) {
            return ((obj != null) &amp;&amp; obj.getClass().equals(
                    EasySSLSocketFactory.class));
        }

        public int hashCode() {
            return EasySSLSocketFactory.class.hashCode();
        }

    }

    private class EasyX509TrustManager implements X509TrustManager {
        private X509TrustManager standardTrustManager = null;

        /**
         * Constructor for EasyX509TrustManager.
         */
        public EasyX509TrustManager(KeyStore keystore)
                throws NoSuchAlgorithmException, KeyStoreException {
            super();
            TrustManagerFactory factory = TrustManagerFactory
                    .getInstance(TrustManagerFactory.getDefaultAlgorithm());
            factory.init(keystore);
            TrustManager[] trustmanagers = factory.getTrustManagers();
            if (trustmanagers.length == 0) {
                throw new NoSuchAlgorithmException(""no trust manager found"");
            }
            this.standardTrustManager = (X509TrustManager) trustmanagers[0];
        }

        /**
         * @see 
         *      javax.net.ssl.X509TrustManager#checkClientTrusted(X509Certificate
         *      [],String authType)
         */
        public void checkClientTrusted(X509Certificate[] certificates,
                String authType) throws CertificateException {
            standardTrustManager.checkClientTrusted(certificates, authType);
        }

        /**
         * @see 
         *      javax.net.ssl.X509TrustManager#checkServerTrusted(X509Certificate
         *      [],String authType)
         */
        public void checkServerTrusted(X509Certificate[] certificates,
                String authType) throws CertificateException {
            if ((certificates != null) &amp;&amp; (certificates.length == 1)) {
                certificates[0].checkValidity();
            } else {
                standardTrustManager.checkServerTrusted(certificates, authType);
            }
        }

        /**
         * @see javax.net.ssl.X509TrustManager#getAcceptedIssuers()
         */
        public X509Certificate[] getAcceptedIssuers() {
            return this.standardTrustManager.getAcceptedIssuers();
        }

    }
}
",4,0,06b6605fc2da6e7a10016b1dd0515f4cfc23ce4296fa726cff8d4f4f2bb27547
,"package com.example.android.streaming.streaming.rtsp;

import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.UnsupportedEncodingException;
import java.math.BigInteger;
import java.net.InetSocketAddress;
import java.net.Socket;
import java.net.SocketException;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.Locale;
import java.util.concurrent.ConcurrentHashMap;

import android.util.Base64;
import android.util.Log;

import com.example.android.streaming.StreamingApp;
import com.example.android.streaming.streaming.Session;
import com.example.android.streaming.BuildConfig;

public class RtspSocket extends Socket {
    public static final int RTSP_HEADER_LENGTH = 4;
    public static final int RTP_HEADER_LENGTH = 12;
    public static final int MTU = 1400;

    public static final int PAYLOAD_OFFSET = RTSP_HEADER_LENGTH + RTP_HEADER_LENGTH;
    public static final int RTP_OFFSET = RTSP_HEADER_LENGTH;

    private ConcurrentHashMap&lt;String, String&gt; headerMap = new ConcurrentHashMap&lt;String, String&gt;();

    static private final String kCRLF = ""\r\n"";

    // RTSP request format strings
    static private final String kOptions = ""OPTIONS %s RTSP/1.0\r\n"";
    static private final String kDescribe = ""DESCRIBE %s RTSP/1.0\r\n"";
    static private final String kAnnounce = ""ANNOUNCE %s RTSP/1.0\r\n"";
    static private final String kSetupPublish = ""SETUP %s/trackid=%d RTSP/1.0\r\n"";
    @SuppressWarnings(""unused"")
    static private final String kSetupPlay = ""SETUP %s/trackid=%d RTSP/1.0\r\n"";
    static private final String kRecord = ""RECORD %s RTSP/1.0\r\n"";
    static private final String kPlay = ""PLAY %s RTSP/1.0\r\n"";
    static private final String kTeardown = ""TEARDOWN %s RTSP/1.0\r\n"";

    // RTSP header format strings
    static private final String kCseq = ""Cseq: %d\r\n"";
    static private final String kContentLength = ""Content-Length: %d\r\n"";
    static private final String kContentType = ""Content-Type: %s\r\n"";
    static private final String kTransport = ""Transport: RTP/AVP/%s;unicast;mode=%s;%s\r\n"";
    static private final String kSession = ""Session: %s\r\n"";
    static private final String kRange = ""range: %s\r\n"";
    static private final String kAccept = ""Accept: %s\r\n"";
    static private final String kAuthBasic = ""Authorization: Basic %s\r\n"";
    static private final String kAuthDigest = ""Authorization: Digest username=\""%s\"",realm=\""%s\"",nonce=\""%s\"",uri=\""%s\"",response=\""%s\""\r\n"";

    // RTSP header keys
    static private final String kSessionKey = ""Session"";
    static private final String kWWWAuthKey = ""WWW-Authenticate"";

    byte header[] = new byte[RTSP_MAX_HEADER + 1];
    static private final int RTSP_MAX_HEADER = 4095;
    static private final int RTSP_MAX_BODY = 4095;

    static private final int RTSP_RESP_ERR = -6;
    // static private final int RTSP_RESP_ERR_SESSION = -7;
    static public final int RTSP_OK = 200;
    static private final int RTSP_BAD_USER_PASS = 401;

    static private final int SOCK_ERR_READ = -5;

    /* Number of channels including control ones. */
    private int channelCount = 0;

    /* RTSP negotiation cmd seq counter */
    private int seq = 0;

    private String authentication = null;
    private String session = null;

    private String path = null;
    private String url = null;
    private String user = null;
    private String pass = null;
    private String sdp = null;

    private byte[] buffer = new byte[MTU];

    public RtspSocket() {
        super();
        try {
            setTcpNoDelay(true);
            setSoTimeout(60000);
        } catch (SocketException e) {
            Log.e(StreamingApp.TAG, ""Failed to set socket params."");
        }
        buffer[RTSP_HEADER_LENGTH] = (byte) Integer.parseInt(""10000000"", 2);
    }

    public byte[] getBuffer() {
        return buffer;
    }

    public static final void setLong(byte[] buffer, long n, int begin, int end) {
        for (end--; end &gt;= begin; end--) {
            buffer[end] = (byte) (n % 256);
            n &gt;&gt;= 8;
        }
    }

    public void setSequence(int seq) {
        setLong(buffer, seq, RTP_OFFSET + 2, RTP_OFFSET + 4);
    }

    public void setSSRC(int ssrc) {
        setLong(buffer, ssrc, RTP_OFFSET + 8, RTP_OFFSET + 12);
    }

    public void setPayload(int payload) {
        buffer[RTP_OFFSET + 1] = (byte) (payload &amp; 0x7f);
    }

    public void setRtpTimestamp(long timestamp) {
        setLong(buffer, timestamp, RTP_OFFSET + 4, RTP_OFFSET + 8);
    }

    /** Sends the RTP packet over the network */
    private void send(int length, int stream) throws IOException {
        buffer[0] = '$';
        buffer[1] = (byte) stream;
        setLong(buffer, length, 2, 4);
        OutputStream s = getOutputStream();
        s.write(buffer, 0, length + RTSP_HEADER_LENGTH);
        s.flush();
    }

    public void sendReport(int length, int ssrc, int stream) throws IOException {
        setPayload(200);
        setLong(buffer, ssrc, RTP_OFFSET + 4, RTP_OFFSET + 8);
        send(length + RTP_HEADER_LENGTH, stream);
    }

    public void sendData(int length, int ssrc, int seq, int payload, int stream, boolean last) throws IOException {
        setSSRC(ssrc);
        setSequence(seq);
        setPayload(payload);
        buffer[RTP_OFFSET + 1] |= (((last ? 1 : 0) &amp; 0x01) &lt;&lt; 7);
        send(length + RTP_HEADER_LENGTH, stream);
    }

    public int getChannelCount() {
        return channelCount;
    }

    private void write(String request) throws IOException {
        try {
            String asci = new String(request.getBytes(), ""US-ASCII"");
            OutputStream out = getOutputStream();
            out.write(asci.getBytes());
        } catch (IOException e) {
            throw new IOException(""Error writing to socket."");
        }
    }

    private String read() throws IOException {
        String response = null;
        try {
            InputStream in = getInputStream();
            int i = 0, len = 0, crlf_count = 0;
            boolean parsedHeader = false;

            for (; i &lt; RTSP_MAX_BODY &amp;&amp; !parsedHeader &amp;&amp; len &gt; -1; i++) {
                len = in.read(header, i, 1);
                if (header[i] == '\r' || header[i] == '\n') {
                    crlf_count++;
                    if (crlf_count == 4)
                        parsedHeader = true;
                } else {
                    crlf_count = 0;
                }
            }
            if (len != -1) {
                len = i;
                header[len] = '\0';
                response = new String(header, 0, len, ""US-ASCII"");
            }
        } catch (IOException e) {
            throw new IOException(""Connection timed out. Check your network settings."");
        }
        return response;
    }

    private int parseResponse(String response) {
        String[] lines = response.split(kCRLF);
        String[] items = response.split("" "");
        String tempString, key, value;

        headerMap.clear();
        if (items.length &lt; 2)
            return RTSP_RESP_ERR;
        int responseCode = RTSP_RESP_ERR;
        try {
            responseCode = Integer.parseInt(items[1]);
        } catch (Exception e) {
            Log.w(StreamingApp.TAG, e.getMessage());
            Log.w(StreamingApp.TAG, response);
        }
        if (responseCode == RTSP_RESP_ERR)
            return responseCode;

        // Parse response header into key value pairs.
        for (int i = 1; i &lt; lines.length; i++) {
            tempString = lines[i];

            if (tempString.length() == 0)
                break;

            int idx = tempString.indexOf("":"");

            if (idx == -1)
                continue;

            key = tempString.substring(0, idx);
            value = tempString.substring(idx + 1);
            headerMap.put(key, value);
        }

        tempString = headerMap.get(kSessionKey);
        if (tempString != null) {
            // Parse session
            items = tempString.split("";"");
            tempString = items[0];
            session = tempString.trim();
        }

        return responseCode;
    }

    private void generateBasicAuth() throws UnsupportedEncodingException {
        String userpass = String.format(""%s:%s"", user, pass);
        authentication = String.format(kAuthBasic, Base64.encodeToString(userpass.getBytes(""US-ASCII""), Base64.DEFAULT));
    }

    public static String md5(String s) {
        MessageDigest digest;
        try {
            digest = MessageDigest.getInstance(""MD5"");
            digest.update(s.getBytes(), 0, s.length());
            String hash = new BigInteger(1, digest.digest()).toString(16);
            return hash;
        } catch (NoSuchAlgorithmException e) {
            e.printStackTrace();
        }
        return """";
    }

    static private final int CC_MD5_DIGEST_LENGTH = 16;

    private String md5HexDigest(String input) {
        byte digest[] = md5(input).getBytes();
        String result = new String();
        for (int i = 0; i &lt; CC_MD5_DIGEST_LENGTH; i++)
            result = result.concat(String.format(""%02x"", digest[i]));
        return result;
    }

    private void generateDigestAuth(String method) {
        String nonce, realm;
        String ha1, ha2, response;

        // WWW-Authenticate: Digest realm=""Streaming Server"",
        // nonce=""206351b944cb28fe37a0794848c2e36f""
        String wwwauth = headerMap.get(kWWWAuthKey);
        int idx = wwwauth.indexOf(""Digest"");
        String authReq = wwwauth.substring(idx + ""Digest"".length() + 1);

        if (BuildConfig.DEBUG)
            Log.d(StreamingApp.TAG, String.format(""Auth Req: %s"", authReq));

        String[] split = authReq.split("","");
        realm = split[0];
        nonce = split[1];

        split = realm.split(""="");
        realm = split[1];
        realm = realm.substring(1, 1 + realm.length() - 2);

        split = nonce.split(""="");
        nonce = split[1];
        nonce = nonce.substring(1, 1 + nonce.length() - 2);

        if (BuildConfig.DEBUG) {
            Log.d(StreamingApp.TAG, String.format(""realm=%s"", realm));
            Log.d(StreamingApp.TAG, String.format(""nonce=%s"", nonce));
        }

        ha1 = md5HexDigest(String.format(""%s:%s:%s"", user, realm, pass));
        ha2 = md5HexDigest(String.format(""%s:%s"", method, url));
        response = md5HexDigest(String.format(""%s:%s:%s"", ha1, nonce, ha2));
        authentication = md5HexDigest(String.format(kAuthDigest, user, realm, nonce, url, response));
    }

    private int options() throws IOException {
        seq++;
        StringBuilder request = new StringBuilder();
        request.append(String.format(kOptions, url));
        request.append(String.format(kCseq, seq));
        request.append(kCRLF);
        if (BuildConfig.DEBUG)
            Log.d(StreamingApp.TAG, ""--- OPTIONS Request ---\n\n"" + request);
        write(request.toString());
        String response = read();
        if (response == null)
            return SOCK_ERR_READ;
        if (BuildConfig.DEBUG)
            Log.d(StreamingApp.TAG, ""--- OPTIONS Response ---\n\n"" + response);
        return parseResponse(response);
    }

    @SuppressWarnings(""unused"")
    private int describe() throws IOException {
        seq++;
        StringBuilder request = new StringBuilder();
        request.append(String.format(kDescribe, url));
        request.append(String.format(kAccept, ""application/sdp""));
        request.append(String.format(kCseq, seq));
        request.append(kCRLF);
        if (BuildConfig.DEBUG)
            Log.d(StreamingApp.TAG, ""--- DESCRIBE Request ---\n\n"" + request);
        write(request.toString());
        String response = read();
        if (response == null)
            return SOCK_ERR_READ;
        if (BuildConfig.DEBUG)
            Log.d(StreamingApp.TAG, ""--- DESCRIBE Response ---\n\n"" + response);
        return parseResponse(response);
    }

    private int recurseDepth = 0;

    private int announce() throws IOException {
        seq++;
        recurseDepth = 0;
        StringBuilder request = new StringBuilder();
        request.append(String.format(kAnnounce, url));
        request.append(String.format(kCseq, seq));
        request.append(String.format(kContentLength, sdp.length()));
        request.append(String.format(kContentType, ""application/sdp""));
        request.append(kCRLF);
        if (sdp.length() &gt; 0)
            request.append(sdp);
        if (BuildConfig.DEBUG)
            Log.d(StreamingApp.TAG, ""--- ANNOUNCE Request ---\n\n"" + request);
        write(request.toString());
        String response = read();
        if (response == null)
            return SOCK_ERR_READ;
        if (BuildConfig.DEBUG)
            Log.d(StreamingApp.TAG, ""--- ANNOUNCE Response ---\n\n"" + response);

        int ret = parseResponse(response);
        if (ret == RTSP_BAD_USER_PASS &amp;&amp; recurseDepth == 0) {
            String wwwauth = headerMap.get(kWWWAuthKey);
            if (wwwauth != null) {
                if (BuildConfig.DEBUG)
                    Log.d(StreamingApp.TAG, String.format(""WWW Auth Value: %s"", wwwauth));
                int idx = wwwauth.indexOf(""Basic"");
                recurseDepth++;

                if (idx != -1) {
                    generateBasicAuth();
                } else {
                    // We are assuming Digest here.
                    generateDigestAuth(""ANNOUNCE"");
                }

                ret = announce();
                recurseDepth--;
            }
        }
        return ret;
    }

    private int setup(int trackId) throws IOException {
        seq++;
        recurseDepth = 0;
        StringBuilder request = new StringBuilder();
        request.append(String.format(kSetupPublish, url, trackId));
        request.append(String.format(kCseq, seq));

        /* One channel for rtp (data) and one for rtcp (control) */
        String tempString = String.format(Locale.getDefault(), ""interleaved=%d-%d"", channelCount++, channelCount++);

        request.append(String.format(kTransport, ""TCP"", ""record"", tempString));
        request.append(kCRLF);
        if (BuildConfig.DEBUG)
            Log.d(StreamingApp.TAG, ""--- SETUP Request ---\n\n"" + request);
        write(request.toString());
        String response = read();
        if (response == null)
            return SOCK_ERR_READ;
        if (BuildConfig.DEBUG)
            Log.d(StreamingApp.TAG, ""--- SETUP Response ---\n\n"" + response);

        int ret = parseResponse(response);
        if (ret == RTSP_BAD_USER_PASS &amp;&amp; recurseDepth == 0) {
            String wwwauth = headerMap.get(kWWWAuthKey);
            if (wwwauth != null) {
                if (BuildConfig.DEBUG)
                    Log.d(StreamingApp.TAG, String.format(""WWW Auth Value: %s"", wwwauth));
                int idx = wwwauth.indexOf(""Basic"");
                recurseDepth++;

                if (idx != -1) {
                    generateBasicAuth();
                } else {
                    // We are assuming Digest here.
                    generateDigestAuth(""SETUP"");
                }

                ret = setup(trackId);
                authentication = null;
                recurseDepth--;
            }
        }
        return ret;
    }

    private int record() throws IOException {
        seq++;
        recurseDepth = 0;
        StringBuilder request = new StringBuilder();
        request.append(String.format(kRecord, url));
        request.append(String.format(kCseq, seq));
        request.append(String.format(kRange, ""npt=0.000-""));
        if (authentication != null)
            request.append(authentication);
        if (session != null)
            request.append(String.format(kSession, session));
        request.append(kCRLF);
        if (BuildConfig.DEBUG)
            Log.d(StreamingApp.TAG, ""--- RECORD Request ---\n\n"" + request);
        write(request.toString());
        String response = read();
        if (response == null)
            return SOCK_ERR_READ;
        if (BuildConfig.DEBUG)
            Log.d(StreamingApp.TAG, ""--- RECORD Response ---\n\n"" + response);
        int ret = parseResponse(response);
        if (ret == RTSP_BAD_USER_PASS &amp;&amp; recurseDepth == 0) {
            String wwwauth = headerMap.get(kWWWAuthKey);
            if (wwwauth != null) {
                if (BuildConfig.DEBUG)
                    Log.d(StreamingApp.TAG, String.format(""WWW Auth Value: %s"", wwwauth));
                int idx = wwwauth.indexOf(""Basic"");
                recurseDepth++;

                if (idx != -1) {
                    generateBasicAuth();
                } else {
                    // We are assuming Digest here.
                    generateDigestAuth(""RECORD"");
                }

                ret = record();
                authentication = null;
                recurseDepth--;
            }
        }
        return ret;
    }

    @SuppressWarnings(""unused"")
    private int play() throws IOException {
        seq++;
        recurseDepth = 0;
        StringBuilder request = new StringBuilder();
        request.append(String.format(kPlay, url));
        request.append(String.format(kCseq, seq));
        request.append(String.format(kRange, ""npt=0.000-""));
        if (authentication != null)
            request.append(authentication);
        if (session != null)
            request.append(String.format(kSession, session));
        request.append(kCRLF);
        if (BuildConfig.DEBUG)
            Log.d(StreamingApp.TAG, ""--- PLAY Request ---\n\n"" + request);
        write(request.toString());
        String response = read();
        if (response == null)
            return SOCK_ERR_READ;
        if (BuildConfig.DEBUG)
            Log.d(StreamingApp.TAG, ""--- PLAY Response ---\n\n"" + response);
        int ret = parseResponse(response);
        if (ret == RTSP_BAD_USER_PASS &amp;&amp; recurseDepth == 0) {
            String wwwauth = headerMap.get(kWWWAuthKey);
            if (wwwauth != null) {
                if (BuildConfig.DEBUG)
                    Log.d(StreamingApp.TAG, String.format(""WWW Auth Value: %s"", wwwauth));
                int idx = wwwauth.indexOf(""Basic"");
                recurseDepth++;

                if (idx != -1) {
                    generateBasicAuth();
                } else {
                    // We are assuming Digest here.
                    generateDigestAuth(""PLAY"");
                }

                ret = record();
                authentication = null;
                recurseDepth--;
            }
        }
        return ret;
    }

    private int teardown() throws IOException {
        seq++;
        recurseDepth = 0;
        StringBuilder request = new StringBuilder();
        request.append(String.format(kTeardown, url));
        request.append(String.format(kCseq, seq));
        if (authentication != null)
            request.append(authentication);
        if (session != null)
            request.append(String.format(kSession, session));
        request.append(kCRLF);
        if (BuildConfig.DEBUG)
            Log.d(StreamingApp.TAG, ""--- TEARDOWN Request ---\n\n"" + request);
        write(request.toString());
        String response = read();
        if (response == null)
            return SOCK_ERR_READ;
        if (BuildConfig.DEBUG)
            Log.d(StreamingApp.TAG, ""--- TEARDOWN Response ---\n\n"" + response);
        int ret = parseResponse(response);
        if (ret == RTSP_BAD_USER_PASS &amp;&amp; recurseDepth == 0) {
            String wwwauth = headerMap.get(kWWWAuthKey);
            if (wwwauth != null) {
                if (BuildConfig.DEBUG)
                    Log.d(StreamingApp.TAG, String.format(""WWW Auth Value: %s"", wwwauth));
                int idx = wwwauth.indexOf(""Basic"");
                recurseDepth++;

                if (idx != -1) {
                    generateBasicAuth();
                } else {
                    // We are assuming Digest here.
                    generateDigestAuth(""TEARDOWN"");
                }

                ret = record();
                authentication = null;
                recurseDepth--;
            }
        }
        return ret;
    }

    public void connect(String dest, int port, Session session) throws IOException {
        int trackId = 1;
        int responseCode;

        if (isConnected())
            return;

        if (!session.hasAudioTrack() &amp;&amp; !session.hasVideoTrack())
            throw new IOException(""No tracks found in session."");

        InetSocketAddress addr = null;
        try {
            addr = new InetSocketAddress(dest, port);
        } catch (Exception e) {
            throw new IOException(""Failed to resolve rtsp server address."");
        }

        this.sdp = session.getSDP();
        this.user = session.getUser();
        this.pass = session.getPass();
        this.path = session.getPath();
        this.url = String.format(""rtsp://%s:%d%s"", dest, addr.getPort(), this.path);

        try {
            super.connect(addr);
        } catch (IOException e) {
            throw new IOException(""Failed to connect rtsp server."");
        }

        responseCode = announce();
        if (responseCode != RTSP_OK) {
            close();
            throw new IOException(""RTSP announce failed: "" + responseCode);
        }

        responseCode = options();
        if (responseCode != RTSP_OK) {
            close();
            throw new IOException(""RTSP options failed: "" + responseCode);
        }

        /* Setup audio */
        if (session.hasAudioTrack()) {
            session.getAudioTrack().setStreamId(channelCount);
            responseCode = setup(trackId++);
            if (responseCode != RTSP_OK) {
                close();
                throw new IOException(""RTSP video failed: "" + responseCode);
            }
        }

        /* Setup video */
        if (session.hasVideoTrack()) {
            session.getVideoTrack().setStreamId(channelCount);
            responseCode = setup(trackId++);
            if (responseCode != RTSP_OK) {
                close();
                throw new IOException(""RTSP audio setup failed: "" + responseCode);
            }
        }

        responseCode = record();
        if (responseCode != RTSP_OK) {
            close();
            throw new IOException(""RTSP record failed: "" + responseCode);
        }
    }

    public void close() throws IOException {
        if (!isConnected())
            return;
        teardown();
        super.close();
    }
}
",3,0,d8625f698df9c694b36d38a090629403dacb0b24f770db6f80077325541cef76
,"public class PayUMoneyActivity extends AppCompatActivity {

    /**
     * Adding WebView as setContentView
     */
    WebView webView;

    /**
     * Context for Activity
     */
    Context activity;
    /**
     * Order Id
     * To Request for Updating Payment Status if Payment Successfully Done
     */
    int mId; //Getting from Previous Activity
    /**
     * Required Fields
     */
    // Test Variables
    /*
    private String mMerchantKey = ""FCyqqZ"";
    private String mSalt = ""sfBpGA8E"";
    private String mBaseURL = ""https://test.payu.in"";
    */

    // Final Variables
    private String mMerchantKey = ""Your Merchant Key"";
    private String mSalt = ""Salt"";
    private String mBaseURL = ""https://secure.payu.in"";


    private String mAction = """"; // For Final URL
    private String mTXNId; // This will create below randomly
    private String mHash; // This will create below randomly
    private String mProductInfo = ""Food Items""; //Passing String only
    private String mFirstName; // From Previous Activity
    private String mEmailId; // From Previous Activity
    private double mAmount; // From Previous Activity
    private String mPhone; // From Previous Activity
    private String mServiceProvider = ""payu_paisa"";
    private String mSuccessUrl = ""your success URL"";
    private String mFailedUrl = ""Your Failure URL"";


    boolean isFromOrder;
    /**
     * Handler
     */
    Handler mHandler = new Handler();

    /**
     * @param savedInstanceState
     */
    @SuppressLint({""AddJavascriptInterface"", ""SetJavaScriptEnabled""})
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        getWindow().requestFeature(Window.FEATURE_PROGRESS);
        super.onCreate(savedInstanceState);

        /**
        * Setting WebView to Screen
        */
        setContentView(R.layout.activity_webview_for_payumoney);

        /**
         * Creating WebView
         */
        webView = (WebView) findViewById(R.id.payumoney_webview);

        /**
         * Context Variable
         */
        activity = getApplicationContext();

        /**
         * Actionbar Settings
         */
        Toolbar toolbar = (Toolbar) findViewById(R.id.toolbar);
        setSupportActionBar(toolbar);

        ActionBar ab = getSupportActionBar();
        ab.setDisplayHomeAsUpEnabled(true);
        // enabling action bar app icon and behaving it as toggle button
        ab.setHomeButtonEnabled(true);
        ab.setTitle(getString(R.string.title_activity_online_payment));

        /**
         * Getting Intent Variables...
         */
        Bundle bundle = getIntent().getExtras();
        if (bundle != null) {

            mFirstName = bundle.getString(""name"");
            mEmailId = bundle.getString(""email"");
            mAmount = bundle.getDouble(""amount"");
            mPhone = bundle.getString(""phone"");
            mId = bundle.getInt(""id"");
            isFromOrder = bundle.getBoolean(""isFromOrder"");

            Log.i(TAG, """" + mFirstName + "" : "" + mEmailId + "" : "" + mAmount + "" : "" + mPhone);

            /**
             * Creating Transaction Id
             */
            Random rand = new Random();
            String randomString = Integer.toString(rand.nextInt()) + (System.currentTimeMillis() / 1000L);
            mTXNId = hashCal(""SHA-256"", randomString).substring(0, 20);

            mAmount = new BigDecimal(mAmount).setScale(0, RoundingMode.UP).intValue();

            /**
             * Creating Hash Key
             */
            mHash = hashCal(""SHA-512"", mMerchantKey + ""|"" +
                    mTXNId + ""|"" +
                    mAmount + ""|"" +
                    mProductInfo + ""|"" +
                    mFirstName + ""|"" +
                    mEmailId + ""|||||||||||"" +
                    mSalt);

            /**
             * Final Action URL...
             */
            mAction = mBaseURL.concat(""/_payment"");

            /**
             * WebView Client
             */
            webView.setWebViewClient(new WebViewClient() {

                @Override
                public void onReceivedError(WebView view, WebResourceRequest request, WebResourceError error) {
                    super.onReceivedError(view, request, error);
                    Toast.makeText(activity, ""Oh no! "" + error, Toast.LENGTH_SHORT).show();
                }

                @Override
                public void onReceivedSslError(WebView view,
                                               SslErrorHandler handler, SslError error) {
                    Toast.makeText(activity, ""SSL Error! "" + error, Toast.LENGTH_SHORT).show();
                    handler.proceed();
                }

                @Override
                public boolean shouldOverrideUrlLoading(WebView view, String url) {
                    return super.shouldOverrideUrlLoading(view, url);
                }

                @Override
                public void onPageFinished(WebView view, String url) {

                    if (url.equals(mSuccessUrl)) {
                        Intent intent = new Intent(PayUMoneyActivity.this, PaymentStatusActivity.class);
                        intent.putExtra(""status"", true);
                        intent.putExtra(""transaction_id"", mTXNId);
                        intent.putExtra(""id"", mId);
                        intent.putExtra(""isFromOrder"", isFromOrder);
                        intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);
                        startActivity(intent);
                    } else if (url.equals(mFailedUrl)) {
                        Intent intent = new Intent(PayUMoneyActivity.this, PaymentStatusActivity.class);
                        intent.putExtra(""status"", false);
                        intent.putExtra(""transaction_id"", mTXNId);
                        intent.putExtra(""id"", mId);
                        intent.putExtra(""isFromOrder"", isFromOrder);
                        intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);
                        startActivity(intent);
                    }
                    super.onPageFinished(view, url);
                }
            });

            webView.setVisibility(View.VISIBLE);
            webView.getSettings().setBuiltInZoomControls(true);
            webView.getSettings().setCacheMode(2);
            webView.getSettings().setDomStorageEnabled(true);
            webView.clearHistory();
            webView.clearCache(true);
            webView.getSettings().setJavaScriptEnabled(true);
            webView.getSettings().setSupportZoom(true);
            webView.getSettings().setUseWideViewPort(false);
            webView.getSettings().setLoadWithOverviewMode(false);
            webView.addJavascriptInterface(new PayUJavaScriptInterface(PayUMoneyActivity.this), ""PayUMoney"");

            /**
             * Mapping Compulsory Key Value Pairs
             */
            Map&lt;String, String&gt; mapParams = new HashMap&lt;&gt;();

            mapParams.put(""key"", mMerchantKey);
            mapParams.put(""txnid"", mTXNId);
            mapParams.put(""amount"", String.valueOf(mAmount));
            mapParams.put(""productinfo"", mProductInfo);
            mapParams.put(""firstname"", mFirstName);
            mapParams.put(""email"", mEmailId);
            mapParams.put(""phone"", mPhone);
            mapParams.put(""surl"", mSuccessUrl);
            mapParams.put(""furl"", mFailedUrl);
            mapParams.put(""hash"", mHash);
            mapParams.put(""service_provider"", mServiceProvider);

            webViewClientPost(webView, mAction, mapParams.entrySet());
        } else {
            Toast.makeText(activity, ""Something went wrong, Try again."", Toast.LENGTH_LONG).show();
        }
    }

    /**
     * Posting Data on PayUMoney Site with Form
     *
     * @param webView
     * @param url
     * @param postData
     */
    public void webViewClientPost(WebView webView, String url,
                                  Collection&lt;Map.Entry&lt;String, String&gt;&gt; postData) {
        StringBuilder sb = new StringBuilder();

        sb.append(""&lt;html&gt;&lt;head&gt;&lt;/head&gt;"");
        sb.append(""&lt;body onload='form1.submit()'&gt;"");
        sb.append(String.format(""&lt;form id='form1' action='%s' method='%s'&gt;"", url, ""post""));

        for (Map.Entry&lt;String, String&gt; item : postData) {
            sb.append(String.format(""&lt;input name='%s' type='hidden' value='%s' /&gt;"", item.getKey(), item.getValue()));
        }
        sb.append(""&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;"");

        Log.d(""TAG"", ""webViewClientPost called: "" + sb.toString());
        webView.loadData(sb.toString(), ""text/html"", ""utf-8"");
    }

    /**
     * Hash Key Calculation
     *
     * @param type
     * @param str
     * @return
     */
    public String hashCal(String type, String str) {
        byte[] hashSequence = str.getBytes();
        StringBuffer hexString = new StringBuffer();
        try {
            MessageDigest algorithm = MessageDigest.getInstance(type);
            algorithm.reset();
            algorithm.update(hashSequence);
            byte messageDigest[] = algorithm.digest();

            for (int i = 0; i &lt; messageDigest.length; i++) {
                String hex = Integer.toHexString(0xFF &amp; messageDigest[i]);
                if (hex.length() == 1)
                    hexString.append(""0"");
                hexString.append(hex);
            }
        } catch (NoSuchAlgorithmException NSAE) {
        }
        return hexString.toString();
    }

    @Override
    public boolean onOptionsItemSelected(MenuItem item) {
        if(item.getItemId() == android.R.id.home) {
            onPressingBack();
        }
        return super.onOptionsItemSelected(item);
    }

    @Override
    public void onBackPressed() {
        onPressingBack();
    }

    /**
     * On Pressing Back
     * Giving Alert...
     */
    private void onPressingBack() {

        final Intent intent;

        if(isFromOrder)
            intent = new Intent(PayUMoneyActivity.this, ProductInCartList.class);
        else
            intent = new Intent(PayUMoneyActivity.this, MainActivity.class);

        intent.setFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);

        AlertDialog.Builder alertDialog = new AlertDialog.Builder(PayUMoneyActivity.this);

        // Setting Dialog Title
        alertDialog.setTitle(""Warning"");

        // Setting Dialog Message
        alertDialog.setMessage(""Do you cancel this transaction?"");

        // On pressing Settings button
        alertDialog.setPositiveButton(""Yes"", new DialogInterface.OnClickListener() {
            public void onClick(DialogInterface dialog, int which) {
                finish();
                startActivity(intent);
            }
        });

        // on pressing cancel button
        alertDialog.setNegativeButton(""No"", new DialogInterface.OnClickListener() {
            public void onClick(DialogInterface dialog, int which) {
                dialog.dismiss();
            }
        });

        // Showing Alert Message
        alertDialog.show();
    }

    public class PayUJavaScriptInterface {
        Context mContext;

        /**
         * Instantiate the interface and set the context
         */
        PayUJavaScriptInterface(Context c) {
            mContext = c;
        }

        public void success(long id, final String paymentId) {
            mHandler.post(new Runnable() {

                public void run() {
                    mHandler = null;
                    Toast.makeText(PayUMoneyActivity.this, ""Payment Successfully."", Toast.LENGTH_SHORT).show();
                }
            });
        }
    }
}
",4,0,f1dea4f9fb7eb02235e0eb58374889c5cfdb52e75915ba93c75bfed248acdaad
,"import android.app.Activity;
import android.content.Intent;
import android.content.pm.PackageInfo;
import android.content.pm.PackageManager;
import android.content.pm.Signature;
import android.os.Bundle;
import android.util.Base64;
import android.util.Log;
import android.view.View;
import android.widget.Button;
import android.widget.TextView;
import android.widget.Toast;

import com.linkedin.platform.LISessionManager;
import com.linkedin.platform.errors.LIAuthError;
import com.linkedin.platform.listeners.AuthListener;
import com.linkedin.platform.utils.Scope;

import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;

public class MainActivity extends Activity {
    private static final String TAG = MainActivity.class.getSimpleName();
    public static final String PACKAGE = ""com.android.app"";
                                          // your package name

    Button login_linkedin_btn;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        generateHashkey();

        login_linkedin_btn = (Button) findViewById(R.id.login_button);
        login_linkedin_btn.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View view) {
                login_linkedin();
            }
        });
    }

    // Authenticate with linkedin and intialize Session.

    public void login_linkedin(){
        LISessionManager.getInstance(getApplicationContext()).init(this, buildScope(), new AuthListener() {
            @Override
            public void onAuthSuccess() {

                // Toast.makeText(getApplicationContext(), ""success"" + LISessionManager.getInstance(getApplicationContext()).getSession().getAccessToken().toString(), Toast.LENGTH_LONG).show();

            }

            @Override
            public void onAuthError(LIAuthError error) {

                Toast.makeText(getApplicationContext(), ""failed "" + error.toString(),
                                 Toast.LENGTH_LONG).show();
            }
        }, true);
    }

    // After complete authentication start new HomePage Activity

    @Override
    protected void onActivityResult(int requestCode, int resultCode, Intent data) {
        LISessionManager.getInstance(getApplicationContext()).onActivityResult(this,
                                      requestCode, resultCode, data);
        Intent intent = new Intent(MainActivity.this,UserProfile.class);
        startActivity(intent);
    }

     // generate the hash key 
     public void generateHashkey(){
        try {
            PackageInfo info = getPackageManager().getPackageInfo(
                    PACKAGE,
                    PackageManager.GET_SIGNATURES);
            for (Signature signature : info.signatures) {
                MessageDigest md = MessageDigest.getInstance(""SHA"");
                md.update(signature.toByteArray());

                Log.d(""Hask key"",Base64.encodeToString(md.digest(), Base64.NO_WRAP));

            }
        } catch (PackageManager.NameNotFoundException e) {
            Log.d(TAG, e.getMessage(), e);
        } catch (NoSuchAlgorithmException e) {
            Log.d(TAG, e.getMessage(), e);
        }
    }

    // This method is used to make permissions to retrieve data from linkedin

    private static Scope buildScope() {
        return Scope.build(Scope.R_BASICPROFILE, Scope.R_EMAILADDRESS);
    }
}
",3,0,00d79b89f708c1983946693024e75e0fc8b6697a8bcf96d72538f08715f80a66
,"    public String computeFingerPrint(final byte[] certRaw) {

    String strResult = """";

    MessageDigest md;
    try {
        md = MessageDigest.getInstance(""SHA1"");
        md.update(certRaw);
        for (byte b : md.digest()) {
            strResult += Integer.toString(b &amp; 0xff, 16);
        }
        strResult = strResult.toUpperCase(DATA_LOCALE);
    }
    catch (NoSuchAlgorithmException ex) {
        ex.printStackTrace();
    }

    return strResult;
}
",3,0,e82f2796832df9cf35cd4d022506425419e33c351325ed55503874b189121968
,"    package au.gov.dhsJobSeeker.main.readwriteprefssettings.util;

    import java.security.SecureRandom;

    import javax.crypto.Cipher;
    import javax.crypto.KeyGenerator;
    import javax.crypto.SecretKey;
    import javax.crypto.spec.SecretKeySpec;

    import android.util.Base64;

    public class EncodeDecodeAES {

private final static String HEX = ""0123456789ABCDEF"";
private final static int JELLY_BEAN_4_2 = 17;
private final static byte[] key = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };


// static {
// Security.addProvider(new BouncyCastleProvider());
// }

public static String encrypt(String seed, String cleartext) throws Exception {
    byte[] rawKey = getRawKey(seed.getBytes());
    byte[] result = encrypt(rawKey, cleartext.getBytes());
    String fromHex = toHex(result);
    String base64 = new String(Base64.encodeToString(fromHex.getBytes(), 0));
    return base64;
}


public static String decrypt(String seed, String encrypted) throws Exception {
    byte[] seedByte = seed.getBytes();
    System.arraycopy(seedByte, 0, key, 0, ((seedByte.length &lt; 16) ? seedByte.length : 16));
    String base64 = new String(Base64.decode(encrypted, 0));
    byte[] rawKey = getRawKey(seedByte);
    byte[] enc = toByte(base64);
    byte[] result = decrypt(rawKey, enc);
    return new String(result);
}


public static byte[] encryptBytes(String seed, byte[] cleartext) throws Exception {
    byte[] rawKey = getRawKey(seed.getBytes());
    byte[] result = encrypt(rawKey, cleartext);
    return result;
}


public static byte[] decryptBytes(String seed, byte[] encrypted) throws Exception {
    byte[] rawKey = getRawKey(seed.getBytes());
    byte[] result = decrypt(rawKey, encrypted);
    return result;
}


private static byte[] getRawKey(byte[] seed) throws Exception {
    KeyGenerator kgen = KeyGenerator.getInstance(""AES""); // , ""SC"");
    SecureRandom sr = null;
    if (android.os.Build.VERSION.SDK_INT &gt;= JELLY_BEAN_4_2) {
        sr = SecureRandom.getInstance(""SHA1PRNG"", ""Crypto"");
    } else {
        sr = SecureRandom.getInstance(""SHA1PRNG"");
    }
    sr.setSeed(seed);
    try {
        kgen.init(256, sr);
        // kgen.init(128, sr);
    } catch (Exception e) {
        // Log.w(LOG, ""This device doesn't suppor 256bits, trying 192bits."");
        try {
            kgen.init(192, sr);
        } catch (Exception e1) {
            // Log.w(LOG, ""This device doesn't suppor 192bits, trying 128bits."");
            kgen.init(128, sr);
        }
    }
    SecretKey skey = kgen.generateKey();
    byte[] raw = skey.getEncoded();
    return raw;
}


private static byte[] encrypt(byte[] raw, byte[] clear) throws Exception {
    SecretKeySpec skeySpec = new SecretKeySpec(raw, ""AES"");
    Cipher cipher = Cipher.getInstance(""AES""); // /ECB/PKCS7Padding"", ""SC"");
    cipher.init(Cipher.ENCRYPT_MODE, skeySpec);
    byte[] encrypted = cipher.doFinal(clear);
    return encrypted;
}


private static byte[] decrypt(byte[] raw, byte[] encrypted) throws Exception {
    SecretKeySpec skeySpec = new SecretKeySpec(raw, ""AES"");
    Cipher cipher = Cipher.getInstance(""AES""); // /ECB/PKCS7Padding"", ""SC"");
    cipher.init(Cipher.DECRYPT_MODE, skeySpec);
    byte[] decrypted = cipher.doFinal(encrypted);
    return decrypted;
}


public static String toHex(String txt) {
    return toHex(txt.getBytes());
}


public static String fromHex(String hex) {
    return new String(toByte(hex));
}


public static byte[] toByte(String hexString) {
    int len = hexString.length() / 2;
    byte[] result = new byte[len];
    for (int i = 0; i &lt; len; i++)
        result[i] = Integer.valueOf(hexString.substring(2 * i, 2 * i + 2), 16).byteValue();
    return result;
}


public static String toHex(byte[] buf) {
    if (buf == null) return """";
    StringBuffer result = new StringBuffer(2 * buf.length);
    for (int i = 0; i &lt; buf.length; i++) {
        appendHex(result, buf[i]);
    }
    return result.toString();
}


private static void appendHex(StringBuffer sb, byte b) {
    sb.append(HEX.charAt((b &gt;&gt; 4) &amp; 0x0f)).append(HEX.charAt(b &amp; 0x0f));
}

    }
",4,0,453372f2c74bdac5a4e89bd96c46d5f2ea4502b26368489c6ed80f83bb1b6233
,"package com.fsck.k9.mail.store;

import android.app.Application;
import android.content.Context;
import android.util.Log;
import com.fsck.k9.K9;
import com.fsck.k9.helper.DomainNameChecker;
import org.apache.commons.io.IOUtils;

import javax.net.ssl.TrustManager;
import javax.net.ssl.X509TrustManager;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.security.KeyStore;
import java.security.KeyStoreException;
import java.security.NoSuchAlgorithmException;
import java.security.cert.CertificateException;
import java.security.cert.X509Certificate;
import java.util.HashMap;
import java.util.Map;

public final class TrustManagerFactory {
    private static final String LOG_TAG = ""TrustManagerFactory"";

    private static X509TrustManager defaultTrustManager;
    private static X509TrustManager unsecureTrustManager;
    private static X509TrustManager localTrustManager;

    private static X509Certificate[] lastCertChain = null;

    private static File keyStoreFile;
    private static KeyStore keyStore;


    private static class SimpleX509TrustManager implements X509TrustManager {
        public void checkClientTrusted(X509Certificate[] chain, String authType)
        throws CertificateException {
        }

        public void checkServerTrusted(X509Certificate[] chain, String authType)
        throws CertificateException {
        }

        public X509Certificate[] getAcceptedIssuers() {
            return null;
        }
    }

    private static class SecureX509TrustManager implements X509TrustManager {
        private static final Map&lt;String, SecureX509TrustManager&gt; mTrustManager =
            new HashMap&lt;String, SecureX509TrustManager&gt;();

        private final String mHost;

        private SecureX509TrustManager(String host) {
            mHost = host;
        }

        public synchronized static X509TrustManager getInstance(String host) {
            SecureX509TrustManager trustManager;
            if (mTrustManager.containsKey(host)) {
                trustManager = mTrustManager.get(host);
            } else {
                trustManager = new SecureX509TrustManager(host);
                mTrustManager.put(host, trustManager);
            }

            return trustManager;
        }

        public void checkClientTrusted(X509Certificate[] chain, String authType)
        throws CertificateException {
            defaultTrustManager.checkClientTrusted(chain, authType);
        }

        public void checkServerTrusted(X509Certificate[] chain, String authType)
        throws CertificateException {
            // FIXME: Using a static field to store the certificate chain is a bad idea. Instead
            // create a CertificateException subclass and store the chain there.
            TrustManagerFactory.setLastCertChain(chain);
            try {
                defaultTrustManager.checkServerTrusted(chain, authType);
            } catch (CertificateException e) {
                localTrustManager.checkServerTrusted(new X509Certificate[] {chain[0]}, authType);
            }
            if (!DomainNameChecker.match(chain[0], mHost)) {
                try {
                    String dn = chain[0].getSubjectDN().toString();
                    if ((dn != null) &amp;&amp; (dn.equalsIgnoreCase(keyStore.getCertificateAlias(chain[0])))) {
                        return;
                    }
                } catch (KeyStoreException e) {
                    throw new CertificateException(""Certificate cannot be verified; KeyStore Exception: "" + e);
                }
                throw new CertificateException(""Certificate domain name does not match ""
                                               + mHost);
            }
        }

        public X509Certificate[] getAcceptedIssuers() {
            return defaultTrustManager.getAcceptedIssuers();
        }

    }

    static {
        java.io.InputStream fis = null;
        try {
            javax.net.ssl.TrustManagerFactory tmf = javax.net.ssl.TrustManagerFactory.getInstance(""X509"");
            Application app = K9.app;
            keyStoreFile = new File(app.getDir(""KeyStore"", Context.MODE_PRIVATE) + File.separator + ""KeyStore.bks"");
            keyStore = KeyStore.getInstance(KeyStore.getDefaultType());
            try {
                fis = new java.io.FileInputStream(keyStoreFile);
            } catch (FileNotFoundException e1) {
                fis = null;
            }
            try {
                keyStore.load(fis, """".toCharArray());
            } catch (IOException e) {
                Log.e(LOG_TAG, ""KeyStore IOException while initializing TrustManagerFactory "", e);
                keyStore = null;
            } catch (CertificateException e) {
                Log.e(LOG_TAG, ""KeyStore CertificateException while initializing TrustManagerFactory "", e);
                keyStore = null;
            }
            tmf.init(keyStore);
            TrustManager[] tms = tmf.getTrustManagers();
            if (tms != null) {
                for (TrustManager tm : tms) {
                    if (tm instanceof X509TrustManager) {
                        localTrustManager = (X509TrustManager)tm;
                        break;
                    }
                }
            }
            tmf = javax.net.ssl.TrustManagerFactory.getInstance(""X509"");
            tmf.init((KeyStore)null);
            tms = tmf.getTrustManagers();
            if (tms != null) {
                for (TrustManager tm : tms) {
                    if (tm instanceof X509TrustManager) {
                        defaultTrustManager = (X509TrustManager) tm;
                        break;
                    }
                }
            }

        } catch (NoSuchAlgorithmException e) {
            Log.e(LOG_TAG, ""Unable to get X509 Trust Manager "", e);
        } catch (KeyStoreException e) {
            Log.e(LOG_TAG, ""Key Store exception while initializing TrustManagerFactory "", e);
        } finally {
            IOUtils.closeQuietly(fis);
        }
        unsecureTrustManager = new SimpleX509TrustManager();
    }

    private TrustManagerFactory() {
    }

    public static X509TrustManager get(String host, boolean secure) {
        return secure ? SecureX509TrustManager.getInstance(host) :
               unsecureTrustManager;
    }

    public static KeyStore getKeyStore() {
        return keyStore;
    }

    public static void setLastCertChain(X509Certificate[] chain) {
        lastCertChain = chain;
    }
    public static X509Certificate[] getLastCertChain() {
        return lastCertChain;
    }

    public static void addCertificateChain(String alias, X509Certificate[] chain) throws CertificateException {
        try {
            javax.net.ssl.TrustManagerFactory tmf = javax.net.ssl.TrustManagerFactory.getInstance(""X509"");
            for (X509Certificate element : chain) {
                keyStore.setCertificateEntry
                (element.getSubjectDN().toString(), element);
            }

            tmf.init(keyStore);
            TrustManager[] tms = tmf.getTrustManagers();
            if (tms != null) {
                for (TrustManager tm : tms) {
                    if (tm instanceof X509TrustManager) {
                        localTrustManager = (X509TrustManager) tm;
                        break;
                    }
                }
            }
            java.io.OutputStream keyStoreStream = null;
            try {
                keyStoreStream = new java.io.FileOutputStream(keyStoreFile);
                keyStore.store(keyStoreStream, """".toCharArray());
            } catch (FileNotFoundException e) {
                throw new CertificateException(""Unable to write KeyStore: "" + e.getMessage());
            } catch (CertificateException e) {
                throw new CertificateException(""Unable to write KeyStore: "" + e.getMessage());
            } catch (IOException e) {
                throw new CertificateException(""Unable to write KeyStore: "" + e.getMessage());
            } finally {
                IOUtils.closeQuietly(keyStoreStream);
            }

        } catch (NoSuchAlgorithmException e) {
            Log.e(LOG_TAG, ""Unable to get X509 Trust Manager "", e);
        } catch (KeyStoreException e) {
            Log.e(LOG_TAG, ""Key Store exception while initializing TrustManagerFactory "", e);
        }
    }
}
",3,0,6eb1d81c4053c25a6bb970518465ebafd28f2b39b11bef469cc83d1bce779637
,"trustStore = KeyStore.getInstance(""PKCS12"");
InputStream in = getResources().openRawResource(R.raw.keystore);
trustStore.load(in, ""xxxpasswordxxx"".toCharArray());
",,1,30efb5abdafdf0cac6fba129c663aa4ff301f670d91f0c484314c2d0759b3e24
,"public class MyHttpClient extends DefaultHttpClient {
    private static final String KEYSTORE_PASS = ""XXXXX"";
    private static final String KEYSTORE_TYPE = ""BKS"";

    final Context context;

    public MyHttpClient(Context context) {
        this.context = context;
    }

    @Override
    protected ClientConnectionManager createClientConnectionManager() {
        SchemeRegistry registry = new SchemeRegistry();
        registry.register(new Scheme(""http"", PlainSocketFactory.getSocketFactory(), 80));
        // Register for port 443 our SSLSocketFactory with our keystore
        // to the ConnectionManager
        registry.register(new Scheme(""https"", newSslSocketFactory(), 443));
        return new SingleClientConnManager(getParams(), registry);
    }

    private SSLSocketFactory newSslSocketFactory() {
        try {
            KeyStore trusted = KeyStore.getInstance(KEYSTORE_TYPE);         
            InputStream in = context.getResources().openRawResource(R.raw.keystore);
            try {
                 trusted.load(in, KEYSTORE_PASS.toCharArray());
            } finally {
                in.close();
            }
            SSLSocketFactory sf = new SSLSocketFactory(trusted);
            sf.setHostnameVerifier(SSLSocketFactory.STRICT_HOSTNAME_VERIFIER);
            return sf;
        } catch (Exception e) {
            throw new AssertionError(e);
        }
    }
    }

// In the Login class:
class RequestTask extends AsyncTask&lt;String, String, String&gt; {

        @Override
        protected String doInBackground(String... uri) {
            DefaultHttpClient client = new MyHttpClient(getActivity());
            HttpGet get = new HttpGet(uri[0]);
            String responseString = null;
            try {           
                HttpResponse getResponse = client.execute(get);
                HttpEntity responseEntity = getResponse.getEntity();
                StatusLine statusLine = getResponse.getStatusLine();
                if (statusLine.getStatusCode() == HttpStatus.SC_OK) {
                    ByteArrayOutputStream salida = new ByteArrayOutputStream();
                    getResponse.getEntity().writeTo(salida);
                    salida.close();
                    responseString = salida.toString();
                } else {
                    getResponse.getEntity().getContent().close();
                    throw new IOException(statusLine.getReasonPhrase());
                }           

            } catch (ClientProtocolException cpe) {
                cpe.printStackTrace();
            } catch (IOException ioe) {
                ioe.printStackTrace();
            }
            return responseString;

        }

        @Override
        protected void onPostExecute(String result) {
            super.onPostExecute(result);
            // Whatever I want = nothing, I only want to do the CA validation with it.
        }
    }
",3,0,58554aacd1eda49c24670bc3c3f03518ef6eb3ef7e5694ef1546e664bfde13c2
,"@Configuration
public class GcmXmppConnection {

@Value(""${gcm.senderID}"")
private String username;

@Value(""${gcm.apiKey}"")
private String password;

@Value(""${gcm.host}"")
private String host;

@Value(""${gcm.port}"")
private int port;

@Bean(name=""gcmConnection"")
public XmppConnectionFactoryBean xmppConnectionFactoryBean(){

    ConnectionConfiguration configuration = new    ConnectionConfiguration(host, port);
    configuration.setSecurityMode(SecurityMode.enabled);
    configuration.setReconnectionAllowed(true);
    configuration.setRosterLoadedAtLogin(false);
    configuration.setSendPresence(false);
    configuration.setSocketFactory(SSLSocketFactory.getDefault());

//      configuration.setDebuggerEnabled(true);
    XmppConnectionFactoryBean connectionFactoryBean = new XmppConnectionFactoryBean(configuration);

    connectionFactoryBean.setUser(username);
    connectionFactoryBean.setPassword(password);

    return connectionFactoryBean;
}
}
",,1,42caca941799e884cf8b4168a0b1f09c4ab6c6bf97b968ce2709a4f78b66d2e6
,"package mypackage;

import java.security.MessageDigest;
import java.util.Arrays;

import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;

import org.apache.commons.codec.binary.Base64;

public class Main {

    public static void main(String[] args) throws Exception {

        String text = ""neeraj"";

        String codedtext = new Main().encrypt(text);

        String decodedtext = new Main().decrypt(codedtext);

        System.out.println(codedtext); // this is a byte array, you'll just see a reference to an array
        System.out.println(decodedtext); // This correctly shows ""neeraj""
    }

    public String encrypt(String message) throws Exception {
        final MessageDigest md = MessageDigest.getInstance(""md5"");
        final byte[] digestOfPassword = md.digest(""KEY""
                .getBytes(""utf-8""));
        final byte[] keyBytes = Arrays.copyOf(digestOfPassword, 24);
        for (int j = 0, k = 16; j &lt; 8;) {
            keyBytes[k++] = keyBytes[j++];
        }

        final SecretKey key = new SecretKeySpec(keyBytes, ""DESede"");
        final IvParameterSpec iv = new IvParameterSpec(new byte[8]);
        final Cipher cipher = Cipher.getInstance(""DESede/CBC/PKCS5Padding"");
        cipher.init(Cipher.ENCRYPT_MODE, key, iv);

        final byte[] plainTextBytes = message.getBytes(""utf-8"");
        final byte[] cipherText = cipher.doFinal(plainTextBytes);
        // final String encodedCipherText = new sun.misc.BASE64Encoder()
        // .encode(cipherText);

        return Base64.encodeBase64String(cipherText);
    }

    public String decrypt(String input) throws Exception {

        byte[] message = Base64.decodeBase64(input);

        final MessageDigest md = MessageDigest.getInstance(""md5"");
        final byte[] digestOfPassword = md.digest(""KEY""
                .getBytes(""utf-8""));
        final byte[] keyBytes = Arrays.copyOf(digestOfPassword, 24);
        for (int j = 0, k = 16; j &lt; 8;) {
            keyBytes[k++] = keyBytes[j++];
        }

        final SecretKey key = new SecretKeySpec(keyBytes, ""DESede"");
        final IvParameterSpec iv = new IvParameterSpec(new byte[8]);
        final Cipher decipher = Cipher.getInstance(""DESede/CBC/PKCS5Padding"");
        decipher.init(Cipher.DECRYPT_MODE, key, iv);

        // final byte[] encData = new
        // sun.misc.BASE64Decoder().decodeBuffer(message);
        final byte[] plainText = decipher.doFinal(message);

        return new String(plainText, ""UTF-8"");
    }
}
",4,0,24716305d0976cb3f03687a575ddf251dbc8f761635e236297ccb9e3730ca4de
,"   public class AES2 {

    private static final String TRANSFORMATION = ""AES/CFB8/NoPadding"";
    private static final String ALGO_MD5       = ""MD5"";
    private static final String ALGO_AES       = ""AES"";

    /**
     * See http://www.logikdev.com/2012/12/12/md5-generates-31-bytes-instead-of-32/ form more detail.
     * 
     * @param input
     * @return
     * @throws NoSuchAlgorithmException
     */
    private static String md5(String input) throws NoSuchAlgorithmException {
        MessageDigest md = MessageDigest.getInstance(ALGO_MD5);
        byte[] messageDigest = md.digest(input.getBytes());
        BigInteger number = new BigInteger(1, messageDigest);
        return String.format(""%032x"", number);
    }

    public static String decrypt(String encryptedData, String initialVectorString, String secretKey) {
        String decryptedData = null;
        try {
            String md5Key = md5(secretKey);
            SecretKeySpec skeySpec = new SecretKeySpec(md5Key.getBytes(), ALGO_AES);
            IvParameterSpec initialVector = new IvParameterSpec(initialVectorString.getBytes());
            Cipher cipher = Cipher.getInstance(TRANSFORMATION);
            cipher.init(Cipher.DECRYPT_MODE, skeySpec, initialVector);
            byte[] encryptedByteArray = Base64.decode(encryptedData.getBytes(), Base64.DEFAULT);
            byte[] decryptedByteArray = cipher.doFinal(encryptedByteArray);
            decryptedData = new String(decryptedByteArray);
        } catch (NoSuchAlgorithmException e) {
            e.printStackTrace();
        } catch (NoSuchPaddingException e) {
            e.printStackTrace();
        } catch (InvalidKeyException e) {
            e.printStackTrace();
        } catch (InvalidAlgorithmParameterException e) {
            e.printStackTrace();
        } catch (IllegalBlockSizeException e) {
            e.printStackTrace();
        } catch (BadPaddingException e) {
            e.printStackTrace();
        }

        return decryptedData;
    }

}
",1,0,46c0c3f8eaa7d0e92df02c3929e39e8abdbd0a0bdc577a0b000fa194e0142b9d
," SSLContext sslContext = SSLContext.getInstance(""TLSv1"");
                sslContext.init(null, null, null);
                SSLSocketFactory socketFactory = sslContext.getSocketFactory();
                            httpURLConnection.setSSLSocketFactory(socketFactory);
",3,0,e9767a91e77da2048e04012bfc3149aeee0029a78be6871da346adcf446cf0e6
,"public class HttpsClient extends DefaultHttpClient {

    final Context context;

    public HttpsClient(Context context) {
        this.context = context;
    }

    @Override
    protected ClientConnectionManager createClientConnectionManager() {
        SchemeRegistry registry = new SchemeRegistry();
        registry.register(new Scheme(""http"", PlainSocketFactory
                .getSocketFactory(), 80));
        // Register for port 443 our SSLSocketFactory with our keystore
        // to the ConnectionManager
        registry.register(new Scheme(""https"", newSslSocketFactory(), 443));
        return new SingleClientConnManager(getParams(), registry);
    }

    private SSLSocketFactory newSslSocketFactory() {
        try {
            // Get an instance of the Bouncy Castle KeyStore format
            KeyStore trusted = KeyStore.getInstance(""BKS"");
            // Get the raw resource, which contains the keystore with
            // your trusted certificates (root and any intermediate certs)
            InputStream in = context.getResources().openRawResource(
                    R.raw.mykeystore);
            try {
                // Initialize the keystore with the provided trusted
                // certificates
                // Also provide the password of the keystore
                trusted.load(in, ""mysecret"".toCharArray());
            } finally {
                in.close();
            }
            // Pass the keystore to the SSLSocketFactory. The factory is
            // responsible
            // for the verification of the server certificate.
            SSLSocketFactory sf = new SSLSocketFactory(trusted);
            // Hostname verification from certificate
            sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
            return sf;
        } catch (Exception e) {
            throw new AssertionError(e);
        }
    }
}
",4,0,922674b56227dd4bf167bfbaff70afc73f1cda6b2260f453108db8601772b9b9
,"KeyPairGenerator kpg;

KeyPair kp;

static PublicKey publicKey;

static PrivateKey privateKey;

byte [] encryptedBytes,decryptedBytes;

Cipher cipher;

public String GetEncryptValue(String value) 
throws InvalidKeyException, NoSuchAlgorithmException, NoSuchPaddingException, 
       IllegalBlockSizeException, BadPaddingException 
{
    InputStream is = null;
    javax.security.cert.X509Certificate x5092 = null;
    try {
        is = getAssets().open(""publicCer.cer"");
         x5092 = javax.security.cert.X509Certificate.getInstance(is);
    } catch (javax.security.cert.CertificateException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    } catch (IOException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    }

    return RSAEncrypt(""Gergova"", x5092);
}

public String RSAEncrypt (
    final String plain, javax.security.cert.X509Certificate x5092) 
        throws NoSuchAlgorithmException, NoSuchPaddingException, 
           InvalidKeyException, IllegalBlockSizeException, 
           BadPaddingException 
{
    kpg = KeyPairGenerator.getInstance(""RSA"");
    kpg.initialize(1024);
    kp = kpg.genKeyPair();
    publicKey = x5092.getPublicKey();
    privateKey = kp.getPrivate();

    cipher = Cipher.getInstance(""RSA"");
    cipher.init(Cipher.ENCRYPT_MODE, publicKey);
    encryptedBytes = cipher.doFinal(stringToBytesASCII(plain));
    String str = null;
    try {
        str = new String(encryptedBytes, ""ISO-8859-1"");
    } catch (UnsupportedEncodingException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    }
    return str;
}

public static byte[] stringToBytesASCII(String str) {

     byte[] b = new byte[str.length()];
     for (int i = 0; i &lt; b.length; i++) {
      b[i] = (byte) str.charAt(i);
     }
     return b;
}
",3,0,7f90739fdd9826234a2bee0a690e6d512dbe63343a8da984c0e6d1a683319675
,"PrivateKey myKey = getKey();
X509Certificate certificate = getCertificate();
KeyStore keyStore = KeyStore.getInstance(""AndroidKeyStore"");
keyStore.load(null);
keystore.setKeyEntry(""anAlias"", myKey, null, new Certificate[] { certificate });
",,1,2f5bd2c2521ab7b7c84831f7d54b07b0da5b3e2312d94b5e777854a4cbd817a2
,"if (""https"".equals(url.getProtocol()) &amp;&amp; mSslSocketFactory != null) {            
    ((HttpsURLConnection)connection).setSSLSocketFactory(mSslSocketFactory);
    ((HttpsURLConnection)connection).setHostnameVerifier(new CustomHostnameVerifier());         
}
",4,0,0771480cfd925ad1a006b7a60d8641c424c19d685a3ec236a281caf9cf30ed82
,"  OkHttpClient okHttpClient = new OkHttpClient();
  SSLContext sslContext;
  try {
    sslContext = SSLContext.getInstance(""TLS"");
    sslContext.init(null, null, null);
  } catch (GeneralSecurityException e) {
    throw new AssertionError(); // The system has no TLS. Just give up.
  }
  okHttpClient.setSslSocketFactory(sslContext.getSocketFactory());
",3,0,8dcc85edfc4f2a5a7b406bc8ad93957fdc6ae713c44696efe2c817947b3d635b
,"// Create and initialize HTTP parameters
HttpParams params = new BasicHttpParams();
HttpClientParams.setRedirecting(params, true );

// Set the timeout in milliseconds until a connection is established.
HttpConnectionParams.setConnectionTimeout( params, 5000 );

// Set the default socket timeout (SO_TIMEOUT)
// in milliseconds which is the timeout for waiting for data.
HttpConnectionParams.setSoTimeout( params, 10000 );

// The params are read in the ctor of the pool constructed by
// ThreadSafeClientConnManager, and need to be set before constructing it.
ConnManagerParams.setMaxTotalConnections(params, 15);
ConnPerRoute cpr = new ConnPerRoute() {
   @Override
   public int getMaxForRoute(HttpRoute httpRoute) { return 5; }
};

ConnManagerParams.setMaxConnectionsPerRoute(params, cpr);

HttpProtocolParams.setVersion(params, HttpVersion.HTTP_1_1);

// Create and initialize scheme registry
SchemeRegistry schemeRegistry = new SchemeRegistry();
schemeRegistry.register( new Scheme(""http"", PlainSocketFactory.getSocketFactory(), 80));

/* Since I'm in a development environment I need to trust self-signed certs */
SSLSocketFactory sslSocketFactory = null;
try {
   X509TrustManager tm = new X509TrustManager() {
      public void checkClientTrusted(X509Certificate[] xcs, String string)
         throws CertificateException { }

      public void checkServerTrusted(X509Certificate[] xcs, String string)
         throws CertificateException { }

      public X509Certificate[] getAcceptedIssuers() { return null; }
   };

   SSLContext ctx = SSLContext.getInstance(""TLS"");
   ctx.init(null, new TrustManager[]{tm}, null);

   sslSocketFactory = new TrustAllSSLSocketFactory(ctx);
   if (sslSocketFactory != null)
      sslSocketFactory.setHostnameVerifier(
          SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);

} catch (Exception ex) {
   Log.e(TAG, ex.getMessage(), ex);
   sslSocketFactory = null;
}

if (sslSocketFactory == null) {
   sslSocketFactory = SSLSocketFactory.getSocketFactory();
   sslSocketFactory.setHostnameVerifier(
      SSLSocketFactory.BROWSER_COMPATIBLE_HOSTNAME_VERIFIER);
}

schemeRegistry.register(new Scheme(""https"", sslSocketFactory, 443));

// Create an HttpClient with the ThreadSafeClientConnManager.
// This connection manager must be used if more than one thread will
// be using the HttpClient.
ClientConnectionManager cm = new ThreadSafeClientConnManager(params, schemeRegistry);

DefaultHttpClient client = new DefaultHttpClient(cm, params);

HttpProtocolParams.setUseExpectContinue(client.getParams(), false);

HttpRequestRetryHandler retryHandler = new HttpRequestRetryHandler() {
   public boolean retryRequest(IOException exception, int executionCount,
      HttpContext context) {
      // retry a max of 5 times
      if(executionCount &gt;= 5) { return false; }
      if(exception instanceof NoHttpResponseException){
         return true;
      } else if (exception instanceof ClientProtocolException){
         return true;
      }
      return false;
   }
};

client.setHttpRequestRetryHandler(retryHandler);

/* Cookie Management */
CookiesStore cookieStore = new BasicCookieStore();
client.setCookieStore(cookieStore);
",4,0,e2f4c417c0cd82ef333f497db56c86f360e1217dcaea75244e8c92081e46e2d2
,"static final
private class TrustAllSSLSocketFactory extends SSLSocketFactory {

   private SSLContext sslContext = SSLContext.getInstance(""TLS"");

   public TrustAllSSLSocketFactory(KeyStore truststore) 
       throws NoSuchAlgorithmException,
          KeyManagementException,
              KeyStoreException, UnrecoverableKeyException {
      super(truststore);

  TrustManager tm = new X509TrustManager() {
          @Override
          public X509Certificate[] getAcceptedIssuers() { return null; }

          @Override
          public void checkServerTrusted(X509Certificate[] chain, String authType)
             throws CertificateException { }

          @Override
          public void checkClientTrusted(X509Certificate[] chain, String authType)
             throws CertificateException { }
      };

      sslContext.init(null, new TrustManager[] { tm }, null);
  }

  public TrustAllSSLSocketFactory(SSLContext context)
      throws KeyManagementException, 
             NoSuchAlgorithmException, KeyStoreException, 
             UnrecoverableKeyException {
    super(null);
    sslContext = context;
  }

  @Override
  public Socket createSocket(Socket socket, String host, int port, boolean autoClose)
     throws IOException, UnknownHostException {
      return sslContext.getSocketFactory()
         .createSocket(socket, host, port, autoClose);  
  }

  @Override
  public Socket createSocket() throws IOException {
     return sslContext.getSocketFactory().createSocket();
  }
};
",4,0,c592c6f854a30a2d041028b994bf566650e52084c8007d5d699be3ba7c04fdb0
,"            TrustManager[] trustAllCerts = new TrustManager[]{new X509TrustManager() {
            public java.security.cert.X509Certificate[] getAcceptedIssuers() {
                return null;
            }

            public void checkClientTrusted(X509Certificate[] certs, String authType) {
            }

            public void checkServerTrusted(X509Certificate[] certs, String authType) {
            }
        }
        };

        // Install the all-trusting trust manager
        SSLContext sc = SSLContext.getInstance(""SSL"");
        sc.init(null, trustAllCerts, new java.security.SecureRandom());
        HttpsURLConnection.setDefaultSSLSocketFactory(sc.getSocketFactory());

        // Create all-trusting host name verifier
        HostnameVerifier allHostsValid = new HostnameVerifier() {
            public boolean verify(String hostname, SSLSession session) {
                return true;
            }
        };
",4,0,769b6a2395074401c4a64e909d1dbe39065ff757eb6d44b1803a040db90c584b
,"public class Login extends Activity {

      //URL to get JSON Array
      private static String url = ""https://demo.vtiger.com/webservice.php?operation=getchallenge&amp;username=admin"";

      //JSON Node Names
      private static final String TAG_RESULT = ""result"";
      private static final String TAG_TOKEN = ""token"";

      // contacts JSONArray
      JSONArray contacts = null;

      String token = null;
      String sessionId;

    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.login);

        if (android.os.Build.VERSION.SDK_INT &gt; 9) {
            StrictMode.ThreadPolicy policy = new StrictMode.ThreadPolicy.Builder().permitAll().build();
            StrictMode.setThreadPolicy(policy);
        }


        new AsyncTask&lt;Void, Void, Void&gt;() {

            private ProgressDialog dialog = new ProgressDialog(Login.this);
            protected void onPreExecute() {
                   dialog.setMessage(""Loging In... Please wait..."");
                   dialog.show();
                  }

            @SuppressWarnings(""unused"")
            JSONObject result;

            @Override
            protected Void doInBackground(Void... params) {

                // Creating new JSON Parser
                JSONParser jParser = new JSONParser();

                // Getting JSON from URL
                JSONObject json = jParser.getJSONFromUrl(url);

                try {
                    // Getting JSON Array
                    result = json.getJSONObject(TAG_RESULT);
                      JSONObject json_result = json.getJSONObject(TAG_RESULT);

                    // Storing  JSON item in a Variable
                    token = json_result.getString(TAG_TOKEN);

                    //Importing TextView

                } catch (JSONException e) {
                    e.printStackTrace();
                }

                String username=""admin"";
                String accesskeyvalue = ""w9OweWKUS4a5sSL"";
                String accessKey=md5(token + accesskeyvalue);

                //For debugging purpose only
                //System.out.println(accesskeyvalue);
                //System.out.println(token);
                //System.out.println(accessKey);

        String data = null;

            try {
                data = URLEncoder.encode(""username"", ""UTF-8"")
                        + ""="" + URLEncoder.encode(username, ""UTF-8"");
                data += ""&amp;"" + URLEncoder.encode(""accessKey"", ""UTF-8"") + ""=""
                        + URLEncoder.encode(accessKey, ""UTF-8"");
            } catch (UnsupportedEncodingException e) {
                // TODO Auto-generated catch block
                e.printStackTrace();
            } 
        String text = """";
        BufferedReader reader=null;
        //System.out.println(data);

        // Send data
        try
        {

            // Defined URL  where to send data
            URL url = new URL(""https://demo.vtiger.com/webservice.php?operation=login"");

         // Send POST data request
          URLConnection conn = url.openConnection();
          conn.setDoOutput(true);
          OutputStreamWriter wr = new OutputStreamWriter(conn.getOutputStream());
          wr.write( data );
          wr.flush();    

        // Get the server response    
        reader = new BufferedReader(new InputStreamReader(conn.getInputStream()));
        StringBuilder sb = new StringBuilder();
        String line = null;

        // Read Server Response
        while((line = reader.readLine()) != null)
            {
                   // Append server response in string
                   sb.append(line + ""\n"");
            }


            text = sb.toString();
        }
        catch(Exception ex)
        {

        }
        finally
        {
            try
            {

                reader.close();
            }

            catch(Exception ex) {}
        }

        // Show response
        System.out.println(text);
        sessionId = text.substring(41, 62);
        //System.out.println(""doInBackground()""+sessionId);



    return null;    
    }
            @Override
            protected void onPostExecute(Void aVoid) {
                super.onPostExecute(aVoid);    
                dialog.dismiss();
               }

         }.execute();

    } 

    public String md5(String s) 
    {
    MessageDigest digest;
        try 
            {
                digest = MessageDigest.getInstance(""MD5"");
                digest.update(s.getBytes(),0,s.length());
                String hash = new BigInteger(1, digest.digest()).toString(16);
                return hash;
            } 
        catch (NoSuchAlgorithmException e) 
            {
                e.printStackTrace();
            }
        return """";
    }
",,1,88a575a6ec22721e8b55d9ab7a041634f809d838b6d24e36849366609e5663eb
,"    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        PrintHashKeyInLog();

    }

    public void PrintHashKeyInLog() {

        PackageInfo info;
        try {
            info = getPackageManager().getPackageInfo(
                    ""Your package name"",
                    PackageManager.GET_SIGNATURES);
            for (Signature signature : info.signatures) {
                MessageDigest md;
                md = MessageDigest.getInstance(""SHA"");
                md.update(signature.toByteArray());
                String something = new String(Base64.encode(md.digest(), 0)); // String
                something = new String(Base64.encode(md.digest(), 0));
                Log.e(""hash key"", something);
            }
        } catch (NameNotFoundException e1) {
            Log.e(""name not found"", e1.toString());
        } catch (NoSuchAlgorithmException e) {
            Log.e(""no such an algorithm"", e.toString());
        } catch (Exception e) {
            Log.e(""exception"", e.toString());
        }
    }
",3,0,e92a646d3d9ea651d0e42d04a7c4120fa99b2ae3d3997fe512af219cbfb65ad5
,"public static String decrypt(String key, String value)throws java.io.UnsupportedEncodingException,
        NoSuchAlgorithmException,
        NoSuchPaddingException,
        InvalidKeyException,
        InvalidAlgorithmParameterException,
        IllegalBlockSizeException,
        BadPaddingException {

    byte[] keyBytes = key.getBytes(""UTF-8"");
    AlgorithmParameterSpec ivSpec = new IvParameterSpec(ivBytes);
    SecretKeySpec newKey = new SecretKeySpec(keyBytes, ""AES"");
    Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
    cipher.init(Cipher.DECRYPT_MODE, newKey, ivSpec);
    byte[] decodedVal = Base64.decode(value.getBytes(""UTF-8""), Base64.DEFAULT);
    byte[] cipherData = cipher.doFinal(decodedVal);
    ILog.d(""cipherData"",""""+cipherData);
    String decryptedData = new String(cipherData, ""UTF-8"");
    ILog.d(""Data"",decryptedData);
    return decryptedData.trim();
}
",1,0,e6221a517e33fe31b3b5b3f020d1de0870a06e89b7ff82315a1352b73aac5444
,"Cipher c1 = Cipher.getInstance(""RSA"");
c1.init(Cipher.ENCRYPT_MODE, publicKey);
encodedBytes = c1.doFinal(secretMessage.getBytes());
encodedMessage = Base64.encodeToString(encodedBytes, Base64.DEFAULT);

Cipher c2 = Cipher.getInstance(""RSA"");    
c2.init(Cipher.DECRYPT_MODE, privateKey)      
decodedBytes = Base64.decode(encodedMessage.toByteArray(), Base64.DEFAULT);
decryptedMessage = c2.doFinal(decodedBytes);
",3,0,9d66327ac0aa3d96d7ea88fe6548533e43b7acf79c7496a02aed499a67fe237a
,"SSLContext sc = SSLContext.getInstance(""TLS"");
TrustManager[] trustAllCerts = new TrustManager[] { new X509TrustManager() {
    public X509Certificate[] getAcceptedIssuers() {
        return null;
    }
    @Override
    public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {
        return;
}
    @Override
    public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {
        return;
    }
} };
sc.init(null, trustAllCerts, new SecureRandom());
HttpsURLConnection.setDefaultSSLSocketFactory(sc.getSocketFactory());
HttpURLConnection = connection = endPoint.openConnection();
",4,0,989f81526428ec7078ec27009b2c486f5d4ea045236949dc343f969b0dd49baf
,"package com.duplicate;



   public class RSAEncryptionDescription {


 private static final String PUBLIC_KEY_FILE = ""Public.key"";  
 private static final String PRIVATE_KEY_FILE = ""Private.key"";  

 public static void main(String[] args) throws IOException {  

  try {  
   System.out.println(""-------GENRATE PUBLIC and PRIVATE KEY-------------"");  
   KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance(""RSA"");  
   keyPairGenerator.initialize(2048); //1024 used for normal securities  
   KeyPair keyPair = keyPairGenerator.generateKeyPair();  
   PublicKey publicKey = keyPair.getPublic();  
   PrivateKey privateKey = keyPair.getPrivate();  
   System.out.println(""Public Key - "" + publicKey);  
   System.out.println(""Private Key - "" + privateKey);

   //Pullingout parameters which makes up Key  
   System.out.println(""\n------- PULLING OUT PARAMETERS WHICH MAKES KEYPAIR----------\n"");  
   KeyFactory keyFactory = KeyFactory.getInstance(""RSA"");  
   RSAPublicKeySpec rsaPubKeySpec = keyFactory.getKeySpec(publicKey, RSAPublicKeySpec.class);  
   RSAPrivateKeySpec rsaPrivKeySpec = keyFactory.getKeySpec(privateKey, RSAPrivateKeySpec.class);  
   System.out.println(""PubKey Modulus : "" + rsaPubKeySpec.getModulus());  
   System.out.println(""PubKey Exponent : "" + rsaPubKeySpec.getPublicExponent());  
   System.out.println(""PrivKey Modulus : "" + rsaPrivKeySpec.getModulus());  
   System.out.println(""PrivKey Exponent : "" + rsaPrivKeySpec.getPrivateExponent());  

   //Share public key with other so they can encrypt data and decrypt thoses using private key(Don't share with Other)  
   System.out.println(""\n--------SAVING PUBLIC KEY AND PRIVATE KEY TO FILES-------\n"");  
   RSAEncryptionDescription rsaObj = new RSAEncryptionDescription();  
   rsaObj.saveKeys(PUBLIC_KEY_FILE, rsaPubKeySpec.getModulus(), rsaPubKeySpec.getPublicExponent());  
   rsaObj.saveKeys(PRIVATE_KEY_FILE, rsaPrivKeySpec.getModulus(), rsaPrivKeySpec.getPrivateExponent());  

   //Encrypt Data using Public Key  
   byte[] encryptedData = rsaObj.encryptData(""Anuj Patel - Classified Information !"");  

   //Descypt Data using Private Key  
   rsaObj.decryptData(encryptedData);  

  } catch (NoSuchAlgorithmException e) {  
   e.printStackTrace();  
  }catch (InvalidKeySpecException e) {  
   e.printStackTrace();  
  }  

 }  

 /** 
  * Save Files 
  * @param fileName 
  * @param mod 
  * @param exp 
  * @throws IOException 
  */  
 private void saveKeys(String fileName,BigInteger mod,BigInteger exp) throws IOException{  
  FileOutputStream fos = null;  
  ObjectOutputStream oos = null;  

  try {  
   System.out.println(""Generating ""+fileName + ""..."");  
   fos = new FileOutputStream(fileName);  
   oos = new ObjectOutputStream(new BufferedOutputStream(fos));  

   oos.writeObject(mod);  
   oos.writeObject(exp);     

   System.out.println(fileName + "" generated successfully"");  
  } catch (Exception e) {  
   e.printStackTrace();  
  }  
  finally{  
   if(oos != null){  
    oos.close();  

    if(fos != null){  
     fos.close();  
    }  
   }  
  }    
 }  

 /** 
  * Encrypt Data 
  * @param data 
  * @throws IOException 
  */  
 private byte[] encryptData(String data) throws IOException {  
  System.out.println(""\n----------------ENCRYPTION STARTED------------"");  

  System.out.println(""Data Before Encryption :"" + data);  
  byte[] dataToEncrypt = data.getBytes();  
  byte[] encryptedData = null;  
  try {  
   PublicKey pubKey = readPublicKeyFromFile(PUBLIC_KEY_FILE);  
   Cipher cipher = Cipher.getInstance(""RSA"");  
   cipher.init(Cipher.ENCRYPT_MODE, pubKey);  
   encryptedData = cipher.doFinal(dataToEncrypt);  
   System.out.println(""Encryted Data: "" + encryptedData);  

  } catch (Exception e) {  
   e.printStackTrace();  
  }   

  System.out.println(""----------------ENCRYPTION COMPLETED------------"");    
  return encryptedData;  
 }  

 /** 
  * Encrypt Data 
  * @param data 
  * @throws IOException 
  */  
 private void decryptData(byte[] data) throws IOException {  
  System.out.println(""\n----------------DECRYPTION STARTED------------"");  
  byte[] descryptedData = null;  

  try {  
   PrivateKey privateKey = readPrivateKeyFromFile(PRIVATE_KEY_FILE);  
   Cipher cipher = Cipher.getInstance(""RSA"");  
   cipher.init(Cipher.DECRYPT_MODE, privateKey);  
   descryptedData = cipher.doFinal(data);  
   System.out.println(""Decrypted Data: "" + new String(descryptedData));  

  } catch (Exception e) {  
   e.printStackTrace();  
  }   

  System.out.println(""----------------DECRYPTION COMPLETED------------"");    
 }  

 /** 
  * read Public Key From File 
  * @param fileName 
  * @return PublicKey 
  * @throws IOException 
  */  
 public PublicKey readPublicKeyFromFile(String fileName) throws IOException{  
  FileInputStream fis = null;  
  ObjectInputStream ois = null;  
  try {  
   fis = new FileInputStream(new File(fileName));  
   ois = new ObjectInputStream(fis);  

   BigInteger modulus = (BigInteger) ois.readObject();  
      BigInteger exponent = (BigInteger) ois.readObject();  

      //Get Public Key  
      RSAPublicKeySpec rsaPublicKeySpec = new RSAPublicKeySpec(modulus, exponent);  
      KeyFactory fact = KeyFactory.getInstance(""RSA"");  
      PublicKey publicKey = fact.generatePublic(rsaPublicKeySpec);  

      return publicKey;  

  } catch (Exception e) {  
   e.printStackTrace();  
  }  
  finally{  
   if(ois != null){
    ois.close();  
    if(fis != null){
     fis.close();
    }
   }  
  }  
  return null;  
 }  

 /** 
  * read Public Key From File 
  * @param fileName 
  * @return 
  * @throws IOException 
  */  
 public PrivateKey readPrivateKeyFromFile(String fileName) throws IOException{  
  FileInputStream fis = null;  
  ObjectInputStream ois = null;  
  try {  
   fis = new FileInputStream(new File(fileName));  
   ois = new ObjectInputStream(fis);  

   BigInteger modulus = (BigInteger) ois.readObject();  
      BigInteger exponent = (BigInteger) ois.readObject();  

      //Get Private Key  
      RSAPrivateKeySpec rsaPrivateKeySpec = new RSAPrivateKeySpec(modulus, exponent);  
      KeyFactory fact = KeyFactory.getInstance(""RSA"");  
      PrivateKey privateKey = fact.generatePrivate(rsaPrivateKeySpec);  

      return privateKey;  

  } catch (Exception e) {  
   e.printStackTrace();  
  }  
  finally{  
   if(ois != null){  
    ois.close();  
    if(fis != null){  
     fis.close();  
    }  
   }  
  }  
  return null;  
 }  
}  
",3,0,a0e6bddd1aa7ac0154bffc22098ccf7d6b7ebe305916889aa522d5f2ef3cada1
,"import java.io.BufferedInputStream;
import java.io.BufferedOutputStream;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.HttpURLConnection;
import java.net.URL;
import java.net.UnknownHostException;

import javax.net.ssl.HttpsURLConnection;
import javax.net.ssl.SSLSocketFactory;

import org.osmdroid.tileprovider.MapTile;
import org.osmdroid.tileprovider.MapTileRequestState;
import org.osmdroid.tileprovider.modules.IFilesystemCache;
import org.osmdroid.tileprovider.modules.INetworkAvailablityCheck;
import org.osmdroid.tileprovider.modules.MapTileDownloader;
import org.osmdroid.tileprovider.modules.MapTileModuleProviderBase;
import org.osmdroid.tileprovider.tilesource.BitmapTileSourceBase.LowMemoryException;
import org.osmdroid.tileprovider.tilesource.ITileSource;
import org.osmdroid.tileprovider.tilesource.OnlineTileSourceBase;
import org.osmdroid.tileprovider.util.StreamUtils;

import android.graphics.drawable.Drawable;
import android.text.TextUtils;
import android.util.Log;

/**
 * A drop-in replacement for {@link MapTileDownloader}. This loads tiles from an
 * HTTP or HTTPS server, making use of a custom {@link SSLSocketFactory} for SSL
 * peer verification.
 */
public class MyTileDownloader extends MapTileModuleProviderBase {
    private static final String TAG = ""MyMapTileDownloader"";

    protected OnlineTileSourceBase mTileSource;
    protected final IFilesystemCache mFilesystemCache;
    protected final INetworkAvailablityCheck mNetworkAvailablityCheck;
    protected final SSLSocketFactory mSSLSocketFactory;

    public MyTileDownloader(ITileSource pTileSource,
            IFilesystemCache pFilesystemCache,
            INetworkAvailablityCheck pNetworkAvailablityCheck,
            SSLSocketFactory pSSLSocketFactory) {
        super(4, TILE_DOWNLOAD_MAXIMUM_QUEUE_SIZE);
        setTileSource(pTileSource);
        mFilesystemCache = pFilesystemCache;
        mNetworkAvailablityCheck = pNetworkAvailablityCheck;
        mSSLSocketFactory = pSSLSocketFactory;
    }

    public ITileSource getTileSource() {
        return mTileSource;
    }

    @Override
    public void setTileSource(final ITileSource tileSource) {
        // We are only interested in OnlineTileSourceBase tile sources
        if (tileSource instanceof OnlineTileSourceBase)
            mTileSource = (OnlineTileSourceBase) tileSource;
        else
            mTileSource = null;
    }

    @Override
    public boolean getUsesDataConnection() {
        return true;
    }

    @Override
    protected String getName() {
        return ""Online Tile Download Provider"";
    }

    @Override
    protected String getThreadGroupName() {
        return ""downloader"";
    }

    @Override
    public int getMinimumZoomLevel() {
        return (mTileSource != null ? mTileSource.getMinimumZoomLevel()
                : MINIMUM_ZOOMLEVEL);
    }

    @Override
    public int getMaximumZoomLevel() {
        return (mTileSource != null ? mTileSource.getMaximumZoomLevel()
                : MAXIMUM_ZOOMLEVEL);
    }

    @Override
    protected Runnable getTileLoader() {
        return new TileLoader();
    };

    private class TileLoader extends MapTileModuleProviderBase.TileLoader {
        @Override
        public Drawable loadTile(final MapTileRequestState aState)
                throws CantContinueException {
            if (mTileSource == null)
                return null;

            InputStream in = null;
            OutputStream out = null;
            final MapTile tile = aState.getMapTile();

            try {
                if (mNetworkAvailablityCheck != null
                        &amp;&amp; !mNetworkAvailablityCheck.getNetworkAvailable()) {
                    if (DEBUGMODE)
                        Log.d(TAG, ""Skipping "" + getName()
                                + "" due to NetworkAvailabliltyCheck."");
                    return null;
                }

                final String tileURLString = mTileSource.getTileURLString(tile);
                if (DEBUGMODE)
                    Log.d(TAG, ""Downloading Maptile from url: "" + tileURLString);

                if (TextUtils.isEmpty(tileURLString))
                    return null;

                // Create an HttpURLConnection to download the tile
                URL url = new URL(tileURLString);
                HttpURLConnection connection = (HttpURLConnection) url
                        .openConnection();
                connection.setConnectTimeout(30000);
                connection.setReadTimeout(30000);

                // Use our custom SSLSocketFactory for secure connections
                if (""https"".equalsIgnoreCase(url.getProtocol()))
                    ((HttpsURLConnection) connection)
                            .setSSLSocketFactory(mSSLSocketFactory);

                // Open the input stream
                in = new BufferedInputStream(connection.getInputStream(),
                        StreamUtils.IO_BUFFER_SIZE);

                // Check to see if we got success
                if (connection.getResponseCode() != 200) {
                    Log.w(TAG, ""Problem downloading MapTile: "" + tile
                            + "" HTTP response: "" + connection.getHeaderField(0));
                    return null;
                }

                // Read the tile into an in-memory byte array
                final ByteArrayOutputStream dataStream = new ByteArrayOutputStream();
                out = new BufferedOutputStream(dataStream,
                        StreamUtils.IO_BUFFER_SIZE);
                StreamUtils.copy(in, out);
                out.flush();
                final byte[] data = dataStream.toByteArray();
                final ByteArrayInputStream byteStream = new ByteArrayInputStream(
                        data);

                // Save the data to the filesystem cache
                if (mFilesystemCache != null) {
                    mFilesystemCache.saveFile(mTileSource, tile, byteStream);
                    byteStream.reset();
                }
                final Drawable result = mTileSource.getDrawable(byteStream);
                return result;

            } catch (final UnknownHostException e) {
                Log.w(TAG, ""UnknownHostException downloading MapTile: "" + tile
                        + "" : "" + e);
                throw new CantContinueException(e);

            } catch (final LowMemoryException e) {
                Log.w(TAG, ""LowMemoryException downloading MapTile: "" + tile
                        + "" : "" + e);
                throw new CantContinueException(e);

            } catch (final FileNotFoundException e) {
                Log.w(TAG, ""Tile not found: "" + tile + "" : "" + e);

            } catch (final IOException e) {
                Log.w(TAG, ""IOException downloading MapTile: "" + tile + "" : ""
                        + e);

            } catch (final Throwable e) {
                Log.e(TAG, ""Error downloading MapTile: "" + tile, e);

            } finally {
                StreamUtils.closeStream(in);
                StreamUtils.closeStream(out);
            }
            return null;
        }

        @Override
        protected void tileLoaded(final MapTileRequestState pState,
                final Drawable pDrawable) {
            // Don't return the tile Drawable because we'll wait for the fs
            // provider to ask for it. This prevent flickering when a load
            // of delayed downloads complete for tiles that we might not
            // even be interested in any more.
            super.tileLoaded(pState, null);
        }
    }
}
",,1,72f95ac08ea60b699f644064ca29b24446304e00204932d3d07337be3442abb6
,"    private TrustManager[] getWrappedTrustManagers(TrustManager[] trustManagers) {
        final X509TrustManager originalTrustManager = (X509TrustManager) trustManagers[0];
        return new TrustManager[]{
                new X509TrustManager() {
                    public X509Certificate[] getAcceptedIssuers() {
                        return originalTrustManager.getAcceptedIssuers();
                    }

                    public void checkClientTrusted(X509Certificate[] certs, String authType) {
                        try {
                            originalTrustManager.checkClientTrusted(certs, authType);
                        } catch (CertificateException ignored) {
                        }
                    }

                    public void checkServerTrusted(X509Certificate[] certs, String authType) {
                        try {
                            originalTrustManager.checkServerTrusted(certs, authType);
                        } catch (CertificateException ignored) {
                        }
                    }
                }
        };
    }

    private SSLSocketFactory getSSLSocketFactory() {
        try {
            CertificateFactory cf = CertificateFactory.getInstance(""X.509"");
            InputStream caInput = getResources().openRawResource(R.raw.your_cert);
            Certificate ca = cf.generateCertificate(caInput);
            caInput.close();

            KeyStore keyStore = KeyStore.getInstance(""BKS"");
            keyStore.load(null, null);
            keyStore.setCertificateEntry(""ca"", ca);

            String tmfAlgorithm = TrustManagerFactory.getDefaultAlgorithm();
            TrustManagerFactory tmf = TrustManagerFactory.getInstance(tmfAlgorithm);
            tmf.init(keyStore);

            SSLContext sslContext = SSLContext.getInstance(""TLS"");
            sslContext.init(null, getWrappedTrustManagers(tmf.getTrustManagers()), null);                

            return sslContext.getSocketFactory();
        } catch (Exception e) {
            return HttpsURLConnection.getDefaultSSLSocketFactory();
        }
    }

    private class GETRequest extends AsyncTask&lt;Void, Void, String&gt; {
        @Override
        protected String doInBackground(Void... params) {
            try {
                URL url = new URL(""https://your_server_url"");
                String token = ""rbkY34HnL..."";
                HttpsURLConnection urlConnection = (HttpsURLConnection) url.openConnection();
                urlConnection.setSSLSocketFactory(getSSLSocketFactory());
                urlConnection.setHostnameVerifier(new HostnameVerifier() {
                    @Override
                    public boolean verify(String hostname, SSLSession session) {
//                        return true;
                        HostnameVerifier hv = HttpsURLConnection.getDefaultHostnameVerifier();
                        return hv.verify(""your_domain.com"", session);
                    }
                });    
                urlConnection.setRequestProperty(""Authorization"", ""Bearer "" + token);
                urlConnection.connect();
                InputStream inputStream;
                if (urlConnection.getResponseCode() != HttpURLConnection.HTTP_OK) {
                    inputStream = urlConnection.getErrorStream();
                } else {
                    inputStream = urlConnection.getInputStream();
                }
                return String.valueOf(urlConnection.getResponseCode()) + "" "" + urlConnection.getResponseMessage() + ""\r\n"" + parseStream(inputStream);
            } catch (Exception e) {
                return e.toString();
            }
        }

        @Override
        protected void onPostExecute(String response) {
            super.onPostExecute(response);
            // do something...
        }
    }
",4,0,89cde5f6406320c4adbf3b32de7d9d20fab8aa85261f6d8a16aa4207448939da
,"public void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    Security.addProvider(new org.bouncycastle.jce.provider.BouncyCastleProvider());
    Cipher cipher = null;
    TextView tv = new TextView(this);
    setContentView(tv);

    for (String name : SYMMETRIC_CIPHERS) {
    try {
        cipher = Cipher.getInstance(name, ""BC"");
        tv.append(name);
        tv.append(""\n"");
    } catch (Exception e) {
    }
    }
}
",,1,cc8a9fcf6e3a2f7fa545dc5b6d64c80efbe9fab8456348dba116d75cd371ad28
,"CertificateFactory cf = CertificateFactory.getInstance(""X.509"");
// From https://www.washington.edu/itconnect/security/ca/load-der.crt

InputStream caInput = new BufferedInputStream(new FileInputStream(""load-   der.crt""));
Certificate ca;
try {
ca = cf.generateCertificate(caInput);
System.out.println(""ca="" + ((X509Certificate) ca).getSubjectDN());
} finally {
caInput.close();
}
",,1,1c92a97e1264b7c1b3fa68123653ee6be12090671e8dcce0ef740b86a46d55e7
,"String keyStoreType = KeyStore.getDefaultType();
KeyStore keyStore = KeyStore.getInstance(keyStoreType);
keyStore.load(null, null);
keyStore.setCertificateEntry(""ca"", ca);
",,1,2a86c5abd21388479ada62a1800a6748d5ce9d206d12e3fd231c79a9a455751f
,"String tmfAlgorithm = TrustManagerFactory.getDefaultAlgorithm();
TrustManagerFactory tmf = TrustManagerFactory.getInstance(tmfAlgorithm);
tmf.init(keyStore);
",,1,ac5c3c8fa8348ad169e57dc0e31532dd7c46d345ac8fd53b2239192cc6d1eafe
,"SSLContext context = SSLContext.getInstance(""TLS"");
context.init(null, tmf.getTrustManagers(), null);
",,1,d994adb34a2c54600ceb60bd3ab213f8617e4d300740b3bca88df60e7cfd7665
,"    for (Signature signature : info.signatures) {
            MessageDigest md = MessageDigest.getInstance(""SHA"");
            md.update(signature.toByteArray());
            Log.d(""KeyHash:"", Base64.encodeToString(md.digest(), Base64.DEFAULT));
    }
",3,0,51eec898168340aa21c7a7001522d12e5c923242545a0a55c4182131e3d40ce5
,"public class Cryptooo {

SecretKeySpec key = null;
byte[] ciphertext;

 public void generateKey()  {

 String passphrase = ""3xtr3meDiFficUltp@ss"";

 MessageDigest digest = null;
 try {
     digest = MessageDigest.getInstance(""SHA"");
 } catch (NoSuchAlgorithmException e) {
     e.printStackTrace();
 }

 digest.update(passphrase.getBytes());
 key = new SecretKeySpec(digest.digest(), 0, 16, ""AES"");

 byte[] keyBytes = key.getEncoded();



 }


public byte[] encrypt(String string)    {
    Cipher aes = null;
    try {
        aes = Cipher.getInstance(""AES/ECB/PKCS5Padding"");

    aes.init(Cipher.ENCRYPT_MODE, key);
    ciphertext = aes.doFinal(string.getBytes());


    } catch (NoSuchAlgorithmException e) {
        e.printStackTrace();
    } catch (NoSuchPaddingException e) {
        e.printStackTrace();
    } catch (IllegalBlockSizeException e) {
        e.printStackTrace();
    } catch (BadPaddingException e) {
        e.printStackTrace();
    } catch (InvalidKeyException e) {
        e.printStackTrace();
    }

    return ciphertext;
}

public String decrypt(byte[] ciphertext)    {

    Cipher aes = null;
    String cleartext =null;


    try {
        aes = Cipher.getInstance(""AES/ECB/PKCS5Padding"");
        aes.init(Cipher.DECRYPT_MODE, key);
        cleartext = new String(aes.doFinal(ciphertext));

    } catch (NoSuchAlgorithmException e) {
        e.printStackTrace();
    } catch (NoSuchPaddingException e) {
        e.printStackTrace();
    } catch (IllegalBlockSizeException e) {
        e.printStackTrace();
    } catch (BadPaddingException e) {
        e.printStackTrace();
    } catch (InvalidKeyException e) {
        e.printStackTrace();
    }

    return cleartext;
}

}
",4,0,4010519261d5f41bf63f34c1e993da56b254310c1f826db33711d040ae4a4374
,"File cert = new File(""mnt/sdcard/"" + filename + "".p12"");
InputStream inputStreamFromDownload = null;

keyStore = KeyStore.getInstance(""PKCS12"");
inputStreamFromDownload = new BufferedInputStream(new FileInputStream(cert));

Log.i(""Certificate"", inputStreamFromDownload.available() + """");
",,1,93c1b521d174cb90d704d30be1552a1cb852b7ff630407c41b5cb907141f1a55
,"        KeyStore trustStore;
        try {
            trustStore = KeyStore.getInstance(KeyStore.getDefaultType());
            trustStore.load(null, null);
            SSLSocketFactory sf = new EasySSLSocketFactory(trustStore);
            sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
            BasicHttpParams params = new BasicHttpParams();
            HttpProtocolParams.setContentCharset(params, HTTP.UTF_8);
            SchemeRegistry registry = new SchemeRegistry();
            registry.register(new Scheme(""http"", PlainSocketFactory.getSocketFactory(), 80));
            registry.register(new Scheme(""https"", sf, 443));
            ClientConnectionManager ccm = new ThreadSafeClientConnManager(params, registry);
            DefaultHttpClient httpClient = new DefaultHttpClient(ccm, params);
            HttpsURLConnection.setDefaultHostnameVerifier(sf.getHostnameVerifier());
            HttpGet getRequest = new HttpGet(url);
            BasicHttpParams httpParameters = new BasicHttpParams();
            int timeoutConnection = 10000;
            HttpConnectionParams.setConnectionTimeout(httpParameters, timeoutConnection);
            int timeoutSocket = 15000;
            HttpConnectionParams.setSoTimeout(httpParameters, timeoutSocket);
            httpClient.setParams(httpParameters);
            HttpResponse getResponse = httpClient.execute(getRequest);
            final int statusCode = getResponse.getStatusLine().getStatusCode();
            if (statusCode != HttpStatus.SC_OK) 
            { 
                return null;
            }
            HttpEntity getResponseEntity = getResponse.getEntity();
            String content = EntityUtils.toString(getResponseEntity);
            InputStream is = new ByteArrayInputStream(content.getBytes(""UTF-8""));
            return is;
        } catch (KeyStoreException e1) {
            e1.printStackTrace();
        } catch (ParseException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        } catch (NoSuchAlgorithmException e) {
            e.printStackTrace();
        } catch (CertificateException e) {
            e.printStackTrace();
        } catch (KeyManagementException e) {
            e.printStackTrace();
        } catch (UnrecoverableKeyException e) {
            e.printStackTrace();
        }
    return null;
",4,0,e24a68b8a8ab77a3a980fe4f61b6d1390cffd58f61a3ff492cfd8a93b2c9843e
,"cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
cipher.init(Cipher.DECRYPT_MODE, key, new IvParameterSpec(iv)); 
ciphertext = cipher.doFinal(imageByte);
",2,0,5de11891e9412fdf426fa3fa0489a01cf591900949c07c3d07441fa2dc1114da
,"   KeyStore ks = KeyStore.getInstance();
 // get the names of all keys created by our app
 String[] keyNames = ks.saw("""");

 // store a symmetric key in the keystore
 SecretKey key = Crypto.generateKey();
 boolean success = ks.put(""secretKey1"", key.getEncoded());
 // check if operation succeeded and get error code if not
 if (!success) {
    int errorCode = ks.getLastError();
    throw new RuntimeException(""Keystore error: "" + errorCode); 
 }

 // get a key from the keystore
 byte[] keyBytes = ks.get(""secretKey1"");
 SecretKey key = new SecretKeySpec(keyBytes, ""AES"");

 // delete a key
 boolean success = ks.delete(""secretKey1"");
",,1,9b487fdccab8b9993313ec446eb5d0bf0bcb0d56f7e4f3a0907366697ef4d260
,"KeyStore keyStore_manager = KeyStore.getInstance(KeyStore.getDefaultType());
keyStore_manager.load(_context.getAssets().open(your_keystore),password.toCharArray());
KeyStore keyStore_trust = KeyStore.getInstance(KeyStore.getDefaultType());
keyStore_trust.load(_context.getAssets().open(your_trustore),password.toCharArray());
KeyManagerFactory keyManagerFactory = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());
keyManagerFactory.init(keyStore_manager, password.toCharArray());
TrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());
tmf.init(keyStore_trust);
HttpsURLConnection.setDefaultHostnameVerifier(new NullHostNameVerifier());
SSLContext sslContext = SSLContext.getInstance(""TLS"");
sslContext.init(keyManagerFactory.getKeyManagers(),tmf.getTrustManagers(), null);
HttpsURLConnection.setDefaultSSLSocketFactory(sslContext.getSocketFactory());
URL url = new URL(your_url);
HttpsURLConnection urlConnection = (HttpsURLConnection) requestedUrl.openConnection();
if (urlConnection instanceof HttpsURLConnection)
{
    ((HttpsURLConnection) urlConnection).setSSLSocketFactory(sslContext
            .getSocketFactory());
}
urlConnection.setRequestMethod(""GET"");
urlConnection.setConnectTimeout(1500);
urlConnection.connect();
String data = """";
int http_status = urlConnection.getResponseCode();
if (http_status == 200)
{
//read data sent from server
    InputStream response = new BufferedInputStream(

    urlConnection.getInputStream());

    int bytesRead = -1;
    byte[] buffer = new byte[30 * 1024];
    while ((bytesRead = response.read(buffer)) &gt; 0)
    {
        data = new String(buffer, 0, bytesRead);
    }

}
urlConnection.disconnect();
",4,0,efbd16cac98183406ba97544d9f6488aee40eec14bd6658a1ba5daee7090be14
,"    try {

        PackageInfo info = getPackageManager().getPackageInfo(
                    ""Your PAckage here"", 
                        PackageManager.GET_SIGNATURES);
                for (Signature signature : info.signatures) {
                    MessageDigest md = MessageDigest.getInstance(""SHA"");
                    md.update(signature.toByteArray());
                    Log.d(""KeyHash:"", Base64.encodeToString(md.digest(), Base64.DEFAULT));
    //              //              System.out.println(""KEY HASH..........""+Base64.encodeToString(md.digest(), Base64.DEFAULT));
                }
            } catch (NameNotFoundException e) {
                System.out.println(""name not found....""+e);
            } catch (NoSuchAlgorithmException e) {
                System.out.println(""NoSuchAlgorithmException....""+e);
            }
",3,0,f2497a3b7ec09cf0877582281d609a2baf8ae6c5004102c75ac590204b4d1502
,"private final static String algorithm = ""PBKDF2WithHmacSHA1"";

private final static String HEX = ""0123456789ABCDEF"";

private static final String CP_ALGORITH = ""AES"";
private static final String CP_KEY = ""PUTsomeKEYinHere"";

public static String cipher(String cipherKey, String data) throws NoSuchAlgorithmException, 
                    InvalidKeySpecException, NoSuchPaddingException, InvalidKeyException, 
                    IllegalBlockSizeException, BadPaddingException {
    SecretKeyFactory skf = SecretKeyFactory.getInstance(algorithm);
    KeySpec spec = new PBEKeySpec(cipherKey.toCharArray(), cipherKey.getBytes(), 128, 256);
    SecretKey tmp = skf.generateSecret(spec);
    SecretKey key = new SecretKeySpec(tmp.getEncoded(), CP_ALGORITH);
    Cipher cipher = Cipher.getInstance(CP_ALGORITH);
    cipher.init(Cipher.ENCRYPT_MODE, key);
    return toHex(cipher.doFinal(data.getBytes()));
}

public static String decipher(String cipherKey, String data) throws NoSuchAlgorithmException, 
                        InvalidKeySpecException, NoSuchPaddingException, InvalidKeyException, 
                        IllegalBlockSizeException, BadPaddingException {
    SecretKeyFactory skf = SecretKeyFactory.getInstance(algorithm);
    KeySpec spec = new PBEKeySpec(cipherKey.toCharArray(), cipherKey.getBytes(), 128, 256);
    SecretKey tmp = skf.generateSecret(spec);
    SecretKey key = new SecretKeySpec(tmp.getEncoded(), CP_ALGORITH);
    Cipher cipher = Cipher.getInstance(CP_ALGORITH);
    cipher.init(Cipher.DECRYPT_MODE, key);
    return new String(cipher.doFinal(toByte(data)));
}

private static byte[] toByte(String data) throws NullPointerException{
    int len = data.length()/2;
    byte[] result = new byte[len];
    for (int i = 0; i &lt; len; i++)
        result[i] = Integer.valueOf(data.substring(2*i, 2*i+2), 16).byteValue();
    return result;
}

private static String toHex(byte[] doFinal) {
    StringBuffer result = new StringBuffer(2*doFinal.length);
    for (int i = 0; i &lt; doFinal.length; i++) {
        result.append(HEX.charAt((doFinal[i]&gt;&gt;4)&amp;0x0f)).append(HEX.charAt(doFinal[i]&amp;0x0f));
    }
    return result.toString();
}
",3,0,38948d43f6f553853cec8b4b7679cd93d9ef5887c8a1db9f000a5c2eea69c914
,"import android.content.pm.Signature;

      try {
        PackageInfo info = getPackageManager().getPackageInfo(
                **""do not forgot to your package name""**, PackageManager.GET_SIGNATURES);
        for (Signature signature : info.signatures) {
            MessageDigest md = MessageDigest.getInstance(""SHA"");
            md.update(signature.toByteArray());
            Log.d(""KeyHash:"",
                    Base64.encodeToString(md.digest(), Base64.DEFAULT));
        }
    } catch (NameNotFoundException e) {

    } catch (NoSuchAlgorithmException e) {

    }



OR 

1. for Android default keystore  : add this to in your terminal 

keytool -exportcert -alias androiddebugkey -keystore ~/.android/debug.keystore | openssl sha1 -binary | openssl base64

2. for signed keystore 

keytool -exportcert -alias aliasname -keystore keystorename | openssl sha1 -binary | openssl base64
",3,0,80cc559a1f551fc58d72d262b2974147e7dd1b064802fd0f840bd5b5867d1aa3
,"HttpsURLConnection.setDefaultHostnameVerifier(new NullHostNameVerifier());
SSLContext context = SSLContext.getInstance(""TLS"");
context.init(null, new X509TrustManager[]{new NullX509TrustManager()}, new SecureRandom());
HttpsURLConnection.setDefaultSSLSocketFactory(context.getSocketFactory());
",4,0,6666cd756d8f9a1adb58ae7833574da89c35c2304097a483d85e0349ec23a6ca
,"public static void main(String[] args) throws Exception
{
    // Initialise secret key with predefined byte array [] like below. I
    // have used simple string to array method to generate 16 byte array.
    // AES Key must be minimum 16 bytes.
    // Now you can put this byte array some where is .SO file.
    // Generate new Key using this byte []
    // Then you can generate a key using device specific information at
    // first boot up.
    // Use second key to encrypt data and first key to encrypt the second
    // key
    // I Hope it clears all the doubts
    SecretKey key = new SecretKeySpec(""ABCDEFGHIJKLMNOP"".getBytes(), ""AES"");
    System.out.println(Arrays.toString(key.getEncoded()));
    // Initialise Cipher with AES Algorithm
    Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
    // Set The Encrypt Mode
    cipher.init(Cipher.ENCRYPT_MODE, key);
    // Encrypt some bytes
    byte[] encrypted = cipher.doFinal(""ABCDEFGH"".getBytes());
    // Print it to vefiry
    System.out.println(Arrays.toString(encrypted));

    // Get The IV
    byte[] iv = cipher.getIV();
    System.out.println(iv.length);
    // Now why storing you can create structure like [16 IV][Encrypted Data]
    // And while decrypting you can read first [16] bytes IV and then
    // decrypt remaining bytes

    //byte[] iv = new byte[16];
    // System.arraycopy(encrypted, 0, iv, 0, 16)
    //Copy remaining bytes to decrypt


    // set cipher to decrypt mode

    cipher.init(Cipher.DECRYPT_MODE, key,new IvParameterSpec(iv));

    // decrypt it
    byte[] decrypted = cipher.doFinal(encrypted);
    System.out.println(new String(decrypted));

}
",2,0,aa5dbbd3091ca5a793763bd0e337c6d87c769c92e925dad037a3eec01ac4fa32
,"public byte[] passwordToHash(String password) {
    if (password == null) {
        return null;
    }
    String algo = null;
    byte[] hashed = null;
    try {
        byte[] saltedPassword = (password + getSalt()).getBytes();
        byte[] sha1 = MessageDigest.getInstance(algo = ""SHA-1"").digest(saltedPassword);
        byte[] md5 = MessageDigest.getInstance(algo = ""MD5"").digest(saltedPassword);
        hashed = (toHex(sha1) + toHex(md5)).getBytes();
    } catch (NoSuchAlgorithmException e) {
        Log.w(TAG, ""Failed to encode string because of missing algorithm: "" + algo);
    }
    return hashed;
}
",3,0,3c245f1aaf640dc035d95a903b0e573134c376862dc40f3c8bc062978f273587
,"import java.io.IOException;
import java.util.HashMap;
import java.util.Map;

import org.jivesoftware.smack.SASLAuthentication;
import org.jivesoftware.smack.XMPPException;
import org.jivesoftware.smack.packet.Packet;
import org.jivesoftware.smack.sasl.SASLMechanism;
import org.jivesoftware.smack.util.Base64;

import de.measite.smack.Sasl;

public class SASLXOAuth2Mechanism extends SASLMechanism
{
    static final String AUTHENTICATOR_URL = ""http://www.google.com/talk/protocol/auth"";
    protected String authenticationText = null;
    static final String TAG = ""SASLXOAuth2Mechanism"";

    public SASLXOAuth2Mechanism(SASLAuthentication saslAuthentication) {
        super(saslAuthentication);
    }

    @Override
    protected String getName()
    {
        return ""X-OAUTH2"";
    }

    @Override
    public void authenticate(String username, String host, String password) throws IOException, XMPPException {
        this.password = password;
        this.authenticationId = username;

        StringBuilder credentials = new StringBuilder();
        credentials.append(""\0"");
        credentials.append(username);
        credentials.append(""\0"");
        credentials.append(password);
        authenticationText = Base64.encodeBytes(credentials.toString().getBytes(""UTF-8""), Base64.DONT_BREAK_LINES);

        String[] mechanisms = { ""PLAIN"" };
        Map&lt;String,String&gt; props = new HashMap&lt;String,String&gt;();
        sc = Sasl.createSaslClient(mechanisms, username, ""xmpp"", host, props, this);
        authenticate();
    }

    protected void authenticate() throws IOException, XMPPException {
        // Send the authentication to the server
        getSASLAuthentication().send(new XOAuth2AuthMechanism(getName(), authenticationText));
    }

    /**
     * Initiating SASL authentication by select a mechanism.
     */
    public class XOAuth2AuthMechanism extends Packet {
        final private String name;
        final private String authenticationText;

        public XOAuth2AuthMechanism(String name, String authenticationText) {
            super();
            this.name = name;
            this.authenticationText = authenticationText;
        }

        public String toXML() {
            StringBuilder stanza = new StringBuilder();
            stanza.append(""&lt;auth mechanism=\"""").append(name);
            stanza.append(""\"" xmlns=\""urn:ietf:params:xml:ns:xmpp-sasl\"" auth:service=\""oauth2\"" xmlns:auth=\"""").append(AUTHENTICATOR_URL);
            stanza.append(""\""&gt;"");
            if (authenticationText != null) {
                stanza.append(authenticationText);
            }
            stanza.append(""&lt;/auth&gt;"");
            return stanza.toString();
        }
    }
}
",1,0,e53b055ce4b2fcee2af7ae28a5ae6c2de3501cabfbf8c6ebcd9ba533486c0daf
,"// This can be any protocol supported by your target devices.
// For example ""TLSv1.2"" is supported by the latest versions of Android
final String SSL_PROTOCOL = ""TLS"";

try {               
   sslContext = SSLContext.getInstance(SSL_PROTOCOL);

   // Initialize the context with your key manager and the default trust manager 
   // and randomness source
   sslContext.init(keyManagerFactory.getKeyManagers(), null, null);
} catch (NoSuchAlgorithmException e) {
   Log.e(TAG, ""Specified SSL protocol not supported! Protocol="" + SSL_PROTOCOL);
   e.printStackTrace();
} catch (KeyManagementException e) {
   Log.e(TAG, ""Error setting up the SSL context!"");
   e.printStackTrace();
}

// Get the socket factory
socketFactory = sslContext.getSocketFactory();
",3,0,0c8b8f82db9bd01b55b10a9ec7424e9411600a16d93d624fb72edce82f822a8c
,"    KeyGenerator keyGen = KeyGenerator.getInstance(""AES"");
    keyGen.init(128); // or 256

    // Generate the secret key specs
    SecretKey secretKey = keyGen.generateKey();
    byte[] byteArray = secretKey.getEncoded();
",2,0,dfbce99bd92f9c1dfe3a6229d01136d4373b3e91da43882bd9d3886677c45311
,"PackageInfo packageInfo = null;

try {
   packageInfo = getPackageManager().getPackageInfo(getPackageName(), 
                                           PackageManager.GET_SIGNATURES);

   Signature[] signatures = packageInfo.signatures;
   byte[] cert = signatures[0].toByteArray();
   InputStream input = new ByteArrayInputStream(cert);

   CertificateFactory cf = CertificateFactory.getInstance(""X509"");
   X509Certificate c = (X509Certificate)cf.generateCertificate(input);

   PublicKey key = c.getPublicKey();

   ...   

} catch ( Exception e) {
        e.printStackTrace();
}
",,1,251821546e9381bd31abab40d9feb8858ce247a7bb2844a4714a69e2c351392a
,"import java.io.BufferedInputStream;
import java.io.IOException;
import java.io.InputStream;

// Some of these exist in more than one package, be careful to include these
import java.security.GeneralSecurityException;
import java.security.KeyStore;
import java.security.cert.Certificate;
import java.security.cert.CertificateFactory;

// This would reference to your KeyStore to store the certificate
KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());
ks.load(null);             // This will make a new store
// In the next line, specify the file path
// You can also export the destination certificate (in your case, Paypal's)
// put it as a hardcoded `String` and work with it.
InputStream is = ...;
BufferedInputStream bis = new BufferedInputStream(is);

CertificateFactory cf = CertificateFactory.getInstance(""X.509"");

while (bis.available() &gt; 0) {
  Certificate cert = cf.generateCertificate(bis);
  trustStore.setCertificateEntry(""myAlias"" + bis.available(), cert);
}
",,1,3e7d3982e94fb6ec72b4a15765c212f45d1a87c48b07c53c1f848309116b0332
,"@SuppressLint(""NewApi"")
public static void getApplicationSignature(Activity activity){
    try {
        PackageInfo info = activity.getPackageManager().getPackageInfo(""your.package.name.here"", PackageManager.GET_SIGNATURES);
        for (Signature signature : info.signatures) {
            MessageDigest md = MessageDigest.getInstance(""SHA"");
            md.update(signature.toByteArray());
            Log.e(""MY KEY HASH:"", Base64.encodeToString(md.digest(), Base64.DEFAULT));
        }
    } catch (NameNotFoundException e) {

    } catch (NoSuchAlgorithmException e) {

    }
}
",3,0,c47721e331279a1064450ed870fd7be094cbc5f1de40171e77b8baf76999f93d
,"byte[] iv = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, }; // use different random value
AlgorithmParameterSpec algorithmSpec = new IvParameterSpec(iv);
Cipher ecipher = Cipher.getInstance(""AES/CBC/PKCS7Padding"");
ecipher.init(Cipher.ENCRYPT_MODE, skeySpec, algorithmSpec);
",4,0,63faf5683723f9902f1b31af7f623fccdaea5f65a6b92170baa034c45617dfca
,"import java.security.NoSuchAlgorithmException;

    import javax.crypto.Cipher;
    import javax.crypto.NoSuchPaddingException;
    import javax.crypto.spec.IvParameterSpec;
    import javax.crypto.spec.SecretKeySpec;

    public class MCrypt {

        private String iv = ""fedcba9876543210"";//Dummy iv (CHANGE IT!)
        private IvParameterSpec ivspec;
        private SecretKeySpec keyspec;
        private Cipher cipher;

        private String SecretKey = ""0123456789abcdef"";//Dummy secretKey (CHANGE IT!)

        public MCrypt()
        {
            ivspec = new IvParameterSpec(iv.getBytes());

            keyspec = new SecretKeySpec(SecretKey.getBytes(), ""AES"");

            try {
                cipher = Cipher.getInstance(""AES/CBC/NoPadding"");
            } catch (NoSuchAlgorithmException e) {
                // TODO Auto-generated catch block
                e.printStackTrace();
            } catch (NoSuchPaddingException e) {
                // TODO Auto-generated catch block
                e.printStackTrace();
            }
        }

        public byte[] encrypt(String text) throws Exception
        {
            if(text == null || text.length() == 0)
                throw new Exception(""Empty string"");

            byte[] encrypted = null;

            try {
                cipher.init(Cipher.ENCRYPT_MODE, keyspec, ivspec);

                encrypted = cipher.doFinal(padString(text).getBytes());
            } catch (Exception e)
            {           
                throw new Exception(""[encrypt] "" + e.getMessage());
            }

            return encrypted;
        }

        public byte[] decrypt(String code) throws Exception
        {
            if(code == null || code.length() == 0)
                throw new Exception(""Empty string"");

            byte[] decrypted = null;


            try {
                cipher.init(Cipher.DECRYPT_MODE, keyspec, ivspec);

                decrypted = cipher.doFinal(hexToBytes(code));
                if( decrypted.length &gt; 0)
                {
                    int trim = 0;
                    for( int i = decrypted.length - 1; i &gt;= 0; i-- ) if( decrypted[i] == 0 ) trim++;

                    if( trim &gt; 0 )
                    {
                        byte[] newArray = new byte[decrypted.length - trim];
                        System.arraycopy(decrypted, 0, newArray, 0, decrypted.length - trim);
                        decrypted = newArray;
                    }
                }
            } catch (Exception e)
            {
                throw new Exception(""[decrypt] "" + e.getMessage());
            }
            return decrypted;
        }



        public static String bytesToHex(byte[] data)
        {
            if (data==null)
            {
                return null;
            }

            int len = data.length;
            String str = """";
            for (int i=0; i&lt;len; i++) {
                if ((data[i]&amp;0xFF)&lt;16)
                    str = str + ""0"" + java.lang.Integer.toHexString(data[i]&amp;0xFF);
                else
                    str = str + java.lang.Integer.toHexString(data[i]&amp;0xFF);
            }
            return str;
        }


        public static byte[] hexToBytes(String str) {
            if (str==null) {
                return null;
            } else if (str.length() &lt; 2) {
                return null;
            } else {
                int len = str.length() / 2;
                byte[] buffer = new byte[len];
                for (int i=0; i&lt;len; i++) {
                    buffer[i] = (byte) Integer.parseInt(str.substring(i*2,i*2+2),16);
                }
                return buffer;
            }
        }



        private static String padString(String source)
        {
          char paddingChar = ' ';
          int size = 16;
          int x = source.length() % size;
          int padLength = size - x;

          for (int i = 0; i &lt; padLength; i++)
          {
              source += paddingChar;
          }

          return source;
        }
    }
",4,0,8d4b59e8b4bbb882a37bce9dda7586de3f63afeb289d4656a1431a85b300df46
,"public static void main(String[] args) throws DataLengthException, IllegalStateException, InvalidCipherTextException {

    // just some constants
    boolean ENCRYPT = true;
    boolean DECRYPT = false;

    // the key is either in binary in PHP or a string (dynamic isn't it?), lets assume ASCII
    byte[] givenKey = args[0].getBytes(Charset.forName(""ASCII""));

    // determine the key size dynamically, somebody thought this was a good idea...
    // NOTE: PHP will emit a warning if the key size is larger, but will simply use the
    // largest key size otherwise
    final int keysize;
    if (givenKey.length &lt;= 128 / Byte.SIZE) {
        keysize = 128;
    } else if (givenKey.length &lt;= 192 / Byte.SIZE) {
        keysize = 192;
    } else {
        keysize = 256;
    }

    // create a 256 bit key by adding zero bytes to the decoded key
    byte[] keyData = new byte[keysize / Byte.SIZE];
    System.arraycopy(givenKey, 0, keyData, 0, Math.min(givenKey.length, keyData.length));
    KeyParameter key = new KeyParameter(keyData);

    // create a Rijndael cipher with 256 bit block size, this is not AES
    BlockCipher rijndael = new RijndaelEngine(256);

    // use a padding method that only works on data that cannot end with zero valued bytes
    ZeroBytePadding c = new ZeroBytePadding();

    // use ECB mode encryption, which should never be used
    PaddedBufferedBlockCipher pbbc = new PaddedBufferedBlockCipher(rijndael, c);

    // initialize the cipher using the key (no need for an IV, this is ECB)
    pbbc.init(ENCRYPT, key);

    // create a plain text byte array
    byte[] plaintext = args[1].getBytes(Charset.forName(""UTF8""));

    // create a buffer for the ciphertext
    byte[] ciphertext = new byte[pbbc.getOutputSize(plaintext.length)];

    int offset = 0;
    offset += pbbc.processBytes(plaintext, 0, plaintext.length, ciphertext, offset);
    offset += pbbc.doFinal(ciphertext, offset);

    // show the ciphertext
    System.out.println(new String(Hex.encode(ciphertext), Charset.forName(""ASCII"")));

    // reverse the encryption
    pbbc.init(DECRYPT, key);
    byte[] decrypted = new byte[pbbc.getOutputSize(ciphertext.length)];
    offset = 0;
    offset += pbbc.processBytes(ciphertext, 0, ciphertext.length, decrypted, offset);
    offset += pbbc.doFinal(decrypted, offset);

    // this will probably print out correctly, but it isn't actually correct
    System.out.println(new String(decrypted, Charset.forName(""UTF8"")));

    // check out the zero's at the end
    System.out.println(new String(Hex.encode(decrypted), Charset.forName(""UTF8"")));

    // so lets make it a bit shorter... the PHP way
    // note that in PHP, the string may *not* contain a null terminator
    // add it yourself before printing the string
    System.out.println(new String(decrypted, Charset.forName(""UTF8"")).replaceAll(""\\x00+$"", """"));
}
",4,0,1eb413cc7dd106db06a20095ddbeccfbd3d4b9d75d8b2ab9b2ab81d34c7987bd
,"public class DeviceInfo {

protected static String imeiNumber;
protected static String wifiMacAddress;
protected static String deviceID;

// This method must be called before other method
public static void init(Context context) throws Exception {
    imeiNumber = getImei(context);
    wifiMacAddress = getWifiMacAddress(context);
    deviceID = getDeviceId(context);
}

public static String getDeviceInfo() {
    return deviceID;
}

public static String getImei() {
    return imeiNumber;
}

public static String getWifiMacAddress() {
    return wifiMacAddress;
}

public static String getModel() {
    return Build.MODEL;
}

public static String getOsVersion() {
    return Build.VERSION.RELEASE;
}

protected static String getDeviceId(Context context) throws Exception {
    String imei = getImei(context);
    if (imei != null) return imei;
    String tid = getWifiMacAddress(context);
    return tid;
}

protected static String getWifiMacAddress(Context context) throws Exception {
    WifiManager manager = (WifiManager) context
            .getSystemService(Context.WIFI_SERVICE);
    WifiInfo wifiInfo = manager.getConnectionInfo();
    if (wifiInfo == null || wifiInfo.getMacAddress() == null)
        return md5(UUID.randomUUID().toString());
    else return wifiInfo.getMacAddress().replace("":"", """").replace(""."", """");
}

protected static String getImei(Context context) {
    TelephonyManager m = (TelephonyManager) context
            .getSystemService(Context.TELEPHONY_SERVICE);
    String imei = m != null ? m.getDeviceId() : null;
    return imei;
}

protected static String md5(String s) throws Exception {
    MessageDigest md = MessageDigest.getInstance(""MD5"");

    md.update(s.getBytes());

    byte digest[] = md.digest();
    StringBuffer result = new StringBuffer();

    for (int i = 0; i &lt; digest.length; i++) {
        result.append(Integer.toHexString(0xFF &amp; digest[i]));
    }
    return (result.toString());
}
}
",,1,e7e56d822b4704de4c1ca8867415f5f254f7bd0649515137e21dff9f1bd2c583
,"if(Build.VERSION.SDK_INT&lt;16)
    sslContext = SSLContext.getInstance(""TLS"");
else
    sslContext = SSLContext.getInstance(""TLSv1.2"");
",2,0,297b9d626a4449bda7a385541e12f6bd413b6ed0d000cb7778128bbdf764844c
,"zerorize(SecretKey key)
{
    byte[] rawKey = key.getEncoded();
    Arrays.fill(rawKey, (byte) 0xFF);
    Arrays.fill(rawKey, (byte) 0xAA);
    Arrays.fill(rawKey, (byte) 0x55);
    Arrays.fill(rawKey, (byte) 0x00);
}
",,1,e16e191fe58d2acf21420c3322614c69d4838bf2941753a5760ad873dfad219f
,"// Trust manager / truststore
KeyStore trustStore=KeyStore.getInstance(KeyStore.getDefaultType());

// If we're on an OS version prior to Ice Cream Sandwich (4.0) then use the standard way to get the system
//   trustStore -- System.getProperty() else we need to use the special name to get the trustStore KeyStore
//   instance as they changed their trustStore implementation.
if (Build.VERSION.RELEASE.compareTo(""4.0"") &lt; 0) {
    TrustManagerFactory trustManagerFactory=TrustManagerFactory
        .getInstance(TrustManagerFactory.getDefaultAlgorithm());
    FileInputStream trustStoreStream=new FileInputStream(System.getProperty(""javax.net.ssl.trustStore""));
    trustStore.load(trustStoreStream, null);
    trustManagerFactory.init(trustStore);
    trustStoreStream.close();
} else {
    trustStore=KeyStore.getInstance(""AndroidCAStore"");
}

InputStream certificateStream=new FileInputStream(userCertFile);
KeyStore keyStore=KeyStore.getInstance(""PKCS12"");
try {
    keyStore.load(certificateStream, certPass.toCharArray());
    Enumeration&lt;String&gt; aliases=keyStore.aliases();
    while (aliases.hasMoreElements()) {
        String alias=aliases.nextElement();
        if (keyStore.getCertificate(alias).getType().equals(""X.509"")) {
            X509Certificate cert=(X509Certificate)keyStore.getCertificate(alias);
            if (new Date().after(cert.getNotAfter())) {
                // This certificate has expired
                return;
            }
        }
    }
} catch (IOException ioe) {
    // This occurs when there is an incorrect password for the certificate
    return;
} finally {
    certificateStream.close();
}

KeyManagerFactory keyManagerFactory=KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());
keyManagerFactory.init(keyStore, certPass.toCharArray());

socketFactory=new SSLSocketFactory(keyStore, certPass, trustStore);
",3,0,57c3d776825907b0383cbd62315c372246290af14f2aeffdae5bfbf549bb6ff2
,"    SecretKeyFactory keyFactory = null;
    try
    {
        keyFactory = SecretKeyFactory.getInstance(""PBKDF2WithHmacSHA1"");
    } 
    catch (NoSuchAlgorithmException e)
",,1,e58a3b95adfee4fb2d37b9a983c901dbdd466a41c9c43329e9da9f2e1f59bfa0
,"public ClientConnectionManager createClientConnectionManager() {
    SchemeRegistry registry = new SchemeRegistry();
    registry.register(new Scheme(""http"", PlainSocketFactory.getSocketFactory(), 80));
    // Register for port 443 our SSLSocketFactory with our keystore
    // to the ConnectionManager
    registry.register(new Scheme(""https"", newSslSocketFactory(), 443));
    return new SingleClientConnManager(getParams(), registry);
}

public SSLSocketFactory newSslSocketFactory() {
    try {
        // Get an instance of the Bouncy Castle KeyStore format
        KeyStore trusted = KeyStore.getInstance(""BKS"");
        // Get the raw resource, which contains the keystore with
        // your trusted certificates (root and any intermediate certs)
        InputStream in = context.getResources().openRawResource(R.raw.mykeystore);
        try {
            // Initialize the keystore with the provided trusted certificates
            // Also provide the password of the keystore
            trusted.load(in, ""my_password"".toCharArray());
        } finally {
            in.close();
        }
        // Pass the keystore to the SSLSocketFactory. The factory is responsible
        // for the verification of the server certificate.
        SSLSocketFactory sf = new SSLSocketFactory(trusted);
        // Hostname verification from certificate
        // http://hc.apache.org/httpcomponents-client-ga/tutorial/html/connmgmt.html#d4e506
        sf.setHostnameVerifier(SSLSocketFactory.STRICT_HOSTNAME_VERIFIER);
        return sf;
    } catch (Exception e) {
        throw new AssertionError(e);
    }
}
",3,0,8c6f3f4fc76e7c794f724059d9eb1d8e1e6a220e935902fd1dafb84319ad647f
,"package com.emailsender;

import java.security.AccessController;

import java.security.Provider;



public final class JSSEProvider extends Provider {



public JSSEProvider() {

super(""HarmonyJSSE"", 1.0, ""Harmony JSSE Provider"");

       AccessController

               .doPrivileged(new java.security.PrivilegedAction&lt;Void&gt;() {

                   public Void run() {

                       put(""SSLContext.TLS"",

                               ""org.apache.harmony.xnet.provider.jsse.SSLContextImpl"");

                       put(""Alg.Alias.SSLContext.TLSv1"", ""TLS"");

                       put(""KeyManagerFactory.X509"",

                               ""org.apache.harmony.xnet.provider.jsse.KeyManagerFactoryImpl"");

                       put(""TrustManagerFactory.X509"",

                               ""org.apache.harmony.xnet.provider.jsse.TrustManagerFactoryImpl"");

                       return null;

                   }

               });

   }

}
",3,0,f983f1469bbe80891e72290a806538d97f94a535ab84812f33b63f5030e70c88
,"package com.emailsender;

import javax.activation.DataHandler;

import javax.activation.DataSource;

import javax.activation.FileDataSource;

import javax.mail.BodyPart;

import javax.mail.Message;

import javax.mail.Multipart;

import javax.mail.PasswordAuthentication;

import javax.mail.Session;

import javax.mail.Transport;

import javax.mail.internet.InternetAddress;

import javax.mail.internet.MimeBodyPart;

import javax.mail.internet.MimeMessage;

import javax.mail.internet.MimeMultipart;  

import java.io.ByteArrayInputStream;

import java.io.IOException;

import java.io.InputStream;

import java.io.OutputStream;

import java.security.Security;

import java.util.Properties;


public class GMailSender extends javax.mail.Authenticator {

private String mailhost = ""smtp.gmail.com"";

    private String user;

    private String password;

    private Session session;



    private Multipart _multipart = new MimeMultipart();

    static {

        Security.addProvider(new  shooreshi.fayyaz.ghariebartar.JSSEProvider());

    }



    public GMailSender(String user, String password) {

        this.user = user;

        this.password = password;



        Properties props = new Properties();

        props.setProperty(""mail.transport.protocol"", ""smtp"");

        props.setProperty(""mail.host"", mailhost);

        props.put(""mail.smtp.auth"", ""true"");

        props.put(""mail.smtp.port"", ""465"");

        props.put(""mail.smtp.socketFactory.port"", ""465"");

        props.put(""mail.smtp.socketFactory.class"",

                ""javax.net.ssl.SSLSocketFactory"");

        props.put(""mail.smtp.socketFactory.fallback"", ""false"");

        props.setProperty(""mail.smtp.quitwait"", ""false"");



        session = Session.getDefaultInstance(props, this);

    }



    protected PasswordAuthentication getPasswordAuthentication() {

        return new PasswordAuthentication(user, password);

    }



    public synchronized void sendMail(String subject, String body,

            String sender, String recipients) throws Exception {

        try {

            MimeMessage message = new MimeMessage(session);

            DataHandler handler = new DataHandler(new ByteArrayDataSource(

                    body.getBytes(), ""music""));

            message.setSender(new InternetAddress(sender));

            message.setSubject(subject);

            message.setDataHandler(handler);

            BodyPart messageBodyPart = new MimeBodyPart();

            messageBodyPart.setText(body);

            _multipart.addBodyPart(messageBodyPart);



            // Put parts in message

            message.setContent(_multipart);

            if (recipients.indexOf(',') &gt; 0)

                message.setRecipients(Message.RecipientType.TO,

                        InternetAddress.parse(recipients));

            else

                message.setRecipient(Message.RecipientType.TO,

                        new InternetAddress(recipients));

            Transport.send(message);

        } catch (Exception e) {



        }

    }



    public void addAttachment(String filename) throws Exception {

        BodyPart messageBodyPart = new MimeBodyPart();

        DataSource source = new FileDataSource(filename);

        messageBodyPart.setDataHandler(new DataHandler(source));

        messageBodyPart.setFileName(""music.mp3"");



        _multipart.addBodyPart(messageBodyPart);

    }



    public class ByteArrayDataSource implements DataSource {

        private byte[] data;

        private String type;





        public ByteArrayDataSource(byte[] data, String type) {

            super();

            this.data = data;

            this.type = type;

        }



        public ByteArrayDataSource(byte[] data) {

            super();

            this.data = data;

        }





        public void setType(String type) {

            this.type = type;

        }



        public String getContentType() {

            if (type == null)

                return ""application/octet-stream"";

            else

                return type;

        }



        public InputStream getInputStream() throws IOException {

            return new ByteArrayInputStream(data);

        }



        public String getName() {

            return ""ByteArrayDataSource"";

        }



        public OutputStream getOutputStream() throws IOException {

            throw new IOException(""Not Supported"");

        }

    }

}
",3,0,f4f86014924fde75a3da0eb5ce49e021ff897a0ead31d34cfbdc93a750928c80
,"import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.Arrays;
import java.util.List;

import android.content.Intent;
import android.content.pm.PackageInfo;
import android.content.pm.PackageManager;
import android.content.pm.PackageManager.NameNotFoundException;
import android.content.pm.Signature;
import android.graphics.Bitmap;
import android.graphics.BitmapFactory;
import android.os.Bundle;
import android.support.v7.app.ActionBarActivity;
import android.util.Base64;
import android.util.Log;
import android.view.View;
import android.view.View.OnClickListener;
import android.widget.Button;
import android.widget.TextView;
import android.widget.Toast;


import com.facebook.Request;
import com.facebook.Response;
import com.facebook.Session;
import com.facebook.SessionState;
import com.facebook.UiLifecycleHelper;
import com.facebook.model.GraphUser;
import com.facebook.widget.LoginButton;
import com.facebook.widget.LoginButton.UserInfoChangedCallback;


public class ShareHelper extends ActionBarActivity{

     private LoginButton loginBtn;
     private Button updateStatusBtn;
  
     private TextView fbquote;
     
     private TextView userName;
  
     private UiLifecycleHelper uiHelper;
  
     private static final List&lt;String&gt; PERMISSIONS = Arrays.asList(""publish_actions"");
     
     private String message;
     
     public void onCreate(Bundle savedInstanceState) {
         super.onCreate(savedInstanceState);
         
      // Add code to print out the key hash
         try {
             PackageInfo info = getPackageManager().getPackageInfo(
                     ""com.facebook.samples.hellofacebook"", 
                     PackageManager.GET_SIGNATURES);
             for (Signature signature : info.signatures) {
                 MessageDigest md = MessageDigest.getInstance(""SHA"");
                 md.update(signature.toByteArray());
                 Log.d(""KeyHash:"", Base64.encodeToString(md.digest(), Base64.DEFAULT));
                 }
         } catch (NameNotFoundException e) {

         } catch (NoSuchAlgorithmException e) {

         }

         
         Intent intent = getIntent();
      
      message = intent.getStringExtra(""quote"");     
    
  
         uiHelper = new UiLifecycleHelper(this, statusCallback);
         uiHelper.onCreate(savedInstanceState);
  
         setContentView(R.layout.sharehelper_activity);
     
         fbquote = (TextView)findViewById(R.id.FbTextView);
         fbquote.setText(message);
         
         userName = (TextView) findViewById(R.id.user_name);
         loginBtn = (LoginButton) findViewById(R.id.fb_login_button);
         loginBtn.setUserInfoChangedCallback(new UserInfoChangedCallback() {
             @Override
             public void onUserInfoFetched(GraphUser user) {
                 if (user != null) {
                     userName.setText(""Hello, "" + user.getName());
                 } else {
                     userName.setText(""You are not logged"");
                 }
             }
         });
  
         updateStatusBtn = (Button) findViewById(R.id.update_status);
         updateStatusBtn.setOnClickListener(new OnClickListener() {
  
             @Override
             public void onClick(View v) {
              postStatusMessage();
             }
         });
  
         buttonsEnabled(false);
     }
  
     private Session.StatusCallback statusCallback = new Session.StatusCallback() {
         @Override
         public void call(Session session, SessionState state,
                 Exception exception) {
             if (state.isOpened()) {
                 buttonsEnabled(true);
                 Log.d(""FacebookSampleActivity"", ""Facebook session opened"");
             } else if (state.isClosed()) {
                 buttonsEnabled(false);
                 Log.d(""FacebookSampleActivity"", ""Facebook session closed"");
             }
         }
     };
  
     public void buttonsEnabled(boolean isEnabled) {
         updateStatusBtn.setEnabled(isEnabled);
     }
  
    
     public void postStatusMessage() {
         if (checkPermissions()) {
             Request request = Request.newStatusUpdateRequest(
                     Session.getActiveSession(), message,
                     new Request.Callback() {
                         @Override
                         public void onCompleted(Response response) {
                             if (response.getError() == null)
                                 Toast.makeText(ShareHelper.this,
                                         ""Quote Shared successfully"",
                                         Toast.LENGTH_LONG).show();
                         }
                     });
             request.executeAsync();
         } else {
             requestPermissions();
         }
     }
  
     public boolean checkPermissions() {
         Session s = Session.getActiveSession();
         if (s != null) {
             return s.getPermissions().contains(""publish_actions"");
         } else
             return false;
     }
  
     public void requestPermissions() {
         Session s = Session.getActiveSession();
         if (s != null)
             s.requestNewPublishPermissions(new Session.NewPermissionsRequest(
                     this, PERMISSIONS));
     }
  
     @Override
     public void onResume() {
         super.onResume();
         uiHelper.onResume();
         buttonsEnabled(Session.getActiveSession().isOpened());
     }
  
     @Override
     public void onPause() {
         super.onPause();
         uiHelper.onPause();
     }
  
     @Override
     public void onDestroy() {
         super.onDestroy();
         uiHelper.onDestroy();
     }
  
     @Override
     public void onActivityResult(int requestCode, int resultCode, Intent data) {
         super.onActivityResult(requestCode, resultCode, data);
         uiHelper.onActivityResult(requestCode, resultCode, data);
     }
  
     @Override
     public void onSaveInstanceState(Bundle savedState) {
         super.onSaveInstanceState(savedState);
         uiHelper.onSaveInstanceState(savedState);
     }
}",3,0,dcd35cf8ddea16ac6429bc43ea8e8a1c91a154b04677c76fadc5ff9985990059
,"String encryptKey(String input)
{
    byte[] inBytes=input.getBytes();
    String finalString=null;
    try {
        Cipher cipher=Cipher.getInstance(""AES/CBC/PKCS5Padding"");
        MessageDigest md = MessageDigest.getInstance(""SHA-1"");
        byte[] keyBytes=md.digest((KeyPart1+KeyPart2).getBytes());
        keyBytes = Arrays.copyOf(keyBytes, 16);
        SecretKey key= new SecretKeySpec(keyBytes,""AES"");
        IvParameterSpec ivSpec = new IvParameterSpec(new byte[] {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0});
        cipher.init(Cipher.ENCRYPT_MODE,key,ivSpec);
        byte[] outBytes = new byte[cipher.getOutputSize(inBytes.length)];
        //cipher.update(encrypted, 0, encrypted.length, decrypted, 0);
        outBytes=cipher.doFinal(inBytes);
        finalString=new String(Base64.encode(outBytes,0));
        Log.v(TAG,""Encrypted=""+finalString);

    } catch (NoSuchAlgorithmException e) {
        Log.e(TAG,""No Such Algorithm"",e);
    } catch (NoSuchPaddingException e) {
        Log.e(TAG,""No Such Padding"",e);
    } catch (InvalidKeyException e) {
        Log.e(TAG,""Invalid Key"",e);
    } catch (InvalidAlgorithmParameterException e) {
        Log.e(TAG,""Invalid Algorithm Parameter"",e);
    } catch (IllegalBlockSizeException e) {
    } catch (BadPaddingException e) {}
    return finalString;
}

String decryptKey(String base64Text)
{
    byte[] encrypted=Base64.decode(base64Text,0);
    //encrypted=base64Text.getBytes();
    String decryptedString=null;
    try {
        Cipher cipher=Cipher.getInstance(""AES/CBC/PKCS5Padding"");
        MessageDigest md = MessageDigest.getInstance(""SHA-1"");
        byte[] keyBytes=md.digest((KeyPart1+KeyPart2).getBytes());
        keyBytes = Arrays.copyOf(keyBytes, 16);
        SecretKey key= new SecretKeySpec(keyBytes,""AES"");
        IvParameterSpec ivSpec = new IvParameterSpec(new byte[] {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0});
        cipher.init(Cipher.DECRYPT_MODE,key,ivSpec);
        byte[] decrypted = new byte[cipher.getOutputSize(encrypted.length)];
        //cipher.update(encrypted, 0, encrypted.length, decrypted, 0);
        decrypted=cipher.doFinal(encrypted);
        decryptedString=new String(decrypted);
    } catch (NoSuchAlgorithmException e) {
        logStackTrace(e);
    } catch (NoSuchPaddingException e) {
        logStackTrace(e);
    } catch (InvalidKeyException e) {
        logStackTrace(e);
    } catch (InvalidAlgorithmParameterException e) {
        logStackTrace(e);
    } catch (IllegalBlockSizeException e) {
        logStackTrace(e);
    } catch (BadPaddingException e) {
        logStackTrace(e);
    }
    return decryptedString;
}
",4,0,28ce81cb2ed81afa07347f04955b612f8e37e6692332c5d178c9a55e036ec914
,"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.UnsupportedEncodingException;
import java.net.HttpCookie;
import java.net.MalformedURLException;
import java.net.URL;
import java.net.URLEncoder;
import java.util.Date;
import java.util.List;
import java.util.Map;

import javax.crypto.Mac;
import javax.crypto.spec.SecretKeySpec;
import javax.net.ssl.HttpsURLConnection;

import org.apache.commons.codec.binary.Hex;
import org.json.simple.JSONObject;
import org.json.simple.parser.JSONParser;
import org.json.simple.parser.ParseException;

public class InstagramPostHelper {

    private static InstagramPostHelper instance = null;

    protected InstagramPostHelper() {}

    public static InstagramPostHelper getInstance() {
        if (instance == null) {
            instance = new InstagramPostHelper();
        }
        return instance;
    }

    private String GenerateSignature(String value, String key) 
    {
        String result = null;
        try {
            byte[] keyBytes = key.getBytes();
            SecretKeySpec signingKey = new SecretKeySpec(keyBytes, ""HmacSHA256"");
            Mac mac = Mac.getInstance(""HmacSHA256"");
            mac.init(signingKey);
            byte[] rawHmac = mac.doFinal(value.getBytes());
            byte[] hexBytes = new Hex().encode(rawHmac);
            result = new String(hexBytes, ""UTF-8"");
    }
    catch (Exception e) {

    }
        return result;

    }

    private static final String COOKIES_HEADER = ""Set-Cookie"";
    public static java.net.CookieManager msCookieManager = new java.net.CookieManager();
    private HttpsURLConnection conn;

    private static String TextUtilsJoin(CharSequence delimiter, List&lt;HttpCookie&gt; list) {
            StringBuilder sb = new StringBuilder();
            boolean firstTime = true;
            for (Object token: list) {

                if (token.toString().trim().length()&lt;1) continue;

                if (firstTime) {
                    firstTime = false;
                } else {
                    sb.append(delimiter + "" "");
                }

                sb.append(token);

            }
            return sb.toString();
        }


    private String GetJSONStringAndPostData(String jsonaddress,String postdata,String agent)
    {
        String sonuc = """";
        try {

            byte[] postDataBytes = postdata.toString().getBytes(""UTF-8"");


            URL url = new URL(jsonaddress);


            conn = (HttpsURLConnection) url.openConnection();
            conn.setRequestMethod(""POST"");
            conn.setRequestProperty(""Content-Length"", String.valueOf(postDataBytes.length));
            conn.setRequestProperty(""User-Agent"", agent);

            //Set Cookies
            if(msCookieManager.getCookieStore().getCookies().size() &gt; 0)
            {
              conn.setRequestProperty(""Cookie"", TextUtilsJoin("";"",  msCookieManager.getCookieStore().getCookies()));    
            }

            conn.setDoOutput(true);
            conn.getOutputStream().write(postDataBytes);

            if (conn.getResponseCode() != 200) {
                throw new RuntimeException(""Failed : HTTP error code : ""
                        + conn.getResponseCode());
            }

            //Get Cookies
            Map&lt;String, List&lt;String&gt;&gt; headerFields = conn.getHeaderFields();
            List&lt;String&gt; cookiesHeader = headerFields.get(COOKIES_HEADER);
            if(cookiesHeader != null)
            {
                for (String cookie : cookiesHeader) 
                {
                  msCookieManager.getCookieStore().add(null,HttpCookie.parse(cookie).get(0));
                }               
            }



            BufferedReader br = new BufferedReader(new InputStreamReader(
                (conn.getInputStream())));
            String output;
            while ((output = br.readLine()) != null) {
                sonuc += output;
            }
            conn.disconnect();
          } catch (MalformedURLException e) {
            return """";
          } catch (IOException e) {
            return """";
          }
        return sonuc;
    }

    public void SendImage(String Caption,byte[] ImageByteArray) throws UnsupportedEncodingException, ParseException
    {
        String Agent = ""Instagram 6.21.2 Android (19/4.4.2; 480dpi; 1152x1920; Meizu; MX4; mx4; mt6595; en_US)"";
        String Guid = java.util.UUID.randomUUID().toString();
        String DeviceId = ""android-"" + Guid;
        String Data = ""{\""device_id\"":\""""  +  DeviceId + ""\"",\""guid\"":\"""" + Guid + ""\"",\""username\"":\""MYUSERNAME\"",\""password\"":\""MYPASSWORD\"",\""Content-Type\"":\""application/x-www-form-urlencoded; charset=UTF-8\""}""; 
        String Sig = GenerateSignature(Data, ""25eace5393646842f0d0c3fb2ac7d3cfa15c052436ee86b5406a8433f54d24a5"");
        Data  = ""signed_body="" + Sig + ""."" +  URLEncoder.encode(Data, ""UTF-8"") + ""&amp;ig_sig_key_version=4"";

        if (msCookieManager.getCookieStore()!= null)
        {
            msCookieManager.getCookieStore().removeAll();
        }
        //Login Request
        String login = GetJSONStringAndPostData(""https://instagram.com/api/v1/accounts/login/"", Data,Agent);

        JSONParser parser = new JSONParser();
        Object obj = parser.parse(login);
        JSONObject jsonObject = (JSONObject) obj;
        if (((String) jsonObject.get(""status"")).equals(""ok"")) //Login SuccessFul
        {
            //Login Successful
            System.out.println(""Login Successful !"");

           //Post Image
            String upload = """";

            try {
                final HttpMultipartHelper http = new HttpMultipartHelper(new URL(""https://instagram.com/api/v1/media/upload/""));
                http.addFormField(""device_timestamp"", Long.toString((new Date()).getTime()));
                http.addFilePart(""photo"", ImageByteArray);
                final byte[] bytes = http.finish();
                upload = new String(bytes);
            } catch (IOException e) {
                e.printStackTrace();
            }


            System.out.println(upload);
            obj = parser.parse(upload);
            jsonObject = (JSONObject) obj;
            if (((String) jsonObject.get(""status"")).equals(""ok"")) //Login SuccessFul
            {
                String mediaID = (String) jsonObject.get(""media_id"");

                Data = ""{\""device_id\"":\"""" + DeviceId + ""\"",\""guid\"":\"""" + Guid + ""\"",\""media_id\"":\"""" + mediaID + ""\"",\""caption\"":\"""" + Caption + ""\"",\""device_timestamp\"":\"""" + Long.toString((new Date()).getTime()).substring(0,10) + ""\"",\""source_type\"":\""5\"",\""filter_type\"":\""0\"",\""extra\"":\""{}\"",\""Content-Type\"":\""application/x-www-form-urlencoded; charset=UTF-8\""}"";
                Sig = GenerateSignature(Data, ""25eace5393646842f0d0c3fb2ac7d3cfa15c052436ee86b5406a8433f54d24a5"");

                Data  = ""signed_body="" + Sig + ""."" +  URLEncoder.encode(Data, ""UTF-8"") + ""&amp;ig_sig_key_version=6"";

                //Login Request
                System.out.println(Data);
                String result = GetJSONStringAndPostData(""https://instagram.com/api/v1/media/configure/"", Data,Agent);

                System.out.println(result);
            }


        }
        else //Login UnsuccessFul
        {
            System.out.println(""Login Unsuccessful !"" + login);
        }


    }

}
",3,0,69c9b40f27b1c92814ae4dbcba1b826665d89b0897d0c5c216ae854e101873cb
,"// derived from https://developer.android.com/google/gcm/ccs.html

import javax.swing.*;
import java.awt.*;
import java.awt.event.*;
//import javax.swing.JScrollPane;
//import javax.swing.SwingUtilities;

import org.jivesoftware.smack.ConnectionConfiguration;
import org.jivesoftware.smack.ConnectionConfiguration.SecurityMode;
import org.jivesoftware.smack.ConnectionListener;
import org.jivesoftware.smack.PacketInterceptor;
import org.jivesoftware.smack.PacketListener;
import org.jivesoftware.smack.SmackException;
import org.jivesoftware.smack.SmackException.NotConnectedException;
import org.jivesoftware.smack.XMPPConnection;
import org.jivesoftware.smack.XMPPException;
import org.jivesoftware.smack.filter.PacketTypeFilter;
import org.jivesoftware.smack.packet.DefaultPacketExtension;
import org.jivesoftware.smack.packet.Message;
import org.jivesoftware.smack.packet.Packet;
import org.jivesoftware.smack.packet.PacketExtension;
import org.jivesoftware.smack.provider.PacketExtensionProvider;
import org.jivesoftware.smack.provider.ProviderManager;
import org.jivesoftware.smack.tcp.XMPPTCPConnection;
import org.jivesoftware.smack.util.StringUtils;
import org.json.simple.JSONValue;
import org.json.simple.JSONObject;
import org.json.simple.parser.ParseException;
import org.xmlpull.v1.XmlPullParser;

import java.io.IOException;
import java.util.HashMap;
import java.util.Map;
import java.util.UUID;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.Calendar;
import java.util.ArrayList;
import java.util.Enumeration;
import java.util.Random;
import java.net.*;
import java.io.*;
import java.util.*;
import javax.net.ssl.SSLSocketFactory;
import javax.net.ssl.HttpsURLConnection;

// list of all users and associated devices
class UserList {
    // (--deleted--)

    // constructor/read existing data from file
    public UserList() {
        // (--deleted--)
    }

    // add a new device to an existing user (called from networking thread)
    // duplicate IDs are quietly accepted
    public synchronized void addDevice( String uname, String newRegToken ) {
        // (--deleted--)
    }

    // generate a group address/notification key
    // !!!!!!!!!!!!!!! W A R N I N G !!!!!!!!!!!!!!!
    //   If the group addr/notification key is lost, it currently CANNOT be recovered/rebuilt
    public String createNotificationKey( String nKeyName, String addr ) {
        String[] idset = new String[1];
        idset[0] = addr;

        String newGroupAddr;

        try {
            // create a https connection to create the notification_key
            URL url = new URL( ""https://android.googleapis.com/gcm/notification"" );
            HttpsURLConnection conn = (HttpsURLConnection)url.openConnection();

            // send as a POST request
            conn.setRequestMethod(""POST"");

            // add request parameters
            conn.addRequestProperty( ""project_id"", """"+GcmPushServer.senderId );
            conn.addRequestProperty( ""Authorization"", ""key=""+GcmPushServer.password );
            // use ""set"" since this may already exist
            conn.setRequestProperty( ""Content-Type"", ""application/json"" );

            // create data to send with request
            Map&lt;String,Object&gt; sendData = new HashMap&lt;&gt;();

            // create a new notification key
            sendData.put( ""operation"", ""create"" );
            sendData.put( ""notification_key_name"", (--deleted--) );
            sendData.put( ""registration_ids"", (--deleted--) );

            String strData = JSONValue.toJSONString(sendData);

            // Send post request
            conn.setDoOutput(true);
            DataOutputStream wr = new DataOutputStream(conn.getOutputStream());
            wr.writeBytes( strData );
            wr.flush();
            wr.close();

            // successful?
            int rc = conn.getResponseCode();
            //System.out.println(""ResponseCode = "" + rc );

            // read the response
            Scanner input = new Scanner( conn.getInputStream() );
            String resp="""";

            // read/display lines
            while( input.hasNextLine() ) {
                String s = input.nextLine();
                resp += s;
            }

            //System.out.println(""Response content: "" + resp);

            if ( rc == HttpsURLConnection.HTTP_OK ) {
                JSONObject obj = (JSONObject) JSONValue.parse(resp);

                newGroupAddr = (String) obj.get( ""notification_key"" );
                //System.out.println("" new notification_key: "" + newGroupAddr );
                return newGroupAddr;
            } else {

            }
        } catch ( Exception e ) {
            //System.out.println(""-- Exception: "" + e.getMessage() );
        }

        return null;
    }

    // add/delete a single address to/from a notification key
    //  (add if doAdd is true, delete otherwise)
    // removing final address will quietly delete the key
    public static void modifyNotificationKey( String nKeyName, String nKey,
                    String addr, boolean doAdd ) {
        String[] idset = new String[1];
        idset[0] = addr;

        try {
            // create a https connection to create the notification_key
            URL url = new URL( ""https://android.googleapis.com/gcm/notification"" );
            HttpsURLConnection conn = (HttpsURLConnection)url.openConnection();

            // send as a POST request
            conn.setRequestMethod(""POST"");

            // add request parameters
            conn.addRequestProperty( ""project_id"", """"+GcmPushServer.senderId );
            conn.addRequestProperty( ""Authorization"", ""key=""+GcmPushServer.password );
            // use ""set"" since this may already exist
            conn.setRequestProperty( ""Content-Type"", ""application/json"" );

            // create data to send with request
            Map&lt;String,Object&gt; sendData = new HashMap&lt;&gt;();

            // create a new notification key
            sendData.put( ""operation"", doAdd? ""add"" : ""remove"" );       // add or delete key?
            sendData.put( ""notification_key_name"", (--deleted--) );
            sendData.put( ""notification_key"", (--deleted--) );
            sendData.put( ""registration_ids"", (--deleted--) );

            String strData = JSONValue.toJSONString(sendData);
            //System.out.println(""genGroupAddress POST data: "" + strData );

            // Send post request
            conn.setDoOutput(true);
            DataOutputStream wr = new DataOutputStream(conn.getOutputStream());
            wr.writeBytes( strData );
            wr.flush();
            wr.close();

            //conn.openConnection();

            // successful?
            int rc = conn.getResponseCode();
            //System.out.println(""ResponseCode = "" + rc );

            Scanner input = new Scanner( conn.getInputStream() );

            // read/display lines
            while( input.hasNextLine() ) {
                System.out.println(""Response content:"");
                String s = input.nextLine();
                System.out.println( s );
            }
        } catch ( Exception e ) {
            // do nothing
        }
    }
}

// text area for log messages
class LogTextArea extends JTextArea {
    // update the ""log"" with the specified message
    public void logMessage( String msg ) {
        // (--deleted--)
    }
}

class CcsServer {
    private static final String GCM_SERVER = ""gcm.googleapis.com"";
    private static final int GCM_PORT = 5235;

    private static final String GCM_ELEMENT_NAME = ""gcm"";
    private static final String GCM_NAMESPACE = ""google:mobile:data"";

    // display/log area
    LogTextArea logArea;
    UserList users;

    CcsServer( LogTextArea lta, UserList u ) {
        logArea = lta;
        users = u;
    }

    static {
        ProviderManager.addExtensionProvider(GCM_ELEMENT_NAME, GCM_NAMESPACE,
            new PacketExtensionProvider() {
                @Override
                public PacketExtension parseExtension(XmlPullParser parser) throws
                        Exception {
                    String json = parser.nextText();
                    return new GcmPacketExtension(json);
                }
            });
    }

    private XMPPConnection connection;

    /**
     * Indicates whether the connection is in draining state, which means that it
     * will not accept any new downstream messages.
     */
    protected volatile boolean connectionDraining = false;

    /**
     * Sends a downstream message to GCM.
     *
     * @return true if the message has been successfully sent.
     */
    public boolean sendDownstreamMessage(String jsonRequest) throws
            NotConnectedException {
        if (!connectionDraining) {
            send(jsonRequest);
            return true;
        }
        logArea.logMessage(""Dropping downstream message since the connection is draining"");
        return false;
    }

    /**
     * Returns a random message id to uniquely identify a message.
     *
     * &lt;p&gt;Note: This is generated by a pseudo random number generator for
     * illustration purpose, and is not guaranteed to be unique.
     */
    public String nextMessageId() {
        return ""m-"" + UUID.randomUUID().toString();
    }

    /**
     * Sends a packet with contents provided.
     */
    protected void send(String jsonRequest) throws NotConnectedException {
        Packet request = new GcmPacketExtension(jsonRequest).toPacket();
        connection.sendPacket(request);
    }

    /**
     * Handles an upstream data message from a device application.
     *
     * &lt;p&gt;This sample echo server sends an echo message back to the device.
     * Subclasses should override this method to properly process upstream messages.
     */
    protected void handleUpstreamMessage(Map&lt;String, Object&gt; jsonObject) {
        // PackageName of the application that sent this message.
        String category = (String) jsonObject.get(""category"");
        String from = (String) jsonObject.get(""from"");
        @SuppressWarnings(""unchecked"")
        Map&lt;String, String&gt; payload = (Map&lt;String, String&gt;) jsonObject.get(""data"");

        // what type of upstream message is this?
        if ( ! payload.containsKey( ""my_action"" ) )
        {
            // Hmmm - this shouldn't happen!
            logArea.logMessage( ""handleUpstreamMessage - incoming message is missing my_action"" );
            // just ignore the  message
            return;
        }

        // what action do they want?
        String my_action = (String) payload.get( ""my_action"" );
        if ( my_action.equals( ""edu.eku.styere.gcmpushclient.REGISTER"" ) ) {
            // registration request
            String username = (String) payload.get( ""username"" );

            logArea.logMessage( ""Registration request: user="" + username + "", ID/Token="" + from );

            // save the information
            users.addDevice( username, from );

            return;
        } else {
            // take default action of echoing the message       
            payload.put(""ECHO"", ""Application: "" + category);

            // Send an ECHO response back
            String echo = createJsonMessage(from, nextMessageId(), payload,
                    ""echo:CollapseKey"", null, false);

            try {
                sendDownstreamMessage(echo);
            } catch (NotConnectedException e) {
                logArea.logMessage( ""Not connected anymore, echo message is not sent: "" + e.getMessage() );
            }
        }
    }

    /**
     * Handles an ACK.
     *
     * &lt;p&gt;Logs a INFO message, but subclasses could override it to
     * properly handle ACKs.
     */
    protected void handleAckReceipt(Map&lt;String, Object&gt; jsonObject) {
        String messageId = (String) jsonObject.get(""message_id"");
        String from = (String) jsonObject.get(""from"");
        logArea.logMessage( ""handleAckReceipt() from: "" + from + "", messageId: "" + messageId );
    }

    /**
     * Handles a NACK.
     *
     * &lt;p&gt;Logs a INFO message, but subclasses could override it to
     * properly handle NACKs.
     */
    protected void handleNackReceipt(Map&lt;String, Object&gt; jsonObject) {
        String messageId = (String) jsonObject.get(""message_id"");
        String from = (String) jsonObject.get(""from"");
        logArea.logMessage( ""handleNackReceipt() from: "" + from + "", messageId: "" + messageId );
    }

    protected void handleControlMessage(Map&lt;String, Object&gt; jsonObject) {
        logArea.logMessage( ""handleControlMessage(): "" + jsonObject );
        String controlType = (String) jsonObject.get(""control_type"");
        if (""CONNECTION_DRAINING"".equals(controlType)) {
            connectionDraining = true;
        } else {
            logArea.logMessage( ""Unrecognised control type: "" + controlType + "". This could ""+
                    ""happen if new features are "" + ""added to the CCS protocol."" );
        }
    }

    /**
     * Creates a JSON encoded GCM message.
     *
     * @param to RegistrationId of the target device (Required).
     * @param messageId Unique messageId for which CCS sends an
     *         ""ack/nack"" (Required).
     * @param payload Message content intended for the application. (Optional).
     * @param collapseKey GCM collapse_key parameter (Optional).
     * @param timeToLive GCM time_to_live parameter (Optional).
     * @param delayWhileIdle GCM delay_while_idle parameter (Optional).
     * @return JSON encoded GCM message.
     */
    public static String createJsonMessage(String to, String messageId,
            Map&lt;String, String&gt; payload, String collapseKey, Long timeToLive,
            Boolean delayWhileIdle) {
        Map&lt;String, Object&gt; message = new HashMap&lt;String, Object&gt;();
        message.put(""to"", to);
        if (collapseKey != null) {
            message.put(""collapse_key"", collapseKey);
        }
        if (timeToLive != null) {
            message.put(""time_to_live"", timeToLive);
        }
        if (delayWhileIdle != null &amp;&amp; delayWhileIdle) {
            message.put(""delay_while_idle"", true);
        }
      message.put(""message_id"", messageId);
      message.put(""data"", payload);
      return JSONValue.toJSONString(message);
    }

    /**
     * Creates a JSON encoded ACK message for an upstream message received
     * from an application.
     *
     * @param to RegistrationId of the device who sent the upstream message.
     * @param messageId messageId of the upstream message to be acknowledged to CCS.
     * @return JSON encoded ack.
     */
        protected static String createJsonAck(String to, String messageId) {
        Map&lt;String, Object&gt; message = new HashMap&lt;String, Object&gt;();
        message.put(""message_type"", ""ack"");
        message.put(""to"", to);
        message.put(""message_id"", messageId);
        return JSONValue.toJSONString(message);
    }

    /**
     * Connects to GCM Cloud Connection Server using the supplied credentials.
     *
     * @param senderId Your GCM project number
     * @param apiKey API Key of your project
     */
    public void connect(long senderId, String apiKey)
            throws XMPPException, IOException, SmackException {
        ConnectionConfiguration config =
                new ConnectionConfiguration(GCM_SERVER, GCM_PORT);
        config.setSecurityMode(SecurityMode.enabled);
        config.setReconnectionAllowed(true);
        config.setRosterLoadedAtLogin(false);
        config.setSendPresence(false);
        config.setSocketFactory(SSLSocketFactory.getDefault());

        connection = new XMPPTCPConnection(config);
        connection.connect();

        connection.addConnectionListener( new LoggingConnectionListener() );

        // Handle incoming packets
        connection.addPacketListener(new PacketListener() {

            @Override
            public void processPacket(Packet packet) {
                logArea.logMessage( ""Received: "" + packet.toXML() );
                Message incomingMessage = (Message) packet;
                GcmPacketExtension gcmPacket =
                        (GcmPacketExtension) incomingMessage.
                        getExtension(GCM_NAMESPACE);
                String json = gcmPacket.getJson();
                try {
                    @SuppressWarnings(""unchecked"")
                    Map&lt;String, Object&gt; jsonObject =
                            (Map&lt;String, Object&gt;) JSONValue.
                            parseWithException(json);

                    // present for ""ack""/""nack"", null otherwise
                    Object messageType = jsonObject.get(""message_type"");

                    if (messageType == null) {
                        // Normal upstream data message
                        handleUpstreamMessage(jsonObject);

                        // Send ACK to CCS
                        String messageId = (String) jsonObject.get(""message_id"");
                        String from = (String) jsonObject.get(""from"");
                        String ack = createJsonAck(from, messageId);
                        send(ack);
                    } else if (""ack"".equals(messageType.toString())) {
                          // Process Ack
                          handleAckReceipt(jsonObject);
                    } else if (""nack"".equals(messageType.toString())) {
                          // Process Nack
                          handleNackReceipt(jsonObject);
                    } else if (""control"".equals(messageType.toString())) {
                          // Process control message
                          handleControlMessage(jsonObject);
                    } else {
                          logArea.logMessage( ""Unrecognised message type: "" + 
                                  messageType.toString() );
                    }
                } catch (ParseException e) {
                    logArea.logMessage( ""Error parsing JSON "" + json );
                } catch (Exception e) {
                    logArea.logMessage( ""Failed to process packet"" );
                }
            }
        }, new PacketTypeFilter(Message.class));

        // Log all outgoing packets
        connection.addPacketInterceptor(new PacketInterceptor() {
            @Override
                public void interceptPacket(Packet packet) {
                    logArea.logMessage( ""Sent: "" + packet.toXML());
                }
            }, new PacketTypeFilter(Message.class));

        connection.login(senderId + ""@gcm.googleapis.com"", apiKey);
    }

    //---------- support classes ----------

    /**
    * XMPP Packet Extension for GCM Cloud Connection Server.
    */
    private static class GcmPacketExtension extends DefaultPacketExtension {

        private final String json;

        public GcmPacketExtension(String json) {
            super( GCM_ELEMENT_NAME, GCM_NAMESPACE);
            this.json = json;
        }

        public String getJson() {
            return json;
        }

        @Override
        public String toXML() {
            return String.format(""&lt;%s xmlns=\""%s\""&gt;%s&lt;/%s&gt;"",
                    GCM_ELEMENT_NAME, GCM_NAMESPACE,
                    StringUtils.escapeForXML(json), GCM_ELEMENT_NAME);
        }

        public Packet toPacket() {
            Message message = new Message();
            message.addExtension(this);
            return message;
        }
    }

    class LoggingConnectionListener implements ConnectionListener {

        @Override
        public void connected(XMPPConnection xmppConnection) {
            logArea.logMessage( ""Connected."" );
        }

        @Override
        public void authenticated(XMPPConnection xmppConnection) {
            logArea.logMessage( ""Authenticated."" );
        }

        @Override
        public void reconnectionSuccessful() {
            logArea.logMessage( ""Reconnecting.."" );
        }

        @Override
        public void reconnectionFailed(Exception e) {
            logArea.logMessage( ""Reconnection failed.. "" + e.getMessage() );
        }

        @Override
        public void reconnectingIn(int seconds) {
            logArea.logMessage( ""Reconnecting in "" + seconds + "" secs"" );
        }

        @Override
        public void connectionClosedOnError(Exception e) {
            logArea.logMessage( ""Connection closed on error."" );
        }

        @Override
        public void connectionClosed() {
            logArea.logMessage( ""Connection closed."" );
        }
    }
}

// a non-editable combo (drop-down) box for destination addresses
class DestComboBox extends JComboBox&lt;String&gt; {
    // (deleted to save space)
}

// screen panel for sending a message
class SendMessagePanel extends JPanel implements ActionListener, ItemListener {     
    // Message Types
    protected final int MSGTYPE_NOTIFICATION = 1;
    protected final int MSGTYPE_NOTIFICATION_DATA = 2;
    protected final int MSGTYPE_DATA_COLLAPSE = 3;
    protected final int MSGTYPE_DATA_NONCOLLAPSE = 4;

    // log window
    LogTextArea msgs;

    // server class
    CcsServer ccsServer;

    // constructor
    SendMessagePanel( UserList u, LogTextArea m, CcsServer c ) {
        // (deleted to save space)
    }

    // respond to the button
    @Override
    public void actionPerformed(ActionEvent e) {
        String toAddr = ""zzzzzz"";   // destination address
               // may be device, notification_key, or topic address
        ttl = 2419200;              // time-to-live in seconds

        // what type of message?
        int msgTypeIndex = (--deleted--);

        // create the message
        Map&lt;String, Object&gt; message = new HashMap&lt;String, Object&gt;();
        message.put(""to"", toAddr);

        if ( msgTypeIndex == MSGTYPE_NOTIFICATION ||
                    msgTypeIndex == MSGTYPE_NOTIFICATION_DATA ||
                    msgTypeIndex == MSGTYPE_DATA_COLLAPSE ) {
            // create a collapse key
            message.put(""collapse_key"", ""ck""+msgTypeIndex );
        }

        message.put(""time_to_live"", ttl);   
        message.put(""message_id"", ccsServer.nextMessageId());

        // notification included?
        if ( msgTypeIndex == MSGTYPE_NOTIFICATION ||
                msgTypeIndex == MSGTYPE_NOTIFICATION_DATA ) {

            // create the notification payload
            HashMap&lt;String, String&gt; notePayload = new HashMap&lt;&gt;();
            notePayload.put( ""title"", ""Gcm Push Message Example"" );
            notePayload.put( ""body"", (--deleted--) );
            // identify which notifications should replace older versions
            notePayload.put( ""tag"", ""ntag"" + msgTypeIndex );
            notePayload.put( ""icon"", ""@drawable/new_picture"" );     // notification icon

            // additional stuff if we also have data
            if ( msgTypeIndex == MSGTYPE_NOTIFICATION_DATA ) {
                // what to do when the user opens the notification
                notePayload.put( ""click_action"", ""OPEN_MAIN_ACTIVITY"" );
            }
            message.put( ""notification"", notePayload );
        }

        // data included?
        if ( msgTypeIndex == MSGTYPE_NOTIFICATION_DATA ||
                    msgTypeIndex == MSGTYPE_DATA_COLLAPSE ||
                    msgTypeIndex == MSGTYPE_DATA_NONCOLLAPSE ) {
            HashMap&lt;String, String&gt; dataPayload = new HashMap&lt;&gt;();

            dataPayload.put( ""contents"", (--deleted--) );

            message.put(""data"", dataPayload);
        }

        // actually send the message
        try {
            ccsServer.sendDownstreamMessage( JSONValue.toJSONString(message) );
        } catch (NotConnectedException enc ) {
            msgs.logMessage( ""Not connected anymore, echo message is not sent: "" + enc.getMessage() );
        }
    }
}

class BorderPanel extends JPanel {
    // (--deleted--)
}

public class GcmPushServer
{
    // (--deleted--)
}
",3,0,1323caf6f823da343bc895a9f368d802cfa5bf414c9da6167fabe5b7e7abd06d
,"/**
 * This utility function will upload the file to the Url
 * * @param filePath - absolute path of the file to be uploaded
 * @param postUrl  - Remote Url where the file need to be posted
 * @param contentType - content-type of the uploaded file
 * @throws Exception
 */
public static void postFile(String filePath, String postUrl,
        String pictureTitleStr, String pseudoTextStr)
        throws Exception {

    String url = postUrl;
    HttpURLConnection conn = null;
    final String CrLf = ""\r\n"";
    JSONObject json = new JSONObject();
    int bytesRead = 0;


    String lineEnd = ""\r\n"";
    String twoHyphens = ""--"";
    String boundary = ""xxxxxxxx"";
    String EndBoundary = """";
    int maxBufferSize = 1 * 1024 * 1024;

    HttpResponse response = null;

  // Having HttpClient to respond to both HTTP and HTTPS url connection by accepting the urls along with keystore / trust certificates 

    try {
        KeyStore trustStore = KeyStore.getInstance(KeyStore
                .getDefaultType());
        trustStore.load(null, null);

        SSLSocketFactory sf = new MySSLSocketFactory(trustStore);
        sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
        HttpParams params = new BasicHttpParams();
        HttpProtocolParams.setVersion(params, HttpVersion.HTTP_1_1);
        HttpProtocolParams.setContentCharset(params, HTTP.UTF_8);
        HttpProtocolParams.setUserAgent(params, ""YourAppName/1.1"");
        HttpConnectionParams.setStaleCheckingEnabled(params, false);
        HttpConnectionParams.setConnectionTimeout(params, 20 * 1000);
        HttpConnectionParams.setSoTimeout(params, 20 * 1000);
        HttpConnectionParams.setSocketBufferSize(params, 8192);
        HttpClientParams.setRedirecting(params, false);

        SchemeRegistry registry = new SchemeRegistry();
        registry.register(new Scheme(""http"", PlainSocketFactory
                .getSocketFactory(), 80));
        registry.register(new Scheme(""https"", sf, 443));

        ClientConnectionManager ccm = new ThreadSafeClientConnManager(
                params, registry);

        mHttpClient = new DefaultHttpClient(ccm, params);



    } catch (Exception e) {

    }

    String base64EncodedCredentials = Base64.encodeToString((userName + "":"" + password).getBytes(""US-ASCII""),
            Base64.DEFAULT);
    System.out.println(""Encoded Credit "" + base64EncodedCredentials);

            json.put(""pseudo"", pseudoTextStr);
            json.put(""title"", pictureTitleStr);

           String jsonStr = json.toString(); 
 //   System.out.println(""JSON VALUE  "" + jsonStr);

    URL url2 = new URL(postUrl);



    Bitmap bm = BitmapFactory.decodeFile(filePath);
    ByteArrayOutputStream baos = new ByteArrayOutputStream();
    bm.compress(Bitmap.CompressFormat.JPEG, 25, baos); // bm is the bitmap object
    byte[] b = baos.toByteArray();

    String encodedImage = Base64.encodeToString(b, Base64.DEFAULT);


    String str = twoHyphens + boundary + lineEnd;
    String str2 = ""Content-Disposition: form-data; name=\""jsonFile\"""";
    String str3 = ""Content-Type: application/json"";
    String str4 = ""Content-Disposition: form-data; name=\""imgName\"""";
    String str5 = ""Content-Type: image/jpeg"";
    String str6 = twoHyphens + boundary + twoHyphens;



    String StrTotal = str + str2 + ""\r\n"" + str3 + ""\r\n"" +""\r\n"" + jsonStr + ""\r\n"" + str
            + str4 + ""\r\n"" + str5 + ""\r\n""+""\r\n""+ encodedImage + ""\r\n"" + str6;

    //System.out.print(""Multipart request string is ""+StrTotal);

 HttpPost post = new HttpPost(postUrl);


post.addHeader(BasicScheme.authenticate(new UsernamePasswordCredentials(
                userName, password), ""UTF-8"", false));
post.addHeader(""Content-Type"",""multipart/form-data;boundary=""+boundary);
// System.out.println(""Sending Post proxy request: "" + post);

 StringEntity se = new StringEntity(StrTotal);
 se.setContentEncoding(""UTF-8"");
 post.setEntity(se);
 response = mHttpClient.execute(post);

/* Checking response */

statusCode = response.getStatusLine().getStatusCode();
System.out.println(""Http Execute finish "" + statusCode);

HttpEntity entity = response.getEntity();
String getResponseText = entity.toString(); // EntityUtils.toString(entity);
System.out.println("" Post Response Text from Server : ""
        + getResponseText);



}
",4,0,0b6b7241ee2314cd1d17b296d0a37e858cdf194c588a0852f82d08a6971b8816
,"@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.payment_home);


    btnBuy.setOnClickListener(new OnClickListener() {

        @SuppressLint({ ""SetJavaScriptEnabled"", ""ShowToast"" }) @Override
        public void onClick(View v) {
            // TODO Auto-generated method stub
            if(f_nm &amp;&amp; f_pn  &amp;&amp; f_email )
            {
                webview.setVisibility(View.VISIBLE);
                Integer randomNum = randInt(0, 9999999);
                txnid=randomNum.toString();
                firstname=etName.getText().toString();
                email=etEmail.getText().toString();
                amount=study_material_price;
                productinfo=study_material_name;
                phone=etPhone.getText().toString();
                String hashSequence = merchant_key+""|""+txnid+""|""+amount+""|""+productinfo+""|""+firstname+""|""+email+""|||||||||||""+salt;
                hash = hashCal(""SHA-512"", hashSequence);
                webview.addJavascriptInterface(new PayUJavaScriptInterface(), ""PayUMoney"");
                String json =""txnid=""+txnid+""&amp;key=""+merchant_key+""&amp;amount=""+amount+""&amp;hash=""+hash+""&amp;productinfo=""+productinfo+""&amp;surl=""+SURL+""&amp;furl=""+FURL+""&amp;firstname=""+firstname+""&amp;email=""+email+""&amp;phone=""+phone+""&amp;service_provider=payu_paisa"";
                webview.getSettings().setUserAgentString(""Mozilla/5.0 (Linux; U; Android 2.0; en-us; Droid Build/ESD20) AppleWebKit/530.17 (KHTML, like Gecko) Version/4.0 Mobile Safari/530.17"");
                webview.getSettings().setDomStorageEnabled(true);
                webview.getSettings().setJavaScriptEnabled(true);
                webview.getSettings().setSupportMultipleWindows(true);
                webview.getSettings().setJavaScriptCanOpenWindowsAutomatically(true);
                webview.getSettings().setSupportZoom(true);       //Zoom Control on web (You don't need this
                //if ROM supports Multi-Touch
                webview.getSettings().setBuiltInZoomControls(true);
                webview.setWebViewClient(new WebViewClient());
                webview.setWebViewClient(
                        new SSLTolerentWebViewClient()
                        );
                webview.postUrl(""https://secure.payu.in/_payment"", EncodingUtils.getBytes(json, ""BASE64""));

                try {

                    webview.setWebViewClient(new WebViewClient() {
                        @Override
                        public void onReceivedError(WebView view, int errorCode,
                                String description, String failingUrl) {
                            Log.d(""WEB_VIEW_TEST"", ""error code:"" + errorCode + "" - "" + description);
                        }

                        @Override
                        public boolean shouldOverrideUrlLoading(WebView view, String url) {
                            // handle different requests for different type of files
                            // this example handles downloads requests for .apk and .mp3 files
                            // everything else the webview can handle normally
                            if (url.endsWith("".mp3"")||url.endsWith("".zip"") || url.endsWith("".pdf"") || url.endsWith("".jpg"")|| url.endsWith("".doc"")|| url.endsWith("".png"")|| url.endsWith("".docx"")|| url.endsWith("".xml"")|| url.endsWith("".gif"")) {
                                String urlSplit[] = url.split(""/"");
                                String fileName = urlSplit[urlSplit.length-1];
                                Uri source = Uri.parse(url);
                                // Make a new request pointing to the .apk url
                                DownloadManager.Request request = new DownloadManager.Request(source);
                                // appears the same in Notification bar while downloading
                                request.setDescription(""Description for the DownloadManager Bar"");
                                request.setTitle(fileName);
                                if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.HONEYCOMB) {
                                    request.allowScanningByMediaScanner();
                                    request.setNotificationVisibility(DownloadManager.Request.VISIBILITY_VISIBLE_NOTIFY_COMPLETED);
                                }
                                // save the file in the ""Downloads"" folder of SDCARD
                                request.setDestinationInExternalPublicDir(Environment.DIRECTORY_DOWNLOADS,fileName);
                                // get download service and enqueue file
                                DownloadManager manager = (DownloadManager) getSystemService(Context.DOWNLOAD_SERVICE);
                                manager.enqueue(request);
                            }
                            // if there is a link to anything else than .apk or .mp3 load the URL in the webview
                            else view.loadUrl(url);
                            return true;                
                        }
                    });


                } catch (Exception e) {
                    e.printStackTrace();
                }
            }else{
                Toast.makeText(getApplicationContext(), ""Please fill all the fields."", 1000).show();
            }
        }
    });
}   

@Override
public boolean onKeyDown(int keyCode, KeyEvent event) {
    if(event.getAction() == KeyEvent.ACTION_DOWN){
        switch(keyCode)
        {
        case KeyEvent.KEYCODE_BACK:
            if(webview.canGoBack()){
                webview.goBack();
            }else{
                finish();
            }
            return true;
        }

    }
    return super.onKeyDown(keyCode, event);
}

private final class PayUJavaScriptInterface {
    PayUJavaScriptInterface() {
    }

    /**
     * This is not called on the UI thread. Post a runnable to invoke
     * loadUrl on the UI thread.
     */
    @JavascriptInterface
    public void success(long id, final String pId) {
        mHandler.post(new Runnable() {
            public void run() {
                mHandler = null;
                Toast.makeText(getApplicationContext(), ""Your Transaction is Successful"", 1000).show();
                status=""Success"";
                paymentId=pId;
                new StoreTransactionData().execute();
                Intent intent = new Intent();
                intent.putExtra(""status"", ""success"");
                intent.putExtra(""transaction_id"", paymentId);
                setResult(RESULT_OK, intent);
                studyDownloadPaid();
                finish();
            }
        });
    }



    @JavascriptInterface
    public void failure(final String id, String error) {
        Log.d(""transaction data fail id"", id +""   "" +study_material_name);
        mHandler.post(new Runnable() {
            @Override
            public void run() {
                paymentId=id;
                status=""Faluire"";
                new StoreTransactionData().execute();
                cancelPayment();
            }
        });
    }

    @JavascriptInterface
    public void failure() {
        failure("""");
    }

    @JavascriptInterface
    public void failure(final String params) {
        mHandler.post(new Runnable() {
            @Override
            public void run() {
                paymentId=params;
                status=""Faluire"";
                new StoreTransactionData().execute();
                Log.d(""transaction data fail param"", params);
                Intent intent = new Intent();
                intent.putExtra(""status"", params);
                setResult(RESULT_CANCELED, intent);
                finish();
            }
        });
    }

}

private void cancelPayment() {
    Intent intent = new Intent();
    intent.putExtra(""status"", ""cancel"");
    //mWebView.destroy();
    setResult(RESULT_CANCELED, intent);
    finish();
}

public static String hashCal(String type, String str) {
    byte[] hashseq = str.getBytes();
    StringBuffer hexString = new StringBuffer();
    try {
        MessageDigest algorithm = MessageDigest.getInstance(type);
        algorithm.reset();
        algorithm.update(hashseq);
        byte messageDigest[] = algorithm.digest();
        for (int i = 0; i &lt; messageDigest.length; i++) {
            String hex = Integer.toHexString(0xFF &amp; messageDigest[i]);
            if (hex.length() == 1) {
                hexString.append(""0"");
            }
            hexString.append(hex);
        }
    } catch (NoSuchAlgorithmException nsae) {
    }
    return hexString.toString();
}

public static int randInt(int min, int max) {
    // Usually this should be a field rather than a method variable so
    // that it is not re-seeded every call.
    Random rand = new Random();

    // nextInt is normally exclusive of the top value,
    // so add 1 to make it inclusive
    int randomNum = rand.nextInt((max - min) + 1) + min;

    return randomNum;
}


private class SSLTolerentWebViewClient extends WebViewClient {

    @Override
    public void onReceivedSslError(WebView view, SslErrorHandler handler, SslError error) {
        handler.proceed(); // Ignore SSL certificate errors
    }

}
",4,0,185ded02661a550b4e16789b0de3c15cfcf76158e3c81c0302006f11fbc6d268
,"private String generateAuthHeader(String verb, String resourceType, String resourceId, String date, String masterKeyBase64) throws Exception
{
    //Decode the master key, and setup the MAC object for signing.
    byte[] masterKeyBytes = Base64.decode(masterKeyBase64, Base64.NO_WRAP);
    Mac mac = Mac.getInstance(""HMACSHA256"");
    mac.init(new SecretKeySpec(masterKeyBytes, ""HMACSHA256""));

    //Build the unsigned auth string.
    String stringToSign = verb + ""\n""
            + resourceType + ""\n""
            + resourceId + ""\n""
            + date + ""\n""
            + ""\n"";

    //Sign and encode the auth string.
    String signature = Base64.encodeToString(mac.doFinal(stringToSign.toLowerCase().getBytes(""UTF8"")), Base64.NO_WRAP);

    //Generate the auth header.
    String authHeader = URLEncoder.encode(""type=master&amp;ver=1.0&amp;sig="" + signature, ""UTF8"");

    return authHeader;
}
",2,0,dd495d7aeaa20f5e343ab5de29af855a3029b6cb993dd27a541f39d3a01f8b66
," fist you download activation.jar,mail.jar,additionnal.jar and add to built to your project                                                       

And code r following
---------Create GMailSender.class
import javax.activation.DataHandler;   
import javax.activation.DataSource;   
import javax.mail.Message;   
import javax.mail.PasswordAuthentication;   
import javax.mail.Session;   
import javax.mail.Transport;   
import javax.mail.internet.InternetAddress;   
import javax.mail.internet.MimeMessage;   
import java.io.ByteArrayInputStream;   
import java.io.IOException;   
import java.io.InputStream;   
import java.io.OutputStream;   
import java.security.Security;   
import java.util.Properties;   

public class GMailSender extends javax.mail.Authenticator {   
    private String mailhost = ""smtp.gmail.com"";   
    private String user;   
    private String password;   
    private Session session;   

    static {   
        Security.addProvider(new JSSEProvider());   
    }  

    public GMailSender(String user, String password) {   
        this.user = user;   
        this.password = password;   

        Properties props = new Properties();   
        props.setProperty(""mail.transport.protocol"", ""smtp"");   
        props.setProperty(""mail.host"", mailhost);   
        props.put(""mail.smtp.auth"", ""true"");   
        props.put(""mail.smtp.port"", ""465"");   
        props.put(""mail.smtp.socketFactory.port"", ""465"");   
        props.put(""mail.smtp.socketFactory.class"",   
                ""javax.net.ssl.SSLSocketFactory"");   
        props.put(""mail.smtp.socketFactory.fallback"", ""false"");   
        props.setProperty(""mail.smtp.quitwait"", ""false"");   

        session = Session.getDefaultInstance(props, this);   
    }   

    protected PasswordAuthentication getPasswordAuthentication() {   
         return new PasswordAuthentication(user, password);   
    }   

    public synchronized void sendMail(String subject, String body, String sender, String recipients) throws Exception {   
        try{
        MimeMessage message = new MimeMessage(session);   
        DataHandler handler = new DataHandler(new ByteArrayDataSource(body.getBytes(), ""text/plain""));   
        message.setSender(new InternetAddress(sender));   
        message.setSubject(subject);   
        message.setDataHandler(handler);   
        if (recipients.indexOf(',') &gt; 0)   
            message.setRecipients(Message.RecipientType.TO, InternetAddress.parse(recipients));   
        else  
            message.setRecipient(Message.RecipientType.TO, new InternetAddress(recipients));   
        Transport.send(message);   
        }catch(Exception e){
            e.printStackTrace();

        }
    }   

    public class ByteArrayDataSource implements DataSource {   
        private byte[] data;   
        private String type;   

        public ByteArrayDataSource(byte[] data, String type) {   
            super();   
            this.data = data;   
            this.type = type;   
        }   

        public ByteArrayDataSource(byte[] data) {   
            super();   
            this.data = data;   
        }   

        public void setType(String type) {   
            this.type = type;   
        }   

        public String getContentType() {   
            if (type == null)   
                return ""application/octet-stream"";   
            else  
                return type;   
        }   

        public InputStream getInputStream() throws IOException {   
            return new ByteArrayInputStream(data);   
        }   

        public String getName() {   
            return ""ByteArrayDataSource"";   
        }   

        public OutputStream getOutputStream() throws IOException {   
            throw new IOException(""Not Supported"");   
        }   
    }   
}  

2-Create JSSEProvider.class
import java.security.AccessController;
import java.security.Provider;

public final class JSSEProvider extends Provider {

    public JSSEProvider() {
        super(""HarmonyJSSE"", 1.0, ""Harmony JSSE Provider"");
        AccessController.doPrivileged(new java.security.PrivilegedAction&lt;Void&gt;() {
            public Void run() {
                put(""SSLContext.TLS"",
                        ""org.apache.harmony.xnet.provider.jsse.SSLContextImpl"");
                put(""Alg.Alias.SSLContext.TLSv1"", ""TLS"");
                put(""KeyManagerFactory.X509"",
                        ""org.apache.harmony.xnet.provider.jsse.KeyManagerFactoryImpl"");
                put(""TrustManagerFactory.X509"",
                        ""org.apache.harmony.xnet.provider.jsse.TrustManagerFactoryImpl"");
                return null;
            }
        });
    }
}

3-use This code in to your Activity button click etc..
try {   
                    GMailSender sender = new GMailSender(""sender gmail ID"", ""password"");
                    sender.sendMail(""This is Subject"",   
                            ""This is Body"",   
                            ""receiverID"",   
                            ""receiverID"");   
                } catch (Exception e) {   
                    Log.e(""SendMail"", e.getMessage(), e);   
                } 
",3,0,2c0a32b02cd2d194b519bba00769cb683db60ca8dfc5a2f352f48ee06fdef3e2
,"public String encode(String text)
            throws NoPassGivenException, NoTextGivenException {

        if (text.length() == 0 || text == null) {
            throw new NoTextGivenException(""Please give text"");
        }

        try {
            SecretKeySpec skeySpec = getKey(KEY);

            System.out.println(""-----Encoding Key-----""+skeySpec);
            byte[] clearText = text.getBytes(""UTF8"");

            //IMPORTANT TO GET SAME RESULTS ON iOS and ANDROID
            final byte[] iv = new byte[16];
            Arrays.fill(iv, (byte) 0x00);
            IvParameterSpec ivParameterSpec = new IvParameterSpec(iv);

            // Cipher is not thread safe
            Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS7Padding"");
            cipher.init(Cipher.ENCRYPT_MODE, skeySpec, ivParameterSpec);

//          IvParameterSpec ivspec = new IvParameterSpec(IV.getBytes());
//          cipher.init(Cipher.ENCRYPT_MODE, skeySpec, ivspec);

            String encrypedValue = Base64.encodeToString(
                    cipher.doFinal(clearText), Base64.DEFAULT);
            return new String(encrypedValue);

        } catch (InvalidKeyException e) {
            e.printStackTrace();
        } catch (UnsupportedEncodingException e) {
            e.printStackTrace();
        } catch (NoSuchAlgorithmException e) {
            e.printStackTrace();
        } catch (BadPaddingException e) {
            e.printStackTrace();
        } catch (NoSuchPaddingException e) {
            e.printStackTrace();
        } catch (IllegalBlockSizeException e) {
            e.printStackTrace();
        } catch (InvalidAlgorithmParameterException e) {
            e.printStackTrace();
        }
        return """";
    }

/**
     * Generates a SecretKeySpec for given password
     * @param password
     * @return SecretKeySpec
     * @throws UnsupportedEncodingException
     */
    public SecretKeySpec getKey(String password)
            throws UnsupportedEncodingException {


        int keyLength = 128;
        byte[] keyBytes = new byte[keyLength / 8];
        // explicitly fill with zeros
        Arrays.fill(keyBytes, (byte) 0x0);

        // if password is shorter then key length, it will be zero-padded
        // to key length
        byte[] passwordBytes = password.getBytes(""UTF-8"");
        int length = passwordBytes.length &lt; keyBytes.length ?          passwordBytes.length
                : keyBytes.length;
        System.arraycopy(passwordBytes, 0, keyBytes, 0, length);
        SecretKeySpec key = new SecretKeySpec(keyBytes, ""AES"");
        return key;
    }
 .// PHP Code to decrypt
    public function decrypt($code) { 

      $decoded = base64_decode($code);
      $iv = mcrypt_create_iv(mcrypt_get_iv_size(MCRYPT_RIJNDAEL_128, MCRYPT_MODE_ECB), MCRYPT_RAND);
      $decrypted = trim(mcrypt_decrypt(MCRYPT_RIJNDAEL_128, $this-&gt;key, trim($decoded), MCRYPT_MODE_ECB, $iv));
      $blocksize = mcrypt_get_block_size(MCRYPT_RIJNDAEL_128, MCRYPT_MODE_CBC);

     return  $this-&gt;pkcs7unpad($decrypted,$blocksize);
    }
 function pkcs7unpad($padded, $blocksize)
    {
        $l = strlen($padded);

        if ($l % $blocksize != 0) 
        {
            throw new Exception(""Padded plaintext cannot be divided by the block size"");
        }

        $padsize = ord($padded[$l - 1]);

        if ($padsize === 0)
        {
            throw new Exception(""Zero padding found instead of PKCS#7 padding"");
        }    

        if ($padsize &gt; $blocksize)
        {
            throw new Exception(""Incorrect amount of PKCS#7 padding for blocksize"");
        }

        // check the correctness of the padding bytes by counting the occurance
        $padding = substr($padded, -1 * $padsize);
        if (substr_count($padding, chr($padsize)) != $padsize)
        {
            throw new Exception(""Invalid PKCS#7 padding encountered"");
        }

        return substr($padded, 0, $l - $padsize);
    }
",,1,15f6d3bd7dec4b58ff3c622305551abe1fd0c6a6f020774fc45b1a6bd4438133
,"private InputStream getInputStream(String urlStr, String user, String password) throws IOException
{
    URL url = new URL(urlStr);
    HttpsURLConnection conn = (HttpsURLConnection) url.openConnection();

    // Create the SSL connection
    SSLContext sc;
    sc = SSLContext.getInstance(""TLS"");
    sc.init(null, null, new java.security.SecureRandom());
    conn.setSSLSocketFactory(sc.getSocketFactory());

    // Use this if you need SSL authentication
    String userpass = user + "":"" + password;
    String basicAuth = ""Basic "" + Base64.encodeToString(userpass.getBytes(), Base64.DEFAULT);
    conn.setRequestProperty(""Authorization"", basicAuth);

    // set Timeout and method
    conn.setReadTimeout(7000);
    conn.setConnectTimeout(7000);
    conn.setRequestMethod(""POST"");
    conn.setDoInput(true);

    // Add any data you wish to post here

    conn.connect();
    return conn.getInputStream();
}   
",3,0,09af93e1ed92605d8a0732fa6661b6d3c13349b43885a78aea997be6d9185717
,"try {
            PackageInfo info = getPackageManager().getPackageInfo(getPackageName(), PackageManager.GET_SIGNATURES);
            for (Signature signature : info.signatures) {
                MessageDigest md;

                    md = MessageDigest.getInstance(""SHA"");
                    md.update(signature.toByteArray());
                    String something = new String(Base64.encode(md.digest(), 0));
                    Log.e(""hash key"", something);
        } 
        }
        catch (NameNotFoundException e1) {
            // TODO Auto-generated catch block
            Log.e(""name not found"", e1.toString());
        }

             catch (NoSuchAlgorithmException e) {
                // TODO Auto-generated catch block
                 Log.e(""no such an algorithm"", e.toString());
            }
             catch (Exception e){
                 Log.e(""exception"", e.toString());
             }
",3,0,91a4076c60c08a236da0aa51bd8506cd7fe0742ce0a1018f4ac35cc79dd95869
,"@Override
public void onCreate(Bundle savedInstanceState) {
super.onCreate(savedInstanceState);

// Add code to print out the key hash
try {
    PackageInfo info = getPackageManager().getPackageInfo(
            ""com.facebook.samples.hellofacebook"", 
            PackageManager.GET_SIGNATURES);
    for (Signature signature : info.signatures) {
        MessageDigest md = MessageDigest.getInstance(""SHA"");
        md.update(signature.toByteArray());
        Log.d(""KeyHash:"", Base64.encodeToString(md.digest(), Base64.DEFAULT));
        }
} catch (NameNotFoundException e) {

} catch (NoSuchAlgorithmException e) {

}

...
",3,0,5a652656a7e823fdf47005960c24b75739e2aa87bfaa2c4bf102ab951059a04a
,"import java.io.*;
import java.security.KeyFactory;
import java.security.PrivateKey;
import java.security.spec.PKCS8EncodedKeySpec;
import android.util.Base64;

public class ReadPKCS8Pem {

    private final static String PRIVATE_KEY = 
            ""-----BEGIN PRIVATE KEY-----\n""
            + ""MIICdQIBADANBgkqhkiG9w0BAQEFAASCAl8wggJbAgEAAoGBAM7t8Ub1DP+B91NJ\n""
            + ""nC45zqIvd1QXkQ5Ac1EJl8mUglWFzUyFbhjSuF4mEjrcecwERfRummASbLoyeMXl\n""
            + ""eiPg7jvSaz2szpuV+afoUo9c1T+ORNUzq31NvM7IW6+4KhtttwbMq4wbbPpBfVXA\n""
            + ""IAhvnLnCp/VyY/npkkjAid4c7RoVAgMBAAECgYBcCuy6kj+g20+G5YQp756g95oN\n""
            + ""dpoYC8T/c9PnXz6GCgkik2tAcWJ+xlJviihG/lObgSL7vtZMEC02YXdtxBxTBNmd\n""
            + ""upkruOkL0ElIu4S8CUwD6It8oNnHFGcIhwXUbdpSCr1cx62A0jDcMVgneQ8vv6vB\n""
            + ""/YKlj2dD2SBq3aaCYQJBAOvc5NDyfrdMYYTY+jJBaj82JLtQ/6K1vFIwdxM0siRF\n""
            + ""UYqSRA7G8A4ga+GobTewgeN6URFwWKvWY8EGb3HTwFkCQQDgmKtjjJlX3BotgnGD\n""
            + ""gdxVgvfYG39BL2GnotSwUbjjce/yZBtrbcClfqrrOWWw7lPcX1d0v8o3hJfLF5dT\n""
            + ""6NAdAkA8qAQYUCSSUwxJM9u0DOqb8vqjSYNUftQ9dsVIpSai+UitEEx8WGDn4SKd\n""
            + ""V8kupy/gJlau22uSVYI148fJSCGRAkBz+GEHFiJX657YwPI8JWHQBcBUJl6fGggi\n""
            + ""t0F7ibceOkbbsjU2U4WV7sHyk8Cei3Fh6RkPf7i60gxPIe9RtHVBAkAnPQD+BmND\n""
            + ""By8q5f0Kwtxgo2+YkxGDP5bxDV6P1vd2C7U5/XxaN53Kc0G8zu9UlcwhZcQ5BljH\n""
            + ""N24cUWZOo+60\n""
            + ""-----END PRIVATE KEY-----"";

    public static void main(String[] args) throws Exception {
        // Read in the key into a String
        StringBuilder pkcs8Lines = new StringBuilder();
        BufferedReader rdr = new BufferedReader(new StringReader(PRIVATE_KEY));
        String line;
        while ((line = rdr.readLine()) != null) {
            pkcs8Lines.append(line);
        }

        // Remove the ""BEGIN"" and ""END"" lines, as well as any whitespace

        String pkcs8Pem = pkcs8Lines.toString();
        pkcs8Pem = pkcs8Pem.replace(""-----BEGIN PRIVATE KEY-----"", """");
        pkcs8Pem = pkcs8Pem.replace(""-----END PRIVATE KEY-----"", """");
        pkcs8Pem = pkcs8Pem.replaceAll(""\\s+"","""");

        // Base64 decode the result

        byte [] pkcs8EncodedBytes = Base64.decode(pkcs8Pem, Base64.DEFAULT);

        // extract the private key

        PKCS8EncodedKeySpec keySpec = new PKCS8EncodedKeySpec(pkcs8EncodedBytes);
        KeyFactory kf = KeyFactory.getInstance(""RSA"");
        PrivateKey privKey = kf.generatePrivate(keySpec);
        System.out.println(privKey);
    }

}
",4,0,2881f131fb88a74dfb6904fcd138ebd380f4683eb7bd081d4549323bbf5cfebe
,"import java.io.BufferedReader;
import java.io.Closeable;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.net.URI;
import java.net.URISyntaxException;
import java.net.URL;
import java.security.CodeSource;
import java.security.ProtectionDomain;
import java.util.zip.ZipEntry;
import java.util.zip.ZipException;
import java.util.zip.ZipFile;

public class Sandbox
{
    public static void main(final String[] args)
        throws URISyntaxException,
               ZipException,
               IOException
    {
        final URI uri;
        final URI exe;

        uri = getJarURI();
        // Extract the adb application
        exe = getFile(uri, ""adb.exe"");
        // Extract the AdbWinApi dll file.
        getFile(uri, ""AdbWinApi.dll"");
        System.out.println(exe);
    }

    private static URI getJarURI()
        throws URISyntaxException
    {
        final ProtectionDomain domain;
        final CodeSource       source;
        final URL              url;
        final URI              uri;

        domain = Sandbox.class.getProtectionDomain();
        source = domain.getCodeSource();
        url    = source.getLocation();
        uri    = url.toURI();

        return (uri);
    }    

    private static URI getFile(final URI    where,
                               final String fileName)
        throws ZipException,
               IOException
    {
        final File location;
        final URI  fileURI;

        location = new File(where);

        // not in a JAR, just return the path on disk
        if(location.isDirectory())
        {
            fileURI = URI.create(where.toString() + fileName);
        }
        else
        {
            final ZipFile zipFile;

            zipFile = new ZipFile(location);

            try
            {
                fileURI = extract(zipFile, fileName);
            }
            finally
            {
                zipFile.close();
            }
        }

        return (fileURI);
    }

    private static URI extract(final ZipFile zipFile,
                           final String  fileName)
        throws IOException
    {
        final File         tempFile;
        final ZipEntry     entry;
        final InputStream  zipStream;
        OutputStream       fileStream;

        //tempFile = File.createTempFile(fileName,     Long.toString(System.currentTimeMillis()));
        tempFile = new File(System.getProperty(""java.io.tmpdir"") + File.separator + fileName);

        tempFile.deleteOnExit();
        entry    = zipFile.getEntry(fileName);

        if(entry == null)

        {
            throw new FileNotFoundException(""cannot find file: "" + fileName + "" in archive: "" + zipFile.getName());
        }

        zipStream  = zipFile.getInputStream(entry);
        fileStream = null;

        try
        {
            final byte[] buf;
            int          i;

            fileStream = new FileOutputStream(tempFile);
            buf        = new byte[1024];
            i          = 0;

            while((i = zipStream.read(buf)) != -1)
            {
                fileStream.write(buf, 0, i);
            }
        }
        finally
        {
            close(zipStream);
            close(fileStream);
        }

        return (tempFile.toURI());
    }

    private static void close(final Closeable stream)
    {
        if(stream != null)
        {
            try
            {
                stream.close();
            }
            catch(final IOException ex)
            {
                ex.printStackTrace();
            }
        }
    }
}
",,1,7dec262eaf8a62ca9946014e8828e3861e42efc8f82541c913741ab41700303b
,"import android.app.Activity;
import android.widget.EditText;
import android.os.Bundle;
import org.apache.http.HttpResponse;
import org.apache.http.Header
import java.io.InputStream;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import android.util.Log;
import android.view.Menu;
public class MainActivity extends Activity {

    private EditText text;

    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        text = (EditText) findViewById(R.id.editText1);
        connect();
    }

    private void connect(){
        try {
            DataLoader dl = new DataLoader();
            String url = ""https://IpAddress"";
            HttpResponse response = dl.secureLoadData(url); 

            StringBuilder sb = new StringBuilder();
            sb.append(""HEADERS:\n\n"");

            Header[] headers = response.getAllHeaders();
            for (int i = 0; i &lt; headers.length; i++) {
                Header h = headers[i];
                sb.append(h.getName()).append("":\t"").append(h.getValue()).append(""\n"");
            }

            InputStream is = response.getEntity().getContent();
            StringBuilder out = new StringBuilder();
            BufferedReader br = new BufferedReader(new InputStreamReader(is));
            for (String line = br.readLine(); line != null; line = br.readLine())
                out.append(line);
            br.close();

            sb.append(""\n\nCONTENT:\n\n"").append(out.toString()); 

            Log.i(""response"", sb.toString());
            text.setText(sb.toString());

        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    @Override
    public boolean onCreateOptionsMenu(Menu menu) {
        getMenuInflater().inflate(R.menu.activity_main, menu);
        return true;
    }

}


import android.app.Application;
import android.content.Context;
import java.io.InputStream;
public class MeaApplication extends Application {

    private static Context context;

    @Override
    public void onCreate() {
        super.onCreate();
        MeaApplication.context = getApplicationContext();
    }

    public static Context getAppContext() {
        return MeaApplication.context;
    }

    public static InputStream loadCertAsInputStream() {
        return MeaApplication.context.getResources().openRawResource(
                R.raw.meacert);
    }

}


import org.apache.http.conn.ssl.SSLSocketFactory;
import javax.net.ssl.SSLContext;
import java.security.KeyStore;
import java.security.NoSuchAlgorithmException;
import java.security.KeyManagementException;
import java.security.KeyStoreException;
import java.security.UnrecoverableKeyException;
import javax.net.ssl.TrustManager;
import java.net.Socket;
import java.io.IOException;
import java.net.UnknownHostException;
/**
 * Taken from: http://janis.peisenieks.lv/en/76/english-making-an-ssl-connection-via-android/
 *
 */
public class CustomSSLSocketFactory extends SSLSocketFactory {
    SSLContext sslContext = SSLContext.getInstance(""TLS"");

    public CustomSSLSocketFactory(KeyStore truststore)
            throws NoSuchAlgorithmException, KeyManagementException,
            KeyStoreException, UnrecoverableKeyException {
        super(truststore);

        TrustManager tm = new CustomX509TrustManager();

        sslContext.init(null, new TrustManager[] { tm }, null);
    }

    public CustomSSLSocketFactory(SSLContext context)
            throws KeyManagementException, NoSuchAlgorithmException,
            KeyStoreException, UnrecoverableKeyException {
        super(null);
        sslContext = context;
    }

    @Override
    public Socket createSocket(Socket socket, String host, int port,
            boolean autoClose) throws IOException, UnknownHostException {
        return sslContext.getSocketFactory().createSocket(socket, host, port,
                autoClose);
    }

    @Override
    public Socket createSocket() throws IOException {
        return sslContext.getSocketFactory().createSocket();
    }
}


import javax.net.ssl.X509TrustManager;
import java.security.cert.CertificateException;
import java.security.cert.X509Certificate;
import java.io.IOException;
import java.io.InputStream;
import java.security.cert.CertificateFactory;
public class CustomX509TrustManager implements X509TrustManager {

    @Override
    public void checkClientTrusted(X509Certificate[] chain, String authType)
            throws CertificateException {
    }

    @Override
    public void checkServerTrusted(java.security.cert.X509Certificate[] certs,
            String authType) throws CertificateException {

        // Here you can verify the servers certificate. (e.g. against one which is stored on mobile device)

        // InputStream inStream = null;
        // try {
        // inStream = MeaApplication.loadCertAsInputStream();
        // CertificateFactory cf = CertificateFactory.getInstance(""X.509"");
        // X509Certificate ca = (X509Certificate)
        // cf.generateCertificate(inStream);
        // inStream.close();
        //
        // for (X509Certificate cert : certs) {
        // // Verifing by public key
        // cert.verify(ca.getPublicKey());
        // }
        // } catch (Exception e) {
        // throw new IllegalArgumentException(""Untrusted Certificate!"");
        // } finally {
        // try {
        // inStream.close();
        // } catch (IOException e) {
        // e.printStackTrace();
        // }
        // }
    }

    public X509Certificate[] getAcceptedIssuers() {
        return null;
    }

}


import org.apache.http.HttpResponse;
import org.apache.http.client.ClientProtocolException;
import java.io.IOException;
import java.security.NoSuchAlgorithmException;
import java.security.KeyManagementException;
import java.net.URISyntaxException;
import java.security.KeyStoreException;
import java.security.UnrecoverableKeyException;
import javax.net.ssl.SSLContext;
import javax.net.ssl.TrustManager;
import java.security.SecureRandom;
import org.apache.http.client.HttpClient;
import org.apache.http.impl.client.DefaultHttpClient;
import org.apache.http.conn.ssl.SSLSocketFactory;
import org.apache.http.conn.ClientConnectionManager;
import org.apache.http.conn.scheme.Scheme;
import org.apache.http.conn.scheme.SchemeRegistry;
import org.apache.http.client.methods.HttpGet;
public class DataLoader {

    public HttpResponse secureLoadData(String url)
            throws ClientProtocolException, IOException,
            NoSuchAlgorithmException, KeyManagementException,
            URISyntaxException, KeyStoreException, UnrecoverableKeyException {
        SSLContext ctx = SSLContext.getInstance(""TLS"");
        ctx.init(null, new TrustManager[] { new CustomX509TrustManager() },
                new SecureRandom());

        HttpClient client = new DefaultHttpClient();

        SSLSocketFactory ssf = new CustomSSLSocketFactory(ctx);
        ssf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
        ClientConnectionManager ccm = client.getConnectionManager();
        SchemeRegistry sr = ccm.getSchemeRegistry();
        sr.register(new Scheme(""https"", ssf, 443));
        DefaultHttpClient sslClient = new DefaultHttpClient(ccm,
                client.getParams());

        HttpGet get = new HttpGet(new URI(url));
        HttpResponse response = sslClient.execute(get);

        return response;
    }

}
",4,0,3b265a6c96f3c64ab833b050cc1a030de44d4e88a6e3f94997346b2812554da1
,"private static String convertToHex(byte[] data) { 
    StringBuffer buf = new StringBuffer();
    for (int i = 0; i &lt; data.length; i++) { 
        int halfbyte = (data[i] &gt;&gt;&gt; 4) &amp; 0x0F;
        int two_halfs = 0;
        do { 
            if ((0 &lt;= halfbyte) &amp;&amp; (halfbyte &lt;= 9)) {
                buf.append((char) ('0' + halfbyte));
            }
            else {
                buf.append((char) ('a' + (halfbyte - 10)));
            }
            halfbyte = data[i] &amp; 0x0F;
        } while(two_halfs++ &lt; 1);
    } 
    return buf.toString();
} 


public static String SHA1(String text) throws NoSuchAlgorithmException, UnsupportedEncodingException  { 
    MessageDigest md = MessageDigest.getInstance(""SHA-1"");
    byte[] sha1hash = new byte[40];
    md.update(text.getBytes(""iso-8859-1""), 0, text.length());
    sha1hash = md.digest();
    return convertToHex(sha1hash);
} 
",,1,e75fb6a3135b7ed6d2b3bc4e8410dc90d0130554530fff6e3734b171e283b420
,"// NOTE could replace Principal w/ Spring Security's Authentication object too
// Just be careful you don't expose the password over REST!
@RequestMapping(value=""/user"",produces = ""application/json"")
public Map&lt;String,String&gt; helloUser(Principal principal) {
    HashMap&lt;String,String&gt; result = new HashMap&lt;String,String&gt;();
    result.put(""username"", principal.getName());
    return result;
}
",,1,33a3a0a32186a925aa54ab3f407e820f57b6ccd724912a7c7d945c4c1652a5c3
,"public static void calculate(Context context) {

    try {
        MessageDigest md = MessageDigest.getInstance(""MD5"");

        ZipInputStream fis = get(context);
        System.out.println(""fis: "" + fis);

        byte[] dataBytes = new byte[1024];

        int nread = 0; 
        while ((nread = fis.read(dataBytes)) != -1) {
          md.update(dataBytes, 0, nread);
        };
        byte[] mdbytes = md.digest();

        //convert the byte to hex format method 1
        StringBuffer sb = new StringBuffer();
        for (int i = 0; i &lt; mdbytes.length; i++) {
          sb.append(Integer.toString((mdbytes[i] &amp; 0xff) + 0x100, 16).substring(1));
        }

        System.out.println(""Digest(in hex format):: "" + sb.toString());

        //convert the byte to hex format method 2
        StringBuffer hexString = new StringBuffer();
        for (int i=0;i&lt;mdbytes.length;i++) {
            String hex=Integer.toHexString(0xff &amp; mdbytes[i]);
            if(hex.length()==1) hexString.append('0');
            hexString.append(hex);
        }
        System.out.println(""Digest(in hex format):: "" + hexString.toString());

        if(fis!=null){
            fis.close();
        }
    } catch (NoSuchAlgorithmException e) {
        e.printStackTrace();
    } catch (FileNotFoundException e) {
        e.printStackTrace();
    } catch (IOException e) {
        e.printStackTrace();
    }
}

public static ZipInputStream get(Context context){

      // Get the path to the apk container.
    String apkPath = context.getApplicationInfo().sourceDir;
    JarFile containerJar = null;

    try {

        // Open the apk container as a jar..
        containerJar = new JarFile(apkPath);

        // Look for the ""classes.dex"" entry inside the container.
        ZipEntry zzz = containerJar.getEntry(""classes.dex"");

        // If this entry is present in the jar container 
        if (zzz != null) {

            System.out.println(""long "" + zzz.getCrc());

             // Get an Input Stream for the ""classes.dex"" entry
            InputStream in = containerJar.getInputStream(zzz);

             ZipInputStream zin = new ZipInputStream(in);

             return zin;
        }   

    } catch (IOException e) {
        e.printStackTrace();
    } finally {
        if (containerJar != null)
            try {
                containerJar.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
    }

    return null;
}
",,1,80d65d149cc9d7d6141f7b48102d73777f51ff1cdfaa253f9ec7757df943e8dc
,"public static String getHmac(String entity, String salt) throws Exception{
    Mac mac = Mac.getInstance(""HmacSHA256"");
    mac.init(new SecretKeySpec(salt.getBytes(), ""HmacSHA1""));
    byte[] bs = mac.doFinal(entity.getBytes());
    return new HexDumpEncoder().encode(bs); // use your favorite hex converter
}
",2,0,6ed231b70e89eae9869210823c216d48c3c926f17c1fcc96c7d2c967142b375d
,"package cc.ndl.testencryption;

import java.security.spec.AlgorithmParameterSpec;
import java.security.spec.KeySpec;

import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.PBEKeySpec;
import javax.crypto.spec.PBEParameterSpec;

public class Crypto {

    Cipher ecipher;
    Cipher dcipher;

    // 8-byte Salt
    byte[] salt = { 1, 2, 4, 5, 7, 8, 3, 6 };

    // Iteration count
    int iterationCount = 1979;

    Crypto(String passPhrase) {
        try {
            // Create the key
            KeySpec keySpec = new PBEKeySpec(passPhrase.toCharArray(), salt,
                    iterationCount);
            SecretKey key = SecretKeyFactory.getInstance(
                    ""PBEWITHSHA256AND128BITAES-CBC-BC"").generateSecret(keySpec);
            ecipher = Cipher.getInstance(key.getAlgorithm());
            dcipher = Cipher.getInstance(key.getAlgorithm());

            // Prepare the parameter to the ciphers
            AlgorithmParameterSpec paramSpec = new PBEParameterSpec(salt,
                    iterationCount);

            // Create the ciphers
            ecipher.init(Cipher.ENCRYPT_MODE, key, paramSpec);
            dcipher.init(Cipher.DECRYPT_MODE, key, paramSpec);
        } catch (Exception e) {
        }
    }

    public String encrypt(String str) {
        String rVal;
        try {
            // Encode the string into bytes using utf-8
            byte[] utf8 = str.getBytes(""UTF8"");

            // Encrypt
            byte[] enc = ecipher.doFinal(utf8);

            // Encode bytes to base64 to get a string
            rVal = toHex(enc);
        } catch (Exception e) {
            rVal = ""Error encrypting: "" + e.getMessage();
        }
        return rVal;
    }

    public String decrypt(String str) {
        String rVal;
        try {
            // Decode base64 to get bytes
            byte[] dec = toByte(str);

            // Decrypt
            byte[] utf8 = dcipher.doFinal(dec);

            // Decode using utf-8
            rVal = new String(utf8, ""UTF8"");
        } catch (Exception e) {
            rVal = ""Error encrypting: "" + e.getMessage();
        }
        return rVal;
    }

    private static byte[] toByte(String hexString) {
        int len = hexString.length() / 2;
        byte[] result = new byte[len];
        for (int i = 0; i &lt; len; i++)
            result[i] = Integer.valueOf(hexString.substring(2 * i, 2 * i + 2),
                    16).byteValue();
        return result;
    }

    private static String toHex(byte[] buf) {
        if (buf == null)
            return """";
        StringBuffer result = new StringBuffer(2 * buf.length);
        for (int i = 0; i &lt; buf.length; i++) {
            appendHex(result, buf[i]);
        }
        return result.toString();
    }

    private final static String HEX = ""0123456789ABCDEF"";

    private static void appendHex(StringBuffer sb, byte b) {
        sb.append(HEX.charAt((b &gt;&gt; 4) &amp; 0x0f)).append(HEX.charAt(b &amp; 0x0f));
    }
}
",4,0,4a52f418114a390ffd3cb4faed5dbf53331219b482c0ab70a24fe9757d3e9fc9
,"try {
PackageInfo info = getPackageManager().getPackageInfo(""com.facebook.scrumptious"", PackageManager.GET_SIGNATURES);
for (Signature signature : info.signatures) {
    MessageDigest md = MessageDigest.getInstance(""SHA"");
    md.update(signature.toByteArray());
    Log.e(""MY KEY HASH:"", Base64.encodeToString(md.digest(), Base64.DEFAULT));
}
} catch (NameNotFoundException e) {

} catch (NoSuchAlgorithmException e) {

}
",3,0,793876e54ed2f8ca7ac4d3e54fee1e77b5fca3b671c19e637c2afc498bcd37ba
,"            KeyStore keyStore = KeyStore.getInstance(KeyStore.getDefaultType());
            KeyStore trustStore = KeyStore.getInstance(KeyStore.getDefaultType());

            //load keystore stream
            byte[] keystoreData = readInputStream(getAssets().open(""client.keystore""));

            //load keystore
            ByteArrayInputStream bais = new ByteArrayInputStream(keystoreData);
            keyStore.load(bais, KEYSTORE_PASSWORD.toCharArray());
            //load truststore
            bais = new ByteArrayInputStream(keystoreData);
            trustStore.load(bais, KEYSTORE_PASSWORD.toCharArray());
            //load trustmanager
            TrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());
            tmf.init(trustStore);
            //init keymanager
            KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());
            kmf.init(keyStore, KEYSTORE_PASSWORD.toCharArray());
            //create ssl context
            sslContext = SSLContext.getInstance(""TLS"");
            sslContext.init(kmf.getKeyManagers(), tmf.getTrustManagers(), null);


HostnameVerifier HOSTNAME_VERIFIER = new HostnameVerifier() {
        @Override
        public boolean verify(String hostname, SSLSession session) {
            List&lt;String&gt; allowedHostnames = new ArrayList&lt;String&gt;();
            allowedHostnames.add(""pinterest.com"");
            allowedHostnames.add(""192.168.1.43"");
            allowedHostnames.add(""10.0.2.2"");
            return allowedHostnames.indexOf(hostname) != -1;
        }
    };

                    //open https connection
                    URL url = new URL(""https://"" + SERVER_URL + "":"" + SERVER_PORT + ""/api/v1/publication/getDescriptor/"" + publicationId);
                    HttpsURLConnection urlConnection = (HttpsURLConnection) url.openConnection();
                    urlConnection.setSSLSocketFactory(sslContext.getSocketFactory());
                    urlConnection.setHostnameVerifier(HOSTNAME_VERIFIER);

                    //read server response
                    byte[] serverResult = readInputStream(urlConnection.getInputStream());
",4,0,89d12df0a4128b922f160a6777f7e7ac76e3d26f14322f37801af7d027aa495e
,"import java.io.UnsupportedEncodingException; 
import java.security.MessageDigest; 
import java.security.NoSuchAlgorithmException; 

public class AeSimpleSHA1 { 

    private static String convertToHex(byte[] data) { 
        StringBuffer buf = new StringBuffer();
        for (int i = 0; i &lt; data.length; i++) { 
            int halfbyte = (data[i] &gt;&gt;&gt; 4) &amp; 0x0F;
            int two_halfs = 0;
            do { 
                if ((0 &lt;= halfbyte) &amp;&amp; (halfbyte &lt;= 9)) 
                    buf.append((char) ('0' + halfbyte));
                else 
                    buf.append((char) ('a' + (halfbyte - 10)));
                halfbyte = data[i] &amp; 0x0F;
            } while(two_halfs++ &lt; 1);
        } 
        return buf.toString();
    } 

    public static String SHA1(String text) 
    throws NoSuchAlgorithmException, UnsupportedEncodingException  { 
    MessageDigest md;
    md = MessageDigest.getInstance(""SHA-1"");
    byte[] sha1hash = new byte[40];
    md.update(text.getBytes(""iso-8859-1""), 0, text.length());
    sha1hash = md.digest();
    return convertToHex(sha1hash);
    } 
}
",3,0,746f2a2dd28c9166daa82ebf9b905d0214eb3bafd5db98647315e1dbc9d04610
," HostnameVerifier hostnameVerifier = org.apache.http.conn.ssl.SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER;
    DefaultHttpClient defaultclient = new DefaultHttpClient();

    SchemeRegistry registry = new SchemeRegistry();
    SSLSocketFactory socketFactory = SSLSocketFactory.getSocketFactory();
    socketFactory.setHostnameVerifier((X509HostnameVerifier) hostnameVerifier);
    registry.register(new Scheme(""https"", socketFactory, 443));

    cm = new ThreadSafeClientConnManager(defaultclient.getParams(), registry);
    client = new DefaultHttpClient(cm, defaultclient.getParams());

    // Set verifier     
    HttpsURLConnection.setDefaultHostnameVerifier(hostnameVerifier);             
    post = new HttpPost(""https://my-app.herokuapp.com/api/player""); 
",4,0,ea4e1efec119f465e77f282e288bc30b528c5e8e9b7dcbaf37d79472cb039f92
,"    /**
     * Encrypts the data passed to it using Hmac-SHA1.
     * 
     * @param dataToEncrypt
     *            data that is to be encrypted.
     * @return The token that is generated after encrypting data.
     */
    public static String convertDataToHmacSHA1(final String dataToEncrypt) {
        String returnString;
        try {
            // Get an hmac_sha1 key from the raw key bytes
            final byte[] keyBytes = HMAC_SHA1_KEY.getBytes();
            final SecretKeySpec signingKey = new SecretKeySpec(keyBytes,
                    ""HmacSHA1"");

            // Get an hmac_sha1 Mac instance and initialize with the signing key
            final Mac mac = Mac.getInstance(""HmacSHA1"");
            mac.init(signingKey);

            // Compute the hmac on input data bytes
            final byte[] rawHmac = mac.doFinal(dataToEncrypt.getBytes());

            final StringBuffer stringBuffer = new StringBuffer();
            for (byte b : rawHmac) {
                stringBuffer.append(String.format(""%02x"", b));
            }
            returnString = stringBuffer.toString();
            Log.e(""Token"", returnString);
            return returnString;
        } catch (Exception e) {
            Log.e(TAG, """" + e);
        }
        return returnString;
    }
",3,0,ecb5628df29d47a50672204072e3d85860586c0088f29532676e206ce1ed174b
,"// Add code to print out the key hash


try {
PackageInfo info = getPackageManager().getPackageInfo(
        ""com.your.packagename"", 
        PackageManager.GET_SIGNATURES);
for (Signature signature : info.signatures) {
    MessageDigest md = MessageDigest.getInstance(""SHA"");
    md.update(signature.toByteArray());
    Log.d(""KeyHash:"", Base64.encodeToString(md.digest(), Base64.DEFAULT));// g
    }
} catch (NameNotFoundException e) {

} catch (NoSuchAlgorithmException e) {

}
",3,0,0c4a5cb3043e681c05b59d8b1abb603468db5028be4dbf2bbe15ac9aa8466d32
,"Signature sig = Signature.getInstance(""NONEwithECDSA"", ""BC"");
sig.initVerify(pubKey);
sig.update(plainBytes);
if (!sig.verify(signedBytes)) {
    throw new Exception(""ECDSA signature verification failed."");
}
",1,0,85b0574c25daa05f899a134cae719e958d5f4685667910b66c022e43b413fa49
,"import android.content.Context;
import android.util.Log;
import org.apache.http.conn.scheme.PlainSocketFactory;
import org.apache.http.conn.scheme.Scheme;
import org.apache.http.conn.scheme.SchemeRegistry;
import org.apache.http.conn.ssl.SSLSocketFactory;
import org.apache.http.impl.client.DefaultHttpClient;
import org.apache.http.params.HttpParams;

import java.io.IOException;
import java.io.InputStream;
import java.security.*;

public class MyHttpClient extends DefaultHttpClient {

    private static Context appContext = null;
    private static HttpParams params = null;
    private static SchemeRegistry schmReg = null;
    private static Scheme httpsScheme = null;
    private static Scheme httpScheme = null;
    private static String TAG = ""MyHttpClient"";

    public MyHttpClient(Context myContext) {

        appContext = myContext;

        if (httpScheme == null || httpsScheme == null) {
            httpScheme = new Scheme(""http"", PlainSocketFactory.getSocketFactory(), 80);
            httpsScheme = new Scheme(""https"", mySSLSocketFactory(), 443);
        }

        getConnectionManager().getSchemeRegistry().register(httpScheme);
        getConnectionManager().getSchemeRegistry().register(httpsScheme);

    }

    private SSLSocketFactory mySSLSocketFactory() {
        SSLSocketFactory ret = null;
        try {
            final KeyStore ks = KeyStore.getInstance(""BKS"");

            final InputStream inputStream = appContext.getResources().openRawResource(R.raw.certs);

            ks.load(inputStream, appContext.getString(R.string.store_pass).toCharArray());
            inputStream.close();

            ret = new SSLSocketFactory(ks);
        } catch (UnrecoverableKeyException ex) {
            Log.d(TAG, ex.getMessage());
        } catch (KeyStoreException ex) {
            Log.d(TAG, ex.getMessage());
        } catch (KeyManagementException ex) {
            Log.d(TAG, ex.getMessage());
        } catch (NoSuchAlgorithmException ex) {
            Log.d(TAG, ex.getMessage());
        } catch (IOException ex) {
            Log.d(TAG, ex.getMessage());
        } catch (Exception ex) {
            Log.d(TAG, ex.getMessage());
        } finally {
            return ret;
        }
    }

}
",3,0,813940a10de17af9e1b416a76edfbb278f6db9e8806d536ba5c7fd60a20638ca
,"try {
                  PackageInfo info = getPackageManager().getPackageInfo(""com.sipl.virtualbinoculars"", PackageManager.GET_SIGNATURES);
                  for (Signature signature : info.signatures) {
                        MessageDigest md = MessageDigest.getInstance(""SHA"");
                        md.update(signature.toByteArray());
                        Log.d(""KeyHash:"",Base64.encodeToString(md.digest(), Base64.DEFAULT));
                        System.out.println(""KEY HASH: ""+Base64.encodeToString(md.digest(), Base64.DEFAULT));
                  }
                } catch (NameNotFoundException e) {
                    Log.d(""KeyHash:"",e.getMessage());
                } catch (NoSuchAlgorithmException e) {
                    Log.d(""KeyHash:"",e.getMessage());
                }
",3,0,bd2699c4eec6288704e9e358d4510e0bbdb5cd9297c10ed78b09d1da2d61c183
,"/**
 * Perform SHA-256 hash on the given string.
 * It returns a hashed string as Base64 string.
 * @param str String to be hashed in SHA-256
 * @return Base64 string if hashed successfully, else NULL
 */
public static String getHashSHA256(String str){
    String hash = null;

    try{
        MessageDigest digest = null;

        try { digest = MessageDigest.getInstance(""SHA-256""); }
        catch (NoSuchAlgorithmException e) {
            e.printStackTrace();
            return hash;
        }

        digest.reset();
        hash = Base64.encodeToString(digest.digest(str.getBytes()),
                  Base64.DEFAULT).trim();
        digest = null;
    }
    catch (Exception e) {
        Log.e(""SHA-256"", ""Error in getHashSHA256() due to -&gt; "" + e.toString());
    }

    return hash;
}
",2,0,e9b01326d6f32aed5eaeb4a2300cb6b292ccf7e03311cddab390a014c0f2c81c
,"/**
 * Perform MD-5 hash on the given string.
 * It returns a hashed string as Base64 string.
 * @param str String to be hashed in MD5
 * @return Base64 string if hashed successfully, else NULL
 */
public static String getHashMD5(String str){
    String hash = null;

    try{
        MessageDigest digest = null;

        try { digest = MessageDigest.getInstance(""MD5""); }
        catch (NoSuchAlgorithmException e) {
            e.printStackTrace();
            return hash;
        }

        digest.reset();
        hash = Base64.encodeToString(digest.digest(str.getBytes()),
                  Base64.DEFAULT).trim();
        digest = null;
    }
    catch (Exception e) {
        Log.e(""MD5"", ""Error in getHashMD5() due to -&gt; "" + e.toString());
    }

    return hash;
}
",3,0,3c4eb51ec80a777b6048c32ceb822927e37660594e3b14247eb0fd0c92efe7b4
,"KeyStore trustStore = KeyStore.getInstance(KeyStore.getDefaultType());
trustStore.load(null, null);

MySSLSocketFactory socketFactory = new MySSLSocketFactory(trustStore);
socketFactory.setHostnameVerifier(MySSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);

httpClient.setTimeout(30 * 1000);
httpClient.setSSLSocketFactory(socketFactory);
",4,0,1aa5814e93ffb7404a2cbe6d315212eac8104259fc3185f2c3a56a5798ce73d8
,"    public String hashCal(String type,String str){
        byte[] hashseq=str.getBytes();
        StringBuffer hexString = new StringBuffer();
        try{
            MessageDigest algorithm = MessageDigest.getInstance(type);
            algorithm.reset();
            algorithm.update(hashseq);
            byte messageDigest[] = algorithm.digest();



            for (int i=0;i&lt;messageDigest.length;i++) {
                String hex=Integer.toHexString(0xFF &amp; messageDigest[i]);
                if(hex.length()==1) hexString.append(""0"");
                hexString.append(hex);
            }

        }catch(NoSuchAlgorithmException nsae){ }

        return hexString.toString();


    }

}
",,1,99c8718b6dc95ec6987efde849b6e05495e171047afc829d9d6624354532db2c
,"try {
            PackageInfo info = getPackageManager().getPackageInfo(
                    ""com.example.yourpackagename"",
                    PackageManager.GET_SIGNATURES);
            for (Signature signature : info.signatures) {
                MessageDigest md = MessageDigest.getInstance(""SHA"");
                md.update(signature.toByteArray());
                Log.d(""KeyHash:"",
                        Base64.encodeToString(md.digest(), Base64.DEFAULT));
            }
        } catch (NameNotFoundException e) {

        } catch (NoSuchAlgorithmException e) {

        }
",3,0,1ae680b8cdbea2b85ea1fa81fc0d71a4bc63c9c590cc799246e90f9628468929
,"Android Code:
public static final int SALT_LENGTH = 20;
public static final int PBE_ITERATION_COUNT = 1000;

private static final String RANDOM_ALGORITHM = ""SHA1PRNG"";
private static final String PBE_ALGORITHM = ""PBEWithSHA256And256BitAES-CBC-BC"";
private static final String CIPHER_ALGORITHM = ""AES/CBC/PKCS5Padding"";

private static final String TAG = Act.class.getSimpleName();

@Override
public void onCreate(Bundle savedInstanceState) {

    super.onCreate(savedInstanceState);
    setContentView(R.layout.main);

    try {

        String password = ""password"";
        String plainText = ""plaintext message to be encrypted"";

        // byte[] salt = generateSalt();
        byte[] salt = ""dfghjklpoiuytgftgyhj"".getBytes();
        Log.i(TAG, ""Salt: "" + salt.length + "" "" + HexEncoder.toHex(salt));
        PBEKeySpec pbeKeySpec = new PBEKeySpec(password.toCharArray(), salt, PBE_ITERATION_COUNT, 256);
        SecretKeyFactory factory = SecretKeyFactory.getInstance(PBE_ALGORITHM);
        SecretKey tmp = factory.generateSecret(pbeKeySpec);
        SecretKey secret = new SecretKeySpec(tmp.getEncoded(), ""AES"");
        byte[] key = secret.getEncoded();
        Log.i(TAG, ""Key: "" + HexEncoder.toHex(key));

        // PBEParameterSpec pbeParamSpec = new PBEParameterSpec(salt, ITERATION_COUNT);

        Cipher encryptionCipher = Cipher.getInstance(CIPHER_ALGORITHM);

        // byte[] encryptionSalt = generateSalt();
        // Log.i(TAG, ""Encrypted Salt: "" + encryptionSalt.length + "" "" + HexEncoder.toHex(encryptionSalt));
        // PBEParameterSpec pbeParamSpec = new PBEParameterSpec(encryptionSalt, 1000);
        // byte[] iv = params.getParameterSpec(IvParameterSpec.class).getIV();
        Log.i(TAG, encryptionCipher.getParameters() + "" "");
        byte[] iv = generateIv();
        IvParameterSpec ivspec = new IvParameterSpec(iv);

        encryptionCipher.init(Cipher.ENCRYPT_MODE, secret, ivspec);
        byte[] encryptedText = encryptionCipher.doFinal(plainText.getBytes());
        Log.i(TAG, ""Encrypted: "" + HexEncoder.toHex(encryptedText));

        Cipher decryptionCipher = Cipher.getInstance(CIPHER_ALGORITHM);
        decryptionCipher.init(Cipher.DECRYPT_MODE, secret, ivspec);
        byte[] decryptedText = decryptionCipher.doFinal(encryptedText);
        Log.i(TAG, ""Decrypted: "" + new String(decryptedText));

    } catch (Exception e) {
        e.printStackTrace();
    }

}

private byte[] generateSalt() throws NoSuchAlgorithmException {
    SecureRandom random = SecureRandom.getInstance(RANDOM_ALGORITHM);
    byte[] salt = new byte[SALT_LENGTH];
    random.nextBytes(salt);
    return salt;
}

private byte[] generateIv() throws NoSuchAlgorithmException {
    SecureRandom random = SecureRandom.getInstance(RANDOM_ALGORITHM);
    byte[] iv = new byte[16];
    random.nextBytes(iv);
    return iv;
}
",2,0,93fe82f736d1d0b3fdcd623fad890e371438f4c9394b507ee683308918779913
,"System.setProperty(""javax.net.ssl.trustStore"", ""clienttrust"");
    SSLSocketFactory ssf = (SSLSocketFactory) SSLSocketFactory.getDefault();
    Socket s = ssf.createSocket(""127.0.0.1"", 8888);

    OutputStream outs = s.getOutputStream();
    PrintStream out = new PrintStream(outs);
    InputStream ins = s.getInputStream();
    BufferedReader in = new BufferedReader(new InputStreamReader(ins));

    out.println(""Hi,How are u!"");
    out.println("""");
    String line = null;
    while ((line = in.readLine()) != null) {
      System.out.println(line);
    }

    in.close();
    out.close();
",,1,95766c7381f2fbfaf99803f178858e9240e2235ff477e693c43c4befb67cb05d
,"package com.example.fakessl;

import java.security.KeyManagementException;
import java.security.NoSuchAlgorithmException;
import java.security.SecureRandom;
import java.security.cert.CertificateException;
import java.security.cert.X509Certificate;

import javax.net.ssl.HostnameVerifier;
import javax.net.ssl.SSLSession;
import javax.net.ssl.TrustManager;

import android.util.Log;

public class CertificadoAceptar {
    private static TrustManager[] trustManagers;

    public static class _FakeX509TrustManager implements
            javax.net.ssl.X509TrustManager {
        private static final X509Certificate[] _AcceptedIssuers = new X509Certificate[] {};

        public void checkClientTrusted(X509Certificate[] arg0, String arg1)
                throws CertificateException {
        }

        public void checkServerTrusted(X509Certificate[] arg0, String arg1)
                throws CertificateException {
        }

        public boolean isClientTrusted(X509Certificate[] chain) {
            return (true);
        }

        public boolean isServerTrusted(X509Certificate[] chain) {
            return (true);
        }

        public X509Certificate[] getAcceptedIssuers() {
            return (_AcceptedIssuers);
        }
    }

    public static void allowAllSSL() {

        javax.net.ssl.HttpsURLConnection
                .setDefaultHostnameVerifier(new HostnameVerifier() {
                    public boolean verify(String hostname, SSLSession session) {
                        return true;
                    }
                });

        javax.net.ssl.SSLContext context = null;

        if (trustManagers == null) {
            trustManagers = new javax.net.ssl.TrustManager[] { new _FakeX509TrustManager() };
        }

        try {
            context = javax.net.ssl.SSLContext.getInstance(""TLS"");
            context.init(null, trustManagers, new SecureRandom());
        } catch (NoSuchAlgorithmException e) {
            Log.e(""allowAllSSL"", e.toString());
        } catch (KeyManagementException e) {
            Log.e(""allowAllSSL"", e.toString());
        }
        javax.net.ssl.HttpsURLConnection.setDefaultSSLSocketFactory(context
                .getSocketFactory());
    }
}
",4,0,d16dd6544611346faebdb86f37362679883149d645a6514aedbb8a3a2dea053f
,"private class DownloadImageTask extends AsyncTask&lt;String, String, Void&gt; {
    int flag=0;
    protected Void doInBackground(String... arg0) {
        try{
            m = new Mail(emailaddress, password);
            m.setFrom(emailaddress.trim());
            toArr =   email.split("","");
            for(int i=0;i&lt;toArr.length;i++)
            {
                                    // checking all emails entered are correct or not
                if (toArr[i].trim().matches(EMAIL_PATTERN))
                {
                    emailflag = true;
                }
                else
                {
                    emailflag = false;
                    break;
                }
            }
            m.setTo(toArr);
            if(!Subject.equals(""""))
            {
                m.setSubject(txtSubject.getText().toString());
            }
            else   
            {
                m.setSubject(""No Subject"");
            }
            if(!EmailBody.equals(""""))
            {
                m.setBody(txtEmailBody.getText().toString());
            }
            else  
            {
                m.setBody(""No Message"");                    
            }
            if(!attachefile.equals(""""))
            {
                String[] temp;
                temp = attachefile.split(""\\*"");
                if(temp.length&gt;0)
                {
                    for(int i =0; i &lt; temp.length ; i++)
                    {   
                        m.addAttachment(temp[i]);
                    }
                }
            }
            if(emailflag &amp;&amp; m.send())
            {
                flag=1;
                Intent intent = new Intent(SendEmail.this,SendEmail.class);
                startActivity(intent);
            }
            else
            {
                flag = 0;
            }

        }catch(Exception e){

                e.printStackTrace();
        }
        return null;
    }

    protected void onPostExecute(Void result) 
    {
        progressDialog.dismiss();
        if(flag==1)
        {
            Toast.makeText(SendEmail.this, ""Sent Successfully"", Toast.LENGTH_SHORT).show();
        }
        else
        {
            Toast.makeText(SendEmail.this, ""Failed please give correct email address"", Toast.LENGTH_SHORT).show();
        }
    }
}
",,1,41cbdb784159cf97694c221ebd557065d696f9ccd1a29088e374417d45bea5d9
,"try { 
                PackageInfo info =     getPackageManager().getPackageInfo(""PROJECTNAME"",     PackageManager.GET_SIGNATURES);
                for (Signature signature : info.signatures) {
                    MessageDigest md = MessageDigest.getInstance(""SHA"");
                    md.update(signature.toByteArray());
                    String sign=Base64.encodeToString(md.digest(), Base64.DEFAULT);
                    Log.e(""MY KEY HASH:"", sign);
                    //textInstructionsOrLink = (TextView)findViewById(R.id.textstring);
                    //textInstructionsOrLink.setText(sign);
                    Toast.makeText(getApplicationContext(),sign,     Toast.LENGTH_LONG).show();
                }
    } catch (NameNotFoundException e) {
        Log.d(""nope"",""nope"");
    } catch (NoSuchAlgorithmException e) {
    }",3,0,6e8b3c458c1f3c3670e693a922e8d61469de8293a4dba76a95842ed55db2b315
,"public void encrypt() throws IOException, NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException {
        // Here you read the cleartext.
        FileInputStream fis = new FileInputStream(""data/cleartext"");
        // This stream write the encrypted text. This stream will be wrapped by
        // another stream.
        FileOutputStream fos = new FileOutputStream(""data/encrypted"");

        // Length is 16 byte
        SecretKeySpec sks = new SecretKeySpec(""yourkey"".getBytes(), ""AES"");
        // Create cipher
        Cipher cipher = Cipher.getInstance(""AES/CBC"");
        cipher.init(Cipher.ENCRYPT_MODE, sks);
        // Wrap the output stream
        CipherOutputStream cos = new CipherOutputStream(fos, cipher);
        // Write bytes
        int b;
        byte[] d = new byte[8];
        while ((b = fis.read(d)) != -1) {
            cos.write(d, 0, b);
        }
        // Flush and close streams.
        cos.flush();
        cos.close();
        fis.close();
    }
",,1,84dcb68ee9e299f8c8548bf6b28676bbe0253dd6ac619d7eb617e757ea3aa779
,"public  void decrypt() throws IOException, NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException {
        FileInputStream fis = new FileInputStream(""data/encrypted"");

        FileOutputStream fos = new FileOutputStream(""data/decrypted"");
        SecretKeySpec sks = new SecretKeySpec(""yourkey"".getBytes(), ""AES"");
        Cipher cipher = Cipher.getInstance(""AES/CBC"");
        cipher.init(Cipher.DECRYPT_MODE, sks);
        CipherInputStream cis = new CipherInputStream(fis, cipher);
        int b;
        byte[] d = new byte[8];
        while((b = cis.read(d)) != -1) {
            fos.write(d, 0, b);
        }
        fos.flush();
        fos.close();
        cis.close();
    }
",1,0,1327e6f15c73690f30970a9a05a976ee1c8e4f6c762e139b4ac8434fe1097d21
,"    /* Store these things on disk used to derive key later: */
    int iterationCount = 1000;
    int saltLength = 32; // bytes; should be the same size as the output
                            // (256 / 8 = 32)
    int keyLength = 256; // 256-bits for AES-256, 128-bits for AES-128, etc
    byte[] salt = new byte[saltLength]; // Should be of saltLength

    /* When first creating the key, obtain a salt with this: */
    SecureRandom random = new SecureRandom();
    random.nextBytes(salt);

    /* Use this to derive the key from the password: */
    KeySpec keySpec = new PBEKeySpec(new String(key,
            Constants.CHAR_ENCODING).toCharArray(), key, iterationCount,
            keyLength);
    SecretKeyFactory keyFactory = SecretKeyFactory
            .getInstance(""PBEWithSHA256And256BitAES-CBC-BC"");
    byte[] keyBytes = keyFactory.generateSecret(keySpec).getEncoded();
    SecretKey secretKey = new SecretKeySpec(keyBytes, ""AES"");

    return secretKey.getEncoded();
",1,0,bd0bf8e25bb4cfde27ebba827ef3a8a6458bd0c3cc91747a861b9e92c7e84ca9
,"private static byte[] getEncrypt(final String key, final String message) throws GeneralSecurityException {
  final byte[] rawData = key.getBytes(Charset.forName(""US-ASCII""));
  if (rawData.length != 16) {
    // If this is not 16 in length, there's a problem with the key size, nothing to do here
    throw new IllegalArgumentException(""You've provided an invalid key size"");
  }

  final SecretKeySpec seckeySpec = new SecretKeySpec(rawData, ""AES"");
  final Cipher ciph = Cipher.getInstance(""AES/CBC/PKCS5Padding"");

  ciph.init(Cipher.ENCRYPT_MODE, seckeySpec, new IvParameterSpec(new byte[16]));
  return ciph.doFinal(message.getBytes(Charset.forName(""US-ASCII"")));
}

private static String getDecrypt(String key, byte[] encrypted) throws GeneralSecurityException {
  final byte[] rawData = key.getBytes(Charset.forName(""US-ASCII""));
  if (rawData.length != 16) {
    // If this is not 16 in length, there's a problem with the key size, nothing to do here
    throw new IllegalArgumentException(""Invalid key size."");
  }

  final SecretKeySpec seckeySpec = new SecretKeySpec(rawData, ""AES"");

  final Cipher ciph = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
  ciph.init(Cipher.DECRYPT_MODE, seckeySpec, new IvParameterSpec(new byte[16]));
  final byte[] decryptedmess = ciph.doFinal(encrypted);

  return new String(decryptedmess, Charset.forName(""US-ASCII""));
}
",1,0,d9b9c1140a3e168c578e145e9db7881b7165bb7ae6c24f1126c51eade3f6b10b
,"public static void AESObjectEncoder(Serializable object, String password, String path) {
        try {
            Cipher cipher = null;
            cipher = Cipher.getInstance(""AES/CBC/PKCS7Padding"");
            cipher.init(Cipher.ENCRYPT_MODE, fromStringToAESkey(password));
            SealedObject sealedObject = null;
            sealedObject = new SealedObject(object, cipher);
            CipherOutputStream cipherOutputStream = null;
            cipherOutputStream = new CipherOutputStream(new BufferedOutputStream(new FileOutputStream(path)), cipher);
            ObjectOutputStream outputStream = null;
            outputStream = new ObjectOutputStream(cipherOutputStream);
            outputStream.writeObject(sealedObject);
            outputStream.close();    
    }
",1,0,0fde0b946e7ea99dec7afd5460fbd13c001f30b8449d4831c8493bdedacace46
," public static Serializable AESObjectDedcoder(String password, String path) {
        Cipher cipher = null;
        Serializable userList = null;
        cipher = Cipher.getInstance(""AES/CBC/PKCS7Pdding"");

        //Code to write your object to file
        cipher.init(Cipher.DECRYPT_MODE, fromStringToAESkey(password));         
        CipherInputStream cipherInputStream = null;
        cipherInputStream = new CipherInputStream(new BufferedInputStream(new FileInputStream(path)), cipher);

        ObjectInputStream inputStream = null;
        inputStream = new ObjectInputStream(cipherInputStream);
        SealedObject sealedObject = null;
        sealedObject = (SealedObject) inputStream.readObject();
        userList = (Serializable) sealedObject.getObject(ciper);  
        return userList;
    }
",1,0,03718826ca2b98f948c664abb72b79acbb8d4fe83b93e63974903166d51b5d3f
,"public void generateFbFingerPrint() {
    try {
        PackageInfo info = getPackageManager().getPackageInfo(
                ""com.group3amd.gc.activity"",
                PackageManager.GET_SIGNATURES);
        for (Signature signature : info.signatures) {
            MessageDigest md = MessageDigest.getInstance(""SHA"");
            md.update(signature.toByteArray());
            String sign = Base64
                    .encodeToString(md.digest(), Base64.DEFAULT);
            Log.e(""KEYHASH:"", sign);
            Toast.makeText(getApplicationContext(), sign, Toast.LENGTH_LONG)
                    .show();
        }
    } catch (NameNotFoundException e) {
        e.printStackTrace();
    } catch (NoSuchAlgorithmException e) {
        e.printStackTrace();
    }




}
",3,0,259bca51f1e145d35c24c3a17acc6fdfa6967d179eb2adde81fcbda13ed151de
,"import java.io.InputStream;
import java.security.KeyStore;
import org.apache.http.conn.ClientConnectionManager;
import org.apache.http.conn.scheme.PlainSocketFactory;
import org.apache.http.conn.scheme.Scheme;
import org.apache.http.conn.scheme.SchemeRegistry;
import org.apache.http.conn.ssl.SSLSocketFactory;
import org.apache.http.impl.client.DefaultHttpClient;
import org.apache.http.impl.conn.SingleClientConnManager;
import com.arisglobal.aglite.activity.R;
import android.content.Context;

public class MyHttpClient extends DefaultHttpClient{
final Context context;

public MyHttpClient(Context context) {
    this.context = context;
}

@Override
protected ClientConnectionManager createClientConnectionManager() {
    SchemeRegistry registry = new SchemeRegistry();

    registry.register(new Scheme(""http"", PlainSocketFactory.getSocketFactory(), 80));

    // Register for port 443 our SSLSocketFactory with our keystore to the ConnectionManager
    registry.register(new Scheme(""https"", newSslSocketFactory(), 443));
    return new SingleClientConnManager(getParams(), registry);
}

private SSLSocketFactory newSslSocketFactory() {
    try {
        // Get an instance of the Bouncy Castle KeyStore format
        KeyStore trusted = KeyStore.getInstance(""BKS"");

        // Get the raw resource, which contains the keystore with your trusted certificates (root and any intermediate certs)
        InputStream in = context.getResources().openRawResource(R.raw.*nameOfYourKey*);
        try {
            // Initialize the keystore with the provided trusted certificates.
            // Also provide the password of the keystore
            trusted.load(in, *yourPassword*.toCharArray());
        } finally {
            in.close();
        }

        // Pass the keystore to the SSLSocketFactory. The factory is responsible for the verification of the server certificate.
        SSLSocketFactory sf = new SSLSocketFactory(trusted);

        // Hostname verification from certificate
        // http://hc.apache.org/httpcomponents-client-ga/tutorial/html/connmgmt.html#d4e506
        sf.setHostnameVerifier(SSLSocketFactory.STRICT_HOSTNAME_VERIFIER);
        return sf;
    } catch (Exception e) {
        throw new AssertionError(e);
    }
}
}
",3,0,2177e25be90f36080151b9342126646925c55d648a20364ed451439d5ab760ec
,"File bufferFile = new File(path);
FileInputStream fis   = new FileInputStream(bufferFile);

Cipher cipher = Cipher.getInstance(""AES/CBC/NoPadding"");
SecretKeySpec keySpec = new SecretKeySpec(""01234567890abcde"".getBytes(), ""AES"");
IvParameterSpec ivSpec = new IvParameterSpec(""fedcba9876543210"".getBytes());
cipher.init(Cipher.DECRYPT_MODE, keySpec, ivSpec);
CipherInputStream cis = new CipherInputStream(fis, cipher);
Bitmap ops = BitmapFactory.decodeStream(cis);
logo.setImageBitmap(ops);
",4,0,492d76b3478009c24d287ed49b1d9e0abf0b6d534d83b0f5b007ebf913fb218c
,"import org.apache.http.conn.ssl.SSLSocketFactory;
import java.io.IOException;
import java.net.Socket;
import java.net.UnknownHostException;
import java.security.KeyManagementException;
import java.security.KeyStore;
import java.security.KeyStoreException;
import java.security.NoSuchAlgorithmException;
import java.security.UnrecoverableKeyException;
import java.security.cert.CertificateException;
import java.security.cert.X509Certificate;

import javax.net.ssl.SSLContext;
import javax.net.ssl.TrustManager;
import javax.net.ssl.X509TrustManager;

public class MySSLSocketFactory extends SSLSocketFactory {
         SSLContext sslContext = SSLContext.getInstance(""TLS"");

    public MySSLSocketFactory(KeyStore truststore) throws NoSuchAlgorithmException, KeyManagementException, KeyStoreException, UnrecoverableKeyException {
        super(truststore);

        TrustManager tm = new X509TrustManager() {
            public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {
            }

            public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {
            }

            public X509Certificate[] getAcceptedIssuers() {
                return null;
            }
        };

        sslContext.init(null, new TrustManager[] { tm }, null);
    }

    @Override
    public Socket createSocket(Socket socket, String host, int port, boolean autoClose) throws IOException, UnknownHostException {
        return sslContext.getSocketFactory().createSocket(socket, host, port, autoClose);
    }

    @Override
    public Socket createSocket() throws IOException {
        return sslContext.getSocketFactory().createSocket();
    }
}
",4,0,8e20e1c2d38b2f43ab8113f18d1d088a8f854f8df42de03eef2ba26534d77e92
,"try {
        KeyStore trustStore = KeyStore.getInstance(KeyStore.getDefaultType());
        trustStore.load(null, null);
        MySSLSocketFactory sf = new MySSLSocketFactory(trustStore);
        sf.setHostnameVerifier(MySSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
        client.setSSLSocketFactory(sf);
}
catch (Exception e) {}
",4,0,6e87de9163e49132dfa3f80457747531cfac2f907dc57a05e8c52c83a685f4b9
,"String Encrypt(String text, String key) throws Exception {
    Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
    byte[] keyBytes = new byte[16];
    byte[] b = key.getBytes(""UTF-8"");
    int len = b.length;
    if (len &gt; keyBytes.length)
        len = keyBytes.length;
    System.arraycopy(b, 0, keyBytes, 0, len);
    SecretKeySpec keySpec = new SecretKeySpec(keyBytes, ""AES"");
    IvParameterSpec ivSpec = new IvParameterSpec(keyBytes);
    cipher.init(Cipher.ENCRYPT_MODE, keySpec, ivSpec);

    byte[] results = cipher.doFinal(text.getBytes(""UTF-8""));
    BASE64Decoder encoder = new BASE64Decoder();
    return encoder.encodeBytes(results);
}
",1,0,bbcd185e0a90ca43b5c49f299b38958d8740aac189fb3cd00e3f678b78f355c8
,"String Decrypt(String text, String key) throws Exception {
    Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
    byte[] keyBytes = new byte[16];
    byte[] b = key.getBytes(""UTF-8"");
    int len = b.length;
    if (len &gt; keyBytes.length)
        len = keyBytes.length;
    System.arraycopy(b, 0, keyBytes, 0, len);
    SecretKeySpec keySpec = new SecretKeySpec(keyBytes, ""AES"");
    IvParameterSpec ivSpec = new IvParameterSpec(keyBytes);
    cipher.init(Cipher.DECRYPT_MODE, keySpec,ivSpec);

    BASE64Decoder decoder = new BASE64Decoder();
    byte[] results = cipher.doFinal(decoder.decode(text));
    return new String(results, ""UTF-8"");
}
",3,0,b37885336f91a6fb39dd7d8ed8660288d8abfb903ef679d0ceb4cccd8eb23da3
,"   public static void main(String[] args) throws SQLException, Exception {
        Connection con = ConnectionDefinition.getOracleConnection(); //my oracle connection
        PreparedStatement pr = con.prepareStatement(""select  utl_raw.cast_to_raw(dbms_obfuscation_toolkit.md5(input_string =&gt;'password')) from dual"");
        ResultSet rs = pr.executeQuery();
        rs.next();
        byte[] raw = rs.getBytes(1);
        String str = new String(raw);
        System.err.println(str);        

        //Generate MD5 Java
        MessageDigest md = MessageDigest.getInstance(""MD5"");
        md.update(""password"".getBytes());        
        byte byteData[] = md.digest();
        System.err.println(new String(byteData));        
        rs.close();
        pr.close();
        con.close();        
    }
",3,0,afe78850ec2e815954220a9e9977ec536096b34c5857a2badc0e0c8091e20b17
,"  public static String printHashKey(Context context, String packagename)
        {

            String TAG = packagename;
            try
            {
                Log.d(TAG, ""keyHash: start"");
                PackageInfo info = context.getPackageManager().getPackageInfo(TAG,PackageManager.GET_SIGNATURES);
                for (Signature signature: info.signatures)
                {
                    MessageDigest md = MessageDigest.getInstance(""SHA"");
                    md.update(signature.toByteArray());
                    String keyHash = Base64.encodeToString(md.digest(), Base64.DEFAULT);
                    Log.d(TAG, ""keyHash: "" + keyHash);
                    return keyHash;
                }
                Log.d(TAG, ""keyHash: end"");
            }
            catch (NameNotFoundException e)
            {
                Log.d(TAG, ""keyHash: name:""+e);
            }
            catch (NoSuchAlgorithmException e)
            {
                Log.d(TAG, ""keyHash: name:""+e);
            }

            return ""error"";
        }

        public static void updateLanguage(Context context, String code)
        {
            Locale locale = new Locale(code);
            Locale.setDefault(locale);
            Configuration config = new Configuration();
            config.locale = locale;
            context.getResources().updateConfiguration(config, context.getResources().getDisplayMetrics());
        }
",3,0,e87ccdaf648d172579a92f47147327947744e7581cacf9c0e51b6888cfbdfd7f
,"        SchemeRegistry schemeRegistry = new SchemeRegistry ();

        schemeRegistry.register (new Scheme (""http"",
        PlainSocketFactory.getSocketFactory (), 80));
        schemeRegistry.register (new Scheme (""https"",
        new CustomSSLSocketFactory (), 443));

        ThreadSafeClientConnManager cm = new ThreadSafeClientConnManager (
           params, schemeRegistry);


         return new DefaultHttpClient (cm, params);
    }

    // CustomSSLSocketFactory:

       public class CustomSSLSocketFactory extends org.apache.http.conn.ssl.SSLSocketFactory
         {
           private SSLSocketFactory FACTORY =  HttpsURLConnection.getDefaultSSLSocketFactory ();

        public CustomSSLSocketFactory ()
          {
            super(null);  
        try
           {
            SSLContext context = SSLContext.getInstance (""TLS"");
            TrustManager[] tm = new TrustManager[] { new FullX509TrustManager () };
             context.init (null, tm, new SecureRandom ());

             FACTORY = context.getSocketFactory ();
          }
         catch (Exception e)
         {
              e.printStackTrace();
         }
    }

   public Socket createSocket() throws IOException
     {
        return FACTORY.createSocket();
      }

     // TODO: add other methods like createSocket() and getDefaultCipherSuites().
   // Hint: they all just make a call to member FACTORY 
}


   //FullX509TrustManager is a class that implements javax.net.ssl.X509TrustManager,    yet   none of the methods actually perform any work, get a sample here.
",4,0,37eef3be1a9000499dbeed47b8782f4d2a79f63473c02eb55690b4a22c51df85
,"    try {
        PackageInfo info = getPackageManager().getPackageInfo(
                ""com.google.shoppingvn"", PackageManager.GET_SIGNATURES);
        for (Signature signature : info.signatures) {
            MessageDigest md = MessageDigest.getInstance(""SHA"");
            md.update(signature.toByteArray());
            Log.i(""KeyHash:"",
                    Base64.encodeToString(md.digest(), Base64.DEFAULT));
        }
    } catch (NameNotFoundException e) {

    } catch (NoSuchAlgorithmException e) {

    }
",3,0,f0e8284dd07ef19d16f32e1b6061ea92f0cf22c6a8a17ce3e3045f4745a63f4b
,"import java.security.InvalidAlgorithmParameterException;
import java.security.InvalidKeyException;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;

import javax.crypto.BadPaddingException;
import javax.crypto.Cipher;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.NoSuchPaddingException;
import javax.crypto.SecretKey;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;

import android.util.Base64;
import android.util.Log;

public class Crypto {
     public static final String TAG = ""smsfwd"";

        private static Cipher aesCipher;
        private static SecretKey secretKey;
        private static IvParameterSpec ivParameterSpec;

        private static String CIPHER_TRANSFORMATION = ""AES/CBC/PKCS5Padding"";
        private static String CIPHER_ALGORITHM = ""AES"";
        // Replace me with a 16-byte key, share between Java and C#
        private static byte[] rawSecretKey = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                                              0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};

        private static String MESSAGEDIGEST_ALGORITHM = ""MD5"";

        public Crypto(String passphrase) {
            byte[] passwordKey = encodeDigest(passphrase);

            try {
                aesCipher = Cipher.getInstance(CIPHER_TRANSFORMATION);
            } catch (NoSuchAlgorithmException e) {
                Log.e(TAG, ""No such algorithm "" + CIPHER_ALGORITHM, e);
            } catch (NoSuchPaddingException e) {
                Log.e(TAG, ""No such padding PKCS5"", e);
            }

            secretKey = new SecretKeySpec(passwordKey, CIPHER_ALGORITHM);
            ivParameterSpec = new IvParameterSpec(rawSecretKey);
        }

        public String encryptAsBase64(byte[] clearData) {
            byte[] encryptedData = encrypt(clearData);
            return  Base64.encodeToString(encryptedData, Base64.DEFAULT);
        }

        public byte[] encrypt(byte[] clearData) {
            try {
                aesCipher.init(Cipher.ENCRYPT_MODE, secretKey, ivParameterSpec);
            } catch (InvalidKeyException e) {
                Log.e(TAG, ""Invalid key"", e);
                return null;
            } catch (InvalidAlgorithmParameterException e) {
                Log.e(TAG, ""Invalid algorithm "" + CIPHER_ALGORITHM, e);
                return null;
            }

            byte[] encryptedData;
            try {
                encryptedData = aesCipher.doFinal(clearData);
            } catch (IllegalBlockSizeException e) {
                Log.e(TAG, ""Illegal block size"", e);
                return null;
            } catch (BadPaddingException e) {
                Log.e(TAG, ""Bad padding"", e);
                return null;
            }
            return encryptedData;
        }

        private byte[] encodeDigest(String text) {
            MessageDigest digest;
            try {
                digest = MessageDigest.getInstance(MESSAGEDIGEST_ALGORITHM);
                return digest.digest(text.getBytes());
            } catch (NoSuchAlgorithmException e) {
                Log.e(TAG, ""No such algorithm "" + MESSAGEDIGEST_ALGORITHM, e);
            }

            return null;
        }
}
",4,0,2d29a4fb98034ff2417bfed95d4e69ba968c7d3179f23c8e3ea41cb61228dcf0
,"/*
 * ====================================================================
 * Licensed to the Apache Software Foundation (ASF) [...add this back]
 *
 */

import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.net.Socket;
import java.net.URL;
import java.security.KeyManagementException;
import java.security.KeyStore;
import java.security.KeyStoreException;
import java.security.NoSuchAlgorithmException;
import java.security.Principal;
import java.security.PrivateKey;
import java.security.SecureRandom;
import java.security.UnrecoverableKeyException;
import java.security.cert.CertificateException;
import java.security.cert.X509Certificate;
import java.util.Collection;
import java.util.HashMap;
import java.util.LinkedHashSet;
import java.util.Map;
import java.util.Set;

import javax.net.ssl.KeyManager;
import javax.net.ssl.KeyManagerFactory;
import javax.net.ssl.SSLContext;
import javax.net.ssl.SSLEngine;
import javax.net.ssl.TrustManager;
import javax.net.ssl.TrustManagerFactory;
import javax.net.ssl.X509ExtendedKeyManager;
import javax.net.ssl.X509TrustManager;

/**
 * Builder for {@link javax.net.ssl.SSLContext} instances.
 * &lt;p&gt;
 * Please note: the default Oracle JSSE implementation of {@link SSLContext#init(KeyManager[], TrustManager[], SecureRandom)}
 * accepts multiple key and trust managers, however only only first matching type is ever used.
 * See for example:
 * &lt;a href=""http://docs.oracle.com/javase/7/docs/api/javax/net/ssl/SSLContext.html#init%28javax.net.ssl.KeyManager[],%20javax.net.ssl.TrustManager[],%20java.security.SecureRandom%29""&gt;
 * SSLContext.html#init
 * &lt;/a&gt;
 *
 * @since 4.4
 */
public class SSLContextBuilder {

    static final String TLS   = ""TLS"";

    private String protocol;
    private final Set&lt;KeyManager&gt; keymanagers;
    private final Set&lt;TrustManager&gt; trustmanagers;
    private SecureRandom secureRandom;

    public static SSLContextBuilder create() {
        return new SSLContextBuilder();
    }

    public SSLContextBuilder() {
        super();
        this.keymanagers = new LinkedHashSet&lt;KeyManager&gt;();
        this.trustmanagers = new LinkedHashSet&lt;TrustManager&gt;();
    }

    public SSLContextBuilder useProtocol(final String protocol) {
        this.protocol = protocol;
        return this;
    }

    public SSLContextBuilder setSecureRandom(final SecureRandom secureRandom) {
        this.secureRandom = secureRandom;
        return this;
    }

    public SSLContextBuilder loadTrustMaterial(
            final KeyStore truststore,
            final TrustStrategy trustStrategy) throws NoSuchAlgorithmException, KeyStoreException {
        final TrustManagerFactory tmfactory = TrustManagerFactory.getInstance(
                TrustManagerFactory.getDefaultAlgorithm());
        tmfactory.init(truststore);
        final TrustManager[] tms = tmfactory.getTrustManagers();
        if (tms != null) {
            if (trustStrategy != null) {
                for (int i = 0; i &lt; tms.length; i++) {
                    final TrustManager tm = tms[i];
                    if (tm instanceof X509TrustManager) {
                        tms[i] = new TrustManagerDelegate(
                                (X509TrustManager) tm, trustStrategy);
                    }
                }
            }
            for (final TrustManager tm : tms) {
                this.trustmanagers.add(tm);
            }
        }
        return this;
    }

    public SSLContextBuilder loadTrustMaterial(
            final TrustStrategy trustStrategy) throws NoSuchAlgorithmException, KeyStoreException {
        return loadTrustMaterial(null, trustStrategy);
    }

    public SSLContextBuilder loadTrustMaterial(
            final File file,
            final char[] storePassword,
            final TrustStrategy trustStrategy) throws NoSuchAlgorithmException, KeyStoreException, CertificateException, IOException {
        Args.notNull(file, ""Truststore file"");
        final KeyStore trustStore = KeyStore.getInstance(KeyStore.getDefaultType());
        final FileInputStream instream = new FileInputStream(file);
        try {
            trustStore.load(instream, storePassword);
        } finally {
            instream.close();
        }
        return loadTrustMaterial(trustStore, trustStrategy);
    }

    public SSLContextBuilder loadTrustMaterial(
            final File file,
            final char[] storePassword) throws NoSuchAlgorithmException, KeyStoreException, CertificateException, IOException {
        return loadTrustMaterial(file, storePassword, null);
    }

    public SSLContextBuilder loadTrustMaterial(
            final File file) throws NoSuchAlgorithmException, KeyStoreException, CertificateException, IOException {
        return loadTrustMaterial(file, null);
    }

    public SSLContextBuilder loadTrustMaterial(
            final URL url,
            final char[] storePassword,
            final TrustStrategy trustStrategy) throws NoSuchAlgorithmException, KeyStoreException, CertificateException, IOException {
        Args.notNull(url, ""Truststore URL"");
        final KeyStore trustStore = KeyStore.getInstance(KeyStore.getDefaultType());
        final InputStream instream = url.openStream();
        try {
            trustStore.load(instream, storePassword);
        } finally {
            instream.close();
        }
        return loadTrustMaterial(trustStore, trustStrategy);
    }

    public SSLContextBuilder loadTrustMaterial(
            final URL url,
            final char[] storePassword) throws NoSuchAlgorithmException, KeyStoreException, CertificateException, IOException {
        return loadTrustMaterial(url, storePassword, null);
    }

    public SSLContextBuilder loadKeyMaterial(
            final KeyStore keystore,
            final char[] keyPassword,
            final PrivateKeyStrategy aliasStrategy)
            throws NoSuchAlgorithmException, KeyStoreException, UnrecoverableKeyException {
        final KeyManagerFactory kmfactory = KeyManagerFactory.getInstance(
                KeyManagerFactory.getDefaultAlgorithm());
        kmfactory.init(keystore, keyPassword);
        final KeyManager[] kms =  kmfactory.getKeyManagers();
        if (kms != null) {
            if (aliasStrategy != null) {
                for (int i = 0; i &lt; kms.length; i++) {
                    final KeyManager km = kms[i];
                    if (km instanceof X509ExtendedKeyManager) {
                        kms[i] = new KeyManagerDelegate((X509ExtendedKeyManager) km, aliasStrategy);
                    }
                }
            }
            for (final KeyManager km : kms) {
                keymanagers.add(km);
            }
        }
        return this;
    }

    public SSLContextBuilder loadKeyMaterial(
            final KeyStore keystore,
            final char[] keyPassword) throws NoSuchAlgorithmException, KeyStoreException, UnrecoverableKeyException {
        return loadKeyMaterial(keystore, keyPassword, null);
    }

    public SSLContextBuilder loadKeyMaterial(
            final File file,
            final char[] storePassword,
            final char[] keyPassword,
            final PrivateKeyStrategy aliasStrategy) throws NoSuchAlgorithmException, KeyStoreException, UnrecoverableKeyException, CertificateException, IOException {
        Args.notNull(file, ""Keystore file"");
        final KeyStore identityStore = KeyStore.getInstance(KeyStore.getDefaultType());
        final FileInputStream instream = new FileInputStream(file);
        try {
            identityStore.load(instream, storePassword);
        } finally {
            instream.close();
        }
        return loadKeyMaterial(identityStore, keyPassword, aliasStrategy);
    }

    public SSLContextBuilder loadKeyMaterial(
            final File file,
            final char[] storePassword,
            final char[] keyPassword) throws NoSuchAlgorithmException, KeyStoreException, UnrecoverableKeyException, CertificateException, IOException {
        return loadKeyMaterial(file, storePassword, keyPassword, null);
    }

    public SSLContextBuilder loadKeyMaterial(
            final URL url,
            final char[] storePassword,
            final char[] keyPassword,
            final PrivateKeyStrategy aliasStrategy) throws NoSuchAlgorithmException, KeyStoreException, UnrecoverableKeyException, CertificateException, IOException {
        Args.notNull(url, ""Keystore URL"");
        final KeyStore identityStore = KeyStore.getInstance(KeyStore.getDefaultType());
        final InputStream instream = url.openStream();
        try {
            identityStore.load(instream, storePassword);
        } finally {
            instream.close();
        }
        return loadKeyMaterial(identityStore, keyPassword, aliasStrategy);
    }

    public SSLContextBuilder loadKeyMaterial(
            final URL url,
            final char[] storePassword,
            final char[] keyPassword) throws NoSuchAlgorithmException, KeyStoreException, UnrecoverableKeyException, CertificateException, IOException {
        return loadKeyMaterial(url, storePassword, keyPassword, null);
    }

    protected void initSSLContext(
            final SSLContext sslcontext,
            final Collection&lt;KeyManager&gt; keyManagers,
            final Collection&lt;TrustManager&gt; trustManagers,
            final SecureRandom secureRandom) throws KeyManagementException {
        sslcontext.init(
                !keyManagers.isEmpty() ? keyManagers.toArray(new KeyManager[keyManagers.size()]) : null,
                !trustManagers.isEmpty() ? trustManagers.toArray(new TrustManager[trustManagers.size()]) : null,
                secureRandom);
    }

    public SSLContext build() throws NoSuchAlgorithmException, KeyManagementException {
        final SSLContext sslcontext = SSLContext.getInstance(
                this.protocol != null ? this.protocol : TLS);
        initSSLContext(sslcontext, keymanagers, trustmanagers, secureRandom);
        return sslcontext;
    }

    static class TrustManagerDelegate implements X509TrustManager {

        private final X509TrustManager trustManager;
        private final TrustStrategy trustStrategy;

        TrustManagerDelegate(final X509TrustManager trustManager, final TrustStrategy trustStrategy) {
            super();
            this.trustManager = trustManager;
            this.trustStrategy = trustStrategy;
        }

        @Override
        public void checkClientTrusted(
                final X509Certificate[] chain, final String authType) throws CertificateException {
            this.trustManager.checkClientTrusted(chain, authType);
        }

        @Override
        public void checkServerTrusted(
                final X509Certificate[] chain, final String authType) throws CertificateException {
            if (!this.trustStrategy.isTrusted(chain, authType)) {
                this.trustManager.checkServerTrusted(chain, authType);
            }
        }

        @Override
        public X509Certificate[] getAcceptedIssuers() {
            return this.trustManager.getAcceptedIssuers();
        }

    }

    static class KeyManagerDelegate extends X509ExtendedKeyManager {

        private final X509ExtendedKeyManager keyManager;
        private final PrivateKeyStrategy aliasStrategy;

        KeyManagerDelegate(final X509ExtendedKeyManager keyManager, final PrivateKeyStrategy aliasStrategy) {
            super();
            this.keyManager = keyManager;
            this.aliasStrategy = aliasStrategy;
        }

        @Override
        public String[] getClientAliases(
                final String keyType, final Principal[] issuers) {
            return this.keyManager.getClientAliases(keyType, issuers);
        }

        public Map&lt;String, PrivateKeyDetails&gt; getClientAliasMap(
                final String[] keyTypes, final Principal[] issuers) {
            final Map&lt;String, PrivateKeyDetails&gt; validAliases = new HashMap&lt;String, PrivateKeyDetails&gt;();
            for (final String keyType: keyTypes) {
                final String[] aliases = this.keyManager.getClientAliases(keyType, issuers);
                if (aliases != null) {
                    for (final String alias: aliases) {
                        validAliases.put(alias,
                                new PrivateKeyDetails(keyType, this.keyManager.getCertificateChain(alias)));
                    }
                }
            }
            return validAliases;
        }

        public Map&lt;String, PrivateKeyDetails&gt; getServerAliasMap(
                final String keyType, final Principal[] issuers) {
            final Map&lt;String, PrivateKeyDetails&gt; validAliases = new HashMap&lt;String, PrivateKeyDetails&gt;();
            final String[] aliases = this.keyManager.getServerAliases(keyType, issuers);
            if (aliases != null) {
                for (final String alias: aliases) {
                    validAliases.put(alias,
                            new PrivateKeyDetails(keyType, this.keyManager.getCertificateChain(alias)));
                }
            }
            return validAliases;
        }

        @Override
        public String chooseClientAlias(
                final String[] keyTypes, final Principal[] issuers, final Socket socket) {
            final Map&lt;String, PrivateKeyDetails&gt; validAliases = getClientAliasMap(keyTypes, issuers);
            return this.aliasStrategy.chooseAlias(validAliases, socket);
        }

        @Override
        public String[] getServerAliases(
                final String keyType, final Principal[] issuers) {
            return this.keyManager.getServerAliases(keyType, issuers);
        }

        @Override
        public String chooseServerAlias(
                final String keyType, final Principal[] issuers, final Socket socket) {
            final Map&lt;String, PrivateKeyDetails&gt; validAliases = getServerAliasMap(keyType, issuers);
            return this.aliasStrategy.chooseAlias(validAliases, socket);
        }

        @Override
        public X509Certificate[] getCertificateChain(final String alias) {
            return this.keyManager.getCertificateChain(alias);
        }

        @Override
        public PrivateKey getPrivateKey(final String alias) {
            return this.keyManager.getPrivateKey(alias);
        }

        @Override
        public String chooseEngineClientAlias(
                final String[] keyTypes, final Principal[] issuers, final SSLEngine sslEngine) {
            final Map&lt;String, PrivateKeyDetails&gt; validAliases = getClientAliasMap(keyTypes, issuers);
            return this.aliasStrategy.chooseAlias(validAliases, null);
        }

        @Override
        public String chooseEngineServerAlias(
                final String keyType, final Principal[] issuers, final SSLEngine sslEngine) {
            final Map&lt;String, PrivateKeyDetails&gt; validAliases = getServerAliasMap(keyType, issuers);
            return this.aliasStrategy.chooseAlias(validAliases, null);
        }

    }

}
",3,0,1504ab22dc51025b35b98c87b296ac25b4d9bd7031d7a2e1376eee16574c5aee
,"       SSLContextBuilder sslContextBuilder = SSLContextBuilder.create();
       KeyStore keyStore = KeyStore.getInstance(""BKS"", BouncyCastleProvider.PROVIDER_NAME);
       android.content.res.Resources res = &lt;getter for resources&gt;;
       InputStream inputStream = res.openRawResources(R.raw.cert);           
       keyStore.load(inputStream, trustStorePassword);
       sslContextBuilder.loadTrustMaterial(keyStore, trustStorePassword);
       SSLContext sslContext = sslContextBuilder.build();
       //okHttpClient.setSslSocketFactory(sslContext.getSocketFactory());
",,1,2dc5f52c71747d05d21a387ccbd3097ff4fc1b5975879adc093575cc64cc60d3
,"                keyStore.load(byteArrayInputStream, keyStorePassword);
                Certificate[] certificates = keyStore.getCertificateChain(""key-alias""); //you need to know the alias
                if(certificates.length &gt; 0) {
                    Certificate certificate = certificates[0];
                    X509Certificate x509Certificate = (X509Certificate) certificate;
                    Log.d(TAG,
                          ""Certificate found with DN ["" + x509Certificate.getSubjectDN() + ""]"");
",,1,0303767d1672730330433dffa56d3554860e38d6c088b2ed13438b9ee0f7b4d4
,"/*Copyright 2015 Bhavit Singh Sengar
Licensed under the Apache License, Version 2.0 (the ""License"");
you may not use this file except in compliance with the License.You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an ""AS IS"" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.*/

import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.InetAddress;
import java.net.Socket;
import java.net.SocketAddress;
import java.net.SocketException;
import java.nio.channels.SocketChannel;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import javax.net.ssl.HandshakeCompletedListener;
import javax.net.ssl.HttpsURLConnection;
import javax.net.ssl.SSLSession;
import javax.net.ssl.SSLSocket;
import javax.net.ssl.SSLSocketFactory;


public class NoSSLv3SocketFactory extends SSLSocketFactory{
    private final SSLSocketFactory delegate;

public NoSSLv3SocketFactory() {
    this.delegate = HttpsURLConnection.getDefaultSSLSocketFactory();
}

public NoSSLv3SocketFactory(SSLSocketFactory delegate) {
    this.delegate = delegate;
}

@Override
public String[] getDefaultCipherSuites() {
    return delegate.getDefaultCipherSuites();
}

@Override
public String[] getSupportedCipherSuites() {
    return delegate.getSupportedCipherSuites();
}

private Socket makeSocketSafe(Socket socket) {
    if (socket instanceof SSLSocket) {
        socket = new NoSSLv3SSLSocket((SSLSocket) socket);
    }
    return socket;
}

@Override
public Socket createSocket(Socket s, String host, int port, boolean autoClose) throws IOException {
    return makeSocketSafe(delegate.createSocket(s, host, port, autoClose));
}

@Override
public Socket createSocket(String host, int port) throws IOException {
    return makeSocketSafe(delegate.createSocket(host, port));
}

@Override
public Socket createSocket(String host, int port, InetAddress localHost, int localPort) throws IOException {
    return makeSocketSafe(delegate.createSocket(host, port, localHost, localPort));
}

@Override
public Socket createSocket(InetAddress host, int port) throws IOException {
    return makeSocketSafe(delegate.createSocket(host, port));
}

@Override
public Socket createSocket(InetAddress address, int port, InetAddress localAddress, int localPort) throws IOException {
    return makeSocketSafe(delegate.createSocket(address, port, localAddress, localPort));
}

private class NoSSLv3SSLSocket extends DelegateSSLSocket {

    private NoSSLv3SSLSocket(SSLSocket delegate) {
        super(delegate);

    }

    @Override
    public void setEnabledProtocols(String[] protocols) {
        if (protocols != null &amp;&amp; protocols.length == 1 &amp;&amp; ""SSLv3"".equals(protocols[0])) {

            List&lt;String&gt; enabledProtocols = new ArrayList&lt;String&gt;(Arrays.asList(delegate.getEnabledProtocols()));
            if (enabledProtocols.size() &gt; 1) {
                enabledProtocols.remove(""SSLv3"");
                System.out.println(""Removed SSLv3 from enabled protocols"");
            } else {
                System.out.println(""SSL stuck with protocol available for "" + String.valueOf(enabledProtocols));
            }
            protocols = enabledProtocols.toArray(new String[enabledProtocols.size()]);
        }

        super.setEnabledProtocols(protocols);
    }
}

public class DelegateSSLSocket extends SSLSocket {

    protected final SSLSocket delegate;

    DelegateSSLSocket(SSLSocket delegate) {
        this.delegate = delegate;
    }

    @Override
    public String[] getSupportedCipherSuites() {
        return delegate.getSupportedCipherSuites();
    }

    @Override
    public String[] getEnabledCipherSuites() {
        return delegate.getEnabledCipherSuites();
    }

    @Override
    public void setEnabledCipherSuites(String[] suites) {
        delegate.setEnabledCipherSuites(suites);
    }

    @Override
    public String[] getSupportedProtocols() {
        return delegate.getSupportedProtocols();
    }

    @Override
    public String[] getEnabledProtocols() {
        return delegate.getEnabledProtocols();
    }

    @Override
    public void setEnabledProtocols(String[] protocols) {
        delegate.setEnabledProtocols(protocols);
    }

    @Override
    public SSLSession getSession() {
        return delegate.getSession();
    }

    @Override
    public void addHandshakeCompletedListener(HandshakeCompletedListener listener) {
        delegate.addHandshakeCompletedListener(listener);
    }

    @Override
    public void removeHandshakeCompletedListener(HandshakeCompletedListener listener) {
        delegate.removeHandshakeCompletedListener(listener);
    }

    @Override
    public void startHandshake() throws IOException {
        delegate.startHandshake();
    }

    @Override
    public void setUseClientMode(boolean mode) {
        delegate.setUseClientMode(mode);
    }

    @Override
    public boolean getUseClientMode() {
        return delegate.getUseClientMode();
    }

    @Override
    public void setNeedClientAuth(boolean need) {
        delegate.setNeedClientAuth(need);
    }

    @Override
    public void setWantClientAuth(boolean want) {
        delegate.setWantClientAuth(want);
    }

    @Override
    public boolean getNeedClientAuth() {
        return delegate.getNeedClientAuth();
    }

    @Override
    public boolean getWantClientAuth() {
        return delegate.getWantClientAuth();
    }

    @Override
    public void setEnableSessionCreation(boolean flag) {
        delegate.setEnableSessionCreation(flag);
    }

    @Override
    public boolean getEnableSessionCreation() {
        return delegate.getEnableSessionCreation();
    }

    @Override
    public void bind(SocketAddress localAddr) throws IOException {
        delegate.bind(localAddr);
    }

    @Override
    public synchronized void close() throws IOException {
        delegate.close();
    }

    @Override
    public void connect(SocketAddress remoteAddr) throws IOException {
        delegate.connect(remoteAddr);
    }

    @Override
    public void connect(SocketAddress remoteAddr, int timeout) throws IOException {
        delegate.connect(remoteAddr, timeout);
    }

    @Override
    public SocketChannel getChannel() {
        return delegate.getChannel();
    }

    @Override
    public InetAddress getInetAddress() {
        return delegate.getInetAddress();
    }

    @Override
    public InputStream getInputStream() throws IOException {
        return delegate.getInputStream();
    }

    @Override
    public boolean getKeepAlive() throws SocketException {
        return delegate.getKeepAlive();
    }

    @Override
    public InetAddress getLocalAddress() {
        return delegate.getLocalAddress();
    }

    @Override
    public int getLocalPort() {
        return delegate.getLocalPort();
    }

    @Override
    public SocketAddress getLocalSocketAddress() {
        return delegate.getLocalSocketAddress();
    }

    @Override
    public boolean getOOBInline() throws SocketException {
        return delegate.getOOBInline();
    }

    @Override
    public OutputStream getOutputStream() throws IOException {
        return delegate.getOutputStream();
    }

    @Override
    public int getPort() {
        return delegate.getPort();
    }

    @Override
    public synchronized int getReceiveBufferSize() throws SocketException {
        return delegate.getReceiveBufferSize();
    }

    @Override
    public SocketAddress getRemoteSocketAddress() {
        return delegate.getRemoteSocketAddress();
    }

    @Override
    public boolean getReuseAddress() throws SocketException {
        return delegate.getReuseAddress();
    }

    @Override
    public synchronized int getSendBufferSize() throws SocketException {
        return delegate.getSendBufferSize();
    }

    @Override
    public int getSoLinger() throws SocketException {
        return delegate.getSoLinger();
    }

    @Override
    public synchronized int getSoTimeout() throws SocketException {
        return delegate.getSoTimeout();
    }

    @Override
    public boolean getTcpNoDelay() throws SocketException {
        return delegate.getTcpNoDelay();
    }

    @Override
    public int getTrafficClass() throws SocketException {
        return delegate.getTrafficClass();
    }

    @Override
    public boolean isBound() {
        return delegate.isBound();
    }

    @Override
    public boolean isClosed() {
        return delegate.isClosed();
    }

    @Override
    public boolean isConnected() {
        return delegate.isConnected();
    }

    @Override
    public boolean isInputShutdown() {
        return delegate.isInputShutdown();
    }

    @Override
    public boolean isOutputShutdown() {
        return delegate.isOutputShutdown();
    }

    @Override
    public void sendUrgentData(int value) throws IOException {
        delegate.sendUrgentData(value);
    }

    @Override
    public void setKeepAlive(boolean keepAlive) throws SocketException {
        delegate.setKeepAlive(keepAlive);
    }

    @Override
    public void setOOBInline(boolean oobinline) throws SocketException {
        delegate.setOOBInline(oobinline);
    }

    @Override
    public void setPerformancePreferences(int connectionTime, int latency, int bandwidth) {
        delegate.setPerformancePreferences(connectionTime, latency, bandwidth);
    }

    @Override
    public synchronized void setReceiveBufferSize(int size) throws SocketException {
        delegate.setReceiveBufferSize(size);
    }

    @Override
    public void setReuseAddress(boolean reuse) throws SocketException {
        delegate.setReuseAddress(reuse);
    }

    @Override
    public synchronized void setSendBufferSize(int size) throws SocketException {
        delegate.setSendBufferSize(size);
    }

    @Override
    public void setSoLinger(boolean on, int timeout) throws SocketException {
        delegate.setSoLinger(on, timeout);
    }

    @Override
    public synchronized void setSoTimeout(int timeout) throws SocketException {
        delegate.setSoTimeout(timeout);
    }

    @Override
    public void setTcpNoDelay(boolean on) throws SocketException {
        delegate.setTcpNoDelay(on);
    }

    @Override
    public void setTrafficClass(int value) throws SocketException {
        delegate.setTrafficClass(value);
    }

    @Override
    public void shutdownInput() throws IOException {
        delegate.shutdownInput();
    }

    @Override
    public void shutdownOutput() throws IOException {
        delegate.shutdownOutput();
    }

    @Override
    public String toString() {
        return delegate.toString();
    }

    @Override
    public boolean equals(Object o) {
        return delegate.equals(o);
    }
}
}
",3,0,d96bd1c03d9bf502b1eff6b3b16305883351cebbc91bc852b18a2d390c9455e4
,"SSLContext sslcontext = SSLContext.getInstance(""TLSv1"");

            sslcontext.init(null,
                    null,
                    null);
            SSLSocketFactory NoSSLv3Factory = new NoSSLv3SocketFactory(sslcontext.getSocketFactory());

            HttpsURLConnection.setDefaultSSLSocketFactory(NoSSLv3Factory);
            l_connection = (HttpsURLConnection) l_url.openConnection();
            l_connection.connect();
",4,0,380e69f178727ed2fa7d716bee532b10402066933a96395d82117480b993760e
,"import java.io.BufferedInputStream;
import java.io.BufferedOutputStream;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.HttpURLConnection;
import java.net.URL;
import java.security.cert.CertificateException;
import java.security.cert.X509Certificate;
import java.util.Enumeration;
import java.util.zip.ZipEntry;
import java.util.zip.ZipFile;

import javax.net.ssl.HostnameVerifier;
import javax.net.ssl.HttpsURLConnection;
import javax.net.ssl.SSLContext;
import javax.net.ssl.SSLSession;
import javax.net.ssl.TrustManager;
import javax.net.ssl.X509TrustManager;

import android.annotation.SuppressLint;
import android.app.AlertDialog;
import android.app.ProgressDialog;
import android.content.Context;
import android.content.DialogInterface;
import android.graphics.Color;
import android.os.AsyncTask;
import android.util.Log;
import android.view.Gravity;
import android.widget.TextView;
public class Utils
    {
            public static void createDir(String path,String dirName)
            {
                  String newFolder = ""/""+dirName;
                  File myNewFolder = new File(path + newFolder);
                  myNewFolder.mkdir();
            }

            public void downloadEventData(Context context,String zipFile,String unzipLocation,String url) throws IOException
            {
                try {
                        new DownloadMapAsync(context,zipFile,unzipLocation).execute(url);
                } catch (Exception e) {
                    // TODO Auto-generated catch block
                    e.printStackTrace();
                }
            }
                private class DownloadMapAsync extends AsyncTask&lt;String, String, String&gt; {
                    String result ="""";
                    Context context;
                    String zipFile;
                    String unzipLocation;
                    private ProgressDialog progressDialog;
                    String string;
                    public DownloadMapAsync(Context context,String zipFile,String unzipLocation) {
                        // TODO Auto-generated constructor stub
                        this.context=context;
                        this.zipFile=zipFile;
                        this.unzipLocation=unzipLocation;
                    }
                    @Override
                    protected void onPreExecute() {
                        super.onPreExecute();
                        progressDialog = new ProgressDialog(context);
                        progressDialog.setMessage(""Downloading Zip File.."");
                        progressDialog.setProgressStyle(ProgressDialog.STYLE_HORIZONTAL);
                        progressDialog.setCancelable(false);
                        progressDialog.show();
                    }

                    @Override
                    protected String doInBackground(String... aurl) {
                        int count;
                        HttpURLConnection http = null;
                    try {
                        URL url = new URL(aurl[0]);
                        if (url.getProtocol().toLowerCase().equals(""https"")) {
                            trustAllHosts();
                            HttpsURLConnection https = (HttpsURLConnection) url.openConnection();
                            https.setHostnameVerifier(DO_NOT_VERIFY);
                            http = https;
                        } else {
                            http = (HttpURLConnection) url.openConnection();
                        }
                    http.connect();
                    if (http.getResponseCode()==200)
                    {
                        int lenghtOfFile = http.getContentLength();
                        InputStream input = new BufferedInputStream(url.openStream());

                        OutputStream output = new FileOutputStream(zipFile);

                        byte data[] = new byte[1024];
                        long total = 0;

                            while ((count = input.read(data)) != -1) {
                                total += count;
                                publishProgress(""""+(int)((total*100)/lenghtOfFile));
                                output.write(data, 0, count);
                            }
                            output.close();
                            input.close();
                            result = ""true"";
                    } 
                    else if (http.getResponseCode()==401)
                    {
                        result = ""false"";
                        string= ""Download Limit exceed."";   
                    }  
                    else 
                    {
                        result = ""false"";
                        string=http.getResponseMessage();
                    }

                    } catch (Exception e) {
                        e.printStackTrace();
                        result = ""false"";
                        try {
                            if (http.getResponseCode()==401)
                            {
                                string= ""Download Failed"";  
                            } else {
                                string=e.toString();
                            }

                        } catch (IOException e1) {
                            // TODO Auto-generated catch block
                            e1.printStackTrace();
                        }
                    }
                    return result;

                    }
                    protected void onProgressUpdate(String... progress) {
                         Log.d(""ANDRO_ASYNC"",progress[0]);
                         progressDialog.setProgress(Integer.parseInt(progress[0]));
                    }

                    @Override
                    protected void onPostExecute(String unused) {
                        progressDialog.dismiss();
                        if(result.equalsIgnoreCase(""true""))
                        {
                        try {
                            unzip(context,zipFile,unzipLocation);
                        } catch (IOException e) {
                            // TODO Auto-generated catch block
                            e.printStackTrace();
                        }
                        }
                        else
                        {
                            customAlert(context, string);
                        }
                    }
                }
                @SuppressLint(""NewApi"")
                public void customAlert(Context context,String msgString)
                {
                    AlertDialog.Builder alertDialog2 = new AlertDialog.Builder(context,AlertDialog.THEME_DEVICE_DEFAULT_LIGHT);
                    TextView title = new TextView(context);
                    title.setText(""Message"");
                    title.setPadding(10, 10, 10, 10);
                    title.setGravity(Gravity.CENTER);
                    title.setTextColor(Color.BLACK);
                    title.setTextSize(20);
                    alertDialog2.setCustomTitle(title);
                    TextView msg = new TextView(context);
                    msg.setText(msgString);
                    msg.setPadding(10, 10, 10, 10);
                    msg.setGravity(Gravity.CENTER);
                    msg.setTextSize(18);
                    msg.setTextColor(Color.BLACK);
                    alertDialog2.setView(msg);
                    alertDialog2.setPositiveButton(""OK"",
                        new DialogInterface.OnClickListener() {
                            public void onClick(DialogInterface dialog, int which) {
                                dialog.cancel();
                            }
                        });
                    alertDialog2.show();
                }
                  public void unzip(Context context,String zipFile,String unzipLocation) throws IOException 
                  {
                        new UnZipTask(context,zipFile).execute(unzipLocation);
                  }

                private class UnZipTask extends AsyncTask&lt;String, Void, Boolean&gt; {
                    Context context;
                    String zipFile;
                    ProgressDialog progressDialog;

                 public UnZipTask(Context context,String zipFile) {
                    // TODO Auto-generated constructor stub
                     this.context=context;
                     this.zipFile=zipFile;
                    }
                  @Override
                    protected void onPreExecute() {
                        super.onPreExecute();
                        progressDialog = new ProgressDialog(context);
                        progressDialog.setMessage(""Please Wait...Extracting zip file ... "");
                        progressDialog.setProgressStyle(ProgressDialog.STYLE_SPINNER);
                        progressDialog.setCancelable(false);
                        progressDialog.show();

                    }
                  protected Boolean doInBackground(String... params) 
                  {
                      String filePath = zipFile;
                      String destinationPath = params[0];

                      File archive = new File(filePath);
                      try {


                         ZipFile zipfile = new ZipFile(archive);
                          for (@SuppressWarnings(""rawtypes"")
                        Enumeration e = zipfile.entries(); e.hasMoreElements();) {
                              ZipEntry entry = (ZipEntry) e.nextElement();
                              unzipEntry(zipfile, entry, destinationPath);
                          }


                            UnzipUtil d = new UnzipUtil(zipFile,params[0]); 
                            d.unzip();

                      } catch (Exception e) {
                          e.printStackTrace();
                          return false;
                      }

                      return true;
                  }

                  @Override
                  protected void onPostExecute(Boolean result)
                  {
                      progressDialog.dismiss();
                      File file=new File(zipFile);
                      file.delete();
                      customAlert(context,""Unzipping completed"");
                  }

                  private void unzipEntry(ZipFile zipfile, ZipEntry entry,String outputDir) throws IOException 
                    {

                      if (entry.isDirectory()) {
                          createDir(new File(outputDir, entry.getName()));
                          return;
                      }

                      File outputFile = new File(outputDir, entry.getName());
                      if (!outputFile.getParentFile().exists()) {
                          createDir(outputFile.getParentFile());
                      }

                      BufferedInputStream inputStream = new BufferedInputStream(zipfile.getInputStream(entry));
                      BufferedOutputStream outputStream = new BufferedOutputStream(new FileOutputStream(outputFile));

                      try {

                      } finally {
                        outputStream.flush();
                        outputStream.close();
                        inputStream.close();


                      }
                  }

                  public void createDir(File dir)
                  {
                      if (dir.exists()) {
                          return;
                      }
                      if (!dir.mkdirs()) {
                          throw new RuntimeException(""Can not create dir "" + dir);
                      }
                  }

                  }

                 final static HostnameVerifier DO_NOT_VERIFY = new HostnameVerifier()
                 {
                        public boolean verify(String hostname, SSLSession session) {
                            return true;
                        }
                };
                private static void trustAllHosts() {
                    // Create a trust manager that does not validate certificate chains
                    TrustManager[] trustAllCerts = new TrustManager[] { new X509TrustManager() {
                        public java.security.cert.X509Certificate[] getAcceptedIssuers() {
                            return new java.security.cert.X509Certificate[] {};
                        }

                        public void checkClientTrusted(X509Certificate[] chain,
                                String authType) throws CertificateException {
                        }

                        public void checkServerTrusted(X509Certificate[] chain,
                                String authType) throws CertificateException {
                        }
                    } };

                    // Install the all-trusting trust manager
                    try {
                        SSLContext sc = SSLContext.getInstance(""TLS"");
                        sc.init(null, trustAllCerts, new java.security.SecureRandom());
                        HttpsURLConnection
                                .setDefaultSSLSocketFactory(sc.getSocketFactory());
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                }   
}
",4,0,6e7fecd159477d55f0e20621cb060c573a2537113190d4918335a0b92548ef7b
